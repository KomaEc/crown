Solving bzip2::main_0 with precision 1... ✅
Solving bzlib::BZ2_bzWriteOpen with precision 1... ❌
Solving bzlib::BZ2_bzReadOpen with precision 1... ❌
Solving bzip2recover::bsClose with precision 1... ✅
Solving bzlib::default_bzfree with precision 1... ✅
Solving bzlib::BZ2_bzWriteClose64 with precision 1... ❌
Solving bzlib::BZ2_bzReadClose with precision 1... ❌
Solving bzip2::myMalloc with precision 1... ✅
Solving bzip2recover::bsOpenReadStream with precision 1... ✅
Solving bzip2recover::bsOpenWriteStream with precision 1... ✅
Solving bzlib::default_bzalloc with precision 1... ✅
Solving blocksort::fallbackSimpleSort with precision 1... ✅
Solving blocksort::fallbackQSort3 with precision 1... ✅
Solving blocksort::fallbackSort with precision 1... ✅
Solving blocksort::mainGtU with precision 1... ✅
Solving blocksort::mainSimpleSort with precision 1... ✅
Solving blocksort::mmed3 with precision 1... ✅
Solving blocksort::mainQSort3 with precision 1... ✅
Solving blocksort::mainSort with precision 1... ✅
Solving blocksort::BZ2_blockSort with precision 1... ✅
Solving bzip2::isascii with precision 1... ✅
Solving bzip2::__istype with precision 1... ✅
Solving bzip2::isspace with precision 1... ✅
Solving bzip2::uInt64_from_UInt32s with precision 1... ✅
Solving bzip2::uInt64_to_double with precision 1... ✅
Solving bzip2::uInt64_isZero with precision 1... ✅
Solving bzip2::uInt64_qrm10 with precision 1... ✅
Solving bzip2::uInt64_toAscii with precision 1... ✅
Solving bzip2::myfeof with precision 1... ✅
Solving bzip2::compressStream with precision 1... ✅
Solving bzip2::uncompressStream with precision 1... ✅
Solving bzip2::testStream with precision 1... ✅
Solving bzip2::setExit with precision 1... ✅
Solving bzip2::cadvise with precision 1... ✅
Solving bzip2::showFileNames with precision 1... ✅
Solving bzip2::cleanUpAndFail with precision 1... ✅
Solving bzip2::panic with precision 1... ✅
Solving bzip2::crcError with precision 1... ✅
Solving bzip2::compressedStreamEOF with precision 1... ✅
Solving bzip2::ioError with precision 1... ✅
Solving bzip2::mySignalCatcher with precision 1... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 1... ✅
Solving bzip2::outOfMemory with precision 1... ✅
Solving bzip2::configError with precision 1... ✅
Solving bzip2::pad with precision 1... ✅
Solving bzip2::copyFileName with precision 1... ✅
Solving bzip2::fileExists with precision 1... ✅
Solving bzip2::fopen_output_safely with precision 1... ✅
Solving bzip2::notAStandardFile with precision 1... ✅
Solving bzip2::countHardLinks with precision 1... ✅
Solving bzip2::saveInputFileMetaInfo with precision 1... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 1... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 1... ✅
Solving bzip2::containsDubiousChars with precision 1... ✅
Solving bzip2::hasSuffix with precision 1... ✅
Solving bzip2::mapSuffix with precision 1... ✅
Solving bzip2::compress with precision 1... ✅
Solving bzip2::uncompress with precision 1... ✅
Solving bzip2::testf with precision 1... ✅
Solving bzip2::license with precision 1... ✅
Solving bzip2::usage with precision 1... ✅
Solving bzip2::redundant with precision 1... ✅
Solving bzip2::mkCell with precision 1... ✅
Solving bzip2::snocString with precision 1... ✅
Solving bzip2::addFlagsFromEnvVar with precision 1... ✅
Solving bzip2recover::readError with precision 1... ✅
Solving bzip2recover::writeError with precision 1... ✅
Solving bzip2recover::mallocFail with precision 1... ✅
Solving bzip2recover::tooManyBlocks with precision 1... ✅
Solving bzip2recover::bsPutBit with precision 1... ✅
Solving bzip2recover::bsGetBit with precision 1... ✅
Solving bzip2recover::bsPutUChar with precision 1... ✅
Solving bzip2recover::bsPutUInt32 with precision 1... ✅
Solving bzip2recover::endsInBz2 with precision 1... ✅
Solving bzip2recover::main_0 with precision 1... ❌
Solving bzlib::__isctype with precision 1... ✅
Solving bzlib::isdigit with precision 1... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 1... ✅
Solving bzlib::bz_config_ok with precision 1... ✅
Solving bzlib::prepare_new_block with precision 1... ✅
Solving bzlib::init_RL with precision 1... ✅
Solving bzlib::isempty_RL with precision 1... ✅
Solving bzlib::BZ2_bzCompressInit with precision 1... ❌
Solving bzlib::add_pair_to_block with precision 1... ✅
Solving bzlib::flush_RL with precision 1... ✅
Solving bzlib::copy_input_until_stop with precision 1... ✅
Solving bzlib::copy_output_until_stop with precision 1... ✅
Solving bzlib::handle_compress with precision 1... ❌
Solving bzlib::BZ2_bzCompress with precision 1... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 1... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 1... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 1... ✅
Solving bzlib::BZ2_indexIntoF with precision 1... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 1... ✅
Solving bzlib::BZ2_bzDecompress with precision 1... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 1... ✅
Solving bzlib::myfeof with precision 1... ✅
Solving bzlib::BZ2_bzWrite with precision 1... ✅
Solving bzlib::BZ2_bzWriteClose with precision 1... ✅
Solving bzlib::BZ2_bzRead with precision 1... ✅
Solving bzlib::BZ2_bzReadGetUnused with precision 1... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 1... ✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 1... ✅
Solving bzlib::BZ2_bzlibVersion with precision 1... ✅
Solving bzlib::bzopen_or_bzdopen with precision 1... ✅
Solving bzlib::BZ2_bzopen with precision 1... ✅
Solving bzlib::BZ2_bzdopen with precision 1... ✅
Solving bzlib::BZ2_bzread with precision 1... ✅
Solving bzlib::BZ2_bzwrite with precision 1... ✅
Solving bzlib::BZ2_bzflush with precision 1... ✅
Solving bzlib::BZ2_bzclose with precision 1... ❌
Solving bzlib::BZ2_bzerror with precision 1... ✅
Solving compress::BZ2_bsInitWrite with precision 1... ✅
Solving compress::bsFinishWrite with precision 1... ✅
Solving compress::bsW with precision 1... ✅
Solving compress::bsPutUInt32 with precision 1... ✅
Solving compress::bsPutUChar with precision 1... ✅
Solving compress::makeMaps_e with precision 1... ✅
Solving compress::generateMTFValues with precision 1... ❌
Solving compress::sendMTFValues with precision 1... ✅
Solving compress::BZ2_compressBlock with precision 1... ❌
Solving decompress::makeMaps_d with precision 1... ✅
Solving decompress::BZ2_decompress with precision 1... ❌
Solving huffman::BZ2_hbMakeCodeLengths with precision 1... ✅
Solving huffman::BZ2_hbAssignCodes with precision 1... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 1... ✅
bzip2::main_0: (_, &) -> _
bzlib::BZ2_bzWriteOpen: (&uniq  ↓ &uniq , &, _, _, _) -> &
bzlib::BZ2_bzReadOpen: (&uniq  ↓ &uniq , &, _, _, &, _) -> &
bzip2recover::bsClose: (&move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (&uniq  ↓ &uniq , &, _, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzReadClose: (&uniq  ↓ &uniq , &) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&) -> &move
bzip2recover::bsOpenWriteStream: (&) -> &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (&) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (&) -> _
bzip2::compressStream: (&, &) -> _
bzip2::uncompressStream: (&, &) -> _
bzip2::testStream: (&) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move
bzip2::snocString: (&move, &) -> &move
bzip2::addFlagsFromEnvVar: (&uniq  ↓ &uniq , &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq  ↓ &uniq , _) -> _
bzip2recover::bsGetBit: (&uniq  ↓ &uniq ) -> _
bzip2recover::bsPutUChar: (&uniq  ↓ &uniq , _) -> _
bzip2recover::bsPutUInt32: (&uniq  ↓ &uniq , _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, &any) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq  ↓ &uniq ) -> _
bzlib::init_RL: (&uniq  ↓ &uniq ) -> _
bzlib::isempty_RL: (&) -> _
bzlib::BZ2_bzCompressInit: (&any, _, _, _) -> _
bzlib::add_pair_to_block: (&) -> _
bzlib::flush_RL: (&uniq  ↓ &uniq ) -> _
bzlib::copy_input_until_stop: (&) -> _
bzlib::copy_output_until_stop: (&) -> _
bzlib::handle_compress: (&) -> _
bzlib::BZ2_bzCompress: (&, _) -> _
bzlib::BZ2_bzCompressEnd: (&) -> _
bzlib::BZ2_bzDecompressInit: (&, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (&) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (&) -> _
bzlib::BZ2_bzDecompress: (&) -> _
bzlib::BZ2_bzDecompressEnd: (&) -> _
bzlib::myfeof: (&) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (&any) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq  ↓ &uniq ) -> _
compress::bsFinishWrite: (&) -> _
compress::bsW: (&, _, _) -> _
compress::bsPutUInt32: (&uniq  ↓ &uniq , _) -> _
compress::bsPutUChar: (&uniq  ↓ &uniq , _) -> _
compress::makeMaps_e: (&uniq  ↓ &uniq ) -> _
compress::generateMTFValues: (&any) -> _
compress::sendMTFValues: (&) -> _
compress::BZ2_compressBlock: (&any, _) -> _
decompress::makeMaps_d: (&uniq  ↓ &uniq ) -> _
decompress::BZ2_decompress: (&) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
Solving bzip2::main_0 with precision 2... ❌
Solving bzlib::BZ2_bzWriteOpen with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressInit!
❌
Solving bzlib::BZ2_bzReadOpen with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
❌
Solving bzip2recover::bsClose with precision 2... ✅
Solving bzlib::default_bzfree with precision 2... ✅
Solving bzlib::BZ2_bzWriteClose64 with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
❌
Solving bzlib::BZ2_bzReadClose with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
❌
Solving bzip2::myMalloc with precision 2... ✅
Solving bzip2recover::bsOpenReadStream with precision 2... ✅
Solving bzip2recover::bsOpenWriteStream with precision 2... ✅
Solving bzlib::default_bzalloc with precision 2... ✅
Solving blocksort::fallbackSimpleSort with precision 2... ✅
Solving blocksort::fallbackQSort3 with precision 2... ✅
Solving blocksort::fallbackSort with precision 2... ✅
Solving blocksort::mainGtU with precision 2... ✅
Solving blocksort::mainSimpleSort with precision 2... ✅
Solving blocksort::mmed3 with precision 2... ✅
Solving blocksort::mainQSort3 with precision 2... ✅
Solving blocksort::mainSort with precision 2... ✅
Solving blocksort::BZ2_blockSort with precision 2... ✅
Solving bzip2::isascii with precision 2... ✅
Solving bzip2::__istype with precision 2... ✅
Solving bzip2::isspace with precision 2... ✅
Solving bzip2::uInt64_from_UInt32s with precision 2... ✅
Solving bzip2::uInt64_to_double with precision 2... ✅
Solving bzip2::uInt64_isZero with precision 2... ✅
Solving bzip2::uInt64_qrm10 with precision 2... ✅
Solving bzip2::uInt64_toAscii with precision 2... ✅
Solving bzip2::myfeof with precision 2... ✅
Solving bzip2::compressStream with precision 2... ✅
Solving bzip2::uncompressStream with precision 2... ✅
Solving bzip2::testStream with precision 2... ✅
Solving bzip2::setExit with precision 2... ✅
Solving bzip2::cadvise with precision 2... ✅
Solving bzip2::showFileNames with precision 2... ✅
Solving bzip2::cleanUpAndFail with precision 2... ✅
Solving bzip2::panic with precision 2... ✅
Solving bzip2::crcError with precision 2... ✅
Solving bzip2::compressedStreamEOF with precision 2... ✅
Solving bzip2::ioError with precision 2... ✅
Solving bzip2::mySignalCatcher with precision 2... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 2... ✅
Solving bzip2::outOfMemory with precision 2... ✅
Solving bzip2::configError with precision 2... ✅
Solving bzip2::pad with precision 2... ✅
Solving bzip2::copyFileName with precision 2... ✅
Solving bzip2::fileExists with precision 2... ✅
Solving bzip2::fopen_output_safely with precision 2... ✅
Solving bzip2::notAStandardFile with precision 2... ✅
Solving bzip2::countHardLinks with precision 2... ✅
Solving bzip2::saveInputFileMetaInfo with precision 2... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 2... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 2... ✅
Solving bzip2::containsDubiousChars with precision 2... ✅
Solving bzip2::hasSuffix with precision 2... ✅
Solving bzip2::mapSuffix with precision 2... ✅
Solving bzip2::compress with precision 2... ✅
Solving bzip2::uncompress with precision 2... ✅
Solving bzip2::testf with precision 2... ✅
Solving bzip2::license with precision 2... ✅
Solving bzip2::usage with precision 2... ✅
Solving bzip2::redundant with precision 2... ✅
Solving bzip2::mkCell with precision 2... ✅
Solving bzip2::snocString with precision 2... ❌
Solving bzip2::addFlagsFromEnvVar with precision 2... ✅
Solving bzip2recover::readError with precision 2... ✅
Solving bzip2recover::writeError with precision 2... ✅
Solving bzip2recover::mallocFail with precision 2... ✅
Solving bzip2recover::tooManyBlocks with precision 2... ✅
Solving bzip2recover::bsPutBit with precision 2... ✅
Solving bzip2recover::bsGetBit with precision 2... ✅
Solving bzip2recover::bsPutUChar with precision 2... ✅
Solving bzip2recover::bsPutUInt32 with precision 2... ✅
Solving bzip2recover::endsInBz2 with precision 2... ✅
Solving bzip2recover::main_0 with precision 2... ❌
Solving bzlib::__isctype with precision 2... ✅
Solving bzlib::isdigit with precision 2... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 2... ✅
Solving bzlib::bz_config_ok with precision 2... ✅
Solving bzlib::prepare_new_block with precision 2... ✅
Solving bzlib::init_RL with precision 2... ✅
Solving bzlib::isempty_RL with precision 2... ✅
Solving bzlib::BZ2_bzCompressInit with precision 2... ❌
Solving bzlib::add_pair_to_block with precision 2... ✅
Solving bzlib::flush_RL with precision 2... ✅
Solving bzlib::copy_input_until_stop with precision 2... ✅
Solving bzlib::copy_output_until_stop with precision 2... ✅
Solving bzlib::handle_compress with precision 2... ❌
Solving bzlib::BZ2_bzCompress with precision 2... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 2... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 2... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 2... ✅
Solving bzlib::BZ2_indexIntoF with precision 2... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 2... ✅
Solving bzlib::BZ2_bzDecompress with precision 2... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 2... ✅
Solving bzlib::myfeof with precision 2... ✅
Solving bzlib::BZ2_bzWrite with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
✅
Solving bzlib::BZ2_bzWriteClose with precision 2... ✅
Solving bzlib::BZ2_bzRead with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
✅
Solving bzlib::BZ2_bzReadGetUnused with precision 2... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
✅
Solving bzlib::BZ2_bzlibVersion with precision 2... ✅
Solving bzlib::bzopen_or_bzdopen with precision 2... ✅
Solving bzlib::BZ2_bzopen with precision 2... ✅
Solving bzlib::BZ2_bzdopen with precision 2... ✅
Solving bzlib::BZ2_bzread with precision 2... ✅
Solving bzlib::BZ2_bzwrite with precision 2... ✅
Solving bzlib::BZ2_bzflush with precision 2... ✅
Solving bzlib::BZ2_bzclose with precision 2... ❌
Solving bzlib::BZ2_bzerror with precision 2... ✅
Solving compress::BZ2_bsInitWrite with precision 2... ✅
Solving compress::bsFinishWrite with precision 2... ✅
Solving compress::bsW with precision 2... ✅
Solving compress::bsPutUInt32 with precision 2... ✅
Solving compress::bsPutUChar with precision 2... ✅
Solving compress::makeMaps_e with precision 2... ✅
Solving compress::generateMTFValues with precision 2... ❌
Solving compress::sendMTFValues with precision 2... ✅
Solving compress::BZ2_compressBlock with precision 2... ❌
Solving decompress::makeMaps_d with precision 2... ✅
Solving decompress::BZ2_decompress with precision 2... ❌
Solving huffman::BZ2_hbMakeCodeLengths with precision 2... ✅
Solving huffman::BZ2_hbAssignCodes with precision 2... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 2... ✅
bzip2::main_0: (_, &any &any) -> _
bzlib::BZ2_bzWriteOpen: (&uniq  ↓ &uniq , & & & & & & &, _, _, _) -> &
bzlib::BZ2_bzReadOpen: (&uniq  ↓ &uniq , & & & & & & &, _, _, &, _) -> &
bzip2recover::bsClose: (&move &move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (&uniq  ↓ &uniq , &, _, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzReadClose: (&uniq  ↓ &uniq , &) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&move & & & & & &) -> &move &move
bzip2recover::bsOpenWriteStream: (&move & & & & & &) -> &move &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (& & & & & & & & &) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (& & & & & & &) -> _
bzip2::compressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::uncompressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::testStream: (& & & & & & &) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> & & & & & & &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move & &
bzip2::snocString: (& &any &any, &any) -> & & &
bzip2::addFlagsFromEnvVar: (&uniq & ↓ &uniq &, &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq & ↓ &uniq &, _) -> _
bzip2recover::bsGetBit: (&uniq & ↓ &uniq &) -> _
bzip2recover::bsPutUChar: (&uniq & ↓ &uniq &, _) -> _
bzip2recover::bsPutUInt32: (&uniq & ↓ &uniq &, _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, &any &any) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &) -> _
bzlib::init_RL: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &) -> _
bzlib::isempty_RL: (& & & & & & & & &) -> _
bzlib::BZ2_bzCompressInit: (&any & & & &, _, _, _) -> _
bzlib::add_pair_to_block: (& & & & & & & & &) -> _
bzlib::flush_RL: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &) -> _
bzlib::copy_input_until_stop: (& & & & & & & & &) -> _
bzlib::copy_output_until_stop: (& & & & & & & & &) -> _
bzlib::handle_compress: (& & & & &) -> _
bzlib::BZ2_bzCompress: (& & & & &, _) -> _
bzlib::BZ2_bzCompressEnd: (& & & & &) -> _
bzlib::BZ2_bzDecompressInit: (& & & & &, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (& & & & & & & &) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (& & & & & & & &) -> _
bzlib::BZ2_bzDecompress: (& & & & &) -> _
bzlib::BZ2_bzDecompressEnd: (& & & & &) -> _
bzlib::myfeof: (& & & & & & &) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (&any) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &) -> _
compress::bsFinishWrite: (& & & & & & & & &) -> _
compress::bsW: (& & & & & & & & &, _, _) -> _
compress::bsPutUInt32: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &, _) -> _
compress::bsPutUChar: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &, _) -> _
compress::makeMaps_e: (&uniq & & & & & & & & ↓ &uniq & & & & & & & &) -> _
compress::generateMTFValues: (&any &any &any &any &any &any &any &any &any) -> _
compress::sendMTFValues: (& & & & & & & & &) -> _
compress::BZ2_compressBlock: (&any &any &any &any &any &any &any &any &any, _) -> _
decompress::makeMaps_d: (&uniq & & & & & & & ↓ &uniq & & & & & & &) -> _
decompress::BZ2_decompress: (& & & & & & & &) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
Solving bzip2::main_0 with precision 3... ❌
Solving bzlib::BZ2_bzWriteOpen with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressInit!
❌
Solving bzlib::BZ2_bzReadOpen with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
❌
Solving bzip2recover::bsClose with precision 3... ✅
Solving bzlib::default_bzfree with precision 3... ✅
Solving bzlib::BZ2_bzWriteClose64 with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
❌
Solving bzlib::BZ2_bzReadClose with precision 2... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
❌
Solving bzip2::myMalloc with precision 3... ✅
Solving bzip2recover::bsOpenReadStream with precision 3... ✅
Solving bzip2recover::bsOpenWriteStream with precision 3... ✅
Solving bzlib::default_bzalloc with precision 3... ✅
Solving blocksort::fallbackSimpleSort with precision 3... ✅
Solving blocksort::fallbackQSort3 with precision 3... ✅
Solving blocksort::fallbackSort with precision 3... ✅
Solving blocksort::mainGtU with precision 3... ✅
Solving blocksort::mainSimpleSort with precision 3... ✅
Solving blocksort::mmed3 with precision 3... ✅
Solving blocksort::mainQSort3 with precision 3... ✅
Solving blocksort::mainSort with precision 3... ✅
Solving blocksort::BZ2_blockSort with precision 3... ✅
Solving bzip2::isascii with precision 3... ✅
Solving bzip2::__istype with precision 3... ✅
Solving bzip2::isspace with precision 3... ✅
Solving bzip2::uInt64_from_UInt32s with precision 3... ✅
Solving bzip2::uInt64_to_double with precision 3... ✅
Solving bzip2::uInt64_isZero with precision 3... ✅
Solving bzip2::uInt64_qrm10 with precision 3... ✅
Solving bzip2::uInt64_toAscii with precision 3... ✅
Solving bzip2::myfeof with precision 3... ✅
Solving bzip2::compressStream with precision 3... ✅
Solving bzip2::uncompressStream with precision 3... ✅
Solving bzip2::testStream with precision 3... ✅
Solving bzip2::setExit with precision 3... ✅
Solving bzip2::cadvise with precision 3... ✅
Solving bzip2::showFileNames with precision 3... ✅
Solving bzip2::cleanUpAndFail with precision 3... ✅
Solving bzip2::panic with precision 3... ✅
Solving bzip2::crcError with precision 3... ✅
Solving bzip2::compressedStreamEOF with precision 3... ✅
Solving bzip2::ioError with precision 3... ✅
Solving bzip2::mySignalCatcher with precision 3... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 3... ✅
Solving bzip2::outOfMemory with precision 3... ✅
Solving bzip2::configError with precision 3... ✅
Solving bzip2::pad with precision 3... ✅
Solving bzip2::copyFileName with precision 3... ✅
Solving bzip2::fileExists with precision 3... ✅
Solving bzip2::fopen_output_safely with precision 3... ✅
Solving bzip2::notAStandardFile with precision 3... ✅
Solving bzip2::countHardLinks with precision 3... ✅
Solving bzip2::saveInputFileMetaInfo with precision 3... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 3... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 3... ✅
Solving bzip2::containsDubiousChars with precision 3... ✅
Solving bzip2::hasSuffix with precision 3... ✅
Solving bzip2::mapSuffix with precision 3... ✅
Solving bzip2::compress with precision 3... ✅
Solving bzip2::uncompress with precision 3... ✅
Solving bzip2::testf with precision 3... ✅
Solving bzip2::license with precision 3... ✅
Solving bzip2::usage with precision 3... ✅
Solving bzip2::redundant with precision 3... ✅
Solving bzip2::mkCell with precision 3... ✅
Solving bzip2::snocString with precision 3... ❌
Solving bzip2::addFlagsFromEnvVar with precision 3... ✅
Solving bzip2recover::readError with precision 3... ✅
Solving bzip2recover::writeError with precision 3... ✅
Solving bzip2recover::mallocFail with precision 3... ✅
Solving bzip2recover::tooManyBlocks with precision 3... ✅
Solving bzip2recover::bsPutBit with precision 3... ✅
Solving bzip2recover::bsGetBit with precision 3... ✅
Solving bzip2recover::bsPutUChar with precision 3... ✅
Solving bzip2recover::bsPutUInt32 with precision 3... ✅
Solving bzip2recover::endsInBz2 with precision 3... ✅
Solving bzip2recover::main_0 with precision 2... ❌
Solving bzlib::__isctype with precision 3... ✅
Solving bzlib::isdigit with precision 3... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 3... ✅
Solving bzlib::bz_config_ok with precision 3... ✅
Solving bzlib::prepare_new_block with precision 3... ✅
Solving bzlib::init_RL with precision 3... ✅
Solving bzlib::isempty_RL with precision 3... ✅
Solving bzlib::BZ2_bzCompressInit with precision 2... ❌
Solving bzlib::add_pair_to_block with precision 3... ✅
Solving bzlib::flush_RL with precision 3... ✅
Solving bzlib::copy_input_until_stop with precision 3... ✅
Solving bzlib::copy_output_until_stop with precision 3... ✅
Solving bzlib::handle_compress with precision 2... ❌
Solving bzlib::BZ2_bzCompress with precision 3... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 3... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 3... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 3... ✅
Solving bzlib::BZ2_indexIntoF with precision 3... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 3... ✅
Solving bzlib::BZ2_bzDecompress with precision 3... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 3... ✅
Solving bzlib::myfeof with precision 3... ✅
Solving bzlib::BZ2_bzWrite with precision 3... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
✅
Solving bzlib::BZ2_bzWriteClose with precision 3... ✅
Solving bzlib::BZ2_bzRead with precision 3... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
✅
Solving bzlib::BZ2_bzReadGetUnused with precision 3... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 3... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 3... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
✅
Solving bzlib::BZ2_bzlibVersion with precision 3... ✅
Solving bzlib::bzopen_or_bzdopen with precision 3... ✅
Solving bzlib::BZ2_bzopen with precision 3... ✅
Solving bzlib::BZ2_bzdopen with precision 3... ✅
Solving bzlib::BZ2_bzread with precision 3... ✅
Solving bzlib::BZ2_bzwrite with precision 3... ✅
Solving bzlib::BZ2_bzflush with precision 3... ✅
Solving bzlib::BZ2_bzclose with precision 2... ❌
Solving bzlib::BZ2_bzerror with precision 3... ✅
Solving compress::BZ2_bsInitWrite with precision 3... ✅
Solving compress::bsFinishWrite with precision 3... ✅
Solving compress::bsW with precision 3... ✅
Solving compress::bsPutUInt32 with precision 3... ✅
Solving compress::bsPutUChar with precision 3... ✅
Solving compress::makeMaps_e with precision 3... ✅
Solving compress::generateMTFValues with precision 2... ❌
Solving compress::sendMTFValues with precision 3... ✅
Solving compress::BZ2_compressBlock with precision 2... ❌
Solving decompress::makeMaps_d with precision 3... ✅
Solving decompress::BZ2_decompress with precision 2... ❌
Solving huffman::BZ2_hbMakeCodeLengths with precision 3... ✅
Solving huffman::BZ2_hbAssignCodes with precision 3... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 3... ✅
bzip2::main_0: (_, &any &any) -> _
bzlib::BZ2_bzWriteOpen: (&uniq  ↓ &uniq , & & & & & & &, _, _, _) -> &
bzlib::BZ2_bzReadOpen: (&uniq  ↓ &uniq , & & & & & & &, _, _, &, _) -> &
bzip2recover::bsClose: (&move &move &move &move &move &move &move &move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (&uniq  ↓ &uniq , &, _, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzReadClose: (&uniq  ↓ &uniq , &) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzip2recover::bsOpenWriteStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (& & & & & & & & & & & & &) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (& & & & & & &) -> _
bzip2::compressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::uncompressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::testStream: (& & & & & & &) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> & & & & & & &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move & & & &
bzip2::snocString: (& & & &any &any, &any) -> & & & & &
bzip2::addFlagsFromEnvVar: (&uniq & & & ↓ &uniq & & &, &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsGetBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &) -> _
bzip2recover::bsPutUChar: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsPutUInt32: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, &any &any) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::init_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::isempty_RL: (& & & & & & & & & & & & &) -> _
bzlib::BZ2_bzCompressInit: (&any & & & &, _, _, _) -> _
bzlib::add_pair_to_block: (& & & & & & & & & & & & &) -> _
bzlib::flush_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::copy_input_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::copy_output_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::handle_compress: (& & & & &) -> _
bzlib::BZ2_bzCompress: (& & & & &, _) -> _
bzlib::BZ2_bzCompressEnd: (& & & & &) -> _
bzlib::BZ2_bzDecompressInit: (& & & & &, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (& & & & & & & & & & & &) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (& & & & & & & & & & & &) -> _
bzlib::BZ2_bzDecompress: (& & & & &) -> _
bzlib::BZ2_bzDecompressEnd: (& & & & &) -> _
bzlib::myfeof: (& & & & & & &) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (&any) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::bsFinishWrite: (& & & & & & & & & & & & &) -> _
compress::bsW: (& & & & & & & & & & & & &, _, _) -> _
compress::bsPutUInt32: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::bsPutUChar: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::makeMaps_e: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::generateMTFValues: (&any &any &any &any &any &any &any &any &any) -> _
compress::sendMTFValues: (& & & & & & & & & & & & &) -> _
compress::BZ2_compressBlock: (&any &any &any &any &any &any &any &any &any, _) -> _
decompress::makeMaps_d: (&uniq & & & & & & & & & & & ↓ &uniq & & & & & & & & & & &) -> _
decompress::BZ2_decompress: (& & & & & & & &) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
Solving bzip2::main_0 with precision 2... ❌
Solving bzlib::BZ2_bzWriteOpen with precision 1... ❌
Solving bzlib::BZ2_bzReadOpen with precision 1... ❌
Solving bzip2recover::bsClose with precision 4... ✅
Solving bzlib::default_bzfree with precision 4... ✅
Solving bzlib::BZ2_bzWriteClose64 with precision 1... ❌
Solving bzlib::BZ2_bzReadClose with precision 1... ❌
Solving bzip2::myMalloc with precision 4... ✅
Solving bzip2recover::bsOpenReadStream with precision 4... ✅
Solving bzip2recover::bsOpenWriteStream with precision 4... ✅
Solving bzlib::default_bzalloc with precision 4... ✅
Solving blocksort::fallbackSimpleSort with precision 4... ✅
Solving blocksort::fallbackQSort3 with precision 4... ✅
Solving blocksort::fallbackSort with precision 4... ✅
Solving blocksort::mainGtU with precision 4... ✅
Solving blocksort::mainSimpleSort with precision 4... ✅
Solving blocksort::mmed3 with precision 4... ✅
Solving blocksort::mainQSort3 with precision 4... ✅
Solving blocksort::mainSort with precision 4... ✅
Solving blocksort::BZ2_blockSort with precision 4... ✅
Solving bzip2::isascii with precision 4... ✅
Solving bzip2::__istype with precision 4... ✅
Solving bzip2::isspace with precision 4... ✅
Solving bzip2::uInt64_from_UInt32s with precision 4... ✅
Solving bzip2::uInt64_to_double with precision 4... ✅
Solving bzip2::uInt64_isZero with precision 4... ✅
Solving bzip2::uInt64_qrm10 with precision 4... ✅
Solving bzip2::uInt64_toAscii with precision 4... ✅
Solving bzip2::myfeof with precision 4... ✅
Solving bzip2::compressStream with precision 4... ✅
Solving bzip2::uncompressStream with precision 4... ✅
Solving bzip2::testStream with precision 4... ✅
Solving bzip2::setExit with precision 4... ✅
Solving bzip2::cadvise with precision 4... ✅
Solving bzip2::showFileNames with precision 4... ✅
Solving bzip2::cleanUpAndFail with precision 4... ✅
Solving bzip2::panic with precision 4... ✅
Solving bzip2::crcError with precision 4... ✅
Solving bzip2::compressedStreamEOF with precision 4... ✅
Solving bzip2::ioError with precision 4... ✅
Solving bzip2::mySignalCatcher with precision 4... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 4... ✅
Solving bzip2::outOfMemory with precision 4... ✅
Solving bzip2::configError with precision 4... ✅
Solving bzip2::pad with precision 4... ✅
Solving bzip2::copyFileName with precision 4... ✅
Solving bzip2::fileExists with precision 4... ✅
Solving bzip2::fopen_output_safely with precision 4... ✅
Solving bzip2::notAStandardFile with precision 4... ✅
Solving bzip2::countHardLinks with precision 4... ✅
Solving bzip2::saveInputFileMetaInfo with precision 4... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 4... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 4... ✅
Solving bzip2::containsDubiousChars with precision 4... ✅
Solving bzip2::hasSuffix with precision 4... ✅
Solving bzip2::mapSuffix with precision 4... ✅
Solving bzip2::compress with precision 4... ✅
Solving bzip2::uncompress with precision 4... ✅
Solving bzip2::testf with precision 4... ✅
Solving bzip2::license with precision 4... ✅
Solving bzip2::usage with precision 4... ✅
Solving bzip2::redundant with precision 4... ✅
Solving bzip2::mkCell with precision 4... ✅
Solving bzip2::snocString with precision 2... ❌
Solving bzip2::addFlagsFromEnvVar with precision 4... ✅
Solving bzip2recover::readError with precision 4... ✅
Solving bzip2recover::writeError with precision 4... ✅
Solving bzip2recover::mallocFail with precision 4... ✅
Solving bzip2recover::tooManyBlocks with precision 4... ✅
Solving bzip2recover::bsPutBit with precision 4... ✅
Solving bzip2recover::bsGetBit with precision 4... ✅
Solving bzip2recover::bsPutUChar with precision 4... ✅
Solving bzip2recover::bsPutUInt32 with precision 4... ✅
Solving bzip2recover::endsInBz2 with precision 4... ✅
Solving bzip2recover::main_0 with precision 1... ❌
Solving bzlib::__isctype with precision 4... ✅
Solving bzlib::isdigit with precision 4... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 4... ✅
Solving bzlib::bz_config_ok with precision 4... ✅
Solving bzlib::prepare_new_block with precision 4... ✅
Solving bzlib::init_RL with precision 4... ✅
Solving bzlib::isempty_RL with precision 4... ✅
Solving bzlib::BZ2_bzCompressInit with precision 1... ❌
Solving bzlib::add_pair_to_block with precision 4... ✅
Solving bzlib::flush_RL with precision 4... ✅
Solving bzlib::copy_input_until_stop with precision 4... ✅
Solving bzlib::copy_output_until_stop with precision 4... ✅
Solving bzlib::handle_compress with precision 1... ❌
Solving bzlib::BZ2_bzCompress with precision 4... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 4... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 4... ✅
Solving bzlib::BZ2_indexIntoF with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 4... ✅
Solving bzlib::BZ2_bzDecompress with precision 4... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 4... ✅
Solving bzlib::myfeof with precision 4... ✅
Solving bzlib::BZ2_bzWrite with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
✅
Solving bzlib::BZ2_bzWriteClose with precision 4... ✅
Solving bzlib::BZ2_bzRead with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
✅
Solving bzlib::BZ2_bzReadGetUnused with precision 4... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
✅
Solving bzlib::BZ2_bzlibVersion with precision 4... ✅
Solving bzlib::bzopen_or_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzopen with precision 4... ✅
Solving bzlib::BZ2_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzread with precision 4... ✅
Solving bzlib::BZ2_bzwrite with precision 4... ✅
Solving bzlib::BZ2_bzflush with precision 4... ✅
Solving bzlib::BZ2_bzclose with precision 1... ❌
Solving bzlib::BZ2_bzerror with precision 4... ✅
Solving compress::BZ2_bsInitWrite with precision 4... ✅
Solving compress::bsFinishWrite with precision 4... ✅
Solving compress::bsW with precision 4... ✅
Solving compress::bsPutUInt32 with precision 4... ✅
Solving compress::bsPutUChar with precision 4... ✅
Solving compress::makeMaps_e with precision 4... ✅
Solving compress::generateMTFValues with precision 1... ❌
Solving compress::sendMTFValues with precision 4... ✅
Solving compress::BZ2_compressBlock with precision 1... ❌
Solving decompress::makeMaps_d with precision 4... ✅
Solving decompress::BZ2_decompress with precision 1... ❌
Solving huffman::BZ2_hbMakeCodeLengths with precision 4... ✅
Solving huffman::BZ2_hbAssignCodes with precision 4... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 4... ✅
bzip2::main_0: (_, &any &any) -> _
bzlib::BZ2_bzWriteOpen: (&uniq  ↓ &uniq , &, _, _, _) -> &
bzlib::BZ2_bzReadOpen: (&uniq  ↓ &uniq , &, _, _, &, _) -> &
bzip2recover::bsClose: (&move &move &move &move &move &move &move &move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (&uniq  ↓ &uniq , &, _, &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzReadClose: (&uniq  ↓ &uniq , &) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzip2recover::bsOpenWriteStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (& & & & & & & & & & & & &) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (& & & & & & &) -> _
bzip2::compressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::uncompressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::testStream: (& & & & & & &) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> & & & & & & &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move & & & & & &
bzip2::snocString: (& & &, &any) -> & & &
bzip2::addFlagsFromEnvVar: (&uniq & & & & & ↓ &uniq & & & & &, &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsGetBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &) -> _
bzip2recover::bsPutUChar: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsPutUInt32: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, &any) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::init_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::isempty_RL: (& & & & & & & & & & & & &) -> _
bzlib::BZ2_bzCompressInit: (&any, _, _, _) -> _
bzlib::add_pair_to_block: (& & & & & & & & & & & & &) -> _
bzlib::flush_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::copy_input_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::copy_output_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::handle_compress: (&) -> _
bzlib::BZ2_bzCompress: (& & & & &, _) -> _
bzlib::BZ2_bzCompressEnd: (& & & & &) -> _
bzlib::BZ2_bzDecompressInit: (& & & & &, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (& & & & & & & & & & & &) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (& & & & & & & & & & & &) -> _
bzlib::BZ2_bzDecompress: (& & & & &) -> _
bzlib::BZ2_bzDecompressEnd: (& & & & &) -> _
bzlib::myfeof: (& & & & & & &) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (&any) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::bsFinishWrite: (& & & & & & & & & & & & &) -> _
compress::bsW: (& & & & & & & & & & & & &, _, _) -> _
compress::bsPutUInt32: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::bsPutUChar: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::makeMaps_e: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::generateMTFValues: (&any) -> _
compress::sendMTFValues: (& & & & & & & & & & & & &) -> _
compress::BZ2_compressBlock: (&any, _) -> _
decompress::makeMaps_d: (&uniq & & & & & & & & & & & ↓ &uniq & & & & & & & & & & &) -> _
decompress::BZ2_decompress: (&) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
Solving bzip2::main_0 with precision 1... ✅
Solving bzip2recover::bsClose with precision 4... ✅
Solving bzlib::default_bzfree with precision 4... ✅
Solving bzip2::myMalloc with precision 4... ✅
Solving bzip2recover::bsOpenReadStream with precision 4... ✅
Solving bzip2recover::bsOpenWriteStream with precision 4... ✅
Solving bzlib::default_bzalloc with precision 4... ✅
Solving blocksort::fallbackSimpleSort with precision 4... ✅
Solving blocksort::fallbackQSort3 with precision 4... ✅
Solving blocksort::fallbackSort with precision 4... ✅
Solving blocksort::mainGtU with precision 4... ✅
Solving blocksort::mainSimpleSort with precision 4... ✅
Solving blocksort::mmed3 with precision 4... ✅
Solving blocksort::mainQSort3 with precision 4... ✅
Solving blocksort::mainSort with precision 4... ✅
Solving blocksort::BZ2_blockSort with precision 4... ✅
Solving bzip2::isascii with precision 4... ✅
Solving bzip2::__istype with precision 4... ✅
Solving bzip2::isspace with precision 4... ✅
Solving bzip2::uInt64_from_UInt32s with precision 4... ✅
Solving bzip2::uInt64_to_double with precision 4... ✅
Solving bzip2::uInt64_isZero with precision 4... ✅
Solving bzip2::uInt64_qrm10 with precision 4... ✅
Solving bzip2::uInt64_toAscii with precision 4... ✅
Solving bzip2::myfeof with precision 4... ✅
Solving bzip2::compressStream with precision 4... ✅
Solving bzip2::uncompressStream with precision 4... ✅
Solving bzip2::testStream with precision 4... ✅
Solving bzip2::setExit with precision 4... ✅
Solving bzip2::cadvise with precision 4... ✅
Solving bzip2::showFileNames with precision 4... ✅
Solving bzip2::cleanUpAndFail with precision 4... ✅
Solving bzip2::panic with precision 4... ✅
Solving bzip2::crcError with precision 4... ✅
Solving bzip2::compressedStreamEOF with precision 4... ✅
Solving bzip2::ioError with precision 4... ✅
Solving bzip2::mySignalCatcher with precision 4... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 4... ✅
Solving bzip2::outOfMemory with precision 4... ✅
Solving bzip2::configError with precision 4... ✅
Solving bzip2::pad with precision 4... ✅
Solving bzip2::copyFileName with precision 4... ✅
Solving bzip2::fileExists with precision 4... ✅
Solving bzip2::fopen_output_safely with precision 4... ✅
Solving bzip2::notAStandardFile with precision 4... ✅
Solving bzip2::countHardLinks with precision 4... ✅
Solving bzip2::saveInputFileMetaInfo with precision 4... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 4... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 4... ✅
Solving bzip2::containsDubiousChars with precision 4... ✅
Solving bzip2::hasSuffix with precision 4... ✅
Solving bzip2::mapSuffix with precision 4... ✅
Solving bzip2::compress with precision 4... ✅
Solving bzip2::uncompress with precision 4... ✅
Solving bzip2::testf with precision 4... ✅
Solving bzip2::license with precision 4... ✅
Solving bzip2::usage with precision 4... ✅
Solving bzip2::redundant with precision 4... ✅
Solving bzip2::mkCell with precision 4... ✅
Solving bzip2::snocString with precision 1... ✅
Solving bzip2::addFlagsFromEnvVar with precision 4... ✅
Solving bzip2recover::readError with precision 4... ✅
Solving bzip2recover::writeError with precision 4... ✅
Solving bzip2recover::mallocFail with precision 4... ✅
Solving bzip2recover::tooManyBlocks with precision 4... ✅
Solving bzip2recover::bsPutBit with precision 4... ✅
Solving bzip2recover::bsGetBit with precision 4... ✅
Solving bzip2recover::bsPutUChar with precision 4... ✅
Solving bzip2recover::bsPutUInt32 with precision 4... ✅
Solving bzip2recover::endsInBz2 with precision 4... ✅
Solving bzlib::__isctype with precision 4... ✅
Solving bzlib::isdigit with precision 4... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 4... ✅
Solving bzlib::bz_config_ok with precision 4... ✅
Solving bzlib::prepare_new_block with precision 4... ✅
Solving bzlib::init_RL with precision 4... ✅
Solving bzlib::isempty_RL with precision 4... ✅
Solving bzlib::add_pair_to_block with precision 4... ✅
Solving bzlib::flush_RL with precision 4... ✅
Solving bzlib::copy_input_until_stop with precision 4... ✅
Solving bzlib::copy_output_until_stop with precision 4... ✅
Solving bzlib::BZ2_bzCompress with precision 4... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 4... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 4... ✅
Solving bzlib::BZ2_indexIntoF with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 4... ✅
Solving bzlib::BZ2_bzDecompress with precision 4... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 4... ✅
Solving bzlib::myfeof with precision 4... ✅
Solving bzlib::BZ2_bzWrite with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
✅
Solving bzlib::BZ2_bzWriteClose with precision 4... ✅
Solving bzlib::BZ2_bzRead with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
✅
Solving bzlib::BZ2_bzReadGetUnused with precision 4... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
✅
Solving bzlib::BZ2_bzlibVersion with precision 4... ✅
Solving bzlib::bzopen_or_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzopen with precision 4... ✅
Solving bzlib::BZ2_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzread with precision 4... ✅
Solving bzlib::BZ2_bzwrite with precision 4... ✅
Solving bzlib::BZ2_bzflush with precision 4... ✅
Solving bzlib::BZ2_bzerror with precision 4... ✅
Solving compress::BZ2_bsInitWrite with precision 4... ✅
Solving compress::bsFinishWrite with precision 4... ✅
Solving compress::bsW with precision 4... ✅
Solving compress::bsPutUInt32 with precision 4... ✅
Solving compress::bsPutUChar with precision 4... ✅
Solving compress::makeMaps_e with precision 4... ✅
Solving compress::sendMTFValues with precision 4... ✅
Solving decompress::makeMaps_d with precision 4... ✅
Solving huffman::BZ2_hbMakeCodeLengths with precision 4... ✅
Solving huffman::BZ2_hbAssignCodes with precision 4... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 4... ✅
bzip2::main_0: (_, &) -> _
bzlib::BZ2_bzWriteOpen: (_, _, _, _, _) -> _
bzlib::BZ2_bzReadOpen: (_, _, _, _, _, _) -> _
bzip2recover::bsClose: (&move &move &move &move &move &move &move &move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (_, _, _, _, _, _, _) -> _
bzlib::BZ2_bzReadClose: (_, _) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzip2recover::bsOpenWriteStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (& & & & & & & & & & & & &) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (& & & & & & &) -> _
bzip2::compressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::uncompressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::testStream: (& & & & & & &) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> & & & & & & &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move & & & & & &
bzip2::snocString: (&move, &) -> &move
bzip2::addFlagsFromEnvVar: (&uniq &move & & & & ↓ &uniq &move & & & &, &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsGetBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &) -> _
bzip2recover::bsPutUChar: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsPutUInt32: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, _) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::init_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::isempty_RL: (& & & & & & & & & & & & &) -> _
bzlib::BZ2_bzCompressInit: (_, _, _, _) -> _
bzlib::add_pair_to_block: (& & & & & & & & & & & & &) -> _
bzlib::flush_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::copy_input_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::copy_output_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::handle_compress: (_) -> _
bzlib::BZ2_bzCompress: (& & & & &, _) -> _
bzlib::BZ2_bzCompressEnd: (& & & & &) -> _
bzlib::BZ2_bzDecompressInit: (& & & & &, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (& & & & & & & & & & & &) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (& & & & & & & & & & & &) -> _
bzlib::BZ2_bzDecompress: (& & & & &) -> _
bzlib::BZ2_bzDecompressEnd: (& & & & &) -> _
bzlib::myfeof: (& & & & & & &) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (_) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::bsFinishWrite: (& & & & & & & & & & & & &) -> _
compress::bsW: (& & & & & & & & & & & & &, _, _) -> _
compress::bsPutUInt32: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::bsPutUChar: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::makeMaps_e: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::generateMTFValues: (_) -> _
compress::sendMTFValues: (& & & & & & & & & & & & &) -> _
compress::BZ2_compressBlock: (_, _) -> _
decompress::makeMaps_d: (&uniq & & & & & & & & & & & ↓ &uniq & & & & & & & & & & &) -> _
decompress::BZ2_decompress: (_) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
Solving bzip2::main_0 with precision 1... ✅
Solving bzip2recover::bsClose with precision 4... ✅
Solving bzlib::default_bzfree with precision 4... ✅
Solving bzip2::myMalloc with precision 4... ✅
Solving bzip2recover::bsOpenReadStream with precision 4... ✅
Solving bzip2recover::bsOpenWriteStream with precision 4... ✅
Solving bzlib::default_bzalloc with precision 4... ✅
Solving blocksort::fallbackSimpleSort with precision 4... ✅
Solving blocksort::fallbackQSort3 with precision 4... ✅
Solving blocksort::fallbackSort with precision 4... ✅
Solving blocksort::mainGtU with precision 4... ✅
Solving blocksort::mainSimpleSort with precision 4... ✅
Solving blocksort::mmed3 with precision 4... ✅
Solving blocksort::mainQSort3 with precision 4... ✅
Solving blocksort::mainSort with precision 4... ✅
Solving blocksort::BZ2_blockSort with precision 4... ✅
Solving bzip2::isascii with precision 4... ✅
Solving bzip2::__istype with precision 4... ✅
Solving bzip2::isspace with precision 4... ✅
Solving bzip2::uInt64_from_UInt32s with precision 4... ✅
Solving bzip2::uInt64_to_double with precision 4... ✅
Solving bzip2::uInt64_isZero with precision 4... ✅
Solving bzip2::uInt64_qrm10 with precision 4... ✅
Solving bzip2::uInt64_toAscii with precision 4... ✅
Solving bzip2::myfeof with precision 4... ✅
Solving bzip2::compressStream with precision 4... ✅
Solving bzip2::uncompressStream with precision 4... ✅
Solving bzip2::testStream with precision 4... ✅
Solving bzip2::setExit with precision 4... ✅
Solving bzip2::cadvise with precision 4... ✅
Solving bzip2::showFileNames with precision 4... ✅
Solving bzip2::cleanUpAndFail with precision 4... ✅
Solving bzip2::panic with precision 4... ✅
Solving bzip2::crcError with precision 4... ✅
Solving bzip2::compressedStreamEOF with precision 4... ✅
Solving bzip2::ioError with precision 4... ✅
Solving bzip2::mySignalCatcher with precision 4... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 4... ✅
Solving bzip2::outOfMemory with precision 4... ✅
Solving bzip2::configError with precision 4... ✅
Solving bzip2::pad with precision 4... ✅
Solving bzip2::copyFileName with precision 4... ✅
Solving bzip2::fileExists with precision 4... ✅
Solving bzip2::fopen_output_safely with precision 4... ✅
Solving bzip2::notAStandardFile with precision 4... ✅
Solving bzip2::countHardLinks with precision 4... ✅
Solving bzip2::saveInputFileMetaInfo with precision 4... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 4... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 4... ✅
Solving bzip2::containsDubiousChars with precision 4... ✅
Solving bzip2::hasSuffix with precision 4... ✅
Solving bzip2::mapSuffix with precision 4... ✅
Solving bzip2::compress with precision 4... ✅
Solving bzip2::uncompress with precision 4... ✅
Solving bzip2::testf with precision 4... ✅
Solving bzip2::license with precision 4... ✅
Solving bzip2::usage with precision 4... ✅
Solving bzip2::redundant with precision 4... ✅
Solving bzip2::mkCell with precision 4... ✅
Solving bzip2::snocString with precision 1... ✅
Solving bzip2::addFlagsFromEnvVar with precision 4... ✅
Solving bzip2recover::readError with precision 4... ✅
Solving bzip2recover::writeError with precision 4... ✅
Solving bzip2recover::mallocFail with precision 4... ✅
Solving bzip2recover::tooManyBlocks with precision 4... ✅
Solving bzip2recover::bsPutBit with precision 4... ✅
Solving bzip2recover::bsGetBit with precision 4... ✅
Solving bzip2recover::bsPutUChar with precision 4... ✅
Solving bzip2recover::bsPutUInt32 with precision 4... ✅
Solving bzip2recover::endsInBz2 with precision 4... ✅
Solving bzlib::__isctype with precision 4... ✅
Solving bzlib::isdigit with precision 4... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 4... ✅
Solving bzlib::bz_config_ok with precision 4... ✅
Solving bzlib::prepare_new_block with precision 4... ✅
Solving bzlib::init_RL with precision 4... ✅
Solving bzlib::isempty_RL with precision 4... ✅
Solving bzlib::add_pair_to_block with precision 4... ✅
Solving bzlib::flush_RL with precision 4... ✅
Solving bzlib::copy_input_until_stop with precision 4... ✅
Solving bzlib::copy_output_until_stop with precision 4... ✅
Solving bzlib::BZ2_bzCompress with precision 4... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 4... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 4... ✅
Solving bzlib::BZ2_indexIntoF with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 4... ✅
Solving bzlib::BZ2_bzDecompress with precision 4... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 4... ✅
Solving bzlib::myfeof with precision 4... ✅
Solving bzlib::BZ2_bzWrite with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
✅
Solving bzlib::BZ2_bzWriteClose with precision 4... ✅
Solving bzlib::BZ2_bzRead with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
✅
Solving bzlib::BZ2_bzReadGetUnused with precision 4... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
✅
Solving bzlib::BZ2_bzlibVersion with precision 4... ✅
Solving bzlib::bzopen_or_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzopen with precision 4... ✅
Solving bzlib::BZ2_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzread with precision 4... ✅
Solving bzlib::BZ2_bzwrite with precision 4... ✅
Solving bzlib::BZ2_bzflush with precision 4... ✅
Solving bzlib::BZ2_bzerror with precision 4... ✅
Solving compress::BZ2_bsInitWrite with precision 4... ✅
Solving compress::bsFinishWrite with precision 4... ✅
Solving compress::bsW with precision 4... ✅
Solving compress::bsPutUInt32 with precision 4... ✅
Solving compress::bsPutUChar with precision 4... ✅
Solving compress::makeMaps_e with precision 4... ✅
Solving compress::sendMTFValues with precision 4... ✅
Solving decompress::makeMaps_d with precision 4... ✅
Solving huffman::BZ2_hbMakeCodeLengths with precision 4... ✅
Solving huffman::BZ2_hbAssignCodes with precision 4... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 4... ✅
bzip2::main_0: (_, &) -> _
bzlib::BZ2_bzWriteOpen: (_, _, _, _, _) -> _
bzlib::BZ2_bzReadOpen: (_, _, _, _, _, _) -> _
bzip2recover::bsClose: (&move &move &move &move &move &move &move &move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (_, _, _, _, _, _, _) -> _
bzlib::BZ2_bzReadClose: (_, _) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzip2recover::bsOpenWriteStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (& & & & & & & & & & & & &) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (& & & & & & &) -> _
bzip2::compressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::uncompressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::testStream: (& & & & & & &) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> & & & & & & &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move & & & & & &
bzip2::snocString: (&move, &) -> &move
bzip2::addFlagsFromEnvVar: (&uniq &move & & & & ↓ &uniq &move & & & &, &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsGetBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &) -> _
bzip2recover::bsPutUChar: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsPutUInt32: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, _) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::init_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::isempty_RL: (& & & & & & & & & & & & &) -> _
bzlib::BZ2_bzCompressInit: (_, _, _, _) -> _
bzlib::add_pair_to_block: (& & & & & & & & & & & & &) -> _
bzlib::flush_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::copy_input_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::copy_output_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::handle_compress: (_) -> _
bzlib::BZ2_bzCompress: (& & & & &, _) -> _
bzlib::BZ2_bzCompressEnd: (& & & & &) -> _
bzlib::BZ2_bzDecompressInit: (& & & & &, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (& & & & & & & & & & & &) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (& & & & & & & & & & & &) -> _
bzlib::BZ2_bzDecompress: (& & & & &) -> _
bzlib::BZ2_bzDecompressEnd: (& & & & &) -> _
bzlib::myfeof: (& & & & & & &) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (_) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::bsFinishWrite: (& & & & & & & & & & & & &) -> _
compress::bsW: (& & & & & & & & & & & & &, _, _) -> _
compress::bsPutUInt32: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::bsPutUChar: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::makeMaps_e: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::generateMTFValues: (_) -> _
compress::sendMTFValues: (& & & & & & & & & & & & &) -> _
compress::BZ2_compressBlock: (_, _) -> _
decompress::makeMaps_d: (&uniq & & & & & & & & & & & ↓ &uniq & & & & & & & & & & &) -> _
decompress::BZ2_decompress: (_) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
Solving bzip2::main_0 with precision 1... ✅
Solving bzip2recover::bsClose with precision 4... ✅
Solving bzlib::default_bzfree with precision 4... ✅
Solving bzip2::myMalloc with precision 4... ✅
Solving bzip2recover::bsOpenReadStream with precision 4... ✅
Solving bzip2recover::bsOpenWriteStream with precision 4... ✅
Solving bzlib::default_bzalloc with precision 4... ✅
Solving blocksort::fallbackSimpleSort with precision 4... ✅
Solving blocksort::fallbackQSort3 with precision 4... ✅
Solving blocksort::fallbackSort with precision 4... ✅
Solving blocksort::mainGtU with precision 4... ✅
Solving blocksort::mainSimpleSort with precision 4... ✅
Solving blocksort::mmed3 with precision 4... ✅
Solving blocksort::mainQSort3 with precision 4... ✅
Solving blocksort::mainSort with precision 4... ✅
Solving blocksort::BZ2_blockSort with precision 4... ✅
Solving bzip2::isascii with precision 4... ✅
Solving bzip2::__istype with precision 4... ✅
Solving bzip2::isspace with precision 4... ✅
Solving bzip2::uInt64_from_UInt32s with precision 4... ✅
Solving bzip2::uInt64_to_double with precision 4... ✅
Solving bzip2::uInt64_isZero with precision 4... ✅
Solving bzip2::uInt64_qrm10 with precision 4... ✅
Solving bzip2::uInt64_toAscii with precision 4... ✅
Solving bzip2::myfeof with precision 4... ✅
Solving bzip2::compressStream with precision 4... ✅
Solving bzip2::uncompressStream with precision 4... ✅
Solving bzip2::testStream with precision 4... ✅
Solving bzip2::setExit with precision 4... ✅
Solving bzip2::cadvise with precision 4... ✅
Solving bzip2::showFileNames with precision 4... ✅
Solving bzip2::cleanUpAndFail with precision 4... ✅
Solving bzip2::panic with precision 4... ✅
Solving bzip2::crcError with precision 4... ✅
Solving bzip2::compressedStreamEOF with precision 4... ✅
Solving bzip2::ioError with precision 4... ✅
Solving bzip2::mySignalCatcher with precision 4... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 4... ✅
Solving bzip2::outOfMemory with precision 4... ✅
Solving bzip2::configError with precision 4... ✅
Solving bzip2::pad with precision 4... ✅
Solving bzip2::copyFileName with precision 4... ✅
Solving bzip2::fileExists with precision 4... ✅
Solving bzip2::fopen_output_safely with precision 4... ✅
Solving bzip2::notAStandardFile with precision 4... ✅
Solving bzip2::countHardLinks with precision 4... ✅
Solving bzip2::saveInputFileMetaInfo with precision 4... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 4... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 4... ✅
Solving bzip2::containsDubiousChars with precision 4... ✅
Solving bzip2::hasSuffix with precision 4... ✅
Solving bzip2::mapSuffix with precision 4... ✅
Solving bzip2::compress with precision 4... ✅
Solving bzip2::uncompress with precision 4... ✅
Solving bzip2::testf with precision 4... ✅
Solving bzip2::license with precision 4... ✅
Solving bzip2::usage with precision 4... ✅
Solving bzip2::redundant with precision 4... ✅
Solving bzip2::mkCell with precision 4... ✅
Solving bzip2::snocString with precision 1... ✅
Solving bzip2::addFlagsFromEnvVar with precision 4... ✅
Solving bzip2recover::readError with precision 4... ✅
Solving bzip2recover::writeError with precision 4... ✅
Solving bzip2recover::mallocFail with precision 4... ✅
Solving bzip2recover::tooManyBlocks with precision 4... ✅
Solving bzip2recover::bsPutBit with precision 4... ✅
Solving bzip2recover::bsGetBit with precision 4... ✅
Solving bzip2recover::bsPutUChar with precision 4... ✅
Solving bzip2recover::bsPutUInt32 with precision 4... ✅
Solving bzip2recover::endsInBz2 with precision 4... ✅
Solving bzlib::__isctype with precision 4... ✅
Solving bzlib::isdigit with precision 4... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 4... ✅
Solving bzlib::bz_config_ok with precision 4... ✅
Solving bzlib::prepare_new_block with precision 4... ✅
Solving bzlib::init_RL with precision 4... ✅
Solving bzlib::isempty_RL with precision 4... ✅
Solving bzlib::add_pair_to_block with precision 4... ✅
Solving bzlib::flush_RL with precision 4... ✅
Solving bzlib::copy_input_until_stop with precision 4... ✅
Solving bzlib::copy_output_until_stop with precision 4... ✅
Solving bzlib::BZ2_bzCompress with precision 4... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 4... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 4... ✅
Solving bzlib::BZ2_indexIntoF with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 4... ✅
Solving bzlib::BZ2_bzDecompress with precision 4... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 4... ✅
Solving bzlib::myfeof with precision 4... ✅
Solving bzlib::BZ2_bzWrite with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
✅
Solving bzlib::BZ2_bzWriteClose with precision 4... ✅
Solving bzlib::BZ2_bzRead with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
✅
Solving bzlib::BZ2_bzReadGetUnused with precision 4... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
✅
Solving bzlib::BZ2_bzlibVersion with precision 4... ✅
Solving bzlib::bzopen_or_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzopen with precision 4... ✅
Solving bzlib::BZ2_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzread with precision 4... ✅
Solving bzlib::BZ2_bzwrite with precision 4... ✅
Solving bzlib::BZ2_bzflush with precision 4... ✅
Solving bzlib::BZ2_bzerror with precision 4... ✅
Solving compress::BZ2_bsInitWrite with precision 4... ✅
Solving compress::bsFinishWrite with precision 4... ✅
Solving compress::bsW with precision 4... ✅
Solving compress::bsPutUInt32 with precision 4... ✅
Solving compress::bsPutUChar with precision 4... ✅
Solving compress::makeMaps_e with precision 4... ✅
Solving compress::sendMTFValues with precision 4... ✅
Solving decompress::makeMaps_d with precision 4... ✅
Solving huffman::BZ2_hbMakeCodeLengths with precision 4... ✅
Solving huffman::BZ2_hbAssignCodes with precision 4... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 4... ✅
bzip2::main_0: (_, &) -> _
bzlib::BZ2_bzWriteOpen: (_, _, _, _, _) -> _
bzlib::BZ2_bzReadOpen: (_, _, _, _, _, _) -> _
bzip2recover::bsClose: (&move &move &move &move &move &move &move &move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (_, _, _, _, _, _, _) -> _
bzlib::BZ2_bzReadClose: (_, _) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzip2recover::bsOpenWriteStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (& & & & & & & & & & & & &) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (& & & & & & &) -> _
bzip2::compressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::uncompressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::testStream: (& & & & & & &) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> & & & & & & &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move & & & & & &
bzip2::snocString: (&move, &) -> &move
bzip2::addFlagsFromEnvVar: (&uniq &move & & & & ↓ &uniq &move & & & &, &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsGetBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &) -> _
bzip2recover::bsPutUChar: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsPutUInt32: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, _) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::init_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::isempty_RL: (& & & & & & & & & & & & &) -> _
bzlib::BZ2_bzCompressInit: (_, _, _, _) -> _
bzlib::add_pair_to_block: (& & & & & & & & & & & & &) -> _
bzlib::flush_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::copy_input_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::copy_output_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::handle_compress: (_) -> _
bzlib::BZ2_bzCompress: (& & & & &, _) -> _
bzlib::BZ2_bzCompressEnd: (& & & & &) -> _
bzlib::BZ2_bzDecompressInit: (& & & & &, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (& & & & & & & & & & & &) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (& & & & & & & & & & & &) -> _
bzlib::BZ2_bzDecompress: (& & & & &) -> _
bzlib::BZ2_bzDecompressEnd: (& & & & &) -> _
bzlib::myfeof: (& & & & & & &) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (_) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::bsFinishWrite: (& & & & & & & & & & & & &) -> _
compress::bsW: (& & & & & & & & & & & & &, _, _) -> _
compress::bsPutUInt32: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::bsPutUChar: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::makeMaps_e: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::generateMTFValues: (_) -> _
compress::sendMTFValues: (& & & & & & & & & & & & &) -> _
compress::BZ2_compressBlock: (_, _) -> _
decompress::makeMaps_d: (&uniq & & & & & & & & & & & ↓ &uniq & & & & & & & & & & &) -> _
decompress::BZ2_decompress: (_) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
Solving bzip2::main_0 with precision 1... ✅
Solving bzip2recover::bsClose with precision 4... ✅
Solving bzlib::default_bzfree with precision 4... ✅
Solving bzip2::myMalloc with precision 4... ✅
Solving bzip2recover::bsOpenReadStream with precision 4... ✅
Solving bzip2recover::bsOpenWriteStream with precision 4... ✅
Solving bzlib::default_bzalloc with precision 4... ✅
Solving blocksort::fallbackSimpleSort with precision 4... ✅
Solving blocksort::fallbackQSort3 with precision 4... ✅
Solving blocksort::fallbackSort with precision 4... ✅
Solving blocksort::mainGtU with precision 4... ✅
Solving blocksort::mainSimpleSort with precision 4... ✅
Solving blocksort::mmed3 with precision 4... ✅
Solving blocksort::mainQSort3 with precision 4... ✅
Solving blocksort::mainSort with precision 4... ✅
Solving blocksort::BZ2_blockSort with precision 4... ✅
Solving bzip2::isascii with precision 4... ✅
Solving bzip2::__istype with precision 4... ✅
Solving bzip2::isspace with precision 4... ✅
Solving bzip2::uInt64_from_UInt32s with precision 4... ✅
Solving bzip2::uInt64_to_double with precision 4... ✅
Solving bzip2::uInt64_isZero with precision 4... ✅
Solving bzip2::uInt64_qrm10 with precision 4... ✅
Solving bzip2::uInt64_toAscii with precision 4... ✅
Solving bzip2::myfeof with precision 4... ✅
Solving bzip2::compressStream with precision 4... ✅
Solving bzip2::uncompressStream with precision 4... ✅
Solving bzip2::testStream with precision 4... ✅
Solving bzip2::setExit with precision 4... ✅
Solving bzip2::cadvise with precision 4... ✅
Solving bzip2::showFileNames with precision 4... ✅
Solving bzip2::cleanUpAndFail with precision 4... ✅
Solving bzip2::panic with precision 4... ✅
Solving bzip2::crcError with precision 4... ✅
Solving bzip2::compressedStreamEOF with precision 4... ✅
Solving bzip2::ioError with precision 4... ✅
Solving bzip2::mySignalCatcher with precision 4... ✅
Solving bzip2::mySIGSEGVorSIGBUScatcher with precision 4... ✅
Solving bzip2::outOfMemory with precision 4... ✅
Solving bzip2::configError with precision 4... ✅
Solving bzip2::pad with precision 4... ✅
Solving bzip2::copyFileName with precision 4... ✅
Solving bzip2::fileExists with precision 4... ✅
Solving bzip2::fopen_output_safely with precision 4... ✅
Solving bzip2::notAStandardFile with precision 4... ✅
Solving bzip2::countHardLinks with precision 4... ✅
Solving bzip2::saveInputFileMetaInfo with precision 4... ✅
Solving bzip2::applySavedTimeInfoToOutputFile with precision 4... ✅
Solving bzip2::applySavedFileAttrToOutputFile with precision 4... ✅
Solving bzip2::containsDubiousChars with precision 4... ✅
Solving bzip2::hasSuffix with precision 4... ✅
Solving bzip2::mapSuffix with precision 4... ✅
Solving bzip2::compress with precision 4... ✅
Solving bzip2::uncompress with precision 4... ✅
Solving bzip2::testf with precision 4... ✅
Solving bzip2::license with precision 4... ✅
Solving bzip2::usage with precision 4... ✅
Solving bzip2::redundant with precision 4... ✅
Solving bzip2::mkCell with precision 4... ✅
Solving bzip2::snocString with precision 1... ✅
Solving bzip2::addFlagsFromEnvVar with precision 4... ✅
Solving bzip2recover::readError with precision 4... ✅
Solving bzip2recover::writeError with precision 4... ✅
Solving bzip2recover::mallocFail with precision 4... ✅
Solving bzip2recover::tooManyBlocks with precision 4... ✅
Solving bzip2recover::bsPutBit with precision 4... ✅
Solving bzip2recover::bsGetBit with precision 4... ✅
Solving bzip2recover::bsPutUChar with precision 4... ✅
Solving bzip2recover::bsPutUInt32 with precision 4... ✅
Solving bzip2recover::endsInBz2 with precision 4... ✅
Solving bzlib::__isctype with precision 4... ✅
Solving bzlib::isdigit with precision 4... ✅
Solving bzlib::BZ2_bz__AssertH__fail with precision 4... ✅
Solving bzlib::bz_config_ok with precision 4... ✅
Solving bzlib::prepare_new_block with precision 4... ✅
Solving bzlib::init_RL with precision 4... ✅
Solving bzlib::isempty_RL with precision 4... ✅
Solving bzlib::add_pair_to_block with precision 4... ✅
Solving bzlib::flush_RL with precision 4... ✅
Solving bzlib::copy_input_until_stop with precision 4... ✅
Solving bzlib::copy_output_until_stop with precision 4... ✅
Solving bzlib::BZ2_bzCompress with precision 4... ✅
Solving bzlib::BZ2_bzCompressEnd with precision 4... ✅
Solving bzlib::BZ2_bzDecompressInit with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_FAST with precision 4... ✅
Solving bzlib::BZ2_indexIntoF with precision 4... ✅
Solving bzlib::unRLE_obuf_to_output_SMALL with precision 4... ✅
Solving bzlib::BZ2_bzDecompress with precision 4... ✅
Solving bzlib::BZ2_bzDecompressEnd with precision 4... ✅
Solving bzlib::myfeof with precision 4... ✅
Solving bzlib::BZ2_bzWrite with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
✅
Solving bzlib::BZ2_bzWriteClose with precision 4... ✅
Solving bzlib::BZ2_bzRead with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
✅
Solving bzlib::BZ2_bzReadGetUnused with precision 4... ✅
Solving bzlib::BZ2_bzBuffToBuffCompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzCompressEnd!
✅
Solving bzlib::BZ2_bzBuffToBuffDecompress with precision 4... [31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressInit!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompress!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
[31mERROR[0m [2manalysis::ownership::infer::boundary[0m[2m:[0m bad output parameter analysis for bzlib::BZ2_bzDecompressEnd!
✅
Solving bzlib::BZ2_bzlibVersion with precision 4... ✅
Solving bzlib::bzopen_or_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzopen with precision 4... ✅
Solving bzlib::BZ2_bzdopen with precision 4... ✅
Solving bzlib::BZ2_bzread with precision 4... ✅
Solving bzlib::BZ2_bzwrite with precision 4... ✅
Solving bzlib::BZ2_bzflush with precision 4... ✅
Solving bzlib::BZ2_bzerror with precision 4... ✅
Solving compress::BZ2_bsInitWrite with precision 4... ✅
Solving compress::bsFinishWrite with precision 4... ✅
Solving compress::bsW with precision 4... ✅
Solving compress::bsPutUInt32 with precision 4... ✅
Solving compress::bsPutUChar with precision 4... ✅
Solving compress::makeMaps_e with precision 4... ✅
Solving compress::sendMTFValues with precision 4... ✅
Solving decompress::makeMaps_d with precision 4... ✅
Solving huffman::BZ2_hbMakeCodeLengths with precision 4... ✅
Solving huffman::BZ2_hbAssignCodes with precision 4... ✅
Solving huffman::BZ2_hbCreateDecodeTables with precision 4... ✅
bzip2::main_0: (_, &) -> _
bzlib::BZ2_bzWriteOpen: (_, _, _, _, _) -> _
bzlib::BZ2_bzReadOpen: (_, _, _, _, _, _) -> _
bzip2recover::bsClose: (&move &move &move &move &move &move &move &move) -> _
bzlib::default_bzfree: (&, &move) -> _
bzlib::BZ2_bzWriteClose64: (_, _, _, _, _, _, _) -> _
bzlib::BZ2_bzReadClose: (_, _) -> _
bzip2::myMalloc: (_) -> &move
bzip2recover::bsOpenReadStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzip2recover::bsOpenWriteStream: (&move &move &move &move &move &move &move) -> &move &move &move &move &move &move &move &move
bzlib::default_bzalloc: (&, _, _) -> &move
blocksort::fallbackSimpleSort: (&, &, _, _) -> _
blocksort::fallbackQSort3: (&, &, _, _) -> _
blocksort::fallbackSort: (&, &, &, _, _) -> _
blocksort::mainGtU: (_, _, &, &, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSimpleSort: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mmed3: (_, _, _) -> _
blocksort::mainQSort3: (&, &, &, _, _, _, _, &uniq  ↓ &uniq ) -> _
blocksort::mainSort: (&, &, &, &, _, _, &uniq  ↓ &uniq ) -> _
blocksort::BZ2_blockSort: (& & & & & & & & & & & & &) -> _
bzip2::isascii: (_) -> _
bzip2::__istype: (_, _) -> _
bzip2::isspace: (_) -> _
bzip2::uInt64_from_UInt32s: (&uniq  ↓ &uniq , _, _) -> _
bzip2::uInt64_to_double: (&) -> _
bzip2::uInt64_isZero: (&) -> _
bzip2::uInt64_qrm10: (&uniq  ↓ &uniq ) -> _
bzip2::uInt64_toAscii: (&, &) -> _
bzip2::myfeof: (& & & & & & &) -> _
bzip2::compressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::uncompressStream: (& & & & & & &, & & & & & & &) -> _
bzip2::testStream: (& & & & & & &) -> _
bzip2::setExit: (_) -> _
bzip2::cadvise: () -> _
bzip2::showFileNames: () -> _
bzip2::cleanUpAndFail: (_) -> _
bzip2::panic: (&) -> _
bzip2::crcError: () -> _
bzip2::compressedStreamEOF: () -> _
bzip2::ioError: () -> _
bzip2::mySignalCatcher: (_) -> _
bzip2::mySIGSEGVorSIGBUScatcher: (_) -> _
bzip2::outOfMemory: () -> _
bzip2::configError: () -> _
bzip2::pad: (&) -> _
bzip2::copyFileName: (&, &) -> _
bzip2::fileExists: (&) -> _
bzip2::fopen_output_safely: (&, &) -> & & & & & & &
bzip2::notAStandardFile: (&) -> _
bzip2::countHardLinks: (&) -> _
bzip2::saveInputFileMetaInfo: (&) -> _
bzip2::applySavedTimeInfoToOutputFile: (&) -> _
bzip2::applySavedFileAttrToOutputFile: (_) -> _
bzip2::containsDubiousChars: (&) -> _
bzip2::hasSuffix: (&, &) -> _
bzip2::mapSuffix: (&, &, &) -> _
bzip2::compress: (&) -> _
bzip2::uncompress: (&) -> _
bzip2::testf: (&) -> _
bzip2::license: () -> _
bzip2::usage: (&) -> _
bzip2::redundant: (&) -> _
bzip2::mkCell: () -> &move & & & & & &
bzip2::snocString: (&move, &) -> &move
bzip2::addFlagsFromEnvVar: (&uniq &move & & & & ↓ &uniq &move & & & &, &) -> _
bzip2recover::readError: () -> _
bzip2recover::writeError: () -> _
bzip2recover::mallocFail: (_) -> _
bzip2recover::tooManyBlocks: (_) -> _
bzip2recover::bsPutBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsGetBit: (&uniq & & & & & & & ↓ &uniq & & & & & & &) -> _
bzip2recover::bsPutUChar: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::bsPutUInt32: (&uniq & & & & & & & ↓ &uniq & & & & & & &, _) -> _
bzip2recover::endsInBz2: (&) -> _
bzip2recover::main_0: (_, _) -> _
bzlib::__isctype: (_, _) -> _
bzlib::isdigit: (_) -> _
bzlib::BZ2_bz__AssertH__fail: (_) -> _
bzlib::bz_config_ok: () -> _
bzlib::prepare_new_block: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::init_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::isempty_RL: (& & & & & & & & & & & & &) -> _
bzlib::BZ2_bzCompressInit: (_, _, _, _) -> _
bzlib::add_pair_to_block: (& & & & & & & & & & & & &) -> _
bzlib::flush_RL: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
bzlib::copy_input_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::copy_output_until_stop: (& & & & & & & & & & & & &) -> _
bzlib::handle_compress: (_) -> _
bzlib::BZ2_bzCompress: (& & & & &, _) -> _
bzlib::BZ2_bzCompressEnd: (& & & & &) -> _
bzlib::BZ2_bzDecompressInit: (& & & & &, _, _) -> _
bzlib::unRLE_obuf_to_output_FAST: (& & & & & & & & & & & &) -> _
bzlib::BZ2_indexIntoF: (_, &) -> _
bzlib::unRLE_obuf_to_output_SMALL: (& & & & & & & & & & & &) -> _
bzlib::BZ2_bzDecompress: (& & & & &) -> _
bzlib::BZ2_bzDecompressEnd: (& & & & &) -> _
bzlib::myfeof: (& & & & & & &) -> _
bzlib::BZ2_bzWrite: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzWriteClose: (&uniq  ↓ &uniq , &uniq  ↓ &uniq , _, &uniq  ↓ &uniq , &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzRead: (&uniq  ↓ &uniq , &, &, _) -> _
bzlib::BZ2_bzReadGetUnused: (&uniq  ↓ &uniq , &, &uniq & ↓ &uniq &, &uniq  ↓ &uniq ) -> _
bzlib::BZ2_bzBuffToBuffCompress: (&, &uniq  ↓ &uniq , &, _, _, _, _) -> _
bzlib::BZ2_bzBuffToBuffDecompress: (&, &uniq  ↓ &uniq , &, _, _, _) -> _
bzlib::BZ2_bzlibVersion: () -> &
bzlib::bzopen_or_bzdopen: (&, _, &, _) -> &
bzlib::BZ2_bzopen: (&uniq  ↓ &uniq , &) -> &
bzlib::BZ2_bzdopen: (_, &) -> &
bzlib::BZ2_bzread: (&, &, _) -> _
bzlib::BZ2_bzwrite: (&uniq  ↓ &uniq , &, _) -> _
bzlib::BZ2_bzflush: (&) -> _
bzlib::BZ2_bzclose: (_) -> _
bzlib::BZ2_bzerror: (&, &uniq  ↓ &uniq ) -> &
compress::BZ2_bsInitWrite: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::bsFinishWrite: (& & & & & & & & & & & & &) -> _
compress::bsW: (& & & & & & & & & & & & &, _, _) -> _
compress::bsPutUInt32: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::bsPutUChar: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &, _) -> _
compress::makeMaps_e: (&uniq & & & & & & & & & & & & ↓ &uniq & & & & & & & & & & & &) -> _
compress::generateMTFValues: (_) -> _
compress::sendMTFValues: (& & & & & & & & & & & & &) -> _
compress::BZ2_compressBlock: (_, _) -> _
decompress::makeMaps_d: (&uniq & & & & & & & & & & & ↓ &uniq & & & & & & & & & & &) -> _
decompress::BZ2_decompress: (_) -> _
huffman::BZ2_hbMakeCodeLengths: (&, &, _, _) -> _
huffman::BZ2_hbAssignCodes: (&, &, _, _, _) -> _
huffman::BZ2_hbCreateDecodeTables: (&, &, &, &, _, _, _) -> _
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2826:19: 2826:29 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2829:22: 2829:32 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2833:41: 2833:51 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2834:42: 2834:52 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2837:14: 2837:24 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2873:19: 2873:29 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2877:13: 2877:23 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2879:17: 2879:27 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2882:20: 2882:30 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2884:24: 2884:34 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2909:33: 2909:43 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2917:14: 2917:24 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2922:19: 2922:29 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2926:19: 2926:29 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2930:26: 2930:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2934:26: 2934:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2938:26: 2938:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2942:26: 2942:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2946:26: 2946:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2950:26: 2950:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2954:26: 2954:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2958:26: 2958:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2962:26: 2962:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2966:26: 2966:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2970:26: 2970:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2973:23: 2973:33 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2974:26: 2974:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2977:23: 2977:33 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2978:26: 2978:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2982:26: 2982:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2986:26: 2986:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2990:26: 2990:36 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:2996:24: 2996:34 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3002:68: 3002:78 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3007:14: 3007:24 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3042:27: 3042:37 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3046:30: 3046:40 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3050:30: 3050:40 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3052:22: 3052:32 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3063:27: 3063:37 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3067:30: 3067:40 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3071:32: 3071:42 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3073:22: 3073:32 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3085:27: 3085:37 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3089:30: 3089:40 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3093:27: 3093:37 (#0)
[31mERROR[0m [2manalysis::ownership::solidify[0m[2m:[0m semantics changed @ workspace/bzip2/rust/bzip2.rs:3095:22: 3095:32 (#0)
@DefId(0:16 ~ c2rust_lib[1043]::blocksort::fallbackSimpleSort)
bb0:
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_u32
  using: 
  _10 = _3
  using: _3@Entry
  _11 = _4
  using: _4@Entry
  _9 = Eq(move _10, move _11)
  using: _10@Mir(bb0[4]), _11@Mir(bb0[5])
  switchInt(move _9) -> [0: bb1, otherwise: bb47]
  using: _9@Mir(bb0[6])
bb1:
  _14 = _4
  using: _4@Entry
  _15 = _3
  using: _3@Entry
  _16 = CheckedSub(_14, _15)
  using: _14@Mir(bb1[0]), _15@Mir(bb1[1])
  assert(!move (_16.1: bool), "attempt to compute `{} - {}`, which would overflow", move _14, move _15) -> bb2
  using: _16@Entry, _14@Entry, _15@Entry
bb2:
  _13 = move (_16.0: i32)
  using: _16@Mir(bb1[2])
  _17 = const 3_i32
  using: 
  _12 = Gt(move _13, move _17)
  using: _13@Mir(bb2[0]), _17@Mir(bb2[1])
  switchInt(move _12) -> [0: bb25, otherwise: bb3]
  using: _12@Mir(bb2[2])
bb3:
  _18 = _4
  using: _4@Entry
  _19 = const 4_i32
  using: 
  _20 = CheckedSub(_18, _19)
  using: _18@Mir(bb3[0]), _19@Mir(bb3[1])
  assert(!move (_20.1: bool), "attempt to compute `{} - {}`, which would overflow", move _18, move _19) -> bb4
  using: _20@Entry, _18@Entry, _19@Entry
bb4:
  _5 = move (_20.0: i32)
  using: _20@Mir(bb3[2])
  goto -> bb5
  using: 
bb5:
  _22 = _5
  using: _5@Phi(bb5)
  _23 = _3
  using: _3@Entry
  _21 = Ge(move _22, move _23)
  using: _22@Mir(bb5[0]), _23@Mir(bb5[1])
  switchInt(move _21) -> [0: bb25, otherwise: bb6]
  using: _21@Mir(bb5[2])
bb6:
  _26 = _1
  using: _1@Phi(bb5)
  _28 = _5
  using: _5@Phi(bb5)
  _27 = move _28 as isize (IntToInt)
  using: _28@Mir(bb6[1])
  _25 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _26, move _27) -> bb7
  using: _26@Mir(bb6[0]), _27@Mir(bb6[2])
bb7:
  _24 = (*_25)
  using: _25@Mir(bb6[3])
  _7 = move _24 as i32 (IntToInt)
  using: _24@Mir(bb7[0])
  _31 = _2
  using: _2@Phi(bb5)
  _33 = _7
  using: _7@Mir(bb7[1])
  _32 = move _33 as isize (IntToInt)
  using: _33@Mir(bb7[3])
  _30 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _31, move _32) -> bb8
  using: _31@Mir(bb7[2]), _32@Mir(bb7[4])
bb8:
  _29 = (*_30)
  using: _30@Mir(bb7[5])
  _8 = move _29
  using: _29@Mir(bb8[0])
  _34 = _5
  using: _5@Phi(bb5)
  _35 = const 4_i32
  using: 
  _36 = CheckedAdd(_34, _35)
  using: _34@Mir(bb8[2]), _35@Mir(bb8[3])
  assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", move _34, move _35) -> bb9
  using: _36@Entry, _34@Entry, _35@Entry
bb9:
  _6 = move (_36.0: i32)
  using: _36@Mir(bb8[4])
  goto -> bb10
  using: 
bb10:
  _39 = _6
  using: _6@Phi(bb10)
  _40 = _4
  using: _4@Phi(bb5)
  _38 = Le(move _39, move _40)
  using: _39@Mir(bb10[0]), _40@Mir(bb10[1])
  switchInt(move _38) -> [0: bb11, otherwise: bb12]
  using: _38@Mir(bb10[2])
bb11:
  _37 = const false
  using: 
  goto -> bb13
  using: 
bb12:
  _42 = _8
  using: _8@Phi(bb10)
  _45 = _2
  using: _2@Phi(bb10)
  _49 = _1
  using: _1@Phi(bb10)
  _51 = _6
  using: _6@Phi(bb10)
  _50 = move _51 as isize (IntToInt)
  using: _51@Mir(bb12[3])
  _48 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _49, move _50) -> bb14
  using: _49@Mir(bb12[2]), _50@Mir(bb12[4])
bb13:
  switchInt(move _37) -> [0: bb21, otherwise: bb16]
  using: _37@Phi(bb13)
bb14:
  _47 = (*_48)
  using: _48@Mir(bb12[5])
  _46 = move _47 as isize (IntToInt)
  using: _47@Mir(bb14[0])
  _44 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _45, move _46) -> bb15
  using: _45@Mir(bb12[1]), _46@Mir(bb14[1])
bb15:
  _43 = (*_44)
  using: _44@Mir(bb14[2])
  _41 = Gt(move _42, move _43)
  using: _42@Mir(bb12[0]), _43@Mir(bb15[0])
  _37 = move _41
  using: _41@Mir(bb15[1])
  goto -> bb13
  using: 
bb16:
  _54 = _1
  using: _1@Phi(bb13)
  _56 = _6
  using: _6@Phi(bb13)
  _55 = move _56 as isize (IntToInt)
  using: _56@Mir(bb16[1])
  _53 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _54, move _55) -> bb17
  using: _54@Mir(bb16[0]), _55@Mir(bb16[2])
bb17:
  _52 = (*_53)
  using: _53@Mir(bb16[3])
  _58 = _1
  using: _1@Phi(bb13)
  _61 = _6
  using: _6@Phi(bb13)
  _62 = const 4_i32
  using: 
  _63 = CheckedSub(_61, _62)
  using: _61@Mir(bb17[2]), _62@Mir(bb17[3])
  assert(!move (_63.1: bool), "attempt to compute `{} - {}`, which would overflow", move _61, move _62) -> bb18
  using: _63@Entry, _61@Entry, _62@Entry
bb18:
  _60 = move (_63.0: i32)
  using: _63@Mir(bb17[4])
  _59 = move _60 as isize (IntToInt)
  using: _60@Mir(bb18[0])
  _57 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _58, move _59) -> bb19
  using: _58@Mir(bb17[1]), _59@Mir(bb18[1])
bb19:
  (*_57) = move _52
  using: _57@Mir(bb18[2]), _52@Mir(bb17[0])
  _64 = const 4_i32
  using: 
  _65 = CheckedAdd(_6, _64)
  using: _6@Phi(bb13), _64@Mir(bb19[1])
  assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, move _64) -> bb20
  using: _65@Entry, _6@Entry, _64@Entry
bb20:
  _6 = move (_65.0: i32)
  using: _65@Mir(bb19[2])
  goto -> bb10
  using: 
bb21:
  _66 = _7
  using: _7@Mir(bb7[1])
  _68 = _1
  using: _1@Phi(bb13)
  _71 = _6
  using: _6@Phi(bb13)
  _72 = const 4_i32
  using: 
  _73 = CheckedSub(_71, _72)
  using: _71@Mir(bb21[2]), _72@Mir(bb21[3])
  assert(!move (_73.1: bool), "attempt to compute `{} - {}`, which would overflow", move _71, move _72) -> bb22
  using: _73@Entry, _71@Entry, _72@Entry
bb22:
  _70 = move (_73.0: i32)
  using: _73@Mir(bb21[4])
  _69 = move _70 as isize (IntToInt)
  using: _70@Mir(bb22[0])
  _67 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _68, move _69) -> bb23
  using: _68@Mir(bb21[1]), _69@Mir(bb22[1])
bb23:
  (*_67) = move _66 as u32 (IntToInt)
  using: _67@Mir(bb22[2]), _66@Mir(bb21[0])
  _74 = CheckedSub(_5, const 1_i32)
  using: _5@Phi(bb5)
  assert(!move (_74.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> bb24
  using: _74@Entry, _5@Entry
bb24:
  _5 = move (_74.0: i32)
  using: _74@Mir(bb23[1])
  goto -> bb5
  using: 
bb25:
  _75 = _4
  using: _4@Phi(bb25)
  _76 = const 1_i32
  using: 
  _77 = CheckedSub(_75, _76)
  using: _75@Mir(bb25[0]), _76@Mir(bb25[1])
  assert(!move (_77.1: bool), "attempt to compute `{} - {}`, which would overflow", move _75, move _76) -> bb26
  using: _77@Entry, _75@Entry, _76@Entry
bb26:
  _5 = move (_77.0: i32)
  using: _77@Mir(bb25[2])
  goto -> bb27
  using: 
bb27:
  _79 = _5
  using: _5@Phi(bb27)
  _80 = _3
  using: _3@Phi(bb25)
  _78 = Ge(move _79, move _80)
  using: _79@Mir(bb27[0]), _80@Mir(bb27[1])
  switchInt(move _78) -> [0: bb47, otherwise: bb28]
  using: _78@Mir(bb27[2])
bb28:
  _83 = _1
  using: _1@Phi(bb27)
  _85 = _5
  using: _5@Phi(bb27)
  _84 = move _85 as isize (IntToInt)
  using: _85@Mir(bb28[1])
  _82 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _83, move _84) -> bb29
  using: _83@Mir(bb28[0]), _84@Mir(bb28[2])
bb29:
  _81 = (*_82)
  using: _82@Mir(bb28[3])
  _7 = move _81 as i32 (IntToInt)
  using: _81@Mir(bb29[0])
  _88 = _2
  using: _2@Phi(bb27)
  _90 = _7
  using: _7@Mir(bb29[1])
  _89 = move _90 as isize (IntToInt)
  using: _90@Mir(bb29[3])
  _87 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _88, move _89) -> bb30
  using: _88@Mir(bb29[2]), _89@Mir(bb29[4])
bb30:
  _86 = (*_87)
  using: _87@Mir(bb29[5])
  _8 = move _86
  using: _86@Mir(bb30[0])
  _91 = _5
  using: _5@Phi(bb27)
  _92 = const 1_i32
  using: 
  _93 = CheckedAdd(_91, _92)
  using: _91@Mir(bb30[2]), _92@Mir(bb30[3])
  assert(!move (_93.1: bool), "attempt to compute `{} + {}`, which would overflow", move _91, move _92) -> bb31
  using: _93@Entry, _91@Entry, _92@Entry
bb31:
  _6 = move (_93.0: i32)
  using: _93@Mir(bb30[4])
  goto -> bb32
  using: 
bb32:
  _96 = _6
  using: _6@Phi(bb32)
  _97 = _4
  using: _4@Phi(bb27)
  _95 = Le(move _96, move _97)
  using: _96@Mir(bb32[0]), _97@Mir(bb32[1])
  switchInt(move _95) -> [0: bb33, otherwise: bb34]
  using: _95@Mir(bb32[2])
bb33:
  _94 = const false
  using: 
  goto -> bb35
  using: 
bb34:
  _99 = _8
  using: _8@Phi(bb32)
  _102 = _2
  using: _2@Phi(bb32)
  _106 = _1
  using: _1@Phi(bb32)
  _108 = _6
  using: _6@Phi(bb32)
  _107 = move _108 as isize (IntToInt)
  using: _108@Mir(bb34[3])
  _105 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _106, move _107) -> bb36
  using: _106@Mir(bb34[2]), _107@Mir(bb34[4])
bb35:
  switchInt(move _94) -> [0: bb43, otherwise: bb38]
  using: _94@Phi(bb35)
bb36:
  _104 = (*_105)
  using: _105@Mir(bb34[5])
  _103 = move _104 as isize (IntToInt)
  using: _104@Mir(bb36[0])
  _101 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _102, move _103) -> bb37
  using: _102@Mir(bb34[1]), _103@Mir(bb36[1])
bb37:
  _100 = (*_101)
  using: _101@Mir(bb36[2])
  _98 = Gt(move _99, move _100)
  using: _99@Mir(bb34[0]), _100@Mir(bb37[0])
  _94 = move _98
  using: _98@Mir(bb37[1])
  goto -> bb35
  using: 
bb38:
  _111 = _1
  using: _1@Phi(bb35)
  _113 = _6
  using: _6@Phi(bb35)
  _112 = move _113 as isize (IntToInt)
  using: _113@Mir(bb38[1])
  _110 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _111, move _112) -> bb39
  using: _111@Mir(bb38[0]), _112@Mir(bb38[2])
bb39:
  _109 = (*_110)
  using: _110@Mir(bb38[3])
  _115 = _1
  using: _1@Phi(bb35)
  _118 = _6
  using: _6@Phi(bb35)
  _119 = const 1_i32
  using: 
  _120 = CheckedSub(_118, _119)
  using: _118@Mir(bb39[2]), _119@Mir(bb39[3])
  assert(!move (_120.1: bool), "attempt to compute `{} - {}`, which would overflow", move _118, move _119) -> bb40
  using: _120@Entry, _118@Entry, _119@Entry
bb40:
  _117 = move (_120.0: i32)
  using: _120@Mir(bb39[4])
  _116 = move _117 as isize (IntToInt)
  using: _117@Mir(bb40[0])
  _114 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _115, move _116) -> bb41
  using: _115@Mir(bb39[1]), _116@Mir(bb40[1])
bb41:
  (*_114) = move _109
  using: _114@Mir(bb40[2]), _109@Mir(bb39[0])
  _121 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb35)
  assert(!move (_121.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb42
  using: _121@Entry, _6@Entry
bb42:
  _6 = move (_121.0: i32)
  using: _121@Mir(bb41[1])
  goto -> bb32
  using: 
bb43:
  _122 = _7
  using: _7@Mir(bb29[1])
  _124 = _1
  using: _1@Phi(bb35)
  _127 = _6
  using: _6@Phi(bb35)
  _128 = const 1_i32
  using: 
  _129 = CheckedSub(_127, _128)
  using: _127@Mir(bb43[2]), _128@Mir(bb43[3])
  assert(!move (_129.1: bool), "attempt to compute `{} - {}`, which would overflow", move _127, move _128) -> bb44
  using: _129@Entry, _127@Entry, _128@Entry
bb44:
  _126 = move (_129.0: i32)
  using: _129@Mir(bb43[4])
  _125 = move _126 as isize (IntToInt)
  using: _126@Mir(bb44[0])
  _123 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _124, move _125) -> bb45
  using: _124@Mir(bb43[1]), _125@Mir(bb44[1])
bb45:
  (*_123) = move _122 as u32 (IntToInt)
  using: _123@Mir(bb44[2]), _122@Mir(bb43[0])
  _130 = CheckedSub(_5, const 1_i32)
  using: _5@Phi(bb27)
  assert(!move (_130.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> bb46
  using: _130@Entry, _5@Entry
bb46:
  _5 = move (_130.0: i32)
  using: _130@Mir(bb45[1])
  goto -> bb27
  using: 
bb47:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:152:25: 152:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:153:30: 153:50 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:157:48: 157:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:157:35: 157:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:159:27: 159:45 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:158:23: 158:70 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:162:19: 162:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:168:21: 168:39 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:169:26: 169:46 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:172:49: 172:67 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:172:36: 172:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:174:23: 174:41 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:173:19: 173:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:177:15: 177:62 (#0) by default
@DefId(0:17 ~ c2rust_lib[1043]::blocksort::fallbackQSort3)
bb0:
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  _14 = const 0_u32
  using: 
  _15 = const 0_u32
  using: 
  _16 = const 0_u32
  using: 
  _17 = [const 0_i32; 100]
  using: 
  _18 = [const 0_i32; 100]
  using: 
  _15 = const 0_u32
  using: 
  _11 = const 0_i32
  using: 
  _19 = _3
  using: _3@Entry
  _20 = const 0_usize
  using: 
  _17[_20] = move _19
  using: _20@Mir(bb0[17]), _19@Mir(bb0[16])
  _21 = _4
  using: _4@Entry
  _23 = _11
  using: _11@Mir(bb0[15])
  _22 = move _23 as usize (IntToInt)
  using: _23@Mir(bb0[20])
  _24 = const 100_usize
  using: 
  _25 = Lt(_22, _24)
  using: _22@Mir(bb0[21]), _24@Mir(bb0[22])
  assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _22) -> bb1
  using: _25@Entry, _24@Entry, _22@Entry
bb1:
  _18[_22] = move _21
  using: _22@Mir(bb0[21]), _21@Mir(bb0[19])
  _26 = CheckedAdd(_11, const 1_i32)
  using: _11@Mir(bb0[15])
  assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb2
  using: _26@Entry, _11@Entry
bb2:
  _11 = move (_26.0: i32)
  using: _26@Mir(bb1[1])
  goto -> bb3
  using: 
bb3:
  _28 = _11
  using: _11@Phi(bb3)
  _29 = const 0_i32
  using: 
  _27 = Gt(move _28, move _29)
  using: _28@Mir(bb3[0]), _29@Mir(bb3[1])
  switchInt(move _27) -> [0: bb129, otherwise: bb4]
  using: _27@Mir(bb3[2])
bb4:
  _32 = _11
  using: _11@Phi(bb3)
  _33 = const 99_i32
  using: 
  _31 = Lt(move _32, move _33)
  using: _32@Mir(bb4[0]), _33@Mir(bb4[1])
  _30 = Not(move _31)
  using: _31@Mir(bb4[2])
  switchInt(move _30) -> [0: bb6, otherwise: bb5]
  using: _30@Mir(bb4[3])
bb5:
  _35 = const 1004_i32
  using: 
  _34 = bzlib::BZ2_bz__AssertH__fail(move _35) -> bb6
  using: _35@Mir(bb5[0])
bb6:
  _36 = CheckedSub(_11, const 1_i32)
  using: _11@Phi(bb3)
  assert(!move (_36.1: bool), "attempt to compute `{} - {}`, which would overflow", _11, const 1_i32) -> bb7
  using: _36@Entry, _11@Entry
bb7:
  _11 = move (_36.0: i32)
  using: _36@Mir(bb6[0])
  _39 = _11
  using: _11@Mir(bb7[0])
  _38 = move _39 as usize (IntToInt)
  using: _39@Mir(bb7[1])
  _40 = const 100_usize
  using: 
  _41 = Lt(_38, _40)
  using: _38@Mir(bb7[2]), _40@Mir(bb7[3])
  assert(move _41, "index out of bounds: the length is {} but the index is {}", move _40, _38) -> bb8
  using: _41@Entry, _40@Entry, _38@Entry
bb8:
  _37 = _17[_38]
  using: _17@Phi(bb3), _38@Mir(bb7[2])
  _12 = move _37
  using: _37@Mir(bb8[0])
  _44 = _11
  using: _11@Mir(bb7[0])
  _43 = move _44 as usize (IntToInt)
  using: _44@Mir(bb8[2])
  _45 = const 100_usize
  using: 
  _46 = Lt(_43, _45)
  using: _43@Mir(bb8[3]), _45@Mir(bb8[4])
  assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _43) -> bb9
  using: _46@Entry, _45@Entry, _43@Entry
bb9:
  _42 = _18[_43]
  using: _18@Phi(bb3), _43@Mir(bb8[3])
  _13 = move _42
  using: _42@Mir(bb9[0])
  _49 = _13
  using: _13@Mir(bb9[1])
  _50 = _12
  using: _12@Mir(bb8[1])
  _51 = CheckedSub(_49, _50)
  using: _49@Mir(bb9[2]), _50@Mir(bb9[3])
  assert(!move (_51.1: bool), "attempt to compute `{} - {}`, which would overflow", move _49, move _50) -> bb10
  using: _51@Entry, _49@Entry, _50@Entry
bb10:
  _48 = move (_51.0: i32)
  using: _51@Mir(bb9[4])
  _52 = const 10_i32
  using: 
  _47 = Lt(move _48, move _52)
  using: _48@Mir(bb10[0]), _52@Mir(bb10[1])
  switchInt(move _47) -> [0: bb12, otherwise: bb11]
  using: _47@Mir(bb10[2])
bb11:
  _54 = _1
  using: _1@Phi(bb3)
  _55 = _2
  using: _2@Phi(bb3)
  _56 = _12
  using: _12@Mir(bb8[1])
  _57 = _13
  using: _13@Mir(bb9[1])
  _53 = blocksort::fallbackSimpleSort(move _54, move _55, move _56, move _57) -> bb3
  using: _54@Mir(bb11[0]), _55@Mir(bb11[1]), _56@Mir(bb11[2]), _57@Mir(bb11[3])
bb12:
  _61 = _15
  using: _15@Phi(bb3)
  _62 = const 7621_u32
  using: 
  _60 = core::num::<impl u32>::wrapping_mul(move _61, move _62) -> bb13
  using: _61@Mir(bb12[0]), _62@Mir(bb12[1])
bb13:
  _63 = const 1_u32
  using: 
  _59 = core::num::<impl u32>::wrapping_add(move _60, move _63) -> bb14
  using: _60@Mir(bb12[2]), _63@Mir(bb13[0])
bb14:
  _64 = const 32768_u32
  using: 
  _58 = core::num::<impl u32>::wrapping_rem(move _59, move _64) -> bb15
  using: _59@Mir(bb13[1]), _64@Mir(bb14[0])
bb15:
  _15 = move _58
  using: _58@Mir(bb14[1])
  _66 = _15
  using: _15@Mir(bb15[0])
  _67 = const 3_u32
  using: 
  _65 = core::num::<impl u32>::wrapping_rem(move _66, move _67) -> bb16
  using: _66@Mir(bb15[1]), _67@Mir(bb15[2])
bb16:
  _16 = move _65
  using: _65@Mir(bb15[3])
  _69 = _16
  using: _16@Mir(bb16[0])
  _70 = const 0_u32
  using: 
  _68 = Eq(move _69, move _70)
  using: _69@Mir(bb16[1]), _70@Mir(bb16[2])
  switchInt(move _68) -> [0: bb20, otherwise: bb17]
  using: _68@Mir(bb16[3])
bb17:
  _73 = _2
  using: _2@Phi(bb3)
  _77 = _1
  using: _1@Phi(bb3)
  _79 = _12
  using: _12@Mir(bb8[1])
  _78 = move _79 as isize (IntToInt)
  using: _79@Mir(bb17[2])
  _76 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _77, move _78) -> bb18
  using: _77@Mir(bb17[1]), _78@Mir(bb17[3])
bb18:
  _75 = (*_76)
  using: _76@Mir(bb17[4])
  _74 = move _75 as isize (IntToInt)
  using: _75@Mir(bb18[0])
  _72 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _73, move _74) -> bb19
  using: _73@Mir(bb17[0]), _74@Mir(bb18[1])
bb19:
  _71 = (*_72)
  using: _72@Mir(bb18[2])
  _14 = move _71
  using: _71@Mir(bb19[0])
  goto -> bb29
  using: 
bb20:
  _81 = _16
  using: _16@Mir(bb16[0])
  _82 = const 1_u32
  using: 
  _80 = Eq(move _81, move _82)
  using: _81@Mir(bb20[0]), _82@Mir(bb20[1])
  switchInt(move _80) -> [0: bb26, otherwise: bb21]
  using: _80@Mir(bb20[2])
bb21:
  _85 = _2
  using: _2@Phi(bb3)
  _89 = _1
  using: _1@Phi(bb3)
  _93 = _12
  using: _12@Mir(bb8[1])
  _94 = _13
  using: _13@Mir(bb9[1])
  _95 = CheckedAdd(_93, _94)
  using: _93@Mir(bb21[2]), _94@Mir(bb21[3])
  assert(!move (_95.1: bool), "attempt to compute `{} + {}`, which would overflow", move _93, move _94) -> bb22
  using: _95@Entry, _93@Entry, _94@Entry
bb22:
  _92 = move (_95.0: i32)
  using: _95@Mir(bb21[4])
  _96 = const 1_i32
  using: 
  _97 = CheckedShr(_92, _96)
  using: _92@Mir(bb22[0]), _96@Mir(bb22[1])
  assert(!move (_97.1: bool), "attempt to shift right by `{}`, which would overflow", move _96) -> bb23
  using: _97@Entry, _92@Entry, _96@Entry
bb23:
  _91 = move (_97.0: i32)
  using: _97@Mir(bb22[2])
  _90 = move _91 as isize (IntToInt)
  using: _91@Mir(bb23[0])
  _88 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _89, move _90) -> bb24
  using: _89@Mir(bb21[1]), _90@Mir(bb23[1])
bb24:
  _87 = (*_88)
  using: _88@Mir(bb23[2])
  _86 = move _87 as isize (IntToInt)
  using: _87@Mir(bb24[0])
  _84 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _85, move _86) -> bb25
  using: _85@Mir(bb21[0]), _86@Mir(bb24[1])
bb25:
  _83 = (*_84)
  using: _84@Mir(bb24[2])
  _14 = move _83
  using: _83@Mir(bb25[0])
  goto -> bb29
  using: 
bb26:
  _100 = _2
  using: _2@Phi(bb3)
  _104 = _1
  using: _1@Phi(bb3)
  _106 = _13
  using: _13@Mir(bb9[1])
  _105 = move _106 as isize (IntToInt)
  using: _106@Mir(bb26[2])
  _103 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _104, move _105) -> bb27
  using: _104@Mir(bb26[1]), _105@Mir(bb26[3])
bb27:
  _102 = (*_103)
  using: _103@Mir(bb26[4])
  _101 = move _102 as isize (IntToInt)
  using: _102@Mir(bb27[0])
  _99 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _100, move _101) -> bb28
  using: _100@Mir(bb26[0]), _101@Mir(bb27[1])
bb28:
  _98 = (*_99)
  using: _99@Mir(bb27[2])
  _14 = move _98
  using: _98@Mir(bb28[0])
  goto -> bb29
  using: 
bb29:
  _107 = _12
  using: _12@Phi(bb29)
  _7 = move _107
  using: _107@Mir(bb29[0])
  _108 = _7
  using: _7@Mir(bb29[1])
  _5 = move _108
  using: _108@Mir(bb29[2])
  _109 = _13
  using: _13@Phi(bb29)
  _8 = move _109
  using: _109@Mir(bb29[4])
  _110 = _8
  using: _8@Mir(bb29[5])
  _6 = move _110
  using: _110@Mir(bb29[6])
  goto -> bb30
  using: 
bb30:
  _113 = _5
  using: _5@Phi(bb30)
  _114 = _6
  using: _6@Phi(bb30)
  _112 = Gt(move _113, move _114)
  using: _113@Mir(bb30[0]), _114@Mir(bb30[1])
  _111 = Not(move _112)
  using: _112@Mir(bb30[2])
  switchInt(move _111) -> [0: bb45, otherwise: bb31]
  using: _111@Mir(bb30[3])
bb31:
  _118 = _2
  using: _2@Phi(bb30)
  _122 = _1
  using: _1@Phi(bb30)
  _124 = _5
  using: _5@Phi(bb30)
  _123 = move _124 as isize (IntToInt)
  using: _124@Mir(bb31[2])
  _121 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _122, move _123) -> bb32
  using: _122@Mir(bb31[1]), _123@Mir(bb31[3])
bb32:
  _120 = (*_121)
  using: _121@Mir(bb31[4])
  _119 = move _120 as isize (IntToInt)
  using: _120@Mir(bb32[0])
  _117 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _118, move _119) -> bb33
  using: _118@Mir(bb31[0]), _119@Mir(bb32[1])
bb33:
  _116 = (*_117)
  using: _117@Mir(bb32[2])
  _115 = move _116 as i32 (IntToInt)
  using: _116@Mir(bb33[0])
  _126 = _14
  using: _14@Phi(bb30)
  _125 = move _126 as i32 (IntToInt)
  using: _126@Mir(bb33[2])
  _127 = CheckedSub(_115, _125)
  using: _115@Mir(bb33[1]), _125@Mir(bb33[3])
  assert(!move (_127.1: bool), "attempt to compute `{} - {}`, which would overflow", move _115, move _125) -> bb34
  using: _127@Entry, _115@Entry, _125@Entry
bb34:
  _9 = move (_127.0: i32)
  using: _127@Mir(bb33[4])
  _129 = _9
  using: _9@Mir(bb34[0])
  _130 = const 0_i32
  using: 
  _128 = Eq(move _129, move _130)
  using: _129@Mir(bb34[1]), _130@Mir(bb34[2])
  switchInt(move _128) -> [0: bb42, otherwise: bb35]
  using: _128@Mir(bb34[3])
bb35:
  _134 = _1
  using: _1@Phi(bb30)
  _136 = _5
  using: _5@Phi(bb30)
  _135 = move _136 as isize (IntToInt)
  using: _136@Mir(bb35[1])
  _133 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _134, move _135) -> bb36
  using: _134@Mir(bb35[0]), _135@Mir(bb35[2])
bb36:
  _132 = (*_133)
  using: _133@Mir(bb35[3])
  _131 = move _132 as i32 (IntToInt)
  using: _132@Mir(bb36[0])
  _139 = _1
  using: _1@Phi(bb30)
  _141 = _7
  using: _7@Phi(bb30)
  _140 = move _141 as isize (IntToInt)
  using: _141@Mir(bb36[3])
  _138 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _139, move _140) -> bb37
  using: _139@Mir(bb36[2]), _140@Mir(bb36[4])
bb37:
  _137 = (*_138)
  using: _138@Mir(bb36[5])
  _143 = _1
  using: _1@Phi(bb30)
  _145 = _5
  using: _5@Phi(bb30)
  _144 = move _145 as isize (IntToInt)
  using: _145@Mir(bb37[2])
  _142 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _143, move _144) -> bb38
  using: _143@Mir(bb37[1]), _144@Mir(bb37[3])
bb38:
  (*_142) = move _137
  using: _142@Mir(bb37[4]), _137@Mir(bb37[0])
  _146 = _131
  using: _131@Mir(bb36[1])
  _148 = _1
  using: _1@Phi(bb30)
  _150 = _7
  using: _7@Phi(bb30)
  _149 = move _150 as isize (IntToInt)
  using: _150@Mir(bb38[3])
  _147 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _148, move _149) -> bb39
  using: _148@Mir(bb38[2]), _149@Mir(bb38[4])
bb39:
  (*_147) = move _146 as u32 (IntToInt)
  using: _147@Mir(bb38[5]), _146@Mir(bb38[1])
  _151 = CheckedAdd(_7, const 1_i32)
  using: _7@Phi(bb30)
  assert(!move (_151.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> bb40
  using: _151@Entry, _7@Entry
bb40:
  _7 = move (_151.0: i32)
  using: _151@Mir(bb39[1])
  _152 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb30)
  assert(!move (_152.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb41
  using: _152@Entry, _5@Entry
bb41:
  _5 = move (_152.0: i32)
  using: _152@Mir(bb40[1])
  goto -> bb30
  using: 
bb42:
  _154 = _9
  using: _9@Mir(bb34[0])
  _155 = const 0_i32
  using: 
  _153 = Gt(move _154, move _155)
  using: _154@Mir(bb42[0]), _155@Mir(bb42[1])
  switchInt(move _153) -> [0: bb43, otherwise: bb45]
  using: _153@Mir(bb42[2])
bb43:
  _156 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb30)
  assert(!move (_156.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb44
  using: _156@Entry, _5@Entry
bb44:
  _5 = move (_156.0: i32)
  using: _156@Mir(bb43[0])
  goto -> bb30
  using: 
bb45:
  _159 = _5
  using: _5@Phi(bb45)
  _160 = _6
  using: _6@Phi(bb45)
  _158 = Gt(move _159, move _160)
  using: _159@Mir(bb45[0]), _160@Mir(bb45[1])
  _157 = Not(move _158)
  using: _158@Mir(bb45[2])
  switchInt(move _157) -> [0: bb60, otherwise: bb46]
  using: _157@Mir(bb45[3])
bb46:
  _164 = _2
  using: _2@Phi(bb45)
  _168 = _1
  using: _1@Phi(bb45)
  _170 = _6
  using: _6@Phi(bb45)
  _169 = move _170 as isize (IntToInt)
  using: _170@Mir(bb46[2])
  _167 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _168, move _169) -> bb47
  using: _168@Mir(bb46[1]), _169@Mir(bb46[3])
bb47:
  _166 = (*_167)
  using: _167@Mir(bb46[4])
  _165 = move _166 as isize (IntToInt)
  using: _166@Mir(bb47[0])
  _163 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _164, move _165) -> bb48
  using: _164@Mir(bb46[0]), _165@Mir(bb47[1])
bb48:
  _162 = (*_163)
  using: _163@Mir(bb47[2])
  _161 = move _162 as i32 (IntToInt)
  using: _162@Mir(bb48[0])
  _172 = _14
  using: _14@Phi(bb45)
  _171 = move _172 as i32 (IntToInt)
  using: _172@Mir(bb48[2])
  _173 = CheckedSub(_161, _171)
  using: _161@Mir(bb48[1]), _171@Mir(bb48[3])
  assert(!move (_173.1: bool), "attempt to compute `{} - {}`, which would overflow", move _161, move _171) -> bb49
  using: _173@Entry, _161@Entry, _171@Entry
bb49:
  _9 = move (_173.0: i32)
  using: _173@Mir(bb48[4])
  _175 = _9
  using: _9@Mir(bb49[0])
  _176 = const 0_i32
  using: 
  _174 = Eq(move _175, move _176)
  using: _175@Mir(bb49[1]), _176@Mir(bb49[2])
  switchInt(move _174) -> [0: bb57, otherwise: bb50]
  using: _174@Mir(bb49[3])
bb50:
  _180 = _1
  using: _1@Phi(bb45)
  _182 = _6
  using: _6@Phi(bb45)
  _181 = move _182 as isize (IntToInt)
  using: _182@Mir(bb50[1])
  _179 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _180, move _181) -> bb51
  using: _180@Mir(bb50[0]), _181@Mir(bb50[2])
bb51:
  _178 = (*_179)
  using: _179@Mir(bb50[3])
  _177 = move _178 as i32 (IntToInt)
  using: _178@Mir(bb51[0])
  _185 = _1
  using: _1@Phi(bb45)
  _187 = _8
  using: _8@Phi(bb45)
  _186 = move _187 as isize (IntToInt)
  using: _187@Mir(bb51[3])
  _184 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _185, move _186) -> bb52
  using: _185@Mir(bb51[2]), _186@Mir(bb51[4])
bb52:
  _183 = (*_184)
  using: _184@Mir(bb51[5])
  _189 = _1
  using: _1@Phi(bb45)
  _191 = _6
  using: _6@Phi(bb45)
  _190 = move _191 as isize (IntToInt)
  using: _191@Mir(bb52[2])
  _188 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _189, move _190) -> bb53
  using: _189@Mir(bb52[1]), _190@Mir(bb52[3])
bb53:
  (*_188) = move _183
  using: _188@Mir(bb52[4]), _183@Mir(bb52[0])
  _192 = _177
  using: _177@Mir(bb51[1])
  _194 = _1
  using: _1@Phi(bb45)
  _196 = _8
  using: _8@Phi(bb45)
  _195 = move _196 as isize (IntToInt)
  using: _196@Mir(bb53[3])
  _193 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _194, move _195) -> bb54
  using: _194@Mir(bb53[2]), _195@Mir(bb53[4])
bb54:
  (*_193) = move _192 as u32 (IntToInt)
  using: _193@Mir(bb53[5]), _192@Mir(bb53[1])
  _197 = CheckedSub(_8, const 1_i32)
  using: _8@Phi(bb45)
  assert(!move (_197.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_i32) -> bb55
  using: _197@Entry, _8@Entry
bb55:
  _8 = move (_197.0: i32)
  using: _197@Mir(bb54[1])
  _198 = CheckedSub(_6, const 1_i32)
  using: _6@Phi(bb45)
  assert(!move (_198.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> bb56
  using: _198@Entry, _6@Entry
bb56:
  _6 = move (_198.0: i32)
  using: _198@Mir(bb55[1])
  goto -> bb45
  using: 
bb57:
  _200 = _9
  using: _9@Mir(bb49[0])
  _201 = const 0_i32
  using: 
  _199 = Lt(move _200, move _201)
  using: _200@Mir(bb57[0]), _201@Mir(bb57[1])
  switchInt(move _199) -> [0: bb58, otherwise: bb60]
  using: _199@Mir(bb57[2])
bb58:
  _202 = CheckedSub(_6, const 1_i32)
  using: _6@Phi(bb45)
  assert(!move (_202.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> bb59
  using: _202@Entry, _6@Entry
bb59:
  _6 = move (_202.0: i32)
  using: _202@Mir(bb58[0])
  goto -> bb45
  using: 
bb60:
  _204 = _5
  using: _5@Phi(bb45)
  _205 = _6
  using: _6@Phi(bb60)
  _203 = Gt(move _204, move _205)
  using: _204@Mir(bb60[0]), _205@Mir(bb60[1])
  switchInt(move _203) -> [0: bb62, otherwise: bb61]
  using: _203@Mir(bb60[2])
bb61:
  _229 = _8
  using: _8@Phi(bb45)
  _230 = _7
  using: _7@Phi(bb30)
  _228 = Lt(move _229, move _230)
  using: _229@Mir(bb61[0]), _230@Mir(bb61[1])
  switchInt(move _228) -> [0: bb69, otherwise: bb3]
  using: _228@Mir(bb61[2])
bb62:
  _209 = _1
  using: _1@Phi(bb97)
  _211 = _5
  using: _5@Phi(bb76)
  _210 = move _211 as isize (IntToInt)
  using: _211@Mir(bb62[1])
  _208 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _209, move _210) -> bb63
  using: _209@Mir(bb62[0]), _210@Mir(bb62[2])
bb63:
  _207 = (*_208)
  using: _208@Mir(bb62[3])
  _206 = move _207 as i32 (IntToInt)
  using: _207@Mir(bb63[0])
  _214 = _1
  using: _1@Phi(bb97)
  _216 = _6
  using: _6@Phi(bb94)
  _215 = move _216 as isize (IntToInt)
  using: _216@Mir(bb63[3])
  _213 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _214, move _215) -> bb64
  using: _214@Mir(bb63[2]), _215@Mir(bb63[4])
bb64:
  _212 = (*_213)
  using: _213@Mir(bb63[5])
  _218 = _1
  using: _1@Phi(bb97)
  _220 = _5
  using: _5@Phi(bb76)
  _219 = move _220 as isize (IntToInt)
  using: _220@Mir(bb64[2])
  _217 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _218, move _219) -> bb65
  using: _218@Mir(bb64[1]), _219@Mir(bb64[3])
bb65:
  (*_217) = move _212
  using: _217@Mir(bb64[4]), _212@Mir(bb64[0])
  _221 = _206
  using: _206@Mir(bb63[1])
  _223 = _1
  using: _1@Phi(bb97)
  _225 = _6
  using: _6@Phi(bb94)
  _224 = move _225 as isize (IntToInt)
  using: _225@Mir(bb65[3])
  _222 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _223, move _224) -> bb66
  using: _223@Mir(bb65[2]), _224@Mir(bb65[4])
bb66:
  (*_222) = move _221 as u32 (IntToInt)
  using: _222@Mir(bb65[5]), _221@Mir(bb65[1])
  _226 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb76)
  assert(!move (_226.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb67
  using: _226@Entry, _5@Entry
bb67:
  _5 = move (_226.0: i32)
  using: _226@Mir(bb66[1])
  _227 = CheckedSub(_6, const 1_i32)
  using: _6@Phi(bb94)
  assert(!move (_227.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> bb68
  using: _227@Entry, _6@Entry
bb68:
  _6 = move (_227.0: i32)
  using: _227@Mir(bb67[1])
  goto -> bb30
  using: 
bb69:
  _234 = _7
  using: _7@Phi(bb30)
  _235 = _12
  using: _12@Phi(bb29)
  _236 = CheckedSub(_234, _235)
  using: _234@Mir(bb69[0]), _235@Mir(bb69[1])
  assert(!move (_236.1: bool), "attempt to compute `{} - {}`, which would overflow", move _234, move _235) -> bb70
  using: _236@Entry, _234@Entry, _235@Entry
bb70:
  _233 = move (_236.0: i32)
  using: _236@Mir(bb69[2])
  _238 = _5
  using: _5@Phi(bb45)
  _239 = _7
  using: _7@Phi(bb30)
  _240 = CheckedSub(_238, _239)
  using: _238@Mir(bb70[1]), _239@Mir(bb70[2])
  assert(!move (_240.1: bool), "attempt to compute `{} - {}`, which would overflow", move _238, move _239) -> bb71
  using: _240@Entry, _238@Entry, _239@Entry
bb71:
  _237 = move (_240.0: i32)
  using: _240@Mir(bb70[3])
  _232 = Lt(move _233, move _237)
  using: _233@Mir(bb70[0]), _237@Mir(bb71[0])
  switchInt(move _232) -> [0: bb74, otherwise: bb72]
  using: _232@Mir(bb71[1])
bb72:
  _241 = _7
  using: _7@Phi(bb30)
  _242 = _12
  using: _12@Phi(bb29)
  _243 = CheckedSub(_241, _242)
  using: _241@Mir(bb72[0]), _242@Mir(bb72[1])
  assert(!move (_243.1: bool), "attempt to compute `{} - {}`, which would overflow", move _241, move _242) -> bb73
  using: _243@Entry, _241@Entry, _242@Entry
bb73:
  _231 = move (_243.0: i32)
  using: _243@Mir(bb72[2])
  goto -> bb76
  using: 
bb74:
  _244 = _5
  using: _5@Phi(bb45)
  _245 = _7
  using: _7@Phi(bb30)
  _246 = CheckedSub(_244, _245)
  using: _244@Mir(bb74[0]), _245@Mir(bb74[1])
  assert(!move (_246.1: bool), "attempt to compute `{} - {}`, which would overflow", move _244, move _245) -> bb75
  using: _246@Entry, _244@Entry, _245@Entry
bb75:
  _231 = move (_246.0: i32)
  using: _246@Mir(bb74[2])
  goto -> bb76
  using: 
bb76:
  _9 = move _231
  using: _231@Phi(bb76)
  _247 = _12
  using: _12@Phi(bb76)
  _249 = _5
  using: _5@Phi(bb76)
  _250 = _9
  using: _9@Mir(bb76[0])
  _251 = CheckedSub(_249, _250)
  using: _249@Mir(bb76[2]), _250@Mir(bb76[3])
  assert(!move (_251.1: bool), "attempt to compute `{} - {}`, which would overflow", move _249, move _250) -> bb77
  using: _251@Entry, _249@Entry, _250@Entry
bb77:
  _248 = move (_251.0: i32)
  using: _251@Mir(bb76[4])
  _252 = _9
  using: _9@Mir(bb76[0])
  goto -> bb78
  using: 
bb78:
  _254 = _252
  using: _252@Phi(bb78)
  _255 = const 0_i32
  using: 
  _253 = Gt(move _254, move _255)
  using: _254@Mir(bb78[0]), _255@Mir(bb78[1])
  switchInt(move _253) -> [0: bb87, otherwise: bb79]
  using: _253@Mir(bb78[2])
bb79:
  _259 = _1
  using: _1@Phi(bb78)
  _261 = _247
  using: _247@Phi(bb78)
  _260 = move _261 as isize (IntToInt)
  using: _261@Mir(bb79[1])
  _258 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _259, move _260) -> bb80
  using: _259@Mir(bb79[0]), _260@Mir(bb79[2])
bb80:
  _257 = (*_258)
  using: _258@Mir(bb79[3])
  _256 = move _257 as i32 (IntToInt)
  using: _257@Mir(bb80[0])
  _264 = _1
  using: _1@Phi(bb78)
  _266 = _248
  using: _248@Phi(bb78)
  _265 = move _266 as isize (IntToInt)
  using: _266@Mir(bb80[3])
  _263 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _264, move _265) -> bb81
  using: _264@Mir(bb80[2]), _265@Mir(bb80[4])
bb81:
  _262 = (*_263)
  using: _263@Mir(bb80[5])
  _268 = _1
  using: _1@Phi(bb78)
  _270 = _247
  using: _247@Phi(bb78)
  _269 = move _270 as isize (IntToInt)
  using: _270@Mir(bb81[2])
  _267 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _268, move _269) -> bb82
  using: _268@Mir(bb81[1]), _269@Mir(bb81[3])
bb82:
  (*_267) = move _262
  using: _267@Mir(bb81[4]), _262@Mir(bb81[0])
  _271 = _256
  using: _256@Mir(bb80[1])
  _273 = _1
  using: _1@Phi(bb78)
  _275 = _248
  using: _248@Phi(bb78)
  _274 = move _275 as isize (IntToInt)
  using: _275@Mir(bb82[3])
  _272 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _273, move _274) -> bb83
  using: _273@Mir(bb82[2]), _274@Mir(bb82[4])
bb83:
  (*_272) = move _271 as u32 (IntToInt)
  using: _272@Mir(bb82[5]), _271@Mir(bb82[1])
  _276 = CheckedAdd(_247, const 1_i32)
  using: _247@Phi(bb78)
  assert(!move (_276.1: bool), "attempt to compute `{} + {}`, which would overflow", _247, const 1_i32) -> bb84
  using: _276@Entry, _247@Entry
bb84:
  _247 = move (_276.0: i32)
  using: _276@Mir(bb83[1])
  _277 = CheckedAdd(_248, const 1_i32)
  using: _248@Phi(bb78)
  assert(!move (_277.1: bool), "attempt to compute `{} + {}`, which would overflow", _248, const 1_i32) -> bb85
  using: _277@Entry, _248@Entry
bb85:
  _248 = move (_277.0: i32)
  using: _277@Mir(bb84[1])
  _278 = CheckedSub(_252, const 1_i32)
  using: _252@Phi(bb78)
  assert(!move (_278.1: bool), "attempt to compute `{} - {}`, which would overflow", _252, const 1_i32) -> bb86
  using: _278@Entry, _252@Entry
bb86:
  _252 = move (_278.0: i32)
  using: _278@Mir(bb85[1])
  goto -> bb78
  using: 
bb87:
  _282 = _13
  using: _13@Phi(bb29)
  _283 = _8
  using: _8@Phi(bb45)
  _284 = CheckedSub(_282, _283)
  using: _282@Mir(bb87[0]), _283@Mir(bb87[1])
  assert(!move (_284.1: bool), "attempt to compute `{} - {}`, which would overflow", move _282, move _283) -> bb88
  using: _284@Entry, _282@Entry, _283@Entry
bb88:
  _281 = move (_284.0: i32)
  using: _284@Mir(bb87[2])
  _286 = _8
  using: _8@Phi(bb45)
  _287 = _6
  using: _6@Phi(bb60)
  _288 = CheckedSub(_286, _287)
  using: _286@Mir(bb88[1]), _287@Mir(bb88[2])
  assert(!move (_288.1: bool), "attempt to compute `{} - {}`, which would overflow", move _286, move _287) -> bb89
  using: _288@Entry, _286@Entry, _287@Entry
bb89:
  _285 = move (_288.0: i32)
  using: _288@Mir(bb88[3])
  _280 = Lt(move _281, move _285)
  using: _281@Mir(bb88[0]), _285@Mir(bb89[0])
  switchInt(move _280) -> [0: bb92, otherwise: bb90]
  using: _280@Mir(bb89[1])
bb90:
  _289 = _13
  using: _13@Phi(bb29)
  _290 = _8
  using: _8@Phi(bb45)
  _291 = CheckedSub(_289, _290)
  using: _289@Mir(bb90[0]), _290@Mir(bb90[1])
  assert(!move (_291.1: bool), "attempt to compute `{} - {}`, which would overflow", move _289, move _290) -> bb91
  using: _291@Entry, _289@Entry, _290@Entry
bb91:
  _279 = move (_291.0: i32)
  using: _291@Mir(bb90[2])
  goto -> bb94
  using: 
bb92:
  _292 = _8
  using: _8@Phi(bb45)
  _293 = _6
  using: _6@Phi(bb60)
  _294 = CheckedSub(_292, _293)
  using: _292@Mir(bb92[0]), _293@Mir(bb92[1])
  assert(!move (_294.1: bool), "attempt to compute `{} - {}`, which would overflow", move _292, move _293) -> bb93
  using: _294@Entry, _292@Entry, _293@Entry
bb93:
  _279 = move (_294.0: i32)
  using: _294@Mir(bb92[2])
  goto -> bb94
  using: 
bb94:
  _10 = move _279
  using: _279@Phi(bb94)
  _295 = _5
  using: _5@Phi(bb76)
  _298 = _13
  using: _13@Phi(bb94)
  _299 = _10
  using: _10@Mir(bb94[0])
  _300 = CheckedSub(_298, _299)
  using: _298@Mir(bb94[2]), _299@Mir(bb94[3])
  assert(!move (_300.1: bool), "attempt to compute `{} - {}`, which would overflow", move _298, move _299) -> bb95
  using: _300@Entry, _298@Entry, _299@Entry
bb95:
  _297 = move (_300.0: i32)
  using: _300@Mir(bb94[4])
  _301 = const 1_i32
  using: 
  _302 = CheckedAdd(_297, _301)
  using: _297@Mir(bb95[0]), _301@Mir(bb95[1])
  assert(!move (_302.1: bool), "attempt to compute `{} + {}`, which would overflow", move _297, move _301) -> bb96
  using: _302@Entry, _297@Entry, _301@Entry
bb96:
  _296 = move (_302.0: i32)
  using: _302@Mir(bb95[2])
  _303 = _10
  using: _10@Mir(bb94[0])
  goto -> bb97
  using: 
bb97:
  _305 = _303
  using: _303@Phi(bb97)
  _306 = const 0_i32
  using: 
  _304 = Gt(move _305, move _306)
  using: _305@Mir(bb97[0]), _306@Mir(bb97[1])
  switchInt(move _304) -> [0: bb106, otherwise: bb98]
  using: _304@Mir(bb97[2])
bb98:
  _310 = _1
  using: _1@Phi(bb97)
  _312 = _295
  using: _295@Phi(bb97)
  _311 = move _312 as isize (IntToInt)
  using: _312@Mir(bb98[1])
  _309 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _310, move _311) -> bb99
  using: _310@Mir(bb98[0]), _311@Mir(bb98[2])
bb99:
  _308 = (*_309)
  using: _309@Mir(bb98[3])
  _307 = move _308 as i32 (IntToInt)
  using: _308@Mir(bb99[0])
  _315 = _1
  using: _1@Phi(bb97)
  _317 = _296
  using: _296@Phi(bb97)
  _316 = move _317 as isize (IntToInt)
  using: _317@Mir(bb99[3])
  _314 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _315, move _316) -> bb100
  using: _315@Mir(bb99[2]), _316@Mir(bb99[4])
bb100:
  _313 = (*_314)
  using: _314@Mir(bb99[5])
  _319 = _1
  using: _1@Phi(bb97)
  _321 = _295
  using: _295@Phi(bb97)
  _320 = move _321 as isize (IntToInt)
  using: _321@Mir(bb100[2])
  _318 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _319, move _320) -> bb101
  using: _319@Mir(bb100[1]), _320@Mir(bb100[3])
bb101:
  (*_318) = move _313
  using: _318@Mir(bb100[4]), _313@Mir(bb100[0])
  _322 = _307
  using: _307@Mir(bb99[1])
  _324 = _1
  using: _1@Phi(bb97)
  _326 = _296
  using: _296@Phi(bb97)
  _325 = move _326 as isize (IntToInt)
  using: _326@Mir(bb101[3])
  _323 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _324, move _325) -> bb102
  using: _324@Mir(bb101[2]), _325@Mir(bb101[4])
bb102:
  (*_323) = move _322 as u32 (IntToInt)
  using: _323@Mir(bb101[5]), _322@Mir(bb101[1])
  _327 = CheckedAdd(_295, const 1_i32)
  using: _295@Phi(bb97)
  assert(!move (_327.1: bool), "attempt to compute `{} + {}`, which would overflow", _295, const 1_i32) -> bb103
  using: _327@Entry, _295@Entry
bb103:
  _295 = move (_327.0: i32)
  using: _327@Mir(bb102[1])
  _328 = CheckedAdd(_296, const 1_i32)
  using: _296@Phi(bb97)
  assert(!move (_328.1: bool), "attempt to compute `{} + {}`, which would overflow", _296, const 1_i32) -> bb104
  using: _328@Entry, _296@Entry
bb104:
  _296 = move (_328.0: i32)
  using: _328@Mir(bb103[1])
  _329 = CheckedSub(_303, const 1_i32)
  using: _303@Phi(bb97)
  assert(!move (_329.1: bool), "attempt to compute `{} - {}`, which would overflow", _303, const 1_i32) -> bb105
  using: _329@Entry, _303@Entry
bb105:
  _303 = move (_329.0: i32)
  using: _329@Mir(bb104[1])
  goto -> bb97
  using: 
bb106:
  _332 = _12
  using: _12@Phi(bb76)
  _333 = _5
  using: _5@Phi(bb76)
  _334 = CheckedAdd(_332, _333)
  using: _332@Mir(bb106[0]), _333@Mir(bb106[1])
  assert(!move (_334.1: bool), "attempt to compute `{} + {}`, which would overflow", move _332, move _333) -> bb107
  using: _334@Entry, _332@Entry, _333@Entry
bb107:
  _331 = move (_334.0: i32)
  using: _334@Mir(bb106[2])
  _335 = _7
  using: _7@Phi(bb76)
  _336 = CheckedSub(_331, _335)
  using: _331@Mir(bb107[0]), _335@Mir(bb107[1])
  assert(!move (_336.1: bool), "attempt to compute `{} - {}`, which would overflow", move _331, move _335) -> bb108
  using: _336@Entry, _331@Entry, _335@Entry
bb108:
  _330 = move (_336.0: i32)
  using: _336@Mir(bb107[2])
  _337 = const 1_i32
  using: 
  _338 = CheckedSub(_330, _337)
  using: _330@Mir(bb108[0]), _337@Mir(bb108[1])
  assert(!move (_338.1: bool), "attempt to compute `{} - {}`, which would overflow", move _330, move _337) -> bb109
  using: _338@Entry, _330@Entry, _337@Entry
bb109:
  _9 = move (_338.0: i32)
  using: _338@Mir(bb108[2])
  _340 = _13
  using: _13@Phi(bb94)
  _342 = _8
  using: _8@Phi(bb94)
  _343 = _6
  using: _6@Phi(bb94)
  _344 = CheckedSub(_342, _343)
  using: _342@Mir(bb109[2]), _343@Mir(bb109[3])
  assert(!move (_344.1: bool), "attempt to compute `{} - {}`, which would overflow", move _342, move _343) -> bb110
  using: _344@Entry, _342@Entry, _343@Entry
bb110:
  _341 = move (_344.0: i32)
  using: _344@Mir(bb109[4])
  _345 = CheckedSub(_340, _341)
  using: _340@Mir(bb109[1]), _341@Mir(bb110[0])
  assert(!move (_345.1: bool), "attempt to compute `{} - {}`, which would overflow", move _340, move _341) -> bb111
  using: _345@Entry, _340@Entry, _341@Entry
bb111:
  _339 = move (_345.0: i32)
  using: _345@Mir(bb110[1])
  _346 = const 1_i32
  using: 
  _347 = CheckedAdd(_339, _346)
  using: _339@Mir(bb111[0]), _346@Mir(bb111[1])
  assert(!move (_347.1: bool), "attempt to compute `{} + {}`, which would overflow", move _339, move _346) -> bb112
  using: _347@Entry, _339@Entry, _346@Entry
bb112:
  _10 = move (_347.0: i32)
  using: _347@Mir(bb111[2])
  _350 = _9
  using: _9@Mir(bb109[0])
  _351 = _12
  using: _12@Phi(bb76)
  _352 = CheckedSub(_350, _351)
  using: _350@Mir(bb112[1]), _351@Mir(bb112[2])
  assert(!move (_352.1: bool), "attempt to compute `{} - {}`, which would overflow", move _350, move _351) -> bb113
  using: _352@Entry, _350@Entry, _351@Entry
bb113:
  _349 = move (_352.0: i32)
  using: _352@Mir(bb112[3])
  _354 = _13
  using: _13@Phi(bb94)
  _355 = _10
  using: _10@Mir(bb112[0])
  _356 = CheckedSub(_354, _355)
  using: _354@Mir(bb113[1]), _355@Mir(bb113[2])
  assert(!move (_356.1: bool), "attempt to compute `{} - {}`, which would overflow", move _354, move _355) -> bb114
  using: _356@Entry, _354@Entry, _355@Entry
bb114:
  _353 = move (_356.0: i32)
  using: _356@Mir(bb113[3])
  _348 = Gt(move _349, move _353)
  using: _349@Mir(bb113[0]), _353@Mir(bb114[0])
  switchInt(move _348) -> [0: bb122, otherwise: bb115]
  using: _348@Mir(bb114[1])
bb115:
  _357 = _12
  using: _12@Phi(bb76)
  _359 = _11
  using: _11@Mir(bb7[0])
  _358 = move _359 as usize (IntToInt)
  using: _359@Mir(bb115[1])
  _360 = const 100_usize
  using: 
  _361 = Lt(_358, _360)
  using: _358@Mir(bb115[2]), _360@Mir(bb115[3])
  assert(move _361, "index out of bounds: the length is {} but the index is {}", move _360, _358) -> bb116
  using: _361@Entry, _360@Entry, _358@Entry
bb116:
  _17[_358] = move _357
  using: _358@Mir(bb115[2]), _357@Mir(bb115[0])
  _362 = _9
  using: _9@Mir(bb109[0])
  _364 = _11
  using: _11@Mir(bb7[0])
  _363 = move _364 as usize (IntToInt)
  using: _364@Mir(bb116[2])
  _365 = const 100_usize
  using: 
  _366 = Lt(_363, _365)
  using: _363@Mir(bb116[3]), _365@Mir(bb116[4])
  assert(move _366, "index out of bounds: the length is {} but the index is {}", move _365, _363) -> bb117
  using: _366@Entry, _365@Entry, _363@Entry
bb117:
  _18[_363] = move _362
  using: _363@Mir(bb116[3]), _362@Mir(bb116[1])
  _367 = CheckedAdd(_11, const 1_i32)
  using: _11@Mir(bb7[0])
  assert(!move (_367.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb118
  using: _367@Entry, _11@Entry
bb118:
  _11 = move (_367.0: i32)
  using: _367@Mir(bb117[1])
  _368 = _10
  using: _10@Mir(bb112[0])
  _370 = _11
  using: _11@Mir(bb118[0])
  _369 = move _370 as usize (IntToInt)
  using: _370@Mir(bb118[2])
  _371 = const 100_usize
  using: 
  _372 = Lt(_369, _371)
  using: _369@Mir(bb118[3]), _371@Mir(bb118[4])
  assert(move _372, "index out of bounds: the length is {} but the index is {}", move _371, _369) -> bb119
  using: _372@Entry, _371@Entry, _369@Entry
bb119:
  _17[_369] = move _368
  using: _369@Mir(bb118[3]), _368@Mir(bb118[1])
  _373 = _13
  using: _13@Phi(bb94)
  _375 = _11
  using: _11@Mir(bb118[0])
  _374 = move _375 as usize (IntToInt)
  using: _375@Mir(bb119[2])
  _376 = const 100_usize
  using: 
  _377 = Lt(_374, _376)
  using: _374@Mir(bb119[3]), _376@Mir(bb119[4])
  assert(move _377, "index out of bounds: the length is {} but the index is {}", move _376, _374) -> bb120
  using: _377@Entry, _376@Entry, _374@Entry
bb120:
  _18[_374] = move _373
  using: _374@Mir(bb119[3]), _373@Mir(bb119[1])
  _378 = CheckedAdd(_11, const 1_i32)
  using: _11@Mir(bb118[0])
  assert(!move (_378.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb121
  using: _378@Entry, _11@Entry
bb121:
  _11 = move (_378.0: i32)
  using: _378@Mir(bb120[1])
  goto -> bb3
  using: 
bb122:
  _379 = _10
  using: _10@Mir(bb112[0])
  _381 = _11
  using: _11@Mir(bb7[0])
  _380 = move _381 as usize (IntToInt)
  using: _381@Mir(bb122[1])
  _382 = const 100_usize
  using: 
  _383 = Lt(_380, _382)
  using: _380@Mir(bb122[2]), _382@Mir(bb122[3])
  assert(move _383, "index out of bounds: the length is {} but the index is {}", move _382, _380) -> bb123
  using: _383@Entry, _382@Entry, _380@Entry
bb123:
  _17[_380] = move _379
  using: _380@Mir(bb122[2]), _379@Mir(bb122[0])
  _384 = _13
  using: _13@Phi(bb94)
  _386 = _11
  using: _11@Mir(bb7[0])
  _385 = move _386 as usize (IntToInt)
  using: _386@Mir(bb123[2])
  _387 = const 100_usize
  using: 
  _388 = Lt(_385, _387)
  using: _385@Mir(bb123[3]), _387@Mir(bb123[4])
  assert(move _388, "index out of bounds: the length is {} but the index is {}", move _387, _385) -> bb124
  using: _388@Entry, _387@Entry, _385@Entry
bb124:
  _18[_385] = move _384
  using: _385@Mir(bb123[3]), _384@Mir(bb123[1])
  _389 = CheckedAdd(_11, const 1_i32)
  using: _11@Mir(bb7[0])
  assert(!move (_389.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb125
  using: _389@Entry, _11@Entry
bb125:
  _11 = move (_389.0: i32)
  using: _389@Mir(bb124[1])
  _390 = _12
  using: _12@Phi(bb76)
  _392 = _11
  using: _11@Mir(bb125[0])
  _391 = move _392 as usize (IntToInt)
  using: _392@Mir(bb125[2])
  _393 = const 100_usize
  using: 
  _394 = Lt(_391, _393)
  using: _391@Mir(bb125[3]), _393@Mir(bb125[4])
  assert(move _394, "index out of bounds: the length is {} but the index is {}", move _393, _391) -> bb126
  using: _394@Entry, _393@Entry, _391@Entry
bb126:
  _17[_391] = move _390
  using: _391@Mir(bb125[3]), _390@Mir(bb125[1])
  _395 = _9
  using: _9@Mir(bb109[0])
  _397 = _11
  using: _11@Mir(bb125[0])
  _396 = move _397 as usize (IntToInt)
  using: _397@Mir(bb126[2])
  _398 = const 100_usize
  using: 
  _399 = Lt(_396, _398)
  using: _396@Mir(bb126[3]), _398@Mir(bb126[4])
  assert(move _399, "index out of bounds: the length is {} but the index is {}", move _398, _396) -> bb127
  using: _399@Entry, _398@Entry, _396@Entry
bb127:
  _18[_396] = move _395
  using: _396@Mir(bb126[3]), _395@Mir(bb126[1])
  _400 = CheckedAdd(_11, const 1_i32)
  using: _11@Mir(bb125[0])
  assert(!move (_400.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb128
  using: _400@Entry, _11@Entry
bb128:
  _11 = move (_400.0: i32)
  using: _400@Mir(bb127[1])
  goto -> bb3
  using: 
bb129:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 100] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 100] is not supported
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/blocksort.rs:221:19: 222:57 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:222:58: 224:88 (#0) by default
rewrite call core::num::<impl u32>::wrapping_rem @ workspace/bzip2/rust/blocksort.rs:224:89: 228:119 (#0) by default
rewrite call core::num::<impl u32>::wrapping_rem @ workspace/bzip2/rust/blocksort.rs:229:20: 229:82 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:231:44: 231:63 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:231:31: 231:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:234:42: 235:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:234:29: 235:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:237:44: 237:63 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:237:31: 237:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:246:46: 246:67 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:246:33: 246:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:250:35: 250:56 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:252:35: 252:56 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:251:31: 251:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:253:31: 253:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:260:46: 260:67 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:260:33: 260:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:264:35: 264:56 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:266:35: 266:56 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:265:31: 265:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:267:31: 267:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:273:48: 273:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:274:53: 274:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:274:23: 274:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:275:23: 275:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:288:48: 288:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:289:53: 289:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:289:23: 289:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:290:23: 290:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:304:27: 304:50 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:305:55: 305:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:305:23: 305:46 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:306:23: 306:46 (#0) by default
@DefId(0:22 ~ c2rust_lib[1043]::blocksort::fallbackSort)
bb0:
  _6 = [const 0_i32; 257]
  using: 
  _7 = [const 0_i32; 256]
  using: 
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  _14 = const 0_i32
  using: 
  _15 = const 0_i32
  using: 
  _16 = const 0_i32
  using: 
  _17 = const 0_i32
  using: 
  _19 = _2
  using: _2@Entry
  _18 = move _19 as *mut u8 (PtrToPtr)
  using: _19@Mir(bb0[12])
  _21 = _5
  using: _5@Entry
  _22 = const 4_i32
  using: 
  _20 = Ge(move _21, move _22)
  using: _21@Mir(bb0[14]), _22@Mir(bb0[15])
  switchInt(move _20) -> [0: bb2, otherwise: bb1]
  using: _20@Mir(bb0[16])
bb1:
  _25 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _24 = (*_25)
  using: _25@Mir(bb1[0])
  _29 = const b"        bucket sorting ...\n\x00"
  using: 
  _28 = &raw const (*_29)
  using: _29@Mir(bb1[2])
  _27 = move _28 as *const u8 (Pointer(ArrayToPointer))
  using: _28@Mir(bb1[3])
  _26 = move _27 as *const i8 (PtrToPtr)
  using: _27@Mir(bb1[4])
  _23 = blocksort::fprintf(move _24, move _26) -> bb2
  using: _24@Mir(bb1[1]), _26@Mir(bb1[5])
bb2:
  _9 = const 0_i32
  using: 
  goto -> bb3
  using: 
bb3:
  _31 = _9
  using: _9@Phi(bb3)
  _32 = const 257_i32
  using: 
  _30 = Lt(move _31, move _32)
  using: _31@Mir(bb3[0]), _32@Mir(bb3[1])
  switchInt(move _30) -> [0: bb7, otherwise: bb4]
  using: _30@Mir(bb3[2])
bb4:
  _33 = const 0_i32
  using: 
  _35 = _9
  using: _9@Phi(bb3)
  _34 = move _35 as usize (IntToInt)
  using: _35@Mir(bb4[1])
  _36 = const 257_usize
  using: 
  _37 = Lt(_34, _36)
  using: _34@Mir(bb4[2]), _36@Mir(bb4[3])
  assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _34) -> bb5
  using: _37@Entry, _36@Entry, _34@Entry
bb5:
  _6[_34] = move _33
  using: _34@Mir(bb4[2]), _33@Mir(bb4[0])
  _38 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb3)
  assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb6
  using: _38@Entry, _9@Entry
bb6:
  _9 = move (_38.0: i32)
  using: _38@Mir(bb5[1])
  goto -> bb3
  using: 
bb7:
  _9 = const 0_i32
  using: 
  goto -> bb8
  using: 
bb8:
  _40 = _9
  using: _9@Phi(bb8)
  _41 = _4
  using: _4@Entry
  _39 = Lt(move _40, move _41)
  using: _40@Mir(bb8[0]), _41@Mir(bb8[1])
  switchInt(move _39) -> [0: bb14, otherwise: bb9]
  using: _39@Mir(bb8[2])
bb9:
  _45 = _18
  using: _18@Phi(bb8)
  _47 = _9
  using: _9@Phi(bb8)
  _46 = move _47 as isize (IntToInt)
  using: _47@Mir(bb9[1])
  _44 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _45, move _46) -> bb10
  using: _45@Mir(bb9[0]), _46@Mir(bb9[2])
bb10:
  _43 = (*_44)
  using: _44@Mir(bb9[3])
  _42 = move _43 as usize (IntToInt)
  using: _43@Mir(bb10[0])
  _48 = const 257_usize
  using: 
  _49 = Lt(_42, _48)
  using: _42@Mir(bb10[1]), _48@Mir(bb10[2])
  assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _42) -> bb11
  using: _49@Entry, _48@Entry, _42@Entry
bb11:
  _50 = CheckedAdd(_6[_42], const 1_i32)
  using: _6@Phi(bb8), _42@Mir(bb10[1])
  assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _6[_42], const 1_i32) -> bb12
  using: _50@Entry, _6@Entry, _42@Entry
bb12:
  _6[_42] = move (_50.0: i32)
  using: _42@Mir(bb10[1]), _50@Mir(bb11[0])
  _51 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb8)
  assert(!move (_51.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb13
  using: _51@Entry, _9@Entry
bb13:
  _9 = move (_51.0: i32)
  using: _51@Mir(bb12[1])
  goto -> bb8
  using: 
bb14:
  _9 = const 0_i32
  using: 
  goto -> bb15
  using: 
bb15:
  _53 = _9
  using: _9@Phi(bb15)
  _54 = const 256_i32
  using: 
  _52 = Lt(move _53, move _54)
  using: _53@Mir(bb15[0]), _54@Mir(bb15[1])
  switchInt(move _52) -> [0: bb20, otherwise: bb16]
  using: _52@Mir(bb15[2])
bb16:
  _57 = _9
  using: _9@Phi(bb15)
  _56 = move _57 as usize (IntToInt)
  using: _57@Mir(bb16[0])
  _58 = const 257_usize
  using: 
  _59 = Lt(_56, _58)
  using: _56@Mir(bb16[1]), _58@Mir(bb16[2])
  assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _56) -> bb17
  using: _59@Entry, _58@Entry, _56@Entry
bb17:
  _55 = _6[_56]
  using: _6@Phi(bb15), _56@Mir(bb16[1])
  _61 = _9
  using: _9@Phi(bb15)
  _60 = move _61 as usize (IntToInt)
  using: _61@Mir(bb17[1])
  _62 = const 256_usize
  using: 
  _63 = Lt(_60, _62)
  using: _60@Mir(bb17[2]), _62@Mir(bb17[3])
  assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _60) -> bb18
  using: _63@Entry, _62@Entry, _60@Entry
bb18:
  _7[_60] = move _55
  using: _60@Mir(bb17[2]), _55@Mir(bb17[0])
  _64 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb15)
  assert(!move (_64.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb19
  using: _64@Entry, _9@Entry
bb19:
  _9 = move (_64.0: i32)
  using: _64@Mir(bb18[1])
  goto -> bb15
  using: 
bb20:
  _9 = const 1_i32
  using: 
  goto -> bb21
  using: 
bb21:
  _66 = _9
  using: _9@Phi(bb21)
  _67 = const 257_i32
  using: 
  _65 = Lt(move _66, move _67)
  using: _66@Mir(bb21[0]), _67@Mir(bb21[1])
  switchInt(move _65) -> [0: bb28, otherwise: bb22]
  using: _65@Mir(bb21[2])
bb22:
  _71 = _9
  using: _9@Phi(bb21)
  _72 = const 1_i32
  using: 
  _73 = CheckedSub(_71, _72)
  using: _71@Mir(bb22[0]), _72@Mir(bb22[1])
  assert(!move (_73.1: bool), "attempt to compute `{} - {}`, which would overflow", move _71, move _72) -> bb23
  using: _73@Entry, _71@Entry, _72@Entry
bb23:
  _70 = move (_73.0: i32)
  using: _73@Mir(bb22[2])
  _69 = move _70 as usize (IntToInt)
  using: _70@Mir(bb23[0])
  _74 = const 257_usize
  using: 
  _75 = Lt(_69, _74)
  using: _69@Mir(bb23[1]), _74@Mir(bb23[2])
  assert(move _75, "index out of bounds: the length is {} but the index is {}", move _74, _69) -> bb24
  using: _75@Entry, _74@Entry, _69@Entry
bb24:
  _68 = _6[_69]
  using: _6@Phi(bb21), _69@Mir(bb23[1])
  _77 = _9
  using: _9@Phi(bb21)
  _76 = move _77 as usize (IntToInt)
  using: _77@Mir(bb24[1])
  _78 = const 257_usize
  using: 
  _79 = Lt(_76, _78)
  using: _76@Mir(bb24[2]), _78@Mir(bb24[3])
  assert(move _79, "index out of bounds: the length is {} but the index is {}", move _78, _76) -> bb25
  using: _79@Entry, _78@Entry, _76@Entry
bb25:
  _80 = CheckedAdd(_6[_76], _68)
  using: _6@Phi(bb21), _76@Mir(bb24[2]), _68@Mir(bb24[0])
  assert(!move (_80.1: bool), "attempt to compute `{} + {}`, which would overflow", _6[_76], move _68) -> bb26
  using: _80@Entry, _6@Entry, _76@Entry, _68@Entry
bb26:
  _6[_76] = move (_80.0: i32)
  using: _76@Mir(bb24[2]), _80@Mir(bb25[0])
  _81 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb21)
  assert(!move (_81.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb27
  using: _81@Entry, _9@Entry
bb27:
  _9 = move (_81.0: i32)
  using: _81@Mir(bb26[1])
  goto -> bb21
  using: 
bb28:
  _9 = const 0_i32
  using: 
  goto -> bb29
  using: 
bb29:
  _83 = _9
  using: _9@Phi(bb29)
  _84 = _4
  using: _4@Entry
  _82 = Lt(move _83, move _84)
  using: _83@Mir(bb29[0]), _84@Mir(bb29[1])
  switchInt(move _82) -> [0: bb37, otherwise: bb30]
  using: _82@Mir(bb29[2])
bb30:
  _87 = _18
  using: _18@Phi(bb29)
  _89 = _9
  using: _9@Phi(bb29)
  _88 = move _89 as isize (IntToInt)
  using: _89@Mir(bb30[1])
  _86 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _87, move _88) -> bb31
  using: _87@Mir(bb30[0]), _88@Mir(bb30[2])
bb31:
  _85 = (*_86)
  using: _86@Mir(bb30[3])
  _10 = move _85 as i32 (IntToInt)
  using: _85@Mir(bb31[0])
  _92 = _10
  using: _10@Mir(bb31[1])
  _91 = move _92 as usize (IntToInt)
  using: _92@Mir(bb31[2])
  _93 = const 257_usize
  using: 
  _94 = Lt(_91, _93)
  using: _91@Mir(bb31[3]), _93@Mir(bb31[4])
  assert(move _94, "index out of bounds: the length is {} but the index is {}", move _93, _91) -> bb32
  using: _94@Entry, _93@Entry, _91@Entry
bb32:
  _90 = _6[_91]
  using: _6@Phi(bb29), _91@Mir(bb31[3])
  _95 = const 1_i32
  using: 
  _96 = CheckedSub(_90, _95)
  using: _90@Mir(bb32[0]), _95@Mir(bb32[1])
  assert(!move (_96.1: bool), "attempt to compute `{} - {}`, which would overflow", move _90, move _95) -> bb33
  using: _96@Entry, _90@Entry, _95@Entry
bb33:
  _11 = move (_96.0: i32)
  using: _96@Mir(bb32[2])
  _97 = _11
  using: _11@Mir(bb33[0])
  _99 = _10
  using: _10@Mir(bb31[1])
  _98 = move _99 as usize (IntToInt)
  using: _99@Mir(bb33[2])
  _100 = const 257_usize
  using: 
  _101 = Lt(_98, _100)
  using: _98@Mir(bb33[3]), _100@Mir(bb33[4])
  assert(move _101, "index out of bounds: the length is {} but the index is {}", move _100, _98) -> bb34
  using: _101@Entry, _100@Entry, _98@Entry
bb34:
  _6[_98] = move _97
  using: _98@Mir(bb33[3]), _97@Mir(bb33[1])
  _102 = _9
  using: _9@Phi(bb29)
  _104 = _1
  using: _1@Phi(bb29)
  _106 = _11
  using: _11@Mir(bb33[0])
  _105 = move _106 as isize (IntToInt)
  using: _106@Mir(bb34[3])
  _103 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _104, move _105) -> bb35
  using: _104@Mir(bb34[2]), _105@Mir(bb34[4])
bb35:
  (*_103) = move _102 as u32 (IntToInt)
  using: _103@Mir(bb34[5]), _102@Mir(bb34[1])
  _107 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb29)
  assert(!move (_107.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb36
  using: _107@Entry, _9@Entry
bb36:
  _9 = move (_107.0: i32)
  using: _107@Mir(bb35[1])
  goto -> bb29
  using: 
bb37:
  _108 = const 2_i32
  using: 
  _110 = _4
  using: _4@Entry
  _111 = const 32_i32
  using: 
  _112 = const false
  using: 
  _113 = Eq(_110, const i32::MIN)
  using: _110@Mir(bb37[1])
  _114 = BitAnd(move _112, move _113)
  using: _112@Mir(bb37[3]), _113@Mir(bb37[4])
  assert(!move _114, "attempt to compute `{} / {}`, which would overflow", _110, _111) -> bb38
  using: _114@Entry, _110@Entry, _111@Entry
bb38:
  _109 = Div(move _110, move _111)
  using: _110@Mir(bb37[1]), _111@Mir(bb37[2])
  _115 = CheckedAdd(_108, _109)
  using: _108@Mir(bb37[0]), _109@Mir(bb38[0])
  assert(!move (_115.1: bool), "attempt to compute `{} + {}`, which would overflow", move _108, move _109) -> bb39
  using: _115@Entry, _108@Entry, _109@Entry
bb39:
  _17 = move (_115.0: i32)
  using: _115@Mir(bb38[1])
  _9 = const 0_i32
  using: 
  goto -> bb40
  using: 
bb40:
  _117 = _9
  using: _9@Phi(bb40)
  _118 = _17
  using: _17@Mir(bb39[0])
  _116 = Lt(move _117, move _118)
  using: _117@Mir(bb40[0]), _118@Mir(bb40[1])
  switchInt(move _116) -> [0: bb44, otherwise: bb41]
  using: _116@Mir(bb40[2])
bb41:
  _119 = const 0_i32
  using: 
  _121 = _3
  using: _3@Phi(bb40)
  _123 = _9
  using: _9@Phi(bb40)
  _122 = move _123 as isize (IntToInt)
  using: _123@Mir(bb41[2])
  _120 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _121, move _122) -> bb42
  using: _121@Mir(bb41[1]), _122@Mir(bb41[3])
bb42:
  (*_120) = move _119 as u32 (IntToInt)
  using: _120@Mir(bb41[4]), _119@Mir(bb41[0])
  _124 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb40)
  assert(!move (_124.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb43
  using: _124@Entry, _9@Entry
bb43:
  _9 = move (_124.0: i32)
  using: _124@Mir(bb42[1])
  goto -> bb40
  using: 
bb44:
  _9 = const 0_i32
  using: 
  goto -> bb45
  using: 
bb45:
  _126 = _9
  using: _9@Phi(bb45)
  _127 = const 256_i32
  using: 
  _125 = Lt(move _126, move _127)
  using: _126@Mir(bb45[0]), _127@Mir(bb45[1])
  switchInt(move _125) -> [0: bb53, otherwise: bb46]
  using: _125@Mir(bb45[2])
bb46:
  _128 = const 1_u32
  using: 
  _132 = _9
  using: _9@Phi(bb45)
  _131 = move _132 as usize (IntToInt)
  using: _132@Mir(bb46[1])
  _133 = const 257_usize
  using: 
  _134 = Lt(_131, _133)
  using: _131@Mir(bb46[2]), _133@Mir(bb46[3])
  assert(move _134, "index out of bounds: the length is {} but the index is {}", move _133, _131) -> bb47
  using: _134@Entry, _133@Entry, _131@Entry
bb47:
  _130 = _6[_131]
  using: _6@Phi(bb45), _131@Mir(bb46[2])
  _135 = const 31_i32
  using: 
  _129 = BitAnd(move _130, move _135)
  using: _130@Mir(bb47[0]), _135@Mir(bb47[1])
  _136 = CheckedShl(_128, _129)
  using: _128@Mir(bb46[0]), _129@Mir(bb47[2])
  assert(!move (_136.1: bool), "attempt to shift left by `{}`, which would overflow", move _129) -> bb48
  using: _136@Entry, _128@Entry, _129@Entry
bb48:
  _138 = _3
  using: _3@Phi(bb45)
  _143 = _9
  using: _9@Phi(bb45)
  _142 = move _143 as usize (IntToInt)
  using: _143@Mir(bb48[1])
  _144 = const 257_usize
  using: 
  _145 = Lt(_142, _144)
  using: _142@Mir(bb48[2]), _144@Mir(bb48[3])
  assert(move _145, "index out of bounds: the length is {} but the index is {}", move _144, _142) -> bb49
  using: _145@Entry, _144@Entry, _142@Entry
bb49:
  _141 = _6[_142]
  using: _6@Phi(bb45), _142@Mir(bb48[2])
  _146 = const 5_i32
  using: 
  _147 = CheckedShr(_141, _146)
  using: _141@Mir(bb49[0]), _146@Mir(bb49[1])
  assert(!move (_147.1: bool), "attempt to shift right by `{}`, which would overflow", move _146) -> bb50
  using: _147@Entry, _141@Entry, _146@Entry
bb50:
  _140 = move (_147.0: i32)
  using: _147@Mir(bb49[2])
  _139 = move _140 as isize (IntToInt)
  using: _140@Mir(bb50[0])
  _137 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _138, move _139) -> bb51
  using: _138@Mir(bb48[0]), _139@Mir(bb50[1])
bb51:
  (*_137) = move (_136.0: u32)
  using: _137@Mir(bb50[2]), _136@Mir(bb47[3])
  _148 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb45)
  assert(!move (_148.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb52
  using: _148@Entry, _9@Entry
bb52:
  _9 = move (_148.0: i32)
  using: _148@Mir(bb51[1])
  goto -> bb45
  using: 
bb53:
  _9 = const 0_i32
  using: 
  goto -> bb54
  using: 
bb54:
  _150 = _9
  using: _9@Phi(bb54)
  _151 = const 32_i32
  using: 
  _149 = Lt(move _150, move _151)
  using: _150@Mir(bb54[0]), _151@Mir(bb54[1])
  switchInt(move _149) -> [0: bb73, otherwise: bb55]
  using: _149@Mir(bb54[2])
bb55:
  _152 = const 1_u32
  using: 
  _155 = _4
  using: _4@Phi(bb54)
  _157 = const 2_i32
  using: 
  _158 = _9
  using: _9@Phi(bb54)
  _159 = CheckedMul(_157, _158)
  using: _157@Mir(bb55[2]), _158@Mir(bb55[3])
  assert(!move (_159.1: bool), "attempt to compute `{} * {}`, which would overflow", move _157, move _158) -> bb56
  using: _159@Entry, _157@Entry, _158@Entry
bb56:
  _156 = move (_159.0: i32)
  using: _159@Mir(bb55[4])
  _160 = CheckedAdd(_155, _156)
  using: _155@Mir(bb55[1]), _156@Mir(bb56[0])
  assert(!move (_160.1: bool), "attempt to compute `{} + {}`, which would overflow", move _155, move _156) -> bb57
  using: _160@Entry, _155@Entry, _156@Entry
bb57:
  _154 = move (_160.0: i32)
  using: _160@Mir(bb56[1])
  _161 = const 31_i32
  using: 
  _153 = BitAnd(move _154, move _161)
  using: _154@Mir(bb57[0]), _161@Mir(bb57[1])
  _162 = CheckedShl(_152, _153)
  using: _152@Mir(bb55[0]), _153@Mir(bb57[2])
  assert(!move (_162.1: bool), "attempt to shift left by `{}`, which would overflow", move _153) -> bb58
  using: _162@Entry, _152@Entry, _153@Entry
bb58:
  _164 = _3
  using: _3@Phi(bb54)
  _168 = _4
  using: _4@Phi(bb54)
  _170 = const 2_i32
  using: 
  _171 = _9
  using: _9@Phi(bb54)
  _172 = CheckedMul(_170, _171)
  using: _170@Mir(bb58[2]), _171@Mir(bb58[3])
  assert(!move (_172.1: bool), "attempt to compute `{} * {}`, which would overflow", move _170, move _171) -> bb59
  using: _172@Entry, _170@Entry, _171@Entry
bb59:
  _169 = move (_172.0: i32)
  using: _172@Mir(bb58[4])
  _173 = CheckedAdd(_168, _169)
  using: _168@Mir(bb58[1]), _169@Mir(bb59[0])
  assert(!move (_173.1: bool), "attempt to compute `{} + {}`, which would overflow", move _168, move _169) -> bb60
  using: _173@Entry, _168@Entry, _169@Entry
bb60:
  _167 = move (_173.0: i32)
  using: _173@Mir(bb59[1])
  _174 = const 5_i32
  using: 
  _175 = CheckedShr(_167, _174)
  using: _167@Mir(bb60[0]), _174@Mir(bb60[1])
  assert(!move (_175.1: bool), "attempt to shift right by `{}`, which would overflow", move _174) -> bb61
  using: _175@Entry, _167@Entry, _174@Entry
bb61:
  _166 = move (_175.0: i32)
  using: _175@Mir(bb60[2])
  _165 = move _166 as isize (IntToInt)
  using: _166@Mir(bb61[0])
  _163 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _164, move _165) -> bb62
  using: _164@Mir(bb58[0]), _165@Mir(bb61[1])
bb62:
  (*_163) = move (_162.0: u32)
  using: _163@Mir(bb61[2]), _162@Mir(bb57[3])
  _178 = const 1_u32
  using: 
  _182 = _4
  using: _4@Phi(bb54)
  _184 = const 2_i32
  using: 
  _185 = _9
  using: _9@Phi(bb54)
  _186 = CheckedMul(_184, _185)
  using: _184@Mir(bb62[3]), _185@Mir(bb62[4])
  assert(!move (_186.1: bool), "attempt to compute `{} * {}`, which would overflow", move _184, move _185) -> bb63
  using: _186@Entry, _184@Entry, _185@Entry
bb63:
  _183 = move (_186.0: i32)
  using: _186@Mir(bb62[5])
  _187 = CheckedAdd(_182, _183)
  using: _182@Mir(bb62[2]), _183@Mir(bb63[0])
  assert(!move (_187.1: bool), "attempt to compute `{} + {}`, which would overflow", move _182, move _183) -> bb64
  using: _187@Entry, _182@Entry, _183@Entry
bb64:
  _181 = move (_187.0: i32)
  using: _187@Mir(bb63[1])
  _188 = const 1_i32
  using: 
  _189 = CheckedAdd(_181, _188)
  using: _181@Mir(bb64[0]), _188@Mir(bb64[1])
  assert(!move (_189.1: bool), "attempt to compute `{} + {}`, which would overflow", move _181, move _188) -> bb65
  using: _189@Entry, _181@Entry, _188@Entry
bb65:
  _180 = move (_189.0: i32)
  using: _189@Mir(bb64[2])
  _190 = const 31_i32
  using: 
  _179 = BitAnd(move _180, move _190)
  using: _180@Mir(bb65[0]), _190@Mir(bb65[1])
  _191 = CheckedShl(_178, _179)
  using: _178@Mir(bb62[1]), _179@Mir(bb65[2])
  assert(!move (_191.1: bool), "attempt to shift left by `{}`, which would overflow", move _179) -> bb66
  using: _191@Entry, _178@Entry, _179@Entry
bb66:
  _177 = move (_191.0: u32)
  using: _191@Mir(bb65[3])
  _176 = Not(move _177)
  using: _177@Mir(bb66[0])
  _193 = _3
  using: _3@Phi(bb54)
  _198 = _4
  using: _4@Phi(bb54)
  _200 = const 2_i32
  using: 
  _201 = _9
  using: _9@Phi(bb54)
  _202 = CheckedMul(_200, _201)
  using: _200@Mir(bb66[4]), _201@Mir(bb66[5])
  assert(!move (_202.1: bool), "attempt to compute `{} * {}`, which would overflow", move _200, move _201) -> bb67
  using: _202@Entry, _200@Entry, _201@Entry
bb67:
  _199 = move (_202.0: i32)
  using: _202@Mir(bb66[6])
  _203 = CheckedAdd(_198, _199)
  using: _198@Mir(bb66[3]), _199@Mir(bb67[0])
  assert(!move (_203.1: bool), "attempt to compute `{} + {}`, which would overflow", move _198, move _199) -> bb68
  using: _203@Entry, _198@Entry, _199@Entry
bb68:
  _197 = move (_203.0: i32)
  using: _203@Mir(bb67[1])
  _204 = const 1_i32
  using: 
  _205 = CheckedAdd(_197, _204)
  using: _197@Mir(bb68[0]), _204@Mir(bb68[1])
  assert(!move (_205.1: bool), "attempt to compute `{} + {}`, which would overflow", move _197, move _204) -> bb69
  using: _205@Entry, _197@Entry, _204@Entry
bb69:
  _196 = move (_205.0: i32)
  using: _205@Mir(bb68[2])
  _206 = const 5_i32
  using: 
  _207 = CheckedShr(_196, _206)
  using: _196@Mir(bb69[0]), _206@Mir(bb69[1])
  assert(!move (_207.1: bool), "attempt to shift right by `{}`, which would overflow", move _206) -> bb70
  using: _207@Entry, _196@Entry, _206@Entry
bb70:
  _195 = move (_207.0: i32)
  using: _207@Mir(bb69[2])
  _194 = move _195 as isize (IntToInt)
  using: _195@Mir(bb70[0])
  _192 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _193, move _194) -> bb71
  using: _193@Mir(bb66[2]), _194@Mir(bb70[1])
bb71:
  (*_192) = BitAnd((*_192), move _176)
  using: _192@Mir(bb70[2]), _192@Mir(bb70[2]), _176@Mir(bb66[1])
  _208 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb54)
  assert(!move (_208.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb72
  using: _208@Entry, _9@Entry
bb72:
  _9 = move (_208.0: i32)
  using: _208@Mir(bb71[1])
  goto -> bb54
  using: 
bb73:
  _8 = const 1_i32
  using: 
  goto -> bb74
  using: 
bb74:
  _210 = _5
  using: _5@Phi(bb74)
  _211 = const 4_i32
  using: 
  _209 = Ge(move _210, move _211)
  using: _210@Mir(bb74[0]), _211@Mir(bb74[1])
  switchInt(move _209) -> [0: bb76, otherwise: bb75]
  using: _209@Mir(bb74[2])
bb75:
  _214 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _213 = (*_214)
  using: _214@Mir(bb75[0])
  _218 = const b"        depth %6d has \x00"
  using: 
  _217 = &raw const (*_218)
  using: _218@Mir(bb75[2])
  _216 = move _217 as *const u8 (Pointer(ArrayToPointer))
  using: _217@Mir(bb75[3])
  _215 = move _216 as *const i8 (PtrToPtr)
  using: _216@Mir(bb75[4])
  _219 = _8
  using: _8@Phi(bb74)
  _212 = blocksort::fprintf(move _213, move _215, move _219) -> bb76
  using: _213@Mir(bb75[1]), _215@Mir(bb75[5]), _219@Mir(bb75[6])
bb76:
  _10 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  goto -> bb77
  using: 
bb77:
  _221 = _9
  using: _9@Phi(bb77)
  _222 = _4
  using: _4@Phi(bb77)
  _220 = Lt(move _221, move _222)
  using: _221@Mir(bb77[0]), _222@Mir(bb77[1])
  switchInt(move _220) -> [0: bb91, otherwise: bb78]
  using: _220@Mir(bb77[2])
bb78:
  _226 = _3
  using: _3@Phi(bb77)
  _229 = _9
  using: _9@Phi(bb77)
  _230 = const 5_i32
  using: 
  _231 = CheckedShr(_229, _230)
  using: _229@Mir(bb78[1]), _230@Mir(bb78[2])
  assert(!move (_231.1: bool), "attempt to shift right by `{}`, which would overflow", move _230) -> bb79
  using: _231@Entry, _229@Entry, _230@Entry
bb79:
  _228 = move (_231.0: i32)
  using: _231@Mir(bb78[3])
  _227 = move _228 as isize (IntToInt)
  using: _228@Mir(bb79[0])
  _225 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _226, move _227) -> bb80
  using: _226@Mir(bb78[0]), _227@Mir(bb79[1])
bb80:
  _224 = (*_225)
  using: _225@Mir(bb79[2])
  _233 = const 1_u32
  using: 
  _235 = _9
  using: _9@Phi(bb77)
  _236 = const 31_i32
  using: 
  _234 = BitAnd(move _235, move _236)
  using: _235@Mir(bb80[2]), _236@Mir(bb80[3])
  _237 = CheckedShl(_233, _234)
  using: _233@Mir(bb80[1]), _234@Mir(bb80[4])
  assert(!move (_237.1: bool), "attempt to shift left by `{}`, which would overflow", move _234) -> bb81
  using: _237@Entry, _233@Entry, _234@Entry
bb81:
  _232 = move (_237.0: u32)
  using: _237@Mir(bb80[5])
  _223 = BitAnd(move _224, move _232)
  using: _224@Mir(bb80[0]), _232@Mir(bb81[0])
  switchInt(move _223) -> [0: bb83, otherwise: bb82]
  using: _223@Mir(bb81[1])
bb82:
  _238 = _9
  using: _9@Phi(bb77)
  _10 = move _238
  using: _238@Mir(bb82[0])
  goto -> bb83
  using: 
bb83:
  _242 = _1
  using: _1@Phi(bb77)
  _244 = _9
  using: _9@Phi(bb83)
  _243 = move _244 as isize (IntToInt)
  using: _244@Mir(bb83[1])
  _241 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _242, move _243) -> bb84
  using: _242@Mir(bb83[0]), _243@Mir(bb83[2])
bb84:
  _240 = (*_241)
  using: _241@Mir(bb83[3])
  _246 = _8
  using: _8@Phi(bb77)
  _245 = move _246 as u32 (IntToInt)
  using: _246@Mir(bb84[1])
  _239 = core::num::<impl u32>::wrapping_sub(move _240, move _245) -> bb85
  using: _240@Mir(bb84[0]), _245@Mir(bb84[2])
bb85:
  _11 = move _239 as i32 (IntToInt)
  using: _239@Mir(bb84[3])
  _248 = _11
  using: _11@Mir(bb85[0])
  _249 = const 0_i32
  using: 
  _247 = Lt(move _248, move _249)
  using: _248@Mir(bb85[1]), _249@Mir(bb85[2])
  switchInt(move _247) -> [0: bb88, otherwise: bb86]
  using: _247@Mir(bb85[3])
bb86:
  _250 = _4
  using: _4@Phi(bb77)
  _251 = CheckedAdd(_11, _250)
  using: _11@Mir(bb85[0]), _250@Mir(bb86[0])
  assert(!move (_251.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, move _250) -> bb87
  using: _251@Entry, _11@Entry, _250@Entry
bb87:
  _11 = move (_251.0: i32)
  using: _251@Mir(bb86[1])
  goto -> bb88
  using: 
bb88:
  _252 = _10
  using: _10@Phi(bb83)
  _254 = _2
  using: _2@Phi(bb77)
  _256 = _11
  using: _11@Phi(bb88)
  _255 = move _256 as isize (IntToInt)
  using: _256@Mir(bb88[2])
  _253 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _254, move _255) -> bb89
  using: _254@Mir(bb88[1]), _255@Mir(bb88[3])
bb89:
  (*_253) = move _252 as u32 (IntToInt)
  using: _253@Mir(bb88[4]), _252@Mir(bb88[0])
  _257 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb83)
  assert(!move (_257.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb90
  using: _257@Entry, _9@Entry
bb90:
  _9 = move (_257.0: i32)
  using: _257@Mir(bb89[1])
  goto -> bb77
  using: 
bb91:
  _16 = const 0_i32
  using: 
  _13 = const -1_i32
  using: 
  goto -> bb92
  using: 
bb92:
  _258 = _13
  using: _13@Phi(bb92)
  _259 = const 1_i32
  using: 
  _260 = CheckedAdd(_258, _259)
  using: _258@Mir(bb92[0]), _259@Mir(bb92[1])
  assert(!move (_260.1: bool), "attempt to compute `{} + {}`, which would overflow", move _258, move _259) -> bb93
  using: _260@Entry, _258@Entry, _259@Entry
bb93:
  _11 = move (_260.0: i32)
  using: _260@Mir(bb92[2])
  goto -> bb94
  using: 
bb94:
  _265 = _3
  using: _3@Phi(bb92)
  _268 = _11
  using: _11@Phi(bb94)
  _269 = const 5_i32
  using: 
  _270 = CheckedShr(_268, _269)
  using: _268@Mir(bb94[1]), _269@Mir(bb94[2])
  assert(!move (_270.1: bool), "attempt to shift right by `{}`, which would overflow", move _269) -> bb98
  using: _270@Entry, _268@Entry, _269@Entry
bb95:
  _261 = const false
  using: 
  goto -> bb97
  using: 
bb96:
  _279 = _11
  using: _11@Phi(bb94)
  _280 = const 31_i32
  using: 
  _278 = BitAnd(move _279, move _280)
  using: _279@Mir(bb96[0]), _280@Mir(bb96[1])
  _277 = Ne(move _278, const 0_i32)
  using: _278@Mir(bb96[2])
  _261 = move _277
  using: _277@Mir(bb96[3])
  goto -> bb97
  using: 
bb97:
  switchInt(move _261) -> [0: bb103, otherwise: bb101]
  using: _261@Phi(bb97)
bb98:
  _267 = move (_270.0: i32)
  using: _270@Mir(bb94[3])
  _266 = move _267 as isize (IntToInt)
  using: _267@Mir(bb98[0])
  _264 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _265, move _266) -> bb99
  using: _265@Mir(bb94[0]), _266@Mir(bb98[1])
bb99:
  _263 = (*_264)
  using: _264@Mir(bb98[2])
  _272 = const 1_u32
  using: 
  _274 = _11
  using: _11@Phi(bb94)
  _275 = const 31_i32
  using: 
  _273 = BitAnd(move _274, move _275)
  using: _274@Mir(bb99[2]), _275@Mir(bb99[3])
  _276 = CheckedShl(_272, _273)
  using: _272@Mir(bb99[1]), _273@Mir(bb99[4])
  assert(!move (_276.1: bool), "attempt to shift left by `{}`, which would overflow", move _273) -> bb100
  using: _276@Entry, _272@Entry, _273@Entry
bb100:
  _271 = move (_276.0: u32)
  using: _276@Mir(bb99[5])
  _262 = BitAnd(move _263, move _271)
  using: _263@Mir(bb99[0]), _271@Mir(bb100[0])
  switchInt(move _262) -> [0: bb95, otherwise: bb96]
  using: _262@Mir(bb100[1])
bb101:
  _281 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb97)
  assert(!move (_281.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb102
  using: _281@Entry, _11@Entry
bb102:
  _11 = move (_281.0: i32)
  using: _281@Mir(bb101[0])
  goto -> bb94
  using: 
bb103:
  _285 = _3
  using: _3@Phi(bb92)
  _288 = _11
  using: _11@Phi(bb97)
  _289 = const 5_i32
  using: 
  _290 = CheckedShr(_288, _289)
  using: _288@Mir(bb103[1]), _289@Mir(bb103[2])
  assert(!move (_290.1: bool), "attempt to shift right by `{}`, which would overflow", move _289) -> bb104
  using: _290@Entry, _288@Entry, _289@Entry
bb104:
  _287 = move (_290.0: i32)
  using: _290@Mir(bb103[3])
  _286 = move _287 as isize (IntToInt)
  using: _287@Mir(bb104[0])
  _284 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _285, move _286) -> bb105
  using: _285@Mir(bb103[0]), _286@Mir(bb104[1])
bb105:
  _283 = (*_284)
  using: _284@Mir(bb104[2])
  _292 = const 1_u32
  using: 
  _294 = _11
  using: _11@Phi(bb97)
  _295 = const 31_i32
  using: 
  _293 = BitAnd(move _294, move _295)
  using: _294@Mir(bb105[2]), _295@Mir(bb105[3])
  _296 = CheckedShl(_292, _293)
  using: _292@Mir(bb105[1]), _293@Mir(bb105[4])
  assert(!move (_296.1: bool), "attempt to shift left by `{}`, which would overflow", move _293) -> bb106
  using: _296@Entry, _292@Entry, _293@Entry
bb106:
  _291 = move (_296.0: u32)
  using: _296@Mir(bb105[5])
  _282 = BitAnd(move _283, move _291)
  using: _283@Mir(bb105[0]), _291@Mir(bb106[0])
  switchInt(move _282) -> [0: bb118, otherwise: bb107]
  using: _282@Mir(bb106[1])
bb107:
  _300 = _3
  using: _3@Phi(bb92)
  _303 = _11
  using: _11@Phi(bb107)
  _304 = const 5_i32
  using: 
  _305 = CheckedShr(_303, _304)
  using: _303@Mir(bb107[1]), _304@Mir(bb107[2])
  assert(!move (_305.1: bool), "attempt to shift right by `{}`, which would overflow", move _304) -> bb108
  using: _305@Entry, _303@Entry, _304@Entry
bb108:
  _302 = move (_305.0: i32)
  using: _305@Mir(bb107[3])
  _301 = move _302 as isize (IntToInt)
  using: _302@Mir(bb108[0])
  _299 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _300, move _301) -> bb109
  using: _300@Mir(bb107[0]), _301@Mir(bb108[1])
bb109:
  _298 = (*_299)
  using: _299@Mir(bb108[2])
  _306 = const u32::MAX
  using: 
  _297 = Eq(move _298, move _306)
  using: _298@Mir(bb109[0]), _306@Mir(bb109[1])
  switchInt(move _297) -> [0: bb112, otherwise: bb110]
  using: _297@Mir(bb109[2])
bb110:
  _307 = const 32_i32
  using: 
  _308 = CheckedAdd(_11, _307)
  using: _11@Phi(bb107), _307@Mir(bb110[0])
  assert(!move (_308.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, move _307) -> bb111
  using: _308@Entry, _11@Entry, _307@Entry
bb111:
  _11 = move (_308.0: i32)
  using: _308@Mir(bb110[1])
  goto -> bb107
  using: 
bb112:
  _312 = _3
  using: _3@Phi(bb92)
  _315 = _11
  using: _11@Phi(bb112)
  _316 = const 5_i32
  using: 
  _317 = CheckedShr(_315, _316)
  using: _315@Mir(bb112[1]), _316@Mir(bb112[2])
  assert(!move (_317.1: bool), "attempt to shift right by `{}`, which would overflow", move _316) -> bb113
  using: _317@Entry, _315@Entry, _316@Entry
bb113:
  _314 = move (_317.0: i32)
  using: _317@Mir(bb112[3])
  _313 = move _314 as isize (IntToInt)
  using: _314@Mir(bb113[0])
  _311 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _312, move _313) -> bb114
  using: _312@Mir(bb112[0]), _313@Mir(bb113[1])
bb114:
  _310 = (*_311)
  using: _311@Mir(bb113[2])
  _319 = const 1_u32
  using: 
  _321 = _11
  using: _11@Phi(bb112)
  _322 = const 31_i32
  using: 
  _320 = BitAnd(move _321, move _322)
  using: _321@Mir(bb114[2]), _322@Mir(bb114[3])
  _323 = CheckedShl(_319, _320)
  using: _319@Mir(bb114[1]), _320@Mir(bb114[4])
  assert(!move (_323.1: bool), "attempt to shift left by `{}`, which would overflow", move _320) -> bb115
  using: _323@Entry, _319@Entry, _320@Entry
bb115:
  _318 = move (_323.0: u32)
  using: _323@Mir(bb114[5])
  _309 = BitAnd(move _310, move _318)
  using: _310@Mir(bb114[0]), _318@Mir(bb115[0])
  switchInt(move _309) -> [0: bb118, otherwise: bb116]
  using: _309@Mir(bb115[1])
bb116:
  _324 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb112)
  assert(!move (_324.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb117
  using: _324@Entry, _11@Entry
bb117:
  _11 = move (_324.0: i32)
  using: _324@Mir(bb116[0])
  goto -> bb112
  using: 
bb118:
  _325 = _11
  using: _11@Phi(bb118)
  _326 = const 1_i32
  using: 
  _327 = CheckedSub(_325, _326)
  using: _325@Mir(bb118[0]), _326@Mir(bb118[1])
  assert(!move (_327.1: bool), "attempt to compute `{} - {}`, which would overflow", move _325, move _326) -> bb119
  using: _327@Entry, _325@Entry, _326@Entry
bb119:
  _12 = move (_327.0: i32)
  using: _327@Mir(bb118[2])
  _329 = _12
  using: _12@Mir(bb119[0])
  _330 = _4
  using: _4@Phi(bb92)
  _328 = Ge(move _329, move _330)
  using: _329@Mir(bb119[1]), _330@Mir(bb119[2])
  switchInt(move _328) -> [0: bb120, otherwise: bb162]
  using: _328@Mir(bb119[3])
bb120:
  _335 = _3
  using: _3@Phi(bb118)
  _338 = _11
  using: _11@Phi(bb120)
  _339 = const 5_i32
  using: 
  _340 = CheckedShr(_338, _339)
  using: _338@Mir(bb120[1]), _339@Mir(bb120[2])
  assert(!move (_340.1: bool), "attempt to shift right by `{}`, which would overflow", move _339) -> bb124
  using: _340@Entry, _338@Entry, _339@Entry
bb121:
  _331 = const false
  using: 
  goto -> bb123
  using: 
bb122:
  _349 = _11
  using: _11@Phi(bb120)
  _350 = const 31_i32
  using: 
  _348 = BitAnd(move _349, move _350)
  using: _349@Mir(bb122[0]), _350@Mir(bb122[1])
  _347 = Ne(move _348, const 0_i32)
  using: _348@Mir(bb122[2])
  _331 = move _347
  using: _347@Mir(bb122[3])
  goto -> bb123
  using: 
bb123:
  switchInt(move _331) -> [0: bb129, otherwise: bb127]
  using: _331@Phi(bb123)
bb124:
  _337 = move (_340.0: i32)
  using: _340@Mir(bb120[3])
  _336 = move _337 as isize (IntToInt)
  using: _337@Mir(bb124[0])
  _334 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _335, move _336) -> bb125
  using: _335@Mir(bb120[0]), _336@Mir(bb124[1])
bb125:
  _333 = (*_334)
  using: _334@Mir(bb124[2])
  _342 = const 1_u32
  using: 
  _344 = _11
  using: _11@Phi(bb120)
  _345 = const 31_i32
  using: 
  _343 = BitAnd(move _344, move _345)
  using: _344@Mir(bb125[2]), _345@Mir(bb125[3])
  _346 = CheckedShl(_342, _343)
  using: _342@Mir(bb125[1]), _343@Mir(bb125[4])
  assert(!move (_346.1: bool), "attempt to shift left by `{}`, which would overflow", move _343) -> bb126
  using: _346@Entry, _342@Entry, _343@Entry
bb126:
  _341 = move (_346.0: u32)
  using: _346@Mir(bb125[5])
  _332 = BitAnd(move _333, move _341)
  using: _333@Mir(bb125[0]), _341@Mir(bb126[0])
  switchInt(move _332) -> [0: bb122, otherwise: bb121]
  using: _332@Mir(bb126[1])
bb127:
  _351 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb123)
  assert(!move (_351.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb128
  using: _351@Entry, _11@Entry
bb128:
  _11 = move (_351.0: i32)
  using: _351@Mir(bb127[0])
  goto -> bb120
  using: 
bb129:
  _355 = _3
  using: _3@Phi(bb118)
  _358 = _11
  using: _11@Phi(bb123)
  _359 = const 5_i32
  using: 
  _360 = CheckedShr(_358, _359)
  using: _358@Mir(bb129[1]), _359@Mir(bb129[2])
  assert(!move (_360.1: bool), "attempt to shift right by `{}`, which would overflow", move _359) -> bb130
  using: _360@Entry, _358@Entry, _359@Entry
bb130:
  _357 = move (_360.0: i32)
  using: _360@Mir(bb129[3])
  _356 = move _357 as isize (IntToInt)
  using: _357@Mir(bb130[0])
  _354 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _355, move _356) -> bb131
  using: _355@Mir(bb129[0]), _356@Mir(bb130[1])
bb131:
  _353 = (*_354)
  using: _354@Mir(bb130[2])
  _362 = const 1_u32
  using: 
  _364 = _11
  using: _11@Phi(bb123)
  _365 = const 31_i32
  using: 
  _363 = BitAnd(move _364, move _365)
  using: _364@Mir(bb131[2]), _365@Mir(bb131[3])
  _366 = CheckedShl(_362, _363)
  using: _362@Mir(bb131[1]), _363@Mir(bb131[4])
  assert(!move (_366.1: bool), "attempt to shift left by `{}`, which would overflow", move _363) -> bb132
  using: _366@Entry, _362@Entry, _363@Entry
bb132:
  _361 = move (_366.0: u32)
  using: _366@Mir(bb131[5])
  _352 = BitAnd(move _353, move _361)
  using: _353@Mir(bb131[0]), _361@Mir(bb132[0])
  switchInt(move _352) -> [0: bb133, otherwise: bb144]
  using: _352@Mir(bb132[1])
bb133:
  _370 = _3
  using: _3@Phi(bb118)
  _373 = _11
  using: _11@Phi(bb133)
  _374 = const 5_i32
  using: 
  _375 = CheckedShr(_373, _374)
  using: _373@Mir(bb133[1]), _374@Mir(bb133[2])
  assert(!move (_375.1: bool), "attempt to shift right by `{}`, which would overflow", move _374) -> bb134
  using: _375@Entry, _373@Entry, _374@Entry
bb134:
  _372 = move (_375.0: i32)
  using: _375@Mir(bb133[3])
  _371 = move _372 as isize (IntToInt)
  using: _372@Mir(bb134[0])
  _369 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _370, move _371) -> bb135
  using: _370@Mir(bb133[0]), _371@Mir(bb134[1])
bb135:
  _368 = (*_369)
  using: _369@Mir(bb134[2])
  _376 = const 0_u32
  using: 
  _367 = Eq(move _368, move _376)
  using: _368@Mir(bb135[0]), _376@Mir(bb135[1])
  switchInt(move _367) -> [0: bb138, otherwise: bb136]
  using: _367@Mir(bb135[2])
bb136:
  _377 = const 32_i32
  using: 
  _378 = CheckedAdd(_11, _377)
  using: _11@Phi(bb133), _377@Mir(bb136[0])
  assert(!move (_378.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, move _377) -> bb137
  using: _378@Entry, _11@Entry, _377@Entry
bb137:
  _11 = move (_378.0: i32)
  using: _378@Mir(bb136[1])
  goto -> bb133
  using: 
bb138:
  _382 = _3
  using: _3@Phi(bb118)
  _385 = _11
  using: _11@Phi(bb138)
  _386 = const 5_i32
  using: 
  _387 = CheckedShr(_385, _386)
  using: _385@Mir(bb138[1]), _386@Mir(bb138[2])
  assert(!move (_387.1: bool), "attempt to shift right by `{}`, which would overflow", move _386) -> bb139
  using: _387@Entry, _385@Entry, _386@Entry
bb139:
  _384 = move (_387.0: i32)
  using: _387@Mir(bb138[3])
  _383 = move _384 as isize (IntToInt)
  using: _384@Mir(bb139[0])
  _381 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _382, move _383) -> bb140
  using: _382@Mir(bb138[0]), _383@Mir(bb139[1])
bb140:
  _380 = (*_381)
  using: _381@Mir(bb139[2])
  _389 = const 1_u32
  using: 
  _391 = _11
  using: _11@Phi(bb138)
  _392 = const 31_i32
  using: 
  _390 = BitAnd(move _391, move _392)
  using: _391@Mir(bb140[2]), _392@Mir(bb140[3])
  _393 = CheckedShl(_389, _390)
  using: _389@Mir(bb140[1]), _390@Mir(bb140[4])
  assert(!move (_393.1: bool), "attempt to shift left by `{}`, which would overflow", move _390) -> bb141
  using: _393@Entry, _389@Entry, _390@Entry
bb141:
  _388 = move (_393.0: u32)
  using: _393@Mir(bb140[5])
  _379 = BitAnd(move _380, move _388)
  using: _380@Mir(bb140[0]), _388@Mir(bb141[0])
  switchInt(move _379) -> [0: bb142, otherwise: bb144]
  using: _379@Mir(bb141[1])
bb142:
  _394 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb138)
  assert(!move (_394.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb143
  using: _394@Entry, _11@Entry
bb143:
  _11 = move (_394.0: i32)
  using: _394@Mir(bb142[0])
  goto -> bb138
  using: 
bb144:
  _395 = _11
  using: _11@Phi(bb144)
  _396 = const 1_i32
  using: 
  _397 = CheckedSub(_395, _396)
  using: _395@Mir(bb144[0]), _396@Mir(bb144[1])
  assert(!move (_397.1: bool), "attempt to compute `{} - {}`, which would overflow", move _395, move _396) -> bb145
  using: _397@Entry, _395@Entry, _396@Entry
bb145:
  _13 = move (_397.0: i32)
  using: _397@Mir(bb144[2])
  _399 = _13
  using: _13@Mir(bb145[0])
  _400 = _4
  using: _4@Phi(bb92)
  _398 = Ge(move _399, move _400)
  using: _399@Mir(bb145[1]), _400@Mir(bb145[2])
  switchInt(move _398) -> [0: bb146, otherwise: bb162]
  using: _398@Mir(bb145[3])
bb146:
  _402 = _13
  using: _13@Mir(bb145[0])
  _403 = _12
  using: _12@Mir(bb119[0])
  _401 = Gt(move _402, move _403)
  using: _402@Mir(bb146[0]), _403@Mir(bb146[1])
  switchInt(move _401) -> [0: bb92, otherwise: bb147]
  using: _401@Mir(bb146[2])
bb147:
  _406 = _13
  using: _13@Mir(bb145[0])
  _407 = _12
  using: _12@Mir(bb119[0])
  _408 = CheckedSub(_406, _407)
  using: _406@Mir(bb147[0]), _407@Mir(bb147[1])
  assert(!move (_408.1: bool), "attempt to compute `{} - {}`, which would overflow", move _406, move _407) -> bb148
  using: _408@Entry, _406@Entry, _407@Entry
bb148:
  _405 = move (_408.0: i32)
  using: _408@Mir(bb147[2])
  _409 = const 1_i32
  using: 
  _410 = CheckedAdd(_405, _409)
  using: _405@Mir(bb148[0]), _409@Mir(bb148[1])
  assert(!move (_410.1: bool), "attempt to compute `{} + {}`, which would overflow", move _405, move _409) -> bb149
  using: _410@Entry, _405@Entry, _409@Entry
bb149:
  _404 = move (_410.0: i32)
  using: _410@Mir(bb148[2])
  _411 = CheckedAdd(_16, _404)
  using: _16@Phi(bb92), _404@Mir(bb149[0])
  assert(!move (_411.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, move _404) -> bb150
  using: _411@Entry, _16@Entry, _404@Entry
bb150:
  _16 = move (_411.0: i32)
  using: _411@Mir(bb149[1])
  _413 = _1
  using: _1@Phi(bb92)
  _414 = _2
  using: _2@Phi(bb92)
  _415 = _12
  using: _12@Mir(bb119[0])
  _416 = _13
  using: _13@Mir(bb145[0])
  _412 = blocksort::fallbackQSort3(move _413, move _414, move _415, move _416) -> bb151
  using: _413@Mir(bb150[1]), _414@Mir(bb150[2]), _415@Mir(bb150[3]), _416@Mir(bb150[4])
bb151:
  _14 = const -1_i32
  using: 
  _417 = _12
  using: _12@Mir(bb119[0])
  _9 = move _417
  using: _417@Mir(bb151[1])
  goto -> bb152
  using: 
bb152:
  _419 = _9
  using: _9@Phi(bb152)
  _420 = _13
  using: _13@Mir(bb145[0])
  _418 = Le(move _419, move _420)
  using: _419@Mir(bb152[0]), _420@Mir(bb152[1])
  switchInt(move _418) -> [0: bb92, otherwise: bb153]
  using: _418@Mir(bb152[2])
bb153:
  _423 = _2
  using: _2@Phi(bb152)
  _427 = _1
  using: _1@Phi(bb152)
  _429 = _9
  using: _9@Phi(bb152)
  _428 = move _429 as isize (IntToInt)
  using: _429@Mir(bb153[2])
  _426 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _427, move _428) -> bb154
  using: _427@Mir(bb153[1]), _428@Mir(bb153[3])
bb154:
  _425 = (*_426)
  using: _426@Mir(bb153[4])
  _424 = move _425 as isize (IntToInt)
  using: _425@Mir(bb154[0])
  _422 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _423, move _424) -> bb155
  using: _423@Mir(bb153[0]), _424@Mir(bb154[1])
bb155:
  _421 = (*_422)
  using: _422@Mir(bb154[2])
  _15 = move _421 as i32 (IntToInt)
  using: _421@Mir(bb155[0])
  _431 = _14
  using: _14@Phi(bb152)
  _432 = _15
  using: _15@Mir(bb155[1])
  _430 = Ne(move _431, move _432)
  using: _431@Mir(bb155[2]), _432@Mir(bb155[3])
  switchInt(move _430) -> [0: bb160, otherwise: bb156]
  using: _430@Mir(bb155[4])
bb156:
  _433 = const 1_u32
  using: 
  _435 = _9
  using: _9@Phi(bb152)
  _436 = const 31_i32
  using: 
  _434 = BitAnd(move _435, move _436)
  using: _435@Mir(bb156[1]), _436@Mir(bb156[2])
  _437 = CheckedShl(_433, _434)
  using: _433@Mir(bb156[0]), _434@Mir(bb156[3])
  assert(!move (_437.1: bool), "attempt to shift left by `{}`, which would overflow", move _434) -> bb157
  using: _437@Entry, _433@Entry, _434@Entry
bb157:
  _439 = _3
  using: _3@Phi(bb152)
  _442 = _9
  using: _9@Phi(bb152)
  _443 = const 5_i32
  using: 
  _444 = CheckedShr(_442, _443)
  using: _442@Mir(bb157[1]), _443@Mir(bb157[2])
  assert(!move (_444.1: bool), "attempt to shift right by `{}`, which would overflow", move _443) -> bb158
  using: _444@Entry, _442@Entry, _443@Entry
bb158:
  _441 = move (_444.0: i32)
  using: _444@Mir(bb157[3])
  _440 = move _441 as isize (IntToInt)
  using: _441@Mir(bb158[0])
  _438 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _439, move _440) -> bb159
  using: _439@Mir(bb157[0]), _440@Mir(bb158[1])
bb159:
  (*_438) = move (_437.0: u32)
  using: _438@Mir(bb158[2]), _437@Mir(bb156[4])
  _445 = _15
  using: _15@Mir(bb155[1])
  _14 = move _445
  using: _445@Mir(bb159[1])
  goto -> bb160
  using: 
bb160:
  _446 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb160)
  assert(!move (_446.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb161
  using: _446@Entry, _9@Entry
bb161:
  _9 = move (_446.0: i32)
  using: _446@Mir(bb160[0])
  goto -> bb152
  using: 
bb162:
  _448 = _5
  using: _5@Phi(bb74)
  _449 = const 4_i32
  using: 
  _447 = Ge(move _448, move _449)
  using: _448@Mir(bb162[0]), _449@Mir(bb162[1])
  switchInt(move _447) -> [0: bb164, otherwise: bb163]
  using: _447@Mir(bb162[2])
bb163:
  _452 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _451 = (*_452)
  using: _452@Mir(bb163[0])
  _456 = const b"%6d unresolved strings\n\x00"
  using: 
  _455 = &raw const (*_456)
  using: _456@Mir(bb163[2])
  _454 = move _455 as *const u8 (Pointer(ArrayToPointer))
  using: _455@Mir(bb163[3])
  _453 = move _454 as *const i8 (PtrToPtr)
  using: _454@Mir(bb163[4])
  _457 = _16
  using: _16@Phi(bb92)
  _450 = blocksort::fprintf(move _451, move _453, move _457) -> bb164
  using: _451@Mir(bb163[1]), _453@Mir(bb163[5]), _457@Mir(bb163[6])
bb164:
  _458 = const 2_i32
  using: 
  _459 = CheckedMul(_8, _458)
  using: _8@Phi(bb77), _458@Mir(bb164[0])
  assert(!move (_459.1: bool), "attempt to compute `{} * {}`, which would overflow", _8, move _458) -> bb165
  using: _459@Entry, _8@Entry, _458@Entry
bb165:
  _8 = move (_459.0: i32)
  using: _459@Mir(bb164[1])
  _462 = _8
  using: _8@Mir(bb165[0])
  _463 = _4
  using: _4@Phi(bb162)
  _461 = Gt(move _462, move _463)
  using: _462@Mir(bb165[1]), _463@Mir(bb165[2])
  switchInt(move _461) -> [0: bb167, otherwise: bb166]
  using: _461@Mir(bb165[3])
bb166:
  _460 = const true
  using: 
  goto -> bb168
  using: 
bb167:
  _465 = _16
  using: _16@Phi(bb164)
  _466 = const 0_i32
  using: 
  _464 = Eq(move _465, move _466)
  using: _465@Mir(bb167[0]), _466@Mir(bb167[1])
  _460 = move _464
  using: _464@Mir(bb167[2])
  goto -> bb168
  using: 
bb168:
  switchInt(move _460) -> [0: bb74, otherwise: bb169]
  using: _460@Phi(bb168)
bb169:
  _468 = _5
  using: _5@Phi(bb74)
  _469 = const 4_i32
  using: 
  _467 = Ge(move _468, move _469)
  using: _468@Mir(bb169[0]), _469@Mir(bb169[1])
  switchInt(move _467) -> [0: bb171, otherwise: bb170]
  using: _467@Mir(bb169[2])
bb170:
  _472 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _471 = (*_472)
  using: _472@Mir(bb170[0])
  _476 = const b"        reconstructing block ...\n\x00"
  using: 
  _475 = &raw const (*_476)
  using: _476@Mir(bb170[2])
  _474 = move _475 as *const u8 (Pointer(ArrayToPointer))
  using: _475@Mir(bb170[3])
  _473 = move _474 as *const i8 (PtrToPtr)
  using: _474@Mir(bb170[4])
  _470 = blocksort::fprintf(move _471, move _473) -> bb171
  using: _471@Mir(bb170[1]), _473@Mir(bb170[5])
bb171:
  _10 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  goto -> bb172
  using: 
bb172:
  _478 = _9
  using: _9@Phi(bb172)
  _479 = _4
  using: _4@Phi(bb162)
  _477 = Lt(move _478, move _479)
  using: _478@Mir(bb172[0]), _479@Mir(bb172[1])
  switchInt(move _477) -> [0: bb183, otherwise: bb173]
  using: _477@Mir(bb172[2])
bb173:
  _483 = _10
  using: _10@Phi(bb173)
  _482 = move _483 as usize (IntToInt)
  using: _483@Mir(bb173[0])
  _484 = const 256_usize
  using: 
  _485 = Lt(_482, _484)
  using: _482@Mir(bb173[1]), _484@Mir(bb173[2])
  assert(move _485, "index out of bounds: the length is {} but the index is {}", move _484, _482) -> bb174
  using: _485@Entry, _484@Entry, _482@Entry
bb174:
  _481 = _7[_482]
  using: _7@Phi(bb173), _482@Mir(bb173[1])
  _486 = const 0_i32
  using: 
  _480 = Eq(move _481, move _486)
  using: _481@Mir(bb174[0]), _486@Mir(bb174[1])
  switchInt(move _480) -> [0: bb177, otherwise: bb175]
  using: _480@Mir(bb174[2])
bb175:
  _487 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb173)
  assert(!move (_487.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb176
  using: _487@Entry, _10@Entry
bb176:
  _10 = move (_487.0: i32)
  using: _487@Mir(bb175[0])
  goto -> bb173
  using: 
bb177:
  _489 = _10
  using: _10@Phi(bb173)
  _488 = move _489 as usize (IntToInt)
  using: _489@Mir(bb177[0])
  _490 = const 256_usize
  using: 
  _491 = Lt(_488, _490)
  using: _488@Mir(bb177[1]), _490@Mir(bb177[2])
  assert(move _491, "index out of bounds: the length is {} but the index is {}", move _490, _488) -> bb178
  using: _491@Entry, _490@Entry, _488@Entry
bb178:
  _492 = CheckedSub(_7[_488], const 1_i32)
  using: _7@Phi(bb173), _488@Mir(bb177[1])
  assert(!move (_492.1: bool), "attempt to compute `{} - {}`, which would overflow", _7[_488], const 1_i32) -> bb179
  using: _492@Entry, _7@Entry, _488@Entry
bb179:
  _7[_488] = move (_492.0: i32)
  using: _488@Mir(bb177[1]), _492@Mir(bb178[0])
  _493 = _10
  using: _10@Phi(bb173)
  _495 = _18
  using: _18@Phi(bb172)
  _499 = _1
  using: _1@Phi(bb172)
  _501 = _9
  using: _9@Phi(bb172)
  _500 = move _501 as isize (IntToInt)
  using: _501@Mir(bb179[4])
  _498 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _499, move _500) -> bb180
  using: _499@Mir(bb179[3]), _500@Mir(bb179[5])
bb180:
  _497 = (*_498)
  using: _498@Mir(bb179[6])
  _496 = move _497 as isize (IntToInt)
  using: _497@Mir(bb180[0])
  _494 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _495, move _496) -> bb181
  using: _495@Mir(bb179[2]), _496@Mir(bb180[1])
bb181:
  (*_494) = move _493 as u8 (IntToInt)
  using: _494@Mir(bb180[2]), _493@Mir(bb179[1])
  _502 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb172)
  assert(!move (_502.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb182
  using: _502@Entry, _9@Entry
bb182:
  _9 = move (_502.0: i32)
  using: _502@Mir(bb181[1])
  goto -> bb172
  using: 
bb183:
  _505 = _10
  using: _10@Phi(bb173)
  _506 = const 256_i32
  using: 
  _504 = Lt(move _505, move _506)
  using: _505@Mir(bb183[0]), _506@Mir(bb183[1])
  _503 = Not(move _504)
  using: _504@Mir(bb183[2])
  switchInt(move _503) -> [0: bb185, otherwise: bb184]
  using: _503@Mir(bb183[3])
bb184:
  _508 = const 1005_i32
  using: 
  _507 = bzlib::BZ2_bz__AssertH__fail(move _508) -> bb185
  using: _508@Mir(bb184[0])
bb185:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 257] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 256] is not supported
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:353:9: 355:49 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:364:23: 364:41 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:379:22: 379:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:382:15: 382:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:388:16: 388:34 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:393:16: 393:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:405:16: 406:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:408:16: 409:67 (#0) by default
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:418:13: 420:56 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:425:23: 425:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:431:24: 431:42 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:431:44: 431:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:434:21: 434:39 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:442:26: 442:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:447:23: 447:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:450:30: 450:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:454:30: 454:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:462:26: 462:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:467:23: 467:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:470:30: 470:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:474:30: 474:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:491:46: 491:64 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:491:33: 491:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:494:32: 494:80 (#0) by default
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:503:13: 505:63 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:516:9: 518:49 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:525:31: 525:49 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:525:18: 525:59 (#0) by default
@DefId(0:27 ~ c2rust_lib[1043]::blocksort::mainGtU)
bb0:
  _7 = const 0_i32
  using: 
  _8 = const 0_u8
  using: 
  _9 = const 0_u8
  using: 
  _10 = const 0_u16
  using: 
  _11 = const 0_u16
  using: 
  _14 = _3
  using: _3@Entry
  _16 = _1
  using: _1@Entry
  _15 = move _16 as isize (IntToInt)
  using: _16@Mir(bb0[6])
  _13 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _14, move _15) -> bb1
  using: _14@Mir(bb0[5]), _15@Mir(bb0[7])
bb1:
  _12 = (*_13)
  using: _13@Mir(bb0[8])
  _8 = move _12
  using: _12@Mir(bb1[0])
  _19 = _3
  using: _3@Entry
  _21 = _2
  using: _2@Entry
  _20 = move _21 as isize (IntToInt)
  using: _21@Mir(bb1[3])
  _18 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _19, move _20) -> bb2
  using: _19@Mir(bb1[2]), _20@Mir(bb1[4])
bb2:
  _17 = (*_18)
  using: _18@Mir(bb1[5])
  _9 = move _17
  using: _17@Mir(bb2[0])
  _24 = _8
  using: _8@Mir(bb1[1])
  _23 = move _24 as i32 (IntToInt)
  using: _24@Mir(bb2[2])
  _26 = _9
  using: _9@Mir(bb2[1])
  _25 = move _26 as i32 (IntToInt)
  using: _26@Mir(bb2[4])
  _22 = Ne(move _23, move _25)
  using: _23@Mir(bb2[3]), _25@Mir(bb2[5])
  switchInt(move _22) -> [0: bb4, otherwise: bb3]
  using: _22@Mir(bb2[6])
bb3:
  _30 = _8
  using: _8@Mir(bb1[1])
  _29 = move _30 as i32 (IntToInt)
  using: _30@Mir(bb3[0])
  _32 = _9
  using: _9@Mir(bb2[1])
  _31 = move _32 as i32 (IntToInt)
  using: _32@Mir(bb3[2])
  _28 = Gt(move _29, move _31)
  using: _29@Mir(bb3[1]), _31@Mir(bb3[3])
  _27 = move _28 as i32 (IntToInt)
  using: _28@Mir(bb3[4])
  _0 = move _27 as u8 (IntToInt)
  using: _27@Mir(bb3[5])
  goto -> bb164
  using: 
bb4:
  _34 = _1
  using: _1@Entry
  _33 = core::num::<impl u32>::wrapping_add(move _34, const 1_u32) -> bb5
  using: _34@Mir(bb4[0])
bb5:
  _1 = move _33
  using: _33@Mir(bb4[1])
  _36 = _2
  using: _2@Entry
  _35 = core::num::<impl u32>::wrapping_add(move _36, const 1_u32) -> bb6
  using: _36@Mir(bb5[1])
bb6:
  _2 = move _35
  using: _35@Mir(bb5[2])
  _39 = _3
  using: _3@Entry
  _41 = _1
  using: _1@Mir(bb5[0])
  _40 = move _41 as isize (IntToInt)
  using: _41@Mir(bb6[2])
  _38 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _39, move _40) -> bb7
  using: _39@Mir(bb6[1]), _40@Mir(bb6[3])
bb7:
  _37 = (*_38)
  using: _38@Mir(bb6[4])
  _8 = move _37
  using: _37@Mir(bb7[0])
  _44 = _3
  using: _3@Entry
  _46 = _2
  using: _2@Mir(bb6[0])
  _45 = move _46 as isize (IntToInt)
  using: _46@Mir(bb7[3])
  _43 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _44, move _45) -> bb8
  using: _44@Mir(bb7[2]), _45@Mir(bb7[4])
bb8:
  _42 = (*_43)
  using: _43@Mir(bb7[5])
  _9 = move _42
  using: _42@Mir(bb8[0])
  _49 = _8
  using: _8@Mir(bb7[1])
  _48 = move _49 as i32 (IntToInt)
  using: _49@Mir(bb8[2])
  _51 = _9
  using: _9@Mir(bb8[1])
  _50 = move _51 as i32 (IntToInt)
  using: _51@Mir(bb8[4])
  _47 = Ne(move _48, move _50)
  using: _48@Mir(bb8[3]), _50@Mir(bb8[5])
  switchInt(move _47) -> [0: bb10, otherwise: bb9]
  using: _47@Mir(bb8[6])
bb9:
  _55 = _8
  using: _8@Mir(bb7[1])
  _54 = move _55 as i32 (IntToInt)
  using: _55@Mir(bb9[0])
  _57 = _9
  using: _9@Mir(bb8[1])
  _56 = move _57 as i32 (IntToInt)
  using: _57@Mir(bb9[2])
  _53 = Gt(move _54, move _56)
  using: _54@Mir(bb9[1]), _56@Mir(bb9[3])
  _52 = move _53 as i32 (IntToInt)
  using: _53@Mir(bb9[4])
  _0 = move _52 as u8 (IntToInt)
  using: _52@Mir(bb9[5])
  goto -> bb164
  using: 
bb10:
  _59 = _1
  using: _1@Mir(bb5[0])
  _58 = core::num::<impl u32>::wrapping_add(move _59, const 1_u32) -> bb11
  using: _59@Mir(bb10[0])
bb11:
  _1 = move _58
  using: _58@Mir(bb10[1])
  _61 = _2
  using: _2@Mir(bb6[0])
  _60 = core::num::<impl u32>::wrapping_add(move _61, const 1_u32) -> bb12
  using: _61@Mir(bb11[1])
bb12:
  _2 = move _60
  using: _60@Mir(bb11[2])
  _64 = _3
  using: _3@Entry
  _66 = _1
  using: _1@Mir(bb11[0])
  _65 = move _66 as isize (IntToInt)
  using: _66@Mir(bb12[2])
  _63 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _64, move _65) -> bb13
  using: _64@Mir(bb12[1]), _65@Mir(bb12[3])
bb13:
  _62 = (*_63)
  using: _63@Mir(bb12[4])
  _8 = move _62
  using: _62@Mir(bb13[0])
  _69 = _3
  using: _3@Entry
  _71 = _2
  using: _2@Mir(bb12[0])
  _70 = move _71 as isize (IntToInt)
  using: _71@Mir(bb13[3])
  _68 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _69, move _70) -> bb14
  using: _69@Mir(bb13[2]), _70@Mir(bb13[4])
bb14:
  _67 = (*_68)
  using: _68@Mir(bb13[5])
  _9 = move _67
  using: _67@Mir(bb14[0])
  _74 = _8
  using: _8@Mir(bb13[1])
  _73 = move _74 as i32 (IntToInt)
  using: _74@Mir(bb14[2])
  _76 = _9
  using: _9@Mir(bb14[1])
  _75 = move _76 as i32 (IntToInt)
  using: _76@Mir(bb14[4])
  _72 = Ne(move _73, move _75)
  using: _73@Mir(bb14[3]), _75@Mir(bb14[5])
  switchInt(move _72) -> [0: bb16, otherwise: bb15]
  using: _72@Mir(bb14[6])
bb15:
  _80 = _8
  using: _8@Mir(bb13[1])
  _79 = move _80 as i32 (IntToInt)
  using: _80@Mir(bb15[0])
  _82 = _9
  using: _9@Mir(bb14[1])
  _81 = move _82 as i32 (IntToInt)
  using: _82@Mir(bb15[2])
  _78 = Gt(move _79, move _81)
  using: _79@Mir(bb15[1]), _81@Mir(bb15[3])
  _77 = move _78 as i32 (IntToInt)
  using: _78@Mir(bb15[4])
  _0 = move _77 as u8 (IntToInt)
  using: _77@Mir(bb15[5])
  goto -> bb164
  using: 
bb16:
  _84 = _1
  using: _1@Mir(bb11[0])
  _83 = core::num::<impl u32>::wrapping_add(move _84, const 1_u32) -> bb17
  using: _84@Mir(bb16[0])
bb17:
  _1 = move _83
  using: _83@Mir(bb16[1])
  _86 = _2
  using: _2@Mir(bb12[0])
  _85 = core::num::<impl u32>::wrapping_add(move _86, const 1_u32) -> bb18
  using: _86@Mir(bb17[1])
bb18:
  _2 = move _85
  using: _85@Mir(bb17[2])
  _89 = _3
  using: _3@Entry
  _91 = _1
  using: _1@Mir(bb17[0])
  _90 = move _91 as isize (IntToInt)
  using: _91@Mir(bb18[2])
  _88 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _89, move _90) -> bb19
  using: _89@Mir(bb18[1]), _90@Mir(bb18[3])
bb19:
  _87 = (*_88)
  using: _88@Mir(bb18[4])
  _8 = move _87
  using: _87@Mir(bb19[0])
  _94 = _3
  using: _3@Entry
  _96 = _2
  using: _2@Mir(bb18[0])
  _95 = move _96 as isize (IntToInt)
  using: _96@Mir(bb19[3])
  _93 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _94, move _95) -> bb20
  using: _94@Mir(bb19[2]), _95@Mir(bb19[4])
bb20:
  _92 = (*_93)
  using: _93@Mir(bb19[5])
  _9 = move _92
  using: _92@Mir(bb20[0])
  _99 = _8
  using: _8@Mir(bb19[1])
  _98 = move _99 as i32 (IntToInt)
  using: _99@Mir(bb20[2])
  _101 = _9
  using: _9@Mir(bb20[1])
  _100 = move _101 as i32 (IntToInt)
  using: _101@Mir(bb20[4])
  _97 = Ne(move _98, move _100)
  using: _98@Mir(bb20[3]), _100@Mir(bb20[5])
  switchInt(move _97) -> [0: bb22, otherwise: bb21]
  using: _97@Mir(bb20[6])
bb21:
  _105 = _8
  using: _8@Mir(bb19[1])
  _104 = move _105 as i32 (IntToInt)
  using: _105@Mir(bb21[0])
  _107 = _9
  using: _9@Mir(bb20[1])
  _106 = move _107 as i32 (IntToInt)
  using: _107@Mir(bb21[2])
  _103 = Gt(move _104, move _106)
  using: _104@Mir(bb21[1]), _106@Mir(bb21[3])
  _102 = move _103 as i32 (IntToInt)
  using: _103@Mir(bb21[4])
  _0 = move _102 as u8 (IntToInt)
  using: _102@Mir(bb21[5])
  goto -> bb164
  using: 
bb22:
  _109 = _1
  using: _1@Mir(bb17[0])
  _108 = core::num::<impl u32>::wrapping_add(move _109, const 1_u32) -> bb23
  using: _109@Mir(bb22[0])
bb23:
  _1 = move _108
  using: _108@Mir(bb22[1])
  _111 = _2
  using: _2@Mir(bb18[0])
  _110 = core::num::<impl u32>::wrapping_add(move _111, const 1_u32) -> bb24
  using: _111@Mir(bb23[1])
bb24:
  _2 = move _110
  using: _110@Mir(bb23[2])
  _114 = _3
  using: _3@Entry
  _116 = _1
  using: _1@Mir(bb23[0])
  _115 = move _116 as isize (IntToInt)
  using: _116@Mir(bb24[2])
  _113 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _114, move _115) -> bb25
  using: _114@Mir(bb24[1]), _115@Mir(bb24[3])
bb25:
  _112 = (*_113)
  using: _113@Mir(bb24[4])
  _8 = move _112
  using: _112@Mir(bb25[0])
  _119 = _3
  using: _3@Entry
  _121 = _2
  using: _2@Mir(bb24[0])
  _120 = move _121 as isize (IntToInt)
  using: _121@Mir(bb25[3])
  _118 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _119, move _120) -> bb26
  using: _119@Mir(bb25[2]), _120@Mir(bb25[4])
bb26:
  _117 = (*_118)
  using: _118@Mir(bb25[5])
  _9 = move _117
  using: _117@Mir(bb26[0])
  _124 = _8
  using: _8@Mir(bb25[1])
  _123 = move _124 as i32 (IntToInt)
  using: _124@Mir(bb26[2])
  _126 = _9
  using: _9@Mir(bb26[1])
  _125 = move _126 as i32 (IntToInt)
  using: _126@Mir(bb26[4])
  _122 = Ne(move _123, move _125)
  using: _123@Mir(bb26[3]), _125@Mir(bb26[5])
  switchInt(move _122) -> [0: bb28, otherwise: bb27]
  using: _122@Mir(bb26[6])
bb27:
  _130 = _8
  using: _8@Mir(bb25[1])
  _129 = move _130 as i32 (IntToInt)
  using: _130@Mir(bb27[0])
  _132 = _9
  using: _9@Mir(bb26[1])
  _131 = move _132 as i32 (IntToInt)
  using: _132@Mir(bb27[2])
  _128 = Gt(move _129, move _131)
  using: _129@Mir(bb27[1]), _131@Mir(bb27[3])
  _127 = move _128 as i32 (IntToInt)
  using: _128@Mir(bb27[4])
  _0 = move _127 as u8 (IntToInt)
  using: _127@Mir(bb27[5])
  goto -> bb164
  using: 
bb28:
  _134 = _1
  using: _1@Mir(bb23[0])
  _133 = core::num::<impl u32>::wrapping_add(move _134, const 1_u32) -> bb29
  using: _134@Mir(bb28[0])
bb29:
  _1 = move _133
  using: _133@Mir(bb28[1])
  _136 = _2
  using: _2@Mir(bb24[0])
  _135 = core::num::<impl u32>::wrapping_add(move _136, const 1_u32) -> bb30
  using: _136@Mir(bb29[1])
bb30:
  _2 = move _135
  using: _135@Mir(bb29[2])
  _139 = _3
  using: _3@Entry
  _141 = _1
  using: _1@Mir(bb29[0])
  _140 = move _141 as isize (IntToInt)
  using: _141@Mir(bb30[2])
  _138 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _139, move _140) -> bb31
  using: _139@Mir(bb30[1]), _140@Mir(bb30[3])
bb31:
  _137 = (*_138)
  using: _138@Mir(bb30[4])
  _8 = move _137
  using: _137@Mir(bb31[0])
  _144 = _3
  using: _3@Entry
  _146 = _2
  using: _2@Mir(bb30[0])
  _145 = move _146 as isize (IntToInt)
  using: _146@Mir(bb31[3])
  _143 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _144, move _145) -> bb32
  using: _144@Mir(bb31[2]), _145@Mir(bb31[4])
bb32:
  _142 = (*_143)
  using: _143@Mir(bb31[5])
  _9 = move _142
  using: _142@Mir(bb32[0])
  _149 = _8
  using: _8@Mir(bb31[1])
  _148 = move _149 as i32 (IntToInt)
  using: _149@Mir(bb32[2])
  _151 = _9
  using: _9@Mir(bb32[1])
  _150 = move _151 as i32 (IntToInt)
  using: _151@Mir(bb32[4])
  _147 = Ne(move _148, move _150)
  using: _148@Mir(bb32[3]), _150@Mir(bb32[5])
  switchInt(move _147) -> [0: bb34, otherwise: bb33]
  using: _147@Mir(bb32[6])
bb33:
  _155 = _8
  using: _8@Mir(bb31[1])
  _154 = move _155 as i32 (IntToInt)
  using: _155@Mir(bb33[0])
  _157 = _9
  using: _9@Mir(bb32[1])
  _156 = move _157 as i32 (IntToInt)
  using: _157@Mir(bb33[2])
  _153 = Gt(move _154, move _156)
  using: _154@Mir(bb33[1]), _156@Mir(bb33[3])
  _152 = move _153 as i32 (IntToInt)
  using: _153@Mir(bb33[4])
  _0 = move _152 as u8 (IntToInt)
  using: _152@Mir(bb33[5])
  goto -> bb164
  using: 
bb34:
  _159 = _1
  using: _1@Mir(bb29[0])
  _158 = core::num::<impl u32>::wrapping_add(move _159, const 1_u32) -> bb35
  using: _159@Mir(bb34[0])
bb35:
  _1 = move _158
  using: _158@Mir(bb34[1])
  _161 = _2
  using: _2@Mir(bb30[0])
  _160 = core::num::<impl u32>::wrapping_add(move _161, const 1_u32) -> bb36
  using: _161@Mir(bb35[1])
bb36:
  _2 = move _160
  using: _160@Mir(bb35[2])
  _164 = _3
  using: _3@Entry
  _166 = _1
  using: _1@Mir(bb35[0])
  _165 = move _166 as isize (IntToInt)
  using: _166@Mir(bb36[2])
  _163 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _164, move _165) -> bb37
  using: _164@Mir(bb36[1]), _165@Mir(bb36[3])
bb37:
  _162 = (*_163)
  using: _163@Mir(bb36[4])
  _8 = move _162
  using: _162@Mir(bb37[0])
  _169 = _3
  using: _3@Entry
  _171 = _2
  using: _2@Mir(bb36[0])
  _170 = move _171 as isize (IntToInt)
  using: _171@Mir(bb37[3])
  _168 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _169, move _170) -> bb38
  using: _169@Mir(bb37[2]), _170@Mir(bb37[4])
bb38:
  _167 = (*_168)
  using: _168@Mir(bb37[5])
  _9 = move _167
  using: _167@Mir(bb38[0])
  _174 = _8
  using: _8@Mir(bb37[1])
  _173 = move _174 as i32 (IntToInt)
  using: _174@Mir(bb38[2])
  _176 = _9
  using: _9@Mir(bb38[1])
  _175 = move _176 as i32 (IntToInt)
  using: _176@Mir(bb38[4])
  _172 = Ne(move _173, move _175)
  using: _173@Mir(bb38[3]), _175@Mir(bb38[5])
  switchInt(move _172) -> [0: bb40, otherwise: bb39]
  using: _172@Mir(bb38[6])
bb39:
  _180 = _8
  using: _8@Mir(bb37[1])
  _179 = move _180 as i32 (IntToInt)
  using: _180@Mir(bb39[0])
  _182 = _9
  using: _9@Mir(bb38[1])
  _181 = move _182 as i32 (IntToInt)
  using: _182@Mir(bb39[2])
  _178 = Gt(move _179, move _181)
  using: _179@Mir(bb39[1]), _181@Mir(bb39[3])
  _177 = move _178 as i32 (IntToInt)
  using: _178@Mir(bb39[4])
  _0 = move _177 as u8 (IntToInt)
  using: _177@Mir(bb39[5])
  goto -> bb164
  using: 
bb40:
  _184 = _1
  using: _1@Mir(bb35[0])
  _183 = core::num::<impl u32>::wrapping_add(move _184, const 1_u32) -> bb41
  using: _184@Mir(bb40[0])
bb41:
  _1 = move _183
  using: _183@Mir(bb40[1])
  _186 = _2
  using: _2@Mir(bb36[0])
  _185 = core::num::<impl u32>::wrapping_add(move _186, const 1_u32) -> bb42
  using: _186@Mir(bb41[1])
bb42:
  _2 = move _185
  using: _185@Mir(bb41[2])
  _189 = _3
  using: _3@Entry
  _191 = _1
  using: _1@Mir(bb41[0])
  _190 = move _191 as isize (IntToInt)
  using: _191@Mir(bb42[2])
  _188 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _189, move _190) -> bb43
  using: _189@Mir(bb42[1]), _190@Mir(bb42[3])
bb43:
  _187 = (*_188)
  using: _188@Mir(bb42[4])
  _8 = move _187
  using: _187@Mir(bb43[0])
  _194 = _3
  using: _3@Entry
  _196 = _2
  using: _2@Mir(bb42[0])
  _195 = move _196 as isize (IntToInt)
  using: _196@Mir(bb43[3])
  _193 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _194, move _195) -> bb44
  using: _194@Mir(bb43[2]), _195@Mir(bb43[4])
bb44:
  _192 = (*_193)
  using: _193@Mir(bb43[5])
  _9 = move _192
  using: _192@Mir(bb44[0])
  _199 = _8
  using: _8@Mir(bb43[1])
  _198 = move _199 as i32 (IntToInt)
  using: _199@Mir(bb44[2])
  _201 = _9
  using: _9@Mir(bb44[1])
  _200 = move _201 as i32 (IntToInt)
  using: _201@Mir(bb44[4])
  _197 = Ne(move _198, move _200)
  using: _198@Mir(bb44[3]), _200@Mir(bb44[5])
  switchInt(move _197) -> [0: bb46, otherwise: bb45]
  using: _197@Mir(bb44[6])
bb45:
  _205 = _8
  using: _8@Mir(bb43[1])
  _204 = move _205 as i32 (IntToInt)
  using: _205@Mir(bb45[0])
  _207 = _9
  using: _9@Mir(bb44[1])
  _206 = move _207 as i32 (IntToInt)
  using: _207@Mir(bb45[2])
  _203 = Gt(move _204, move _206)
  using: _204@Mir(bb45[1]), _206@Mir(bb45[3])
  _202 = move _203 as i32 (IntToInt)
  using: _203@Mir(bb45[4])
  _0 = move _202 as u8 (IntToInt)
  using: _202@Mir(bb45[5])
  goto -> bb164
  using: 
bb46:
  _209 = _1
  using: _1@Mir(bb41[0])
  _208 = core::num::<impl u32>::wrapping_add(move _209, const 1_u32) -> bb47
  using: _209@Mir(bb46[0])
bb47:
  _1 = move _208
  using: _208@Mir(bb46[1])
  _211 = _2
  using: _2@Mir(bb42[0])
  _210 = core::num::<impl u32>::wrapping_add(move _211, const 1_u32) -> bb48
  using: _211@Mir(bb47[1])
bb48:
  _2 = move _210
  using: _210@Mir(bb47[2])
  _214 = _3
  using: _3@Entry
  _216 = _1
  using: _1@Mir(bb47[0])
  _215 = move _216 as isize (IntToInt)
  using: _216@Mir(bb48[2])
  _213 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _214, move _215) -> bb49
  using: _214@Mir(bb48[1]), _215@Mir(bb48[3])
bb49:
  _212 = (*_213)
  using: _213@Mir(bb48[4])
  _8 = move _212
  using: _212@Mir(bb49[0])
  _219 = _3
  using: _3@Entry
  _221 = _2
  using: _2@Mir(bb48[0])
  _220 = move _221 as isize (IntToInt)
  using: _221@Mir(bb49[3])
  _218 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _219, move _220) -> bb50
  using: _219@Mir(bb49[2]), _220@Mir(bb49[4])
bb50:
  _217 = (*_218)
  using: _218@Mir(bb49[5])
  _9 = move _217
  using: _217@Mir(bb50[0])
  _224 = _8
  using: _8@Mir(bb49[1])
  _223 = move _224 as i32 (IntToInt)
  using: _224@Mir(bb50[2])
  _226 = _9
  using: _9@Mir(bb50[1])
  _225 = move _226 as i32 (IntToInt)
  using: _226@Mir(bb50[4])
  _222 = Ne(move _223, move _225)
  using: _223@Mir(bb50[3]), _225@Mir(bb50[5])
  switchInt(move _222) -> [0: bb52, otherwise: bb51]
  using: _222@Mir(bb50[6])
bb51:
  _230 = _8
  using: _8@Mir(bb49[1])
  _229 = move _230 as i32 (IntToInt)
  using: _230@Mir(bb51[0])
  _232 = _9
  using: _9@Mir(bb50[1])
  _231 = move _232 as i32 (IntToInt)
  using: _232@Mir(bb51[2])
  _228 = Gt(move _229, move _231)
  using: _229@Mir(bb51[1]), _231@Mir(bb51[3])
  _227 = move _228 as i32 (IntToInt)
  using: _228@Mir(bb51[4])
  _0 = move _227 as u8 (IntToInt)
  using: _227@Mir(bb51[5])
  goto -> bb164
  using: 
bb52:
  _234 = _1
  using: _1@Mir(bb47[0])
  _233 = core::num::<impl u32>::wrapping_add(move _234, const 1_u32) -> bb53
  using: _234@Mir(bb52[0])
bb53:
  _1 = move _233
  using: _233@Mir(bb52[1])
  _236 = _2
  using: _2@Mir(bb48[0])
  _235 = core::num::<impl u32>::wrapping_add(move _236, const 1_u32) -> bb54
  using: _236@Mir(bb53[1])
bb54:
  _2 = move _235
  using: _235@Mir(bb53[2])
  _239 = _3
  using: _3@Entry
  _241 = _1
  using: _1@Mir(bb53[0])
  _240 = move _241 as isize (IntToInt)
  using: _241@Mir(bb54[2])
  _238 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _239, move _240) -> bb55
  using: _239@Mir(bb54[1]), _240@Mir(bb54[3])
bb55:
  _237 = (*_238)
  using: _238@Mir(bb54[4])
  _8 = move _237
  using: _237@Mir(bb55[0])
  _244 = _3
  using: _3@Entry
  _246 = _2
  using: _2@Mir(bb54[0])
  _245 = move _246 as isize (IntToInt)
  using: _246@Mir(bb55[3])
  _243 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _244, move _245) -> bb56
  using: _244@Mir(bb55[2]), _245@Mir(bb55[4])
bb56:
  _242 = (*_243)
  using: _243@Mir(bb55[5])
  _9 = move _242
  using: _242@Mir(bb56[0])
  _249 = _8
  using: _8@Mir(bb55[1])
  _248 = move _249 as i32 (IntToInt)
  using: _249@Mir(bb56[2])
  _251 = _9
  using: _9@Mir(bb56[1])
  _250 = move _251 as i32 (IntToInt)
  using: _251@Mir(bb56[4])
  _247 = Ne(move _248, move _250)
  using: _248@Mir(bb56[3]), _250@Mir(bb56[5])
  switchInt(move _247) -> [0: bb58, otherwise: bb57]
  using: _247@Mir(bb56[6])
bb57:
  _255 = _8
  using: _8@Mir(bb55[1])
  _254 = move _255 as i32 (IntToInt)
  using: _255@Mir(bb57[0])
  _257 = _9
  using: _9@Mir(bb56[1])
  _256 = move _257 as i32 (IntToInt)
  using: _257@Mir(bb57[2])
  _253 = Gt(move _254, move _256)
  using: _254@Mir(bb57[1]), _256@Mir(bb57[3])
  _252 = move _253 as i32 (IntToInt)
  using: _253@Mir(bb57[4])
  _0 = move _252 as u8 (IntToInt)
  using: _252@Mir(bb57[5])
  goto -> bb164
  using: 
bb58:
  _259 = _1
  using: _1@Mir(bb53[0])
  _258 = core::num::<impl u32>::wrapping_add(move _259, const 1_u32) -> bb59
  using: _259@Mir(bb58[0])
bb59:
  _1 = move _258
  using: _258@Mir(bb58[1])
  _261 = _2
  using: _2@Mir(bb54[0])
  _260 = core::num::<impl u32>::wrapping_add(move _261, const 1_u32) -> bb60
  using: _261@Mir(bb59[1])
bb60:
  _2 = move _260
  using: _260@Mir(bb59[2])
  _264 = _3
  using: _3@Entry
  _266 = _1
  using: _1@Mir(bb59[0])
  _265 = move _266 as isize (IntToInt)
  using: _266@Mir(bb60[2])
  _263 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _264, move _265) -> bb61
  using: _264@Mir(bb60[1]), _265@Mir(bb60[3])
bb61:
  _262 = (*_263)
  using: _263@Mir(bb60[4])
  _8 = move _262
  using: _262@Mir(bb61[0])
  _269 = _3
  using: _3@Entry
  _271 = _2
  using: _2@Mir(bb60[0])
  _270 = move _271 as isize (IntToInt)
  using: _271@Mir(bb61[3])
  _268 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _269, move _270) -> bb62
  using: _269@Mir(bb61[2]), _270@Mir(bb61[4])
bb62:
  _267 = (*_268)
  using: _268@Mir(bb61[5])
  _9 = move _267
  using: _267@Mir(bb62[0])
  _274 = _8
  using: _8@Mir(bb61[1])
  _273 = move _274 as i32 (IntToInt)
  using: _274@Mir(bb62[2])
  _276 = _9
  using: _9@Mir(bb62[1])
  _275 = move _276 as i32 (IntToInt)
  using: _276@Mir(bb62[4])
  _272 = Ne(move _273, move _275)
  using: _273@Mir(bb62[3]), _275@Mir(bb62[5])
  switchInt(move _272) -> [0: bb64, otherwise: bb63]
  using: _272@Mir(bb62[6])
bb63:
  _280 = _8
  using: _8@Mir(bb61[1])
  _279 = move _280 as i32 (IntToInt)
  using: _280@Mir(bb63[0])
  _282 = _9
  using: _9@Mir(bb62[1])
  _281 = move _282 as i32 (IntToInt)
  using: _282@Mir(bb63[2])
  _278 = Gt(move _279, move _281)
  using: _279@Mir(bb63[1]), _281@Mir(bb63[3])
  _277 = move _278 as i32 (IntToInt)
  using: _278@Mir(bb63[4])
  _0 = move _277 as u8 (IntToInt)
  using: _277@Mir(bb63[5])
  goto -> bb164
  using: 
bb64:
  _284 = _1
  using: _1@Mir(bb59[0])
  _283 = core::num::<impl u32>::wrapping_add(move _284, const 1_u32) -> bb65
  using: _284@Mir(bb64[0])
bb65:
  _1 = move _283
  using: _283@Mir(bb64[1])
  _286 = _2
  using: _2@Mir(bb60[0])
  _285 = core::num::<impl u32>::wrapping_add(move _286, const 1_u32) -> bb66
  using: _286@Mir(bb65[1])
bb66:
  _2 = move _285
  using: _285@Mir(bb65[2])
  _289 = _3
  using: _3@Entry
  _291 = _1
  using: _1@Mir(bb65[0])
  _290 = move _291 as isize (IntToInt)
  using: _291@Mir(bb66[2])
  _288 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _289, move _290) -> bb67
  using: _289@Mir(bb66[1]), _290@Mir(bb66[3])
bb67:
  _287 = (*_288)
  using: _288@Mir(bb66[4])
  _8 = move _287
  using: _287@Mir(bb67[0])
  _294 = _3
  using: _3@Entry
  _296 = _2
  using: _2@Mir(bb66[0])
  _295 = move _296 as isize (IntToInt)
  using: _296@Mir(bb67[3])
  _293 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _294, move _295) -> bb68
  using: _294@Mir(bb67[2]), _295@Mir(bb67[4])
bb68:
  _292 = (*_293)
  using: _293@Mir(bb67[5])
  _9 = move _292
  using: _292@Mir(bb68[0])
  _299 = _8
  using: _8@Mir(bb67[1])
  _298 = move _299 as i32 (IntToInt)
  using: _299@Mir(bb68[2])
  _301 = _9
  using: _9@Mir(bb68[1])
  _300 = move _301 as i32 (IntToInt)
  using: _301@Mir(bb68[4])
  _297 = Ne(move _298, move _300)
  using: _298@Mir(bb68[3]), _300@Mir(bb68[5])
  switchInt(move _297) -> [0: bb70, otherwise: bb69]
  using: _297@Mir(bb68[6])
bb69:
  _305 = _8
  using: _8@Mir(bb67[1])
  _304 = move _305 as i32 (IntToInt)
  using: _305@Mir(bb69[0])
  _307 = _9
  using: _9@Mir(bb68[1])
  _306 = move _307 as i32 (IntToInt)
  using: _307@Mir(bb69[2])
  _303 = Gt(move _304, move _306)
  using: _304@Mir(bb69[1]), _306@Mir(bb69[3])
  _302 = move _303 as i32 (IntToInt)
  using: _303@Mir(bb69[4])
  _0 = move _302 as u8 (IntToInt)
  using: _302@Mir(bb69[5])
  goto -> bb164
  using: 
bb70:
  _309 = _1
  using: _1@Mir(bb65[0])
  _308 = core::num::<impl u32>::wrapping_add(move _309, const 1_u32) -> bb71
  using: _309@Mir(bb70[0])
bb71:
  _1 = move _308
  using: _308@Mir(bb70[1])
  _311 = _2
  using: _2@Mir(bb66[0])
  _310 = core::num::<impl u32>::wrapping_add(move _311, const 1_u32) -> bb72
  using: _311@Mir(bb71[1])
bb72:
  _2 = move _310
  using: _310@Mir(bb71[2])
  _313 = _5
  using: _5@Entry
  _314 = const 8_u32
  using: 
  _312 = core::num::<impl u32>::wrapping_add(move _313, move _314) -> bb73
  using: _313@Mir(bb72[1]), _314@Mir(bb72[2])
bb73:
  _7 = move _312 as i32 (IntToInt)
  using: _312@Mir(bb72[3])
  goto -> bb74
  using: 
bb74:
  _317 = _3
  using: _3@Phi(bb74)
  _319 = _1
  using: _1@Phi(bb74)
  _318 = move _319 as isize (IntToInt)
  using: _319@Mir(bb74[1])
  _316 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _317, move _318) -> bb75
  using: _317@Mir(bb74[0]), _318@Mir(bb74[2])
bb75:
  _315 = (*_316)
  using: _316@Mir(bb74[3])
  _8 = move _315
  using: _315@Mir(bb75[0])
  _322 = _3
  using: _3@Phi(bb74)
  _324 = _2
  using: _2@Phi(bb74)
  _323 = move _324 as isize (IntToInt)
  using: _324@Mir(bb75[3])
  _321 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _322, move _323) -> bb76
  using: _322@Mir(bb75[2]), _323@Mir(bb75[4])
bb76:
  _320 = (*_321)
  using: _321@Mir(bb75[5])
  _9 = move _320
  using: _320@Mir(bb76[0])
  _327 = _8
  using: _8@Mir(bb75[1])
  _326 = move _327 as i32 (IntToInt)
  using: _327@Mir(bb76[2])
  _329 = _9
  using: _9@Mir(bb76[1])
  _328 = move _329 as i32 (IntToInt)
  using: _329@Mir(bb76[4])
  _325 = Ne(move _326, move _328)
  using: _326@Mir(bb76[3]), _328@Mir(bb76[5])
  switchInt(move _325) -> [0: bb78, otherwise: bb77]
  using: _325@Mir(bb76[6])
bb77:
  _333 = _8
  using: _8@Mir(bb75[1])
  _332 = move _333 as i32 (IntToInt)
  using: _333@Mir(bb77[0])
  _335 = _9
  using: _9@Mir(bb76[1])
  _334 = move _335 as i32 (IntToInt)
  using: _335@Mir(bb77[2])
  _331 = Gt(move _332, move _334)
  using: _332@Mir(bb77[1]), _334@Mir(bb77[3])
  _330 = move _331 as i32 (IntToInt)
  using: _331@Mir(bb77[4])
  _0 = move _330 as u8 (IntToInt)
  using: _330@Mir(bb77[5])
  goto -> bb164
  using: 
bb78:
  _338 = _4
  using: _4@Phi(bb74)
  _340 = _1
  using: _1@Phi(bb74)
  _339 = move _340 as isize (IntToInt)
  using: _340@Mir(bb78[1])
  _337 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _338, move _339) -> bb79
  using: _338@Mir(bb78[0]), _339@Mir(bb78[2])
bb79:
  _336 = (*_337)
  using: _337@Mir(bb78[3])
  _10 = move _336
  using: _336@Mir(bb79[0])
  _343 = _4
  using: _4@Phi(bb74)
  _345 = _2
  using: _2@Phi(bb74)
  _344 = move _345 as isize (IntToInt)
  using: _345@Mir(bb79[3])
  _342 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _343, move _344) -> bb80
  using: _343@Mir(bb79[2]), _344@Mir(bb79[4])
bb80:
  _341 = (*_342)
  using: _342@Mir(bb79[5])
  _11 = move _341
  using: _341@Mir(bb80[0])
  _348 = _10
  using: _10@Mir(bb79[1])
  _347 = move _348 as i32 (IntToInt)
  using: _348@Mir(bb80[2])
  _350 = _11
  using: _11@Mir(bb80[1])
  _349 = move _350 as i32 (IntToInt)
  using: _350@Mir(bb80[4])
  _346 = Ne(move _347, move _349)
  using: _347@Mir(bb80[3]), _349@Mir(bb80[5])
  switchInt(move _346) -> [0: bb82, otherwise: bb81]
  using: _346@Mir(bb80[6])
bb81:
  _354 = _10
  using: _10@Mir(bb79[1])
  _353 = move _354 as i32 (IntToInt)
  using: _354@Mir(bb81[0])
  _356 = _11
  using: _11@Mir(bb80[1])
  _355 = move _356 as i32 (IntToInt)
  using: _356@Mir(bb81[2])
  _352 = Gt(move _353, move _355)
  using: _353@Mir(bb81[1]), _355@Mir(bb81[3])
  _351 = move _352 as i32 (IntToInt)
  using: _352@Mir(bb81[4])
  _0 = move _351 as u8 (IntToInt)
  using: _351@Mir(bb81[5])
  goto -> bb164
  using: 
bb82:
  _358 = _1
  using: _1@Phi(bb74)
  _357 = core::num::<impl u32>::wrapping_add(move _358, const 1_u32) -> bb83
  using: _358@Mir(bb82[0])
bb83:
  _1 = move _357
  using: _357@Mir(bb82[1])
  _360 = _2
  using: _2@Phi(bb74)
  _359 = core::num::<impl u32>::wrapping_add(move _360, const 1_u32) -> bb84
  using: _360@Mir(bb83[1])
bb84:
  _2 = move _359
  using: _359@Mir(bb83[2])
  _363 = _3
  using: _3@Phi(bb74)
  _365 = _1
  using: _1@Mir(bb83[0])
  _364 = move _365 as isize (IntToInt)
  using: _365@Mir(bb84[2])
  _362 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _363, move _364) -> bb85
  using: _363@Mir(bb84[1]), _364@Mir(bb84[3])
bb85:
  _361 = (*_362)
  using: _362@Mir(bb84[4])
  _8 = move _361
  using: _361@Mir(bb85[0])
  _368 = _3
  using: _3@Phi(bb74)
  _370 = _2
  using: _2@Mir(bb84[0])
  _369 = move _370 as isize (IntToInt)
  using: _370@Mir(bb85[3])
  _367 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _368, move _369) -> bb86
  using: _368@Mir(bb85[2]), _369@Mir(bb85[4])
bb86:
  _366 = (*_367)
  using: _367@Mir(bb85[5])
  _9 = move _366
  using: _366@Mir(bb86[0])
  _373 = _8
  using: _8@Mir(bb85[1])
  _372 = move _373 as i32 (IntToInt)
  using: _373@Mir(bb86[2])
  _375 = _9
  using: _9@Mir(bb86[1])
  _374 = move _375 as i32 (IntToInt)
  using: _375@Mir(bb86[4])
  _371 = Ne(move _372, move _374)
  using: _372@Mir(bb86[3]), _374@Mir(bb86[5])
  switchInt(move _371) -> [0: bb88, otherwise: bb87]
  using: _371@Mir(bb86[6])
bb87:
  _379 = _8
  using: _8@Mir(bb85[1])
  _378 = move _379 as i32 (IntToInt)
  using: _379@Mir(bb87[0])
  _381 = _9
  using: _9@Mir(bb86[1])
  _380 = move _381 as i32 (IntToInt)
  using: _381@Mir(bb87[2])
  _377 = Gt(move _378, move _380)
  using: _378@Mir(bb87[1]), _380@Mir(bb87[3])
  _376 = move _377 as i32 (IntToInt)
  using: _377@Mir(bb87[4])
  _0 = move _376 as u8 (IntToInt)
  using: _376@Mir(bb87[5])
  goto -> bb164
  using: 
bb88:
  _384 = _4
  using: _4@Phi(bb74)
  _386 = _1
  using: _1@Mir(bb83[0])
  _385 = move _386 as isize (IntToInt)
  using: _386@Mir(bb88[1])
  _383 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _384, move _385) -> bb89
  using: _384@Mir(bb88[0]), _385@Mir(bb88[2])
bb89:
  _382 = (*_383)
  using: _383@Mir(bb88[3])
  _10 = move _382
  using: _382@Mir(bb89[0])
  _389 = _4
  using: _4@Phi(bb74)
  _391 = _2
  using: _2@Mir(bb84[0])
  _390 = move _391 as isize (IntToInt)
  using: _391@Mir(bb89[3])
  _388 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _389, move _390) -> bb90
  using: _389@Mir(bb89[2]), _390@Mir(bb89[4])
bb90:
  _387 = (*_388)
  using: _388@Mir(bb89[5])
  _11 = move _387
  using: _387@Mir(bb90[0])
  _394 = _10
  using: _10@Mir(bb89[1])
  _393 = move _394 as i32 (IntToInt)
  using: _394@Mir(bb90[2])
  _396 = _11
  using: _11@Mir(bb90[1])
  _395 = move _396 as i32 (IntToInt)
  using: _396@Mir(bb90[4])
  _392 = Ne(move _393, move _395)
  using: _393@Mir(bb90[3]), _395@Mir(bb90[5])
  switchInt(move _392) -> [0: bb92, otherwise: bb91]
  using: _392@Mir(bb90[6])
bb91:
  _400 = _10
  using: _10@Mir(bb89[1])
  _399 = move _400 as i32 (IntToInt)
  using: _400@Mir(bb91[0])
  _402 = _11
  using: _11@Mir(bb90[1])
  _401 = move _402 as i32 (IntToInt)
  using: _402@Mir(bb91[2])
  _398 = Gt(move _399, move _401)
  using: _399@Mir(bb91[1]), _401@Mir(bb91[3])
  _397 = move _398 as i32 (IntToInt)
  using: _398@Mir(bb91[4])
  _0 = move _397 as u8 (IntToInt)
  using: _397@Mir(bb91[5])
  goto -> bb164
  using: 
bb92:
  _404 = _1
  using: _1@Mir(bb83[0])
  _403 = core::num::<impl u32>::wrapping_add(move _404, const 1_u32) -> bb93
  using: _404@Mir(bb92[0])
bb93:
  _1 = move _403
  using: _403@Mir(bb92[1])
  _406 = _2
  using: _2@Mir(bb84[0])
  _405 = core::num::<impl u32>::wrapping_add(move _406, const 1_u32) -> bb94
  using: _406@Mir(bb93[1])
bb94:
  _2 = move _405
  using: _405@Mir(bb93[2])
  _409 = _3
  using: _3@Phi(bb74)
  _411 = _1
  using: _1@Mir(bb93[0])
  _410 = move _411 as isize (IntToInt)
  using: _411@Mir(bb94[2])
  _408 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _409, move _410) -> bb95
  using: _409@Mir(bb94[1]), _410@Mir(bb94[3])
bb95:
  _407 = (*_408)
  using: _408@Mir(bb94[4])
  _8 = move _407
  using: _407@Mir(bb95[0])
  _414 = _3
  using: _3@Phi(bb74)
  _416 = _2
  using: _2@Mir(bb94[0])
  _415 = move _416 as isize (IntToInt)
  using: _416@Mir(bb95[3])
  _413 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _414, move _415) -> bb96
  using: _414@Mir(bb95[2]), _415@Mir(bb95[4])
bb96:
  _412 = (*_413)
  using: _413@Mir(bb95[5])
  _9 = move _412
  using: _412@Mir(bb96[0])
  _419 = _8
  using: _8@Mir(bb95[1])
  _418 = move _419 as i32 (IntToInt)
  using: _419@Mir(bb96[2])
  _421 = _9
  using: _9@Mir(bb96[1])
  _420 = move _421 as i32 (IntToInt)
  using: _421@Mir(bb96[4])
  _417 = Ne(move _418, move _420)
  using: _418@Mir(bb96[3]), _420@Mir(bb96[5])
  switchInt(move _417) -> [0: bb98, otherwise: bb97]
  using: _417@Mir(bb96[6])
bb97:
  _425 = _8
  using: _8@Mir(bb95[1])
  _424 = move _425 as i32 (IntToInt)
  using: _425@Mir(bb97[0])
  _427 = _9
  using: _9@Mir(bb96[1])
  _426 = move _427 as i32 (IntToInt)
  using: _427@Mir(bb97[2])
  _423 = Gt(move _424, move _426)
  using: _424@Mir(bb97[1]), _426@Mir(bb97[3])
  _422 = move _423 as i32 (IntToInt)
  using: _423@Mir(bb97[4])
  _0 = move _422 as u8 (IntToInt)
  using: _422@Mir(bb97[5])
  goto -> bb164
  using: 
bb98:
  _430 = _4
  using: _4@Phi(bb74)
  _432 = _1
  using: _1@Mir(bb93[0])
  _431 = move _432 as isize (IntToInt)
  using: _432@Mir(bb98[1])
  _429 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _430, move _431) -> bb99
  using: _430@Mir(bb98[0]), _431@Mir(bb98[2])
bb99:
  _428 = (*_429)
  using: _429@Mir(bb98[3])
  _10 = move _428
  using: _428@Mir(bb99[0])
  _435 = _4
  using: _4@Phi(bb74)
  _437 = _2
  using: _2@Mir(bb94[0])
  _436 = move _437 as isize (IntToInt)
  using: _437@Mir(bb99[3])
  _434 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _435, move _436) -> bb100
  using: _435@Mir(bb99[2]), _436@Mir(bb99[4])
bb100:
  _433 = (*_434)
  using: _434@Mir(bb99[5])
  _11 = move _433
  using: _433@Mir(bb100[0])
  _440 = _10
  using: _10@Mir(bb99[1])
  _439 = move _440 as i32 (IntToInt)
  using: _440@Mir(bb100[2])
  _442 = _11
  using: _11@Mir(bb100[1])
  _441 = move _442 as i32 (IntToInt)
  using: _442@Mir(bb100[4])
  _438 = Ne(move _439, move _441)
  using: _439@Mir(bb100[3]), _441@Mir(bb100[5])
  switchInt(move _438) -> [0: bb102, otherwise: bb101]
  using: _438@Mir(bb100[6])
bb101:
  _446 = _10
  using: _10@Mir(bb99[1])
  _445 = move _446 as i32 (IntToInt)
  using: _446@Mir(bb101[0])
  _448 = _11
  using: _11@Mir(bb100[1])
  _447 = move _448 as i32 (IntToInt)
  using: _448@Mir(bb101[2])
  _444 = Gt(move _445, move _447)
  using: _445@Mir(bb101[1]), _447@Mir(bb101[3])
  _443 = move _444 as i32 (IntToInt)
  using: _444@Mir(bb101[4])
  _0 = move _443 as u8 (IntToInt)
  using: _443@Mir(bb101[5])
  goto -> bb164
  using: 
bb102:
  _450 = _1
  using: _1@Mir(bb93[0])
  _449 = core::num::<impl u32>::wrapping_add(move _450, const 1_u32) -> bb103
  using: _450@Mir(bb102[0])
bb103:
  _1 = move _449
  using: _449@Mir(bb102[1])
  _452 = _2
  using: _2@Mir(bb94[0])
  _451 = core::num::<impl u32>::wrapping_add(move _452, const 1_u32) -> bb104
  using: _452@Mir(bb103[1])
bb104:
  _2 = move _451
  using: _451@Mir(bb103[2])
  _455 = _3
  using: _3@Phi(bb74)
  _457 = _1
  using: _1@Mir(bb103[0])
  _456 = move _457 as isize (IntToInt)
  using: _457@Mir(bb104[2])
  _454 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _455, move _456) -> bb105
  using: _455@Mir(bb104[1]), _456@Mir(bb104[3])
bb105:
  _453 = (*_454)
  using: _454@Mir(bb104[4])
  _8 = move _453
  using: _453@Mir(bb105[0])
  _460 = _3
  using: _3@Phi(bb74)
  _462 = _2
  using: _2@Mir(bb104[0])
  _461 = move _462 as isize (IntToInt)
  using: _462@Mir(bb105[3])
  _459 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _460, move _461) -> bb106
  using: _460@Mir(bb105[2]), _461@Mir(bb105[4])
bb106:
  _458 = (*_459)
  using: _459@Mir(bb105[5])
  _9 = move _458
  using: _458@Mir(bb106[0])
  _465 = _8
  using: _8@Mir(bb105[1])
  _464 = move _465 as i32 (IntToInt)
  using: _465@Mir(bb106[2])
  _467 = _9
  using: _9@Mir(bb106[1])
  _466 = move _467 as i32 (IntToInt)
  using: _467@Mir(bb106[4])
  _463 = Ne(move _464, move _466)
  using: _464@Mir(bb106[3]), _466@Mir(bb106[5])
  switchInt(move _463) -> [0: bb108, otherwise: bb107]
  using: _463@Mir(bb106[6])
bb107:
  _471 = _8
  using: _8@Mir(bb105[1])
  _470 = move _471 as i32 (IntToInt)
  using: _471@Mir(bb107[0])
  _473 = _9
  using: _9@Mir(bb106[1])
  _472 = move _473 as i32 (IntToInt)
  using: _473@Mir(bb107[2])
  _469 = Gt(move _470, move _472)
  using: _470@Mir(bb107[1]), _472@Mir(bb107[3])
  _468 = move _469 as i32 (IntToInt)
  using: _469@Mir(bb107[4])
  _0 = move _468 as u8 (IntToInt)
  using: _468@Mir(bb107[5])
  goto -> bb164
  using: 
bb108:
  _476 = _4
  using: _4@Phi(bb74)
  _478 = _1
  using: _1@Mir(bb103[0])
  _477 = move _478 as isize (IntToInt)
  using: _478@Mir(bb108[1])
  _475 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _476, move _477) -> bb109
  using: _476@Mir(bb108[0]), _477@Mir(bb108[2])
bb109:
  _474 = (*_475)
  using: _475@Mir(bb108[3])
  _10 = move _474
  using: _474@Mir(bb109[0])
  _481 = _4
  using: _4@Phi(bb74)
  _483 = _2
  using: _2@Mir(bb104[0])
  _482 = move _483 as isize (IntToInt)
  using: _483@Mir(bb109[3])
  _480 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _481, move _482) -> bb110
  using: _481@Mir(bb109[2]), _482@Mir(bb109[4])
bb110:
  _479 = (*_480)
  using: _480@Mir(bb109[5])
  _11 = move _479
  using: _479@Mir(bb110[0])
  _486 = _10
  using: _10@Mir(bb109[1])
  _485 = move _486 as i32 (IntToInt)
  using: _486@Mir(bb110[2])
  _488 = _11
  using: _11@Mir(bb110[1])
  _487 = move _488 as i32 (IntToInt)
  using: _488@Mir(bb110[4])
  _484 = Ne(move _485, move _487)
  using: _485@Mir(bb110[3]), _487@Mir(bb110[5])
  switchInt(move _484) -> [0: bb112, otherwise: bb111]
  using: _484@Mir(bb110[6])
bb111:
  _492 = _10
  using: _10@Mir(bb109[1])
  _491 = move _492 as i32 (IntToInt)
  using: _492@Mir(bb111[0])
  _494 = _11
  using: _11@Mir(bb110[1])
  _493 = move _494 as i32 (IntToInt)
  using: _494@Mir(bb111[2])
  _490 = Gt(move _491, move _493)
  using: _491@Mir(bb111[1]), _493@Mir(bb111[3])
  _489 = move _490 as i32 (IntToInt)
  using: _490@Mir(bb111[4])
  _0 = move _489 as u8 (IntToInt)
  using: _489@Mir(bb111[5])
  goto -> bb164
  using: 
bb112:
  _496 = _1
  using: _1@Mir(bb103[0])
  _495 = core::num::<impl u32>::wrapping_add(move _496, const 1_u32) -> bb113
  using: _496@Mir(bb112[0])
bb113:
  _1 = move _495
  using: _495@Mir(bb112[1])
  _498 = _2
  using: _2@Mir(bb104[0])
  _497 = core::num::<impl u32>::wrapping_add(move _498, const 1_u32) -> bb114
  using: _498@Mir(bb113[1])
bb114:
  _2 = move _497
  using: _497@Mir(bb113[2])
  _501 = _3
  using: _3@Phi(bb74)
  _503 = _1
  using: _1@Mir(bb113[0])
  _502 = move _503 as isize (IntToInt)
  using: _503@Mir(bb114[2])
  _500 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _501, move _502) -> bb115
  using: _501@Mir(bb114[1]), _502@Mir(bb114[3])
bb115:
  _499 = (*_500)
  using: _500@Mir(bb114[4])
  _8 = move _499
  using: _499@Mir(bb115[0])
  _506 = _3
  using: _3@Phi(bb74)
  _508 = _2
  using: _2@Mir(bb114[0])
  _507 = move _508 as isize (IntToInt)
  using: _508@Mir(bb115[3])
  _505 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _506, move _507) -> bb116
  using: _506@Mir(bb115[2]), _507@Mir(bb115[4])
bb116:
  _504 = (*_505)
  using: _505@Mir(bb115[5])
  _9 = move _504
  using: _504@Mir(bb116[0])
  _511 = _8
  using: _8@Mir(bb115[1])
  _510 = move _511 as i32 (IntToInt)
  using: _511@Mir(bb116[2])
  _513 = _9
  using: _9@Mir(bb116[1])
  _512 = move _513 as i32 (IntToInt)
  using: _513@Mir(bb116[4])
  _509 = Ne(move _510, move _512)
  using: _510@Mir(bb116[3]), _512@Mir(bb116[5])
  switchInt(move _509) -> [0: bb118, otherwise: bb117]
  using: _509@Mir(bb116[6])
bb117:
  _517 = _8
  using: _8@Mir(bb115[1])
  _516 = move _517 as i32 (IntToInt)
  using: _517@Mir(bb117[0])
  _519 = _9
  using: _9@Mir(bb116[1])
  _518 = move _519 as i32 (IntToInt)
  using: _519@Mir(bb117[2])
  _515 = Gt(move _516, move _518)
  using: _516@Mir(bb117[1]), _518@Mir(bb117[3])
  _514 = move _515 as i32 (IntToInt)
  using: _515@Mir(bb117[4])
  _0 = move _514 as u8 (IntToInt)
  using: _514@Mir(bb117[5])
  goto -> bb164
  using: 
bb118:
  _522 = _4
  using: _4@Phi(bb74)
  _524 = _1
  using: _1@Mir(bb113[0])
  _523 = move _524 as isize (IntToInt)
  using: _524@Mir(bb118[1])
  _521 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _522, move _523) -> bb119
  using: _522@Mir(bb118[0]), _523@Mir(bb118[2])
bb119:
  _520 = (*_521)
  using: _521@Mir(bb118[3])
  _10 = move _520
  using: _520@Mir(bb119[0])
  _527 = _4
  using: _4@Phi(bb74)
  _529 = _2
  using: _2@Mir(bb114[0])
  _528 = move _529 as isize (IntToInt)
  using: _529@Mir(bb119[3])
  _526 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _527, move _528) -> bb120
  using: _527@Mir(bb119[2]), _528@Mir(bb119[4])
bb120:
  _525 = (*_526)
  using: _526@Mir(bb119[5])
  _11 = move _525
  using: _525@Mir(bb120[0])
  _532 = _10
  using: _10@Mir(bb119[1])
  _531 = move _532 as i32 (IntToInt)
  using: _532@Mir(bb120[2])
  _534 = _11
  using: _11@Mir(bb120[1])
  _533 = move _534 as i32 (IntToInt)
  using: _534@Mir(bb120[4])
  _530 = Ne(move _531, move _533)
  using: _531@Mir(bb120[3]), _533@Mir(bb120[5])
  switchInt(move _530) -> [0: bb122, otherwise: bb121]
  using: _530@Mir(bb120[6])
bb121:
  _538 = _10
  using: _10@Mir(bb119[1])
  _537 = move _538 as i32 (IntToInt)
  using: _538@Mir(bb121[0])
  _540 = _11
  using: _11@Mir(bb120[1])
  _539 = move _540 as i32 (IntToInt)
  using: _540@Mir(bb121[2])
  _536 = Gt(move _537, move _539)
  using: _537@Mir(bb121[1]), _539@Mir(bb121[3])
  _535 = move _536 as i32 (IntToInt)
  using: _536@Mir(bb121[4])
  _0 = move _535 as u8 (IntToInt)
  using: _535@Mir(bb121[5])
  goto -> bb164
  using: 
bb122:
  _542 = _1
  using: _1@Mir(bb113[0])
  _541 = core::num::<impl u32>::wrapping_add(move _542, const 1_u32) -> bb123
  using: _542@Mir(bb122[0])
bb123:
  _1 = move _541
  using: _541@Mir(bb122[1])
  _544 = _2
  using: _2@Mir(bb114[0])
  _543 = core::num::<impl u32>::wrapping_add(move _544, const 1_u32) -> bb124
  using: _544@Mir(bb123[1])
bb124:
  _2 = move _543
  using: _543@Mir(bb123[2])
  _547 = _3
  using: _3@Phi(bb74)
  _549 = _1
  using: _1@Mir(bb123[0])
  _548 = move _549 as isize (IntToInt)
  using: _549@Mir(bb124[2])
  _546 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _547, move _548) -> bb125
  using: _547@Mir(bb124[1]), _548@Mir(bb124[3])
bb125:
  _545 = (*_546)
  using: _546@Mir(bb124[4])
  _8 = move _545
  using: _545@Mir(bb125[0])
  _552 = _3
  using: _3@Phi(bb74)
  _554 = _2
  using: _2@Mir(bb124[0])
  _553 = move _554 as isize (IntToInt)
  using: _554@Mir(bb125[3])
  _551 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _552, move _553) -> bb126
  using: _552@Mir(bb125[2]), _553@Mir(bb125[4])
bb126:
  _550 = (*_551)
  using: _551@Mir(bb125[5])
  _9 = move _550
  using: _550@Mir(bb126[0])
  _557 = _8
  using: _8@Mir(bb125[1])
  _556 = move _557 as i32 (IntToInt)
  using: _557@Mir(bb126[2])
  _559 = _9
  using: _9@Mir(bb126[1])
  _558 = move _559 as i32 (IntToInt)
  using: _559@Mir(bb126[4])
  _555 = Ne(move _556, move _558)
  using: _556@Mir(bb126[3]), _558@Mir(bb126[5])
  switchInt(move _555) -> [0: bb128, otherwise: bb127]
  using: _555@Mir(bb126[6])
bb127:
  _563 = _8
  using: _8@Mir(bb125[1])
  _562 = move _563 as i32 (IntToInt)
  using: _563@Mir(bb127[0])
  _565 = _9
  using: _9@Mir(bb126[1])
  _564 = move _565 as i32 (IntToInt)
  using: _565@Mir(bb127[2])
  _561 = Gt(move _562, move _564)
  using: _562@Mir(bb127[1]), _564@Mir(bb127[3])
  _560 = move _561 as i32 (IntToInt)
  using: _561@Mir(bb127[4])
  _0 = move _560 as u8 (IntToInt)
  using: _560@Mir(bb127[5])
  goto -> bb164
  using: 
bb128:
  _568 = _4
  using: _4@Phi(bb74)
  _570 = _1
  using: _1@Mir(bb123[0])
  _569 = move _570 as isize (IntToInt)
  using: _570@Mir(bb128[1])
  _567 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _568, move _569) -> bb129
  using: _568@Mir(bb128[0]), _569@Mir(bb128[2])
bb129:
  _566 = (*_567)
  using: _567@Mir(bb128[3])
  _10 = move _566
  using: _566@Mir(bb129[0])
  _573 = _4
  using: _4@Phi(bb74)
  _575 = _2
  using: _2@Mir(bb124[0])
  _574 = move _575 as isize (IntToInt)
  using: _575@Mir(bb129[3])
  _572 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _573, move _574) -> bb130
  using: _573@Mir(bb129[2]), _574@Mir(bb129[4])
bb130:
  _571 = (*_572)
  using: _572@Mir(bb129[5])
  _11 = move _571
  using: _571@Mir(bb130[0])
  _578 = _10
  using: _10@Mir(bb129[1])
  _577 = move _578 as i32 (IntToInt)
  using: _578@Mir(bb130[2])
  _580 = _11
  using: _11@Mir(bb130[1])
  _579 = move _580 as i32 (IntToInt)
  using: _580@Mir(bb130[4])
  _576 = Ne(move _577, move _579)
  using: _577@Mir(bb130[3]), _579@Mir(bb130[5])
  switchInt(move _576) -> [0: bb132, otherwise: bb131]
  using: _576@Mir(bb130[6])
bb131:
  _584 = _10
  using: _10@Mir(bb129[1])
  _583 = move _584 as i32 (IntToInt)
  using: _584@Mir(bb131[0])
  _586 = _11
  using: _11@Mir(bb130[1])
  _585 = move _586 as i32 (IntToInt)
  using: _586@Mir(bb131[2])
  _582 = Gt(move _583, move _585)
  using: _583@Mir(bb131[1]), _585@Mir(bb131[3])
  _581 = move _582 as i32 (IntToInt)
  using: _582@Mir(bb131[4])
  _0 = move _581 as u8 (IntToInt)
  using: _581@Mir(bb131[5])
  goto -> bb164
  using: 
bb132:
  _588 = _1
  using: _1@Mir(bb123[0])
  _587 = core::num::<impl u32>::wrapping_add(move _588, const 1_u32) -> bb133
  using: _588@Mir(bb132[0])
bb133:
  _1 = move _587
  using: _587@Mir(bb132[1])
  _590 = _2
  using: _2@Mir(bb124[0])
  _589 = core::num::<impl u32>::wrapping_add(move _590, const 1_u32) -> bb134
  using: _590@Mir(bb133[1])
bb134:
  _2 = move _589
  using: _589@Mir(bb133[2])
  _593 = _3
  using: _3@Phi(bb74)
  _595 = _1
  using: _1@Mir(bb133[0])
  _594 = move _595 as isize (IntToInt)
  using: _595@Mir(bb134[2])
  _592 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _593, move _594) -> bb135
  using: _593@Mir(bb134[1]), _594@Mir(bb134[3])
bb135:
  _591 = (*_592)
  using: _592@Mir(bb134[4])
  _8 = move _591
  using: _591@Mir(bb135[0])
  _598 = _3
  using: _3@Phi(bb74)
  _600 = _2
  using: _2@Mir(bb134[0])
  _599 = move _600 as isize (IntToInt)
  using: _600@Mir(bb135[3])
  _597 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _598, move _599) -> bb136
  using: _598@Mir(bb135[2]), _599@Mir(bb135[4])
bb136:
  _596 = (*_597)
  using: _597@Mir(bb135[5])
  _9 = move _596
  using: _596@Mir(bb136[0])
  _603 = _8
  using: _8@Mir(bb135[1])
  _602 = move _603 as i32 (IntToInt)
  using: _603@Mir(bb136[2])
  _605 = _9
  using: _9@Mir(bb136[1])
  _604 = move _605 as i32 (IntToInt)
  using: _605@Mir(bb136[4])
  _601 = Ne(move _602, move _604)
  using: _602@Mir(bb136[3]), _604@Mir(bb136[5])
  switchInt(move _601) -> [0: bb138, otherwise: bb137]
  using: _601@Mir(bb136[6])
bb137:
  _609 = _8
  using: _8@Mir(bb135[1])
  _608 = move _609 as i32 (IntToInt)
  using: _609@Mir(bb137[0])
  _611 = _9
  using: _9@Mir(bb136[1])
  _610 = move _611 as i32 (IntToInt)
  using: _611@Mir(bb137[2])
  _607 = Gt(move _608, move _610)
  using: _608@Mir(bb137[1]), _610@Mir(bb137[3])
  _606 = move _607 as i32 (IntToInt)
  using: _607@Mir(bb137[4])
  _0 = move _606 as u8 (IntToInt)
  using: _606@Mir(bb137[5])
  goto -> bb164
  using: 
bb138:
  _614 = _4
  using: _4@Phi(bb74)
  _616 = _1
  using: _1@Mir(bb133[0])
  _615 = move _616 as isize (IntToInt)
  using: _616@Mir(bb138[1])
  _613 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _614, move _615) -> bb139
  using: _614@Mir(bb138[0]), _615@Mir(bb138[2])
bb139:
  _612 = (*_613)
  using: _613@Mir(bb138[3])
  _10 = move _612
  using: _612@Mir(bb139[0])
  _619 = _4
  using: _4@Phi(bb74)
  _621 = _2
  using: _2@Mir(bb134[0])
  _620 = move _621 as isize (IntToInt)
  using: _621@Mir(bb139[3])
  _618 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _619, move _620) -> bb140
  using: _619@Mir(bb139[2]), _620@Mir(bb139[4])
bb140:
  _617 = (*_618)
  using: _618@Mir(bb139[5])
  _11 = move _617
  using: _617@Mir(bb140[0])
  _624 = _10
  using: _10@Mir(bb139[1])
  _623 = move _624 as i32 (IntToInt)
  using: _624@Mir(bb140[2])
  _626 = _11
  using: _11@Mir(bb140[1])
  _625 = move _626 as i32 (IntToInt)
  using: _626@Mir(bb140[4])
  _622 = Ne(move _623, move _625)
  using: _623@Mir(bb140[3]), _625@Mir(bb140[5])
  switchInt(move _622) -> [0: bb142, otherwise: bb141]
  using: _622@Mir(bb140[6])
bb141:
  _630 = _10
  using: _10@Mir(bb139[1])
  _629 = move _630 as i32 (IntToInt)
  using: _630@Mir(bb141[0])
  _632 = _11
  using: _11@Mir(bb140[1])
  _631 = move _632 as i32 (IntToInt)
  using: _632@Mir(bb141[2])
  _628 = Gt(move _629, move _631)
  using: _629@Mir(bb141[1]), _631@Mir(bb141[3])
  _627 = move _628 as i32 (IntToInt)
  using: _628@Mir(bb141[4])
  _0 = move _627 as u8 (IntToInt)
  using: _627@Mir(bb141[5])
  goto -> bb164
  using: 
bb142:
  _634 = _1
  using: _1@Mir(bb133[0])
  _633 = core::num::<impl u32>::wrapping_add(move _634, const 1_u32) -> bb143
  using: _634@Mir(bb142[0])
bb143:
  _1 = move _633
  using: _633@Mir(bb142[1])
  _636 = _2
  using: _2@Mir(bb134[0])
  _635 = core::num::<impl u32>::wrapping_add(move _636, const 1_u32) -> bb144
  using: _636@Mir(bb143[1])
bb144:
  _2 = move _635
  using: _635@Mir(bb143[2])
  _639 = _3
  using: _3@Phi(bb74)
  _641 = _1
  using: _1@Mir(bb143[0])
  _640 = move _641 as isize (IntToInt)
  using: _641@Mir(bb144[2])
  _638 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _639, move _640) -> bb145
  using: _639@Mir(bb144[1]), _640@Mir(bb144[3])
bb145:
  _637 = (*_638)
  using: _638@Mir(bb144[4])
  _8 = move _637
  using: _637@Mir(bb145[0])
  _644 = _3
  using: _3@Phi(bb74)
  _646 = _2
  using: _2@Mir(bb144[0])
  _645 = move _646 as isize (IntToInt)
  using: _646@Mir(bb145[3])
  _643 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _644, move _645) -> bb146
  using: _644@Mir(bb145[2]), _645@Mir(bb145[4])
bb146:
  _642 = (*_643)
  using: _643@Mir(bb145[5])
  _9 = move _642
  using: _642@Mir(bb146[0])
  _649 = _8
  using: _8@Mir(bb145[1])
  _648 = move _649 as i32 (IntToInt)
  using: _649@Mir(bb146[2])
  _651 = _9
  using: _9@Mir(bb146[1])
  _650 = move _651 as i32 (IntToInt)
  using: _651@Mir(bb146[4])
  _647 = Ne(move _648, move _650)
  using: _648@Mir(bb146[3]), _650@Mir(bb146[5])
  switchInt(move _647) -> [0: bb148, otherwise: bb147]
  using: _647@Mir(bb146[6])
bb147:
  _655 = _8
  using: _8@Mir(bb145[1])
  _654 = move _655 as i32 (IntToInt)
  using: _655@Mir(bb147[0])
  _657 = _9
  using: _9@Mir(bb146[1])
  _656 = move _657 as i32 (IntToInt)
  using: _657@Mir(bb147[2])
  _653 = Gt(move _654, move _656)
  using: _654@Mir(bb147[1]), _656@Mir(bb147[3])
  _652 = move _653 as i32 (IntToInt)
  using: _653@Mir(bb147[4])
  _0 = move _652 as u8 (IntToInt)
  using: _652@Mir(bb147[5])
  goto -> bb164
  using: 
bb148:
  _660 = _4
  using: _4@Phi(bb74)
  _662 = _1
  using: _1@Mir(bb143[0])
  _661 = move _662 as isize (IntToInt)
  using: _662@Mir(bb148[1])
  _659 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _660, move _661) -> bb149
  using: _660@Mir(bb148[0]), _661@Mir(bb148[2])
bb149:
  _658 = (*_659)
  using: _659@Mir(bb148[3])
  _10 = move _658
  using: _658@Mir(bb149[0])
  _665 = _4
  using: _4@Phi(bb74)
  _667 = _2
  using: _2@Mir(bb144[0])
  _666 = move _667 as isize (IntToInt)
  using: _667@Mir(bb149[3])
  _664 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _665, move _666) -> bb150
  using: _665@Mir(bb149[2]), _666@Mir(bb149[4])
bb150:
  _663 = (*_664)
  using: _664@Mir(bb149[5])
  _11 = move _663
  using: _663@Mir(bb150[0])
  _670 = _10
  using: _10@Mir(bb149[1])
  _669 = move _670 as i32 (IntToInt)
  using: _670@Mir(bb150[2])
  _672 = _11
  using: _11@Mir(bb150[1])
  _671 = move _672 as i32 (IntToInt)
  using: _672@Mir(bb150[4])
  _668 = Ne(move _669, move _671)
  using: _669@Mir(bb150[3]), _671@Mir(bb150[5])
  switchInt(move _668) -> [0: bb152, otherwise: bb151]
  using: _668@Mir(bb150[6])
bb151:
  _676 = _10
  using: _10@Mir(bb149[1])
  _675 = move _676 as i32 (IntToInt)
  using: _676@Mir(bb151[0])
  _678 = _11
  using: _11@Mir(bb150[1])
  _677 = move _678 as i32 (IntToInt)
  using: _678@Mir(bb151[2])
  _674 = Gt(move _675, move _677)
  using: _675@Mir(bb151[1]), _677@Mir(bb151[3])
  _673 = move _674 as i32 (IntToInt)
  using: _674@Mir(bb151[4])
  _0 = move _673 as u8 (IntToInt)
  using: _673@Mir(bb151[5])
  goto -> bb164
  using: 
bb152:
  _680 = _1
  using: _1@Mir(bb143[0])
  _679 = core::num::<impl u32>::wrapping_add(move _680, const 1_u32) -> bb153
  using: _680@Mir(bb152[0])
bb153:
  _1 = move _679
  using: _679@Mir(bb152[1])
  _682 = _2
  using: _2@Mir(bb144[0])
  _681 = core::num::<impl u32>::wrapping_add(move _682, const 1_u32) -> bb154
  using: _682@Mir(bb153[1])
bb154:
  _2 = move _681
  using: _681@Mir(bb153[2])
  _684 = _1
  using: _1@Mir(bb153[0])
  _685 = _5
  using: _5@Phi(bb74)
  _683 = Ge(move _684, move _685)
  using: _684@Mir(bb154[1]), _685@Mir(bb154[2])
  switchInt(move _683) -> [0: bb157, otherwise: bb155]
  using: _683@Mir(bb154[3])
bb155:
  _687 = _1
  using: _1@Mir(bb153[0])
  _688 = _5
  using: _5@Phi(bb74)
  _686 = core::num::<impl u32>::wrapping_sub(move _687, move _688) -> bb156
  using: _687@Mir(bb155[0]), _688@Mir(bb155[1])
bb156:
  _1 = move _686
  using: _686@Mir(bb155[2])
  goto -> bb157
  using: 
bb157:
  _690 = _2
  using: _2@Mir(bb154[0])
  _691 = _5
  using: _5@Phi(bb157)
  _689 = Ge(move _690, move _691)
  using: _690@Mir(bb157[0]), _691@Mir(bb157[1])
  switchInt(move _689) -> [0: bb160, otherwise: bb158]
  using: _689@Mir(bb157[2])
bb158:
  _693 = _2
  using: _2@Mir(bb154[0])
  _694 = _5
  using: _5@Phi(bb157)
  _692 = core::num::<impl u32>::wrapping_sub(move _693, move _694) -> bb159
  using: _693@Mir(bb158[0]), _694@Mir(bb158[1])
bb159:
  _2 = move _692
  using: _692@Mir(bb158[2])
  goto -> bb160
  using: 
bb160:
  _695 = const 8_i32
  using: 
  _696 = CheckedSub(_7, _695)
  using: _7@Phi(bb74), _695@Mir(bb160[0])
  assert(!move (_696.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, move _695) -> bb161
  using: _696@Entry, _7@Entry, _695@Entry
bb161:
  _7 = move (_696.0: i32)
  using: _696@Mir(bb160[1])
  _697 = CheckedSub((*_6), const 1_i32)
  using: _6@Phi(bb74)
  assert(!move (_697.1: bool), "attempt to compute `{} - {}`, which would overflow", (*_6), const 1_i32) -> bb162
  using: _697@Entry, _6@Entry
bb162:
  (*_6) = move (_697.0: i32)
  using: _6@Phi(bb74), _697@Mir(bb161[1])
  _700 = _7
  using: _7@Mir(bb161[0])
  _701 = const 0_i32
  using: 
  _699 = Ge(move _700, move _701)
  using: _700@Mir(bb162[1]), _701@Mir(bb162[2])
  _698 = Not(move _699)
  using: _699@Mir(bb162[3])
  switchInt(move _698) -> [0: bb74, otherwise: bb163]
  using: _698@Mir(bb162[4])
bb163:
  _0 = const 0_u8
  using: 
  goto -> bb164
  using: 
bb164:
  return
  using: _0@Phi(bb164)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:549:17: 549:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:550:17: 550:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:554:13: 554:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:555:13: 555:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:557:17: 557:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:558:17: 558:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:562:13: 562:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:563:13: 563:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:565:17: 565:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:566:17: 566:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:570:13: 570:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:571:13: 571:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:573:17: 573:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:574:17: 574:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:578:13: 578:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:579:13: 579:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:581:17: 581:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:582:17: 582:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:586:13: 586:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:587:13: 587:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:589:17: 589:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:590:17: 590:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:594:13: 594:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:595:13: 595:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:597:17: 597:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:598:17: 598:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:602:13: 602:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:603:13: 603:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:605:17: 605:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:606:17: 606:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:610:13: 610:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:611:13: 611:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:613:17: 613:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:614:17: 614:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:618:13: 618:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:619:13: 619:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:621:17: 621:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:622:17: 622:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:626:13: 626:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:627:13: 627:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:629:17: 629:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:630:17: 630:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:634:13: 634:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:635:13: 635:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:637:17: 637:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:638:17: 638:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:642:13: 642:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:643:13: 643:28 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:644:16: 644:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:647:21: 647:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:648:21: 648:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:653:24: 653:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:654:24: 654:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:659:17: 659:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:660:17: 660:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:662:21: 662:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:663:21: 663:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:668:24: 668:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:669:24: 669:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:674:17: 674:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:675:17: 675:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:677:21: 677:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:678:21: 678:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:683:24: 683:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:684:24: 684:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:689:17: 689:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:690:17: 690:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:692:21: 692:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:693:21: 693:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:698:24: 698:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:699:24: 699:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:704:17: 704:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:705:17: 705:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:707:21: 707:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:708:21: 708:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:713:24: 713:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:714:24: 714:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:719:17: 719:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:720:17: 720:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:722:21: 722:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:723:21: 723:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:728:24: 728:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:729:24: 729:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:734:17: 734:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:735:17: 735:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:737:21: 737:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:738:21: 738:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:743:24: 743:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:744:24: 744:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:749:17: 749:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:750:17: 750:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:752:21: 752:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:753:21: 753:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:758:24: 758:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:759:24: 759:43 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:764:17: 764:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:765:17: 765:32 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:767:47: 767:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:770:47: 770:67 (#0) by default
@DefId(0:30 ~ c2rust_lib[1043]::blocksort::mainSimpleSort)
bb0:
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  _14 = const 0_u32
  using: 
  _16 = _6
  using: _6@Entry
  _17 = _5
  using: _5@Entry
  _18 = CheckedSub(_16, _17)
  using: _16@Mir(bb0[6]), _17@Mir(bb0[7])
  assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", move _16, move _17) -> bb1
  using: _18@Entry, _16@Entry, _17@Entry
bb1:
  _15 = move (_18.0: i32)
  using: _18@Mir(bb0[8])
  _19 = const 1_i32
  using: 
  _20 = CheckedAdd(_15, _19)
  using: _15@Mir(bb1[0]), _19@Mir(bb1[1])
  assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", move _15, move _19) -> bb2
  using: _20@Entry, _15@Entry, _19@Entry
bb2:
  _12 = move (_20.0: i32)
  using: _20@Mir(bb1[2])
  _22 = _12
  using: _12@Mir(bb2[0])
  _23 = const 2_i32
  using: 
  _21 = Lt(move _22, move _23)
  using: _22@Mir(bb2[1]), _23@Mir(bb2[2])
  switchInt(move _21) -> [0: bb3, otherwise: bb71]
  using: _21@Mir(bb2[3])
bb3:
  _13 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _26 = const {alloc22: *mut [i32; 14]}
  using: 
  _28 = _13
  using: _13@Phi(bb4)
  _27 = move _28 as usize (IntToInt)
  using: _28@Mir(bb4[1])
  _29 = const 14_usize
  using: 
  _30 = Lt(_27, _29)
  using: _27@Mir(bb4[2]), _29@Mir(bb4[3])
  assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _27) -> bb5
  using: _30@Entry, _29@Entry, _27@Entry
bb5:
  _25 = (*_26)[_27]
  using: _26@Mir(bb4[0]), _27@Mir(bb4[2])
  _31 = _12
  using: _12@Phi(bb4)
  _24 = Lt(move _25, move _31)
  using: _25@Mir(bb5[0]), _31@Mir(bb5[1])
  switchInt(move _24) -> [0: bb8, otherwise: bb6]
  using: _24@Mir(bb5[2])
bb6:
  _32 = CheckedAdd(_13, const 1_i32)
  using: _13@Phi(bb4)
  assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _13, const 1_i32) -> bb7
  using: _32@Entry, _13@Entry
bb7:
  _13 = move (_32.0: i32)
  using: _32@Mir(bb6[0])
  goto -> bb4
  using: 
bb8:
  _33 = CheckedSub(_13, const 1_i32)
  using: _13@Phi(bb4)
  assert(!move (_33.1: bool), "attempt to compute `{} - {}`, which would overflow", _13, const 1_i32) -> bb9
  using: _33@Entry, _13@Entry
bb9:
  _13 = move (_33.0: i32)
  using: _33@Mir(bb8[0])
  goto -> bb10
  using: 
bb10:
  _35 = _13
  using: _13@Phi(bb10)
  _36 = const 0_i32
  using: 
  _34 = Ge(move _35, move _36)
  using: _35@Mir(bb10[0]), _36@Mir(bb10[1])
  switchInt(move _34) -> [0: bb71, otherwise: bb11]
  using: _34@Mir(bb10[2])
bb11:
  _38 = const {alloc22: *mut [i32; 14]}
  using: 
  _40 = _13
  using: _13@Phi(bb10)
  _39 = move _40 as usize (IntToInt)
  using: _40@Mir(bb11[1])
  _41 = const 14_usize
  using: 
  _42 = Lt(_39, _41)
  using: _39@Mir(bb11[2]), _41@Mir(bb11[3])
  assert(move _42, "index out of bounds: the length is {} but the index is {}", move _41, _39) -> bb12
  using: _42@Entry, _41@Entry, _39@Entry
bb12:
  _37 = (*_38)[_39]
  using: _38@Mir(bb11[0]), _39@Mir(bb11[2])
  _11 = move _37
  using: _37@Mir(bb12[0])
  _43 = _5
  using: _5@Phi(bb10)
  _44 = _11
  using: _11@Mir(bb12[1])
  _45 = CheckedAdd(_43, _44)
  using: _43@Mir(bb12[2]), _44@Mir(bb12[3])
  assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", move _43, move _44) -> bb13
  using: _45@Entry, _43@Entry, _44@Entry
bb13:
  _9 = move (_45.0: i32)
  using: _45@Mir(bb12[4])
  goto -> bb14
  using: 
bb14:
  _47 = _9
  using: _9@Phi(bb14)
  _48 = _6
  using: _6@Phi(bb14)
  _46 = Gt(move _47, move _48)
  using: _47@Mir(bb14[0]), _48@Mir(bb14[1])
  switchInt(move _46) -> [0: bb15, otherwise: bb69]
  using: _46@Mir(bb14[2])
bb15:
  _51 = _1
  using: _1@Phi(bb14)
  _53 = _9
  using: _9@Phi(bb14)
  _52 = move _53 as isize (IntToInt)
  using: _53@Mir(bb15[1])
  _50 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _51, move _52) -> bb16
  using: _51@Mir(bb15[0]), _52@Mir(bb15[2])
bb16:
  _49 = (*_50)
  using: _50@Mir(bb15[3])
  _14 = move _49
  using: _49@Mir(bb16[0])
  _54 = _9
  using: _9@Phi(bb14)
  _10 = move _54
  using: _54@Mir(bb16[2])
  goto -> bb17
  using: 
bb17:
  _59 = _1
  using: _1@Phi(bb17)
  _62 = _10
  using: _10@Phi(bb17)
  _63 = _11
  using: _11@Phi(bb17)
  _64 = CheckedSub(_62, _63)
  using: _62@Mir(bb17[1]), _63@Mir(bb17[2])
  assert(!move (_64.1: bool), "attempt to compute `{} - {}`, which would overflow", move _62, move _63) -> bb18
  using: _64@Entry, _62@Entry, _63@Entry
bb18:
  _61 = move (_64.0: i32)
  using: _64@Mir(bb17[3])
  _60 = move _61 as isize (IntToInt)
  using: _61@Mir(bb18[0])
  _58 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _59, move _60) -> bb19
  using: _59@Mir(bb17[0]), _60@Mir(bb18[1])
bb19:
  _57 = (*_58)
  using: _58@Mir(bb18[2])
  _66 = _7
  using: _7@Phi(bb17)
  _65 = move _66 as u32 (IntToInt)
  using: _66@Mir(bb19[1])
  _56 = core::num::<impl u32>::wrapping_add(move _57, move _65) -> bb20
  using: _57@Mir(bb19[0]), _65@Mir(bb19[2])
bb20:
  _68 = _14
  using: _14@Phi(bb17)
  _70 = _7
  using: _7@Phi(bb17)
  _69 = move _70 as u32 (IntToInt)
  using: _70@Mir(bb20[1])
  _67 = core::num::<impl u32>::wrapping_add(move _68, move _69) -> bb21
  using: _68@Mir(bb20[0]), _69@Mir(bb20[2])
bb21:
  _71 = _2
  using: _2@Phi(bb17)
  _72 = _3
  using: _3@Phi(bb17)
  _74 = _4
  using: _4@Phi(bb17)
  _73 = move _74 as u32 (IntToInt)
  using: _74@Mir(bb21[2])
  _75 = _8
  using: _8@Phi(bb17)
  _55 = blocksort::mainGtU(move _56, move _67, move _71, move _72, move _73, move _75) -> bb22
  using: _56@Mir(bb19[3]), _67@Mir(bb20[3]), _71@Mir(bb21[0]), _72@Mir(bb21[1]), _73@Mir(bb21[3]), _75@Mir(bb21[4])
bb22:
  switchInt(move _55) -> [0: bb30, otherwise: bb23]
  using: _55@Mir(bb21[5])
bb23:
  _78 = _1
  using: _1@Phi(bb17)
  _81 = _10
  using: _10@Phi(bb17)
  _82 = _11
  using: _11@Phi(bb17)
  _83 = CheckedSub(_81, _82)
  using: _81@Mir(bb23[1]), _82@Mir(bb23[2])
  assert(!move (_83.1: bool), "attempt to compute `{} - {}`, which would overflow", move _81, move _82) -> bb24
  using: _83@Entry, _81@Entry, _82@Entry
bb24:
  _80 = move (_83.0: i32)
  using: _83@Mir(bb23[3])
  _79 = move _80 as isize (IntToInt)
  using: _80@Mir(bb24[0])
  _77 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _78, move _79) -> bb25
  using: _78@Mir(bb23[0]), _79@Mir(bb24[1])
bb25:
  _76 = (*_77)
  using: _77@Mir(bb24[2])
  _85 = _1
  using: _1@Phi(bb17)
  _87 = _10
  using: _10@Phi(bb17)
  _86 = move _87 as isize (IntToInt)
  using: _87@Mir(bb25[2])
  _84 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _85, move _86) -> bb26
  using: _85@Mir(bb25[1]), _86@Mir(bb25[3])
bb26:
  (*_84) = move _76
  using: _84@Mir(bb25[4]), _76@Mir(bb25[0])
  _88 = _10
  using: _10@Phi(bb17)
  _89 = _11
  using: _11@Phi(bb17)
  _90 = CheckedSub(_88, _89)
  using: _88@Mir(bb26[1]), _89@Mir(bb26[2])
  assert(!move (_90.1: bool), "attempt to compute `{} - {}`, which would overflow", move _88, move _89) -> bb27
  using: _90@Entry, _88@Entry, _89@Entry
bb27:
  _10 = move (_90.0: i32)
  using: _90@Mir(bb26[3])
  _92 = _10
  using: _10@Mir(bb27[0])
  _95 = _5
  using: _5@Phi(bb17)
  _96 = _11
  using: _11@Phi(bb17)
  _97 = CheckedAdd(_95, _96)
  using: _95@Mir(bb27[2]), _96@Mir(bb27[3])
  assert(!move (_97.1: bool), "attempt to compute `{} + {}`, which would overflow", move _95, move _96) -> bb28
  using: _97@Entry, _95@Entry, _96@Entry
bb28:
  _94 = move (_97.0: i32)
  using: _97@Mir(bb27[4])
  _98 = const 1_i32
  using: 
  _99 = CheckedSub(_94, _98)
  using: _94@Mir(bb28[0]), _98@Mir(bb28[1])
  assert(!move (_99.1: bool), "attempt to compute `{} - {}`, which would overflow", move _94, move _98) -> bb29
  using: _99@Entry, _94@Entry, _98@Entry
bb29:
  _93 = move (_99.0: i32)
  using: _99@Mir(bb28[2])
  _91 = Le(move _92, move _93)
  using: _92@Mir(bb27[1]), _93@Mir(bb29[0])
  switchInt(move _91) -> [0: bb17, otherwise: bb30]
  using: _91@Mir(bb29[1])
bb30:
  _100 = _14
  using: _14@Phi(bb17)
  _102 = _1
  using: _1@Phi(bb30)
  _104 = _10
  using: _10@Phi(bb30)
  _103 = move _104 as isize (IntToInt)
  using: _104@Mir(bb30[2])
  _101 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _102, move _103) -> bb31
  using: _102@Mir(bb30[1]), _103@Mir(bb30[3])
bb31:
  (*_101) = move _100
  using: _101@Mir(bb30[4]), _100@Mir(bb30[0])
  _105 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb14)
  assert(!move (_105.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb32
  using: _105@Entry, _9@Entry
bb32:
  _9 = move (_105.0: i32)
  using: _105@Mir(bb31[1])
  _107 = _9
  using: _9@Mir(bb32[0])
  _108 = _6
  using: _6@Phi(bb14)
  _106 = Gt(move _107, move _108)
  using: _107@Mir(bb32[1]), _108@Mir(bb32[2])
  switchInt(move _106) -> [0: bb33, otherwise: bb69]
  using: _106@Mir(bb32[3])
bb33:
  _111 = _1
  using: _1@Phi(bb30)
  _113 = _9
  using: _9@Mir(bb32[0])
  _112 = move _113 as isize (IntToInt)
  using: _113@Mir(bb33[1])
  _110 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _111, move _112) -> bb34
  using: _111@Mir(bb33[0]), _112@Mir(bb33[2])
bb34:
  _109 = (*_110)
  using: _110@Mir(bb33[3])
  _14 = move _109
  using: _109@Mir(bb34[0])
  _114 = _9
  using: _9@Mir(bb32[0])
  _10 = move _114
  using: _114@Mir(bb34[2])
  goto -> bb35
  using: 
bb35:
  _119 = _1
  using: _1@Phi(bb35)
  _122 = _10
  using: _10@Phi(bb35)
  _123 = _11
  using: _11@Phi(bb35)
  _124 = CheckedSub(_122, _123)
  using: _122@Mir(bb35[1]), _123@Mir(bb35[2])
  assert(!move (_124.1: bool), "attempt to compute `{} - {}`, which would overflow", move _122, move _123) -> bb36
  using: _124@Entry, _122@Entry, _123@Entry
bb36:
  _121 = move (_124.0: i32)
  using: _124@Mir(bb35[3])
  _120 = move _121 as isize (IntToInt)
  using: _121@Mir(bb36[0])
  _118 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _119, move _120) -> bb37
  using: _119@Mir(bb35[0]), _120@Mir(bb36[1])
bb37:
  _117 = (*_118)
  using: _118@Mir(bb36[2])
  _126 = _7
  using: _7@Phi(bb35)
  _125 = move _126 as u32 (IntToInt)
  using: _126@Mir(bb37[1])
  _116 = core::num::<impl u32>::wrapping_add(move _117, move _125) -> bb38
  using: _117@Mir(bb37[0]), _125@Mir(bb37[2])
bb38:
  _128 = _14
  using: _14@Phi(bb35)
  _130 = _7
  using: _7@Phi(bb35)
  _129 = move _130 as u32 (IntToInt)
  using: _130@Mir(bb38[1])
  _127 = core::num::<impl u32>::wrapping_add(move _128, move _129) -> bb39
  using: _128@Mir(bb38[0]), _129@Mir(bb38[2])
bb39:
  _131 = _2
  using: _2@Phi(bb35)
  _132 = _3
  using: _3@Phi(bb35)
  _134 = _4
  using: _4@Phi(bb35)
  _133 = move _134 as u32 (IntToInt)
  using: _134@Mir(bb39[2])
  _135 = _8
  using: _8@Phi(bb35)
  _115 = blocksort::mainGtU(move _116, move _127, move _131, move _132, move _133, move _135) -> bb40
  using: _116@Mir(bb37[3]), _127@Mir(bb38[3]), _131@Mir(bb39[0]), _132@Mir(bb39[1]), _133@Mir(bb39[3]), _135@Mir(bb39[4])
bb40:
  switchInt(move _115) -> [0: bb48, otherwise: bb41]
  using: _115@Mir(bb39[5])
bb41:
  _138 = _1
  using: _1@Phi(bb35)
  _141 = _10
  using: _10@Phi(bb35)
  _142 = _11
  using: _11@Phi(bb35)
  _143 = CheckedSub(_141, _142)
  using: _141@Mir(bb41[1]), _142@Mir(bb41[2])
  assert(!move (_143.1: bool), "attempt to compute `{} - {}`, which would overflow", move _141, move _142) -> bb42
  using: _143@Entry, _141@Entry, _142@Entry
bb42:
  _140 = move (_143.0: i32)
  using: _143@Mir(bb41[3])
  _139 = move _140 as isize (IntToInt)
  using: _140@Mir(bb42[0])
  _137 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _138, move _139) -> bb43
  using: _138@Mir(bb41[0]), _139@Mir(bb42[1])
bb43:
  _136 = (*_137)
  using: _137@Mir(bb42[2])
  _145 = _1
  using: _1@Phi(bb35)
  _147 = _10
  using: _10@Phi(bb35)
  _146 = move _147 as isize (IntToInt)
  using: _147@Mir(bb43[2])
  _144 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _145, move _146) -> bb44
  using: _145@Mir(bb43[1]), _146@Mir(bb43[3])
bb44:
  (*_144) = move _136
  using: _144@Mir(bb43[4]), _136@Mir(bb43[0])
  _148 = _10
  using: _10@Phi(bb35)
  _149 = _11
  using: _11@Phi(bb35)
  _150 = CheckedSub(_148, _149)
  using: _148@Mir(bb44[1]), _149@Mir(bb44[2])
  assert(!move (_150.1: bool), "attempt to compute `{} - {}`, which would overflow", move _148, move _149) -> bb45
  using: _150@Entry, _148@Entry, _149@Entry
bb45:
  _10 = move (_150.0: i32)
  using: _150@Mir(bb44[3])
  _152 = _10
  using: _10@Mir(bb45[0])
  _155 = _5
  using: _5@Phi(bb35)
  _156 = _11
  using: _11@Phi(bb35)
  _157 = CheckedAdd(_155, _156)
  using: _155@Mir(bb45[2]), _156@Mir(bb45[3])
  assert(!move (_157.1: bool), "attempt to compute `{} + {}`, which would overflow", move _155, move _156) -> bb46
  using: _157@Entry, _155@Entry, _156@Entry
bb46:
  _154 = move (_157.0: i32)
  using: _157@Mir(bb45[4])
  _158 = const 1_i32
  using: 
  _159 = CheckedSub(_154, _158)
  using: _154@Mir(bb46[0]), _158@Mir(bb46[1])
  assert(!move (_159.1: bool), "attempt to compute `{} - {}`, which would overflow", move _154, move _158) -> bb47
  using: _159@Entry, _154@Entry, _158@Entry
bb47:
  _153 = move (_159.0: i32)
  using: _159@Mir(bb46[2])
  _151 = Le(move _152, move _153)
  using: _152@Mir(bb45[1]), _153@Mir(bb47[0])
  switchInt(move _151) -> [0: bb35, otherwise: bb48]
  using: _151@Mir(bb47[1])
bb48:
  _160 = _14
  using: _14@Phi(bb35)
  _162 = _1
  using: _1@Phi(bb48)
  _164 = _10
  using: _10@Phi(bb48)
  _163 = move _164 as isize (IntToInt)
  using: _164@Mir(bb48[2])
  _161 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _162, move _163) -> bb49
  using: _162@Mir(bb48[1]), _163@Mir(bb48[3])
bb49:
  (*_161) = move _160
  using: _161@Mir(bb48[4]), _160@Mir(bb48[0])
  _165 = CheckedAdd(_9, const 1_i32)
  using: _9@Mir(bb32[0])
  assert(!move (_165.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb50
  using: _165@Entry, _9@Entry
bb50:
  _9 = move (_165.0: i32)
  using: _165@Mir(bb49[1])
  _167 = _9
  using: _9@Mir(bb50[0])
  _168 = _6
  using: _6@Phi(bb14)
  _166 = Gt(move _167, move _168)
  using: _167@Mir(bb50[1]), _168@Mir(bb50[2])
  switchInt(move _166) -> [0: bb51, otherwise: bb69]
  using: _166@Mir(bb50[3])
bb51:
  _171 = _1
  using: _1@Phi(bb48)
  _173 = _9
  using: _9@Mir(bb50[0])
  _172 = move _173 as isize (IntToInt)
  using: _173@Mir(bb51[1])
  _170 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _171, move _172) -> bb52
  using: _171@Mir(bb51[0]), _172@Mir(bb51[2])
bb52:
  _169 = (*_170)
  using: _170@Mir(bb51[3])
  _14 = move _169
  using: _169@Mir(bb52[0])
  _174 = _9
  using: _9@Mir(bb50[0])
  _10 = move _174
  using: _174@Mir(bb52[2])
  goto -> bb53
  using: 
bb53:
  _179 = _1
  using: _1@Phi(bb53)
  _182 = _10
  using: _10@Phi(bb53)
  _183 = _11
  using: _11@Phi(bb53)
  _184 = CheckedSub(_182, _183)
  using: _182@Mir(bb53[1]), _183@Mir(bb53[2])
  assert(!move (_184.1: bool), "attempt to compute `{} - {}`, which would overflow", move _182, move _183) -> bb54
  using: _184@Entry, _182@Entry, _183@Entry
bb54:
  _181 = move (_184.0: i32)
  using: _184@Mir(bb53[3])
  _180 = move _181 as isize (IntToInt)
  using: _181@Mir(bb54[0])
  _178 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _179, move _180) -> bb55
  using: _179@Mir(bb53[0]), _180@Mir(bb54[1])
bb55:
  _177 = (*_178)
  using: _178@Mir(bb54[2])
  _186 = _7
  using: _7@Phi(bb53)
  _185 = move _186 as u32 (IntToInt)
  using: _186@Mir(bb55[1])
  _176 = core::num::<impl u32>::wrapping_add(move _177, move _185) -> bb56
  using: _177@Mir(bb55[0]), _185@Mir(bb55[2])
bb56:
  _188 = _14
  using: _14@Phi(bb53)
  _190 = _7
  using: _7@Phi(bb53)
  _189 = move _190 as u32 (IntToInt)
  using: _190@Mir(bb56[1])
  _187 = core::num::<impl u32>::wrapping_add(move _188, move _189) -> bb57
  using: _188@Mir(bb56[0]), _189@Mir(bb56[2])
bb57:
  _191 = _2
  using: _2@Phi(bb53)
  _192 = _3
  using: _3@Phi(bb53)
  _194 = _4
  using: _4@Phi(bb53)
  _193 = move _194 as u32 (IntToInt)
  using: _194@Mir(bb57[2])
  _195 = _8
  using: _8@Phi(bb53)
  _175 = blocksort::mainGtU(move _176, move _187, move _191, move _192, move _193, move _195) -> bb58
  using: _176@Mir(bb55[3]), _187@Mir(bb56[3]), _191@Mir(bb57[0]), _192@Mir(bb57[1]), _193@Mir(bb57[3]), _195@Mir(bb57[4])
bb58:
  switchInt(move _175) -> [0: bb66, otherwise: bb59]
  using: _175@Mir(bb57[5])
bb59:
  _198 = _1
  using: _1@Phi(bb53)
  _201 = _10
  using: _10@Phi(bb53)
  _202 = _11
  using: _11@Phi(bb53)
  _203 = CheckedSub(_201, _202)
  using: _201@Mir(bb59[1]), _202@Mir(bb59[2])
  assert(!move (_203.1: bool), "attempt to compute `{} - {}`, which would overflow", move _201, move _202) -> bb60
  using: _203@Entry, _201@Entry, _202@Entry
bb60:
  _200 = move (_203.0: i32)
  using: _203@Mir(bb59[3])
  _199 = move _200 as isize (IntToInt)
  using: _200@Mir(bb60[0])
  _197 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _198, move _199) -> bb61
  using: _198@Mir(bb59[0]), _199@Mir(bb60[1])
bb61:
  _196 = (*_197)
  using: _197@Mir(bb60[2])
  _205 = _1
  using: _1@Phi(bb53)
  _207 = _10
  using: _10@Phi(bb53)
  _206 = move _207 as isize (IntToInt)
  using: _207@Mir(bb61[2])
  _204 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _205, move _206) -> bb62
  using: _205@Mir(bb61[1]), _206@Mir(bb61[3])
bb62:
  (*_204) = move _196
  using: _204@Mir(bb61[4]), _196@Mir(bb61[0])
  _208 = _10
  using: _10@Phi(bb53)
  _209 = _11
  using: _11@Phi(bb53)
  _210 = CheckedSub(_208, _209)
  using: _208@Mir(bb62[1]), _209@Mir(bb62[2])
  assert(!move (_210.1: bool), "attempt to compute `{} - {}`, which would overflow", move _208, move _209) -> bb63
  using: _210@Entry, _208@Entry, _209@Entry
bb63:
  _10 = move (_210.0: i32)
  using: _210@Mir(bb62[3])
  _212 = _10
  using: _10@Mir(bb63[0])
  _215 = _5
  using: _5@Phi(bb53)
  _216 = _11
  using: _11@Phi(bb53)
  _217 = CheckedAdd(_215, _216)
  using: _215@Mir(bb63[2]), _216@Mir(bb63[3])
  assert(!move (_217.1: bool), "attempt to compute `{} + {}`, which would overflow", move _215, move _216) -> bb64
  using: _217@Entry, _215@Entry, _216@Entry
bb64:
  _214 = move (_217.0: i32)
  using: _217@Mir(bb63[4])
  _218 = const 1_i32
  using: 
  _219 = CheckedSub(_214, _218)
  using: _214@Mir(bb64[0]), _218@Mir(bb64[1])
  assert(!move (_219.1: bool), "attempt to compute `{} - {}`, which would overflow", move _214, move _218) -> bb65
  using: _219@Entry, _214@Entry, _218@Entry
bb65:
  _213 = move (_219.0: i32)
  using: _219@Mir(bb64[2])
  _211 = Le(move _212, move _213)
  using: _212@Mir(bb63[1]), _213@Mir(bb65[0])
  switchInt(move _211) -> [0: bb53, otherwise: bb66]
  using: _211@Mir(bb65[1])
bb66:
  _220 = _14
  using: _14@Phi(bb53)
  _222 = _1
  using: _1@Phi(bb66)
  _224 = _10
  using: _10@Phi(bb66)
  _223 = move _224 as isize (IntToInt)
  using: _224@Mir(bb66[2])
  _221 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _222, move _223) -> bb67
  using: _222@Mir(bb66[1]), _223@Mir(bb66[3])
bb67:
  (*_221) = move _220
  using: _221@Mir(bb66[4]), _220@Mir(bb66[0])
  _225 = CheckedAdd(_9, const 1_i32)
  using: _9@Mir(bb50[0])
  assert(!move (_225.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb68
  using: _225@Entry, _9@Entry
bb68:
  _9 = move (_225.0: i32)
  using: _225@Mir(bb67[1])
  _227 = (*_8)
  using: _8@Phi(bb53)
  _228 = const 0_i32
  using: 
  _226 = Lt(move _227, move _228)
  using: _227@Mir(bb68[1]), _228@Mir(bb68[2])
  switchInt(move _226) -> [0: bb14, otherwise: bb71]
  using: _226@Mir(bb68[3])
bb69:
  _229 = CheckedSub(_13, const 1_i32)
  using: _13@Phi(bb10)
  assert(!move (_229.1: bool), "attempt to compute `{} - {}`, which would overflow", _13, const 1_i32) -> bb70
  using: _229@Entry, _13@Entry
bb70:
  _13 = move (_229.0: i32)
  using: _229@Mir(bb69[0])
  goto -> bb10
  using: 
bb71:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:814:22: 814:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:816:33: 817:50 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:817:52: 818:90 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:819:29: 819:68 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:821:48: 821:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:821:22: 821:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:825:18: 825:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:829:22: 829:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:831:33: 832:50 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:832:52: 833:90 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:834:29: 834:68 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:836:48: 836:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:836:22: 836:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:840:18: 840:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:844:22: 844:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:846:33: 847:50 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:847:52: 848:90 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:849:29: 849:68 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:851:48: 851:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:851:22: 851:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:855:18: 855:36 (#0) by default
@DefId(0:31 ~ c2rust_lib[1043]::blocksort::mmed3)
bb0:
  _4 = const 0_u8
  using: 
  _7 = _1
  using: _1@Entry
  _6 = move _7 as i32 (IntToInt)
  using: _7@Mir(bb0[1])
  _9 = _2
  using: _2@Entry
  _8 = move _9 as i32 (IntToInt)
  using: _9@Mir(bb0[3])
  _5 = Gt(move _6, move _8)
  using: _6@Mir(bb0[2]), _8@Mir(bb0[4])
  switchInt(move _5) -> [0: bb2, otherwise: bb1]
  using: _5@Mir(bb0[5])
bb1:
  _10 = _1
  using: _1@Entry
  _4 = move _10
  using: _10@Mir(bb1[0])
  _11 = _2
  using: _2@Entry
  _1 = move _11
  using: _11@Mir(bb1[2])
  _12 = _4
  using: _4@Mir(bb1[1])
  _2 = move _12
  using: _12@Mir(bb1[4])
  goto -> bb2
  using: 
bb2:
  _15 = _2
  using: _2@Phi(bb2)
  _14 = move _15 as i32 (IntToInt)
  using: _15@Mir(bb2[0])
  _17 = _3
  using: _3@Entry
  _16 = move _17 as i32 (IntToInt)
  using: _17@Mir(bb2[2])
  _13 = Gt(move _14, move _16)
  using: _14@Mir(bb2[1]), _16@Mir(bb2[3])
  switchInt(move _13) -> [0: bb5, otherwise: bb3]
  using: _13@Mir(bb2[4])
bb3:
  _18 = _3
  using: _3@Entry
  _2 = move _18
  using: _18@Mir(bb3[0])
  _21 = _1
  using: _1@Phi(bb2)
  _20 = move _21 as i32 (IntToInt)
  using: _21@Mir(bb3[2])
  _23 = _2
  using: _2@Mir(bb3[1])
  _22 = move _23 as i32 (IntToInt)
  using: _23@Mir(bb3[4])
  _19 = Gt(move _20, move _22)
  using: _20@Mir(bb3[3]), _22@Mir(bb3[5])
  switchInt(move _19) -> [0: bb5, otherwise: bb4]
  using: _19@Mir(bb3[6])
bb4:
  _24 = _1
  using: _1@Phi(bb2)
  _2 = move _24
  using: _24@Mir(bb4[0])
  goto -> bb5
  using: 
bb5:
  _0 = _2
  using: _2@Phi(bb5)
  return
  using: _0@Mir(bb5[0])
@DefId(0:32 ~ c2rust_lib[1043]::blocksort::mainQSort3)
bb0:
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  _14 = const 0_i32
  using: 
  _15 = const 0_i32
  using: 
  _16 = const 0_i32
  using: 
  _17 = const 0_i32
  using: 
  _18 = const 0_i32
  using: 
  _19 = const 0_i32
  using: 
  _20 = [const 0_i32; 100]
  using: 
  _21 = [const 0_i32; 100]
  using: 
  _22 = [const 0_i32; 100]
  using: 
  _23 = [const 0_i32; 3]
  using: 
  _24 = [const 0_i32; 3]
  using: 
  _25 = [const 0_i32; 3]
  using: 
  _16 = const 0_i32
  using: 
  _26 = _5
  using: _5@Entry
  _27 = const 0_usize
  using: 
  _20[_27] = move _26
  using: _27@Mir(bb0[19]), _26@Mir(bb0[18])
  _28 = _6
  using: _6@Entry
  _30 = _16
  using: _16@Mir(bb0[17])
  _29 = move _30 as usize (IntToInt)
  using: _30@Mir(bb0[22])
  _31 = const 100_usize
  using: 
  _32 = Lt(_29, _31)
  using: _29@Mir(bb0[23]), _31@Mir(bb0[24])
  assert(move _32, "index out of bounds: the length is {} but the index is {}", move _31, _29) -> bb1
  using: _32@Entry, _31@Entry, _29@Entry
bb1:
  _21[_29] = move _28
  using: _29@Mir(bb0[23]), _28@Mir(bb0[21])
  _33 = _7
  using: _7@Entry
  _35 = _16
  using: _16@Mir(bb0[17])
  _34 = move _35 as usize (IntToInt)
  using: _35@Mir(bb1[2])
  _36 = const 100_usize
  using: 
  _37 = Lt(_34, _36)
  using: _34@Mir(bb1[3]), _36@Mir(bb1[4])
  assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _34) -> bb2
  using: _37@Entry, _36@Entry, _34@Entry
bb2:
  _22[_34] = move _33
  using: _34@Mir(bb1[3]), _33@Mir(bb1[1])
  _38 = CheckedAdd(_16, const 1_i32)
  using: _16@Mir(bb0[17])
  assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, const 1_i32) -> bb3
  using: _38@Entry, _16@Entry
bb3:
  _16 = move (_38.0: i32)
  using: _38@Mir(bb2[1])
  goto -> bb4
  using: 
bb4:
  _40 = _16
  using: _16@Phi(bb4)
  _41 = const 0_i32
  using: 
  _39 = Gt(move _40, move _41)
  using: _40@Mir(bb4[0]), _41@Mir(bb4[1])
  switchInt(move _39) -> [0: bb150, otherwise: bb5]
  using: _39@Mir(bb4[2])
bb5:
  _44 = _16
  using: _16@Phi(bb4)
  _45 = const 98_i32
  using: 
  _43 = Lt(move _44, move _45)
  using: _44@Mir(bb5[0]), _45@Mir(bb5[1])
  _42 = Not(move _43)
  using: _43@Mir(bb5[2])
  switchInt(move _42) -> [0: bb7, otherwise: bb6]
  using: _42@Mir(bb5[3])
bb6:
  _47 = const 1001_i32
  using: 
  _46 = bzlib::BZ2_bz__AssertH__fail(move _47) -> bb7
  using: _47@Mir(bb6[0])
bb7:
  _48 = CheckedSub(_16, const 1_i32)
  using: _16@Phi(bb4)
  assert(!move (_48.1: bool), "attempt to compute `{} - {}`, which would overflow", _16, const 1_i32) -> bb8
  using: _48@Entry, _16@Entry
bb8:
  _16 = move (_48.0: i32)
  using: _48@Mir(bb7[0])
  _51 = _16
  using: _16@Mir(bb8[0])
  _50 = move _51 as usize (IntToInt)
  using: _51@Mir(bb8[1])
  _52 = const 100_usize
  using: 
  _53 = Lt(_50, _52)
  using: _50@Mir(bb8[2]), _52@Mir(bb8[3])
  assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _50) -> bb9
  using: _53@Entry, _52@Entry, _50@Entry
bb9:
  _49 = _20[_50]
  using: _20@Phi(bb4), _50@Mir(bb8[2])
  _17 = move _49
  using: _49@Mir(bb9[0])
  _56 = _16
  using: _16@Mir(bb8[0])
  _55 = move _56 as usize (IntToInt)
  using: _56@Mir(bb9[2])
  _57 = const 100_usize
  using: 
  _58 = Lt(_55, _57)
  using: _55@Mir(bb9[3]), _57@Mir(bb9[4])
  assert(move _58, "index out of bounds: the length is {} but the index is {}", move _57, _55) -> bb10
  using: _58@Entry, _57@Entry, _55@Entry
bb10:
  _54 = _21[_55]
  using: _21@Phi(bb4), _55@Mir(bb9[3])
  _18 = move _54
  using: _54@Mir(bb10[0])
  _61 = _16
  using: _16@Mir(bb8[0])
  _60 = move _61 as usize (IntToInt)
  using: _61@Mir(bb10[2])
  _62 = const 100_usize
  using: 
  _63 = Lt(_60, _62)
  using: _60@Mir(bb10[3]), _62@Mir(bb10[4])
  assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _60) -> bb11
  using: _63@Entry, _62@Entry, _60@Entry
bb11:
  _59 = _22[_60]
  using: _22@Phi(bb4), _60@Mir(bb10[3])
  _19 = move _59
  using: _59@Mir(bb11[0])
  _67 = _18
  using: _18@Mir(bb10[1])
  _68 = _17
  using: _17@Mir(bb9[1])
  _69 = CheckedSub(_67, _68)
  using: _67@Mir(bb11[2]), _68@Mir(bb11[3])
  assert(!move (_69.1: bool), "attempt to compute `{} - {}`, which would overflow", move _67, move _68) -> bb15
  using: _69@Entry, _67@Entry, _68@Entry
bb12:
  _64 = const true
  using: 
  goto -> bb14
  using: 
bb13:
  _72 = _19
  using: _19@Mir(bb11[1])
  _73 = const 14_i32
  using: 
  _71 = Gt(move _72, move _73)
  using: _72@Mir(bb13[0]), _73@Mir(bb13[1])
  _64 = move _71
  using: _71@Mir(bb13[2])
  goto -> bb14
  using: 
bb14:
  switchInt(move _64) -> [0: bb18, otherwise: bb16]
  using: _64@Phi(bb14)
bb15:
  _66 = move (_69.0: i32)
  using: _69@Mir(bb11[4])
  _70 = const 20_i32
  using: 
  _65 = Lt(move _66, move _70)
  using: _66@Mir(bb15[0]), _70@Mir(bb15[1])
  switchInt(move _65) -> [0: bb13, otherwise: bb12]
  using: _65@Mir(bb15[2])
bb16:
  _75 = _1
  using: _1@Phi(bb4)
  _76 = _2
  using: _2@Phi(bb4)
  _77 = _3
  using: _3@Phi(bb4)
  _78 = _4
  using: _4@Phi(bb4)
  _79 = _17
  using: _17@Mir(bb9[1])
  _80 = _18
  using: _18@Mir(bb10[1])
  _81 = _19
  using: _19@Phi(bb14)
  _82 = _8
  using: _8@Phi(bb4)
  _74 = blocksort::mainSimpleSort(move _75, move _76, move _77, move _78, move _79, move _80, move _81, move _82) -> bb17
  using: _75@Mir(bb16[0]), _76@Mir(bb16[1]), _77@Mir(bb16[2]), _78@Mir(bb16[3]), _79@Mir(bb16[4]), _80@Mir(bb16[5]), _81@Mir(bb16[6]), _82@Mir(bb16[7])
bb17:
  _84 = (*_8)
  using: _8@Phi(bb4)
  _85 = const 0_i32
  using: 
  _83 = Lt(move _84, move _85)
  using: _84@Mir(bb17[0]), _85@Mir(bb17[1])
  switchInt(move _83) -> [0: bb4, otherwise: bb150]
  using: _83@Mir(bb17[2])
bb18:
  _89 = _2
  using: _2@Phi(bb4)
  _94 = _1
  using: _1@Phi(bb4)
  _96 = _17
  using: _17@Mir(bb9[1])
  _95 = move _96 as isize (IntToInt)
  using: _96@Mir(bb18[2])
  _93 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _94, move _95) -> bb19
  using: _94@Mir(bb18[1]), _95@Mir(bb18[3])
bb19:
  _92 = (*_93)
  using: _93@Mir(bb18[4])
  _98 = _19
  using: _19@Phi(bb14)
  _97 = move _98 as u32 (IntToInt)
  using: _98@Mir(bb19[1])
  _91 = core::num::<impl u32>::wrapping_add(move _92, move _97) -> bb20
  using: _92@Mir(bb19[0]), _97@Mir(bb19[2])
bb20:
  _90 = move _91 as isize (IntToInt)
  using: _91@Mir(bb19[3])
  _88 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _89, move _90) -> bb21
  using: _89@Mir(bb18[0]), _90@Mir(bb20[0])
bb21:
  _87 = (*_88)
  using: _88@Mir(bb20[1])
  _101 = _2
  using: _2@Phi(bb4)
  _106 = _1
  using: _1@Phi(bb4)
  _108 = _18
  using: _18@Mir(bb10[1])
  _107 = move _108 as isize (IntToInt)
  using: _108@Mir(bb21[3])
  _105 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _106, move _107) -> bb22
  using: _106@Mir(bb21[2]), _107@Mir(bb21[4])
bb22:
  _104 = (*_105)
  using: _105@Mir(bb21[5])
  _110 = _19
  using: _19@Phi(bb14)
  _109 = move _110 as u32 (IntToInt)
  using: _110@Mir(bb22[1])
  _103 = core::num::<impl u32>::wrapping_add(move _104, move _109) -> bb23
  using: _104@Mir(bb22[0]), _109@Mir(bb22[2])
bb23:
  _102 = move _103 as isize (IntToInt)
  using: _103@Mir(bb22[3])
  _100 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _101, move _102) -> bb24
  using: _101@Mir(bb21[1]), _102@Mir(bb23[0])
bb24:
  _99 = (*_100)
  using: _100@Mir(bb23[1])
  _113 = _2
  using: _2@Phi(bb4)
  _118 = _1
  using: _1@Phi(bb4)
  _122 = _17
  using: _17@Mir(bb9[1])
  _123 = _18
  using: _18@Mir(bb10[1])
  _124 = CheckedAdd(_122, _123)
  using: _122@Mir(bb24[3]), _123@Mir(bb24[4])
  assert(!move (_124.1: bool), "attempt to compute `{} + {}`, which would overflow", move _122, move _123) -> bb25
  using: _124@Entry, _122@Entry, _123@Entry
bb25:
  _121 = move (_124.0: i32)
  using: _124@Mir(bb24[5])
  _125 = const 1_i32
  using: 
  _126 = CheckedShr(_121, _125)
  using: _121@Mir(bb25[0]), _125@Mir(bb25[1])
  assert(!move (_126.1: bool), "attempt to shift right by `{}`, which would overflow", move _125) -> bb26
  using: _126@Entry, _121@Entry, _125@Entry
bb26:
  _120 = move (_126.0: i32)
  using: _126@Mir(bb25[2])
  _119 = move _120 as isize (IntToInt)
  using: _120@Mir(bb26[0])
  _117 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _118, move _119) -> bb27
  using: _118@Mir(bb24[2]), _119@Mir(bb26[1])
bb27:
  _116 = (*_117)
  using: _117@Mir(bb26[2])
  _128 = _19
  using: _19@Phi(bb14)
  _127 = move _128 as u32 (IntToInt)
  using: _128@Mir(bb27[1])
  _115 = core::num::<impl u32>::wrapping_add(move _116, move _127) -> bb28
  using: _116@Mir(bb27[0]), _127@Mir(bb27[2])
bb28:
  _114 = move _115 as isize (IntToInt)
  using: _115@Mir(bb27[3])
  _112 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _113, move _114) -> bb29
  using: _113@Mir(bb24[1]), _114@Mir(bb28[0])
bb29:
  _111 = (*_112)
  using: _112@Mir(bb28[1])
  _86 = blocksort::mmed3(move _87, move _99, move _111) -> bb30
  using: _87@Mir(bb21[0]), _99@Mir(bb24[0]), _111@Mir(bb29[0])
bb30:
  _15 = move _86 as i32 (IntToInt)
  using: _86@Mir(bb29[1])
  _129 = _17
  using: _17@Mir(bb9[1])
  _11 = move _129
  using: _129@Mir(bb30[1])
  _130 = _11
  using: _11@Mir(bb30[2])
  _9 = move _130
  using: _130@Mir(bb30[3])
  _131 = _18
  using: _18@Mir(bb10[1])
  _12 = move _131
  using: _131@Mir(bb30[5])
  _132 = _12
  using: _12@Mir(bb30[6])
  _10 = move _132
  using: _132@Mir(bb30[7])
  goto -> bb31
  using: 
bb31:
  goto -> bb32
  using: 
bb32:
  _134 = _9
  using: _9@Phi(bb32)
  _135 = _10
  using: _10@Phi(bb31)
  _133 = Gt(move _134, move _135)
  using: _134@Mir(bb32[0]), _135@Mir(bb32[1])
  switchInt(move _133) -> [0: bb33, otherwise: bb48]
  using: _133@Mir(bb32[2])
bb33:
  _139 = _2
  using: _2@Phi(bb32)
  _144 = _1
  using: _1@Phi(bb32)
  _146 = _9
  using: _9@Phi(bb32)
  _145 = move _146 as isize (IntToInt)
  using: _146@Mir(bb33[2])
  _143 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _144, move _145) -> bb34
  using: _144@Mir(bb33[1]), _145@Mir(bb33[3])
bb34:
  _142 = (*_143)
  using: _143@Mir(bb33[4])
  _148 = _19
  using: _19@Phi(bb32)
  _147 = move _148 as u32 (IntToInt)
  using: _148@Mir(bb34[1])
  _141 = core::num::<impl u32>::wrapping_add(move _142, move _147) -> bb35
  using: _142@Mir(bb34[0]), _147@Mir(bb34[2])
bb35:
  _140 = move _141 as isize (IntToInt)
  using: _141@Mir(bb34[3])
  _138 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _139, move _140) -> bb36
  using: _139@Mir(bb33[0]), _140@Mir(bb35[0])
bb36:
  _137 = (*_138)
  using: _138@Mir(bb35[1])
  _136 = move _137 as i32 (IntToInt)
  using: _137@Mir(bb36[0])
  _149 = _15
  using: _15@Phi(bb32)
  _150 = CheckedSub(_136, _149)
  using: _136@Mir(bb36[1]), _149@Mir(bb36[2])
  assert(!move (_150.1: bool), "attempt to compute `{} - {}`, which would overflow", move _136, move _149) -> bb37
  using: _150@Entry, _136@Entry, _149@Entry
bb37:
  _13 = move (_150.0: i32)
  using: _150@Mir(bb36[3])
  _152 = _13
  using: _13@Mir(bb37[0])
  _153 = const 0_i32
  using: 
  _151 = Eq(move _152, move _153)
  using: _152@Mir(bb37[1]), _153@Mir(bb37[2])
  switchInt(move _151) -> [0: bb45, otherwise: bb38]
  using: _151@Mir(bb37[3])
bb38:
  _157 = _1
  using: _1@Phi(bb32)
  _159 = _9
  using: _9@Phi(bb32)
  _158 = move _159 as isize (IntToInt)
  using: _159@Mir(bb38[1])
  _156 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _157, move _158) -> bb39
  using: _157@Mir(bb38[0]), _158@Mir(bb38[2])
bb39:
  _155 = (*_156)
  using: _156@Mir(bb38[3])
  _154 = move _155 as i32 (IntToInt)
  using: _155@Mir(bb39[0])
  _162 = _1
  using: _1@Phi(bb32)
  _164 = _11
  using: _11@Phi(bb32)
  _163 = move _164 as isize (IntToInt)
  using: _164@Mir(bb39[3])
  _161 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _162, move _163) -> bb40
  using: _162@Mir(bb39[2]), _163@Mir(bb39[4])
bb40:
  _160 = (*_161)
  using: _161@Mir(bb39[5])
  _166 = _1
  using: _1@Phi(bb32)
  _168 = _9
  using: _9@Phi(bb32)
  _167 = move _168 as isize (IntToInt)
  using: _168@Mir(bb40[2])
  _165 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _166, move _167) -> bb41
  using: _166@Mir(bb40[1]), _167@Mir(bb40[3])
bb41:
  (*_165) = move _160
  using: _165@Mir(bb40[4]), _160@Mir(bb40[0])
  _169 = _154
  using: _154@Mir(bb39[1])
  _171 = _1
  using: _1@Phi(bb32)
  _173 = _11
  using: _11@Phi(bb32)
  _172 = move _173 as isize (IntToInt)
  using: _173@Mir(bb41[3])
  _170 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _171, move _172) -> bb42
  using: _171@Mir(bb41[2]), _172@Mir(bb41[4])
bb42:
  (*_170) = move _169 as u32 (IntToInt)
  using: _170@Mir(bb41[5]), _169@Mir(bb41[1])
  _174 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb32)
  assert(!move (_174.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb43
  using: _174@Entry, _11@Entry
bb43:
  _11 = move (_174.0: i32)
  using: _174@Mir(bb42[1])
  _175 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb32)
  assert(!move (_175.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb44
  using: _175@Entry, _9@Entry
bb44:
  _9 = move (_175.0: i32)
  using: _175@Mir(bb43[1])
  goto -> bb32
  using: 
bb45:
  _177 = _13
  using: _13@Mir(bb37[0])
  _178 = const 0_i32
  using: 
  _176 = Gt(move _177, move _178)
  using: _177@Mir(bb45[0]), _178@Mir(bb45[1])
  switchInt(move _176) -> [0: bb46, otherwise: bb48]
  using: _176@Mir(bb45[2])
bb46:
  _179 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb32)
  assert(!move (_179.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb47
  using: _179@Entry, _9@Entry
bb47:
  _9 = move (_179.0: i32)
  using: _179@Mir(bb46[0])
  goto -> bb32
  using: 
bb48:
  _181 = _9
  using: _9@Phi(bb48)
  _182 = _10
  using: _10@Phi(bb48)
  _180 = Gt(move _181, move _182)
  using: _181@Mir(bb48[0]), _182@Mir(bb48[1])
  switchInt(move _180) -> [0: bb49, otherwise: bb64]
  using: _180@Mir(bb48[2])
bb49:
  _186 = _2
  using: _2@Phi(bb48)
  _191 = _1
  using: _1@Phi(bb48)
  _193 = _10
  using: _10@Phi(bb48)
  _192 = move _193 as isize (IntToInt)
  using: _193@Mir(bb49[2])
  _190 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _191, move _192) -> bb50
  using: _191@Mir(bb49[1]), _192@Mir(bb49[3])
bb50:
  _189 = (*_190)
  using: _190@Mir(bb49[4])
  _195 = _19
  using: _19@Phi(bb48)
  _194 = move _195 as u32 (IntToInt)
  using: _195@Mir(bb50[1])
  _188 = core::num::<impl u32>::wrapping_add(move _189, move _194) -> bb51
  using: _189@Mir(bb50[0]), _194@Mir(bb50[2])
bb51:
  _187 = move _188 as isize (IntToInt)
  using: _188@Mir(bb50[3])
  _185 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _186, move _187) -> bb52
  using: _186@Mir(bb49[0]), _187@Mir(bb51[0])
bb52:
  _184 = (*_185)
  using: _185@Mir(bb51[1])
  _183 = move _184 as i32 (IntToInt)
  using: _184@Mir(bb52[0])
  _196 = _15
  using: _15@Phi(bb48)
  _197 = CheckedSub(_183, _196)
  using: _183@Mir(bb52[1]), _196@Mir(bb52[2])
  assert(!move (_197.1: bool), "attempt to compute `{} - {}`, which would overflow", move _183, move _196) -> bb53
  using: _197@Entry, _183@Entry, _196@Entry
bb53:
  _13 = move (_197.0: i32)
  using: _197@Mir(bb52[3])
  _199 = _13
  using: _13@Mir(bb53[0])
  _200 = const 0_i32
  using: 
  _198 = Eq(move _199, move _200)
  using: _199@Mir(bb53[1]), _200@Mir(bb53[2])
  switchInt(move _198) -> [0: bb61, otherwise: bb54]
  using: _198@Mir(bb53[3])
bb54:
  _204 = _1
  using: _1@Phi(bb48)
  _206 = _10
  using: _10@Phi(bb48)
  _205 = move _206 as isize (IntToInt)
  using: _206@Mir(bb54[1])
  _203 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _204, move _205) -> bb55
  using: _204@Mir(bb54[0]), _205@Mir(bb54[2])
bb55:
  _202 = (*_203)
  using: _203@Mir(bb54[3])
  _201 = move _202 as i32 (IntToInt)
  using: _202@Mir(bb55[0])
  _209 = _1
  using: _1@Phi(bb48)
  _211 = _12
  using: _12@Phi(bb48)
  _210 = move _211 as isize (IntToInt)
  using: _211@Mir(bb55[3])
  _208 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _209, move _210) -> bb56
  using: _209@Mir(bb55[2]), _210@Mir(bb55[4])
bb56:
  _207 = (*_208)
  using: _208@Mir(bb55[5])
  _213 = _1
  using: _1@Phi(bb48)
  _215 = _10
  using: _10@Phi(bb48)
  _214 = move _215 as isize (IntToInt)
  using: _215@Mir(bb56[2])
  _212 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _213, move _214) -> bb57
  using: _213@Mir(bb56[1]), _214@Mir(bb56[3])
bb57:
  (*_212) = move _207
  using: _212@Mir(bb56[4]), _207@Mir(bb56[0])
  _216 = _201
  using: _201@Mir(bb55[1])
  _218 = _1
  using: _1@Phi(bb48)
  _220 = _12
  using: _12@Phi(bb48)
  _219 = move _220 as isize (IntToInt)
  using: _220@Mir(bb57[3])
  _217 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _218, move _219) -> bb58
  using: _218@Mir(bb57[2]), _219@Mir(bb57[4])
bb58:
  (*_217) = move _216 as u32 (IntToInt)
  using: _217@Mir(bb57[5]), _216@Mir(bb57[1])
  _221 = CheckedSub(_12, const 1_i32)
  using: _12@Phi(bb48)
  assert(!move (_221.1: bool), "attempt to compute `{} - {}`, which would overflow", _12, const 1_i32) -> bb59
  using: _221@Entry, _12@Entry
bb59:
  _12 = move (_221.0: i32)
  using: _221@Mir(bb58[1])
  _222 = CheckedSub(_10, const 1_i32)
  using: _10@Phi(bb48)
  assert(!move (_222.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 1_i32) -> bb60
  using: _222@Entry, _10@Entry
bb60:
  _10 = move (_222.0: i32)
  using: _222@Mir(bb59[1])
  goto -> bb48
  using: 
bb61:
  _224 = _13
  using: _13@Mir(bb53[0])
  _225 = const 0_i32
  using: 
  _223 = Lt(move _224, move _225)
  using: _224@Mir(bb61[0]), _225@Mir(bb61[1])
  switchInt(move _223) -> [0: bb62, otherwise: bb64]
  using: _223@Mir(bb61[2])
bb62:
  _226 = CheckedSub(_10, const 1_i32)
  using: _10@Phi(bb48)
  assert(!move (_226.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 1_i32) -> bb63
  using: _226@Entry, _10@Entry
bb63:
  _10 = move (_226.0: i32)
  using: _226@Mir(bb62[0])
  goto -> bb48
  using: 
bb64:
  _228 = _9
  using: _9@Phi(bb48)
  _229 = _10
  using: _10@Phi(bb64)
  _227 = Gt(move _228, move _229)
  using: _228@Mir(bb64[0]), _229@Mir(bb64[1])
  switchInt(move _227) -> [0: bb65, otherwise: bb72]
  using: _227@Mir(bb64[2])
bb65:
  _233 = _1
  using: _1@Phi(bb64)
  _235 = _9
  using: _9@Phi(bb48)
  _234 = move _235 as isize (IntToInt)
  using: _235@Mir(bb65[1])
  _232 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _233, move _234) -> bb66
  using: _233@Mir(bb65[0]), _234@Mir(bb65[2])
bb66:
  _231 = (*_232)
  using: _232@Mir(bb65[3])
  _230 = move _231 as i32 (IntToInt)
  using: _231@Mir(bb66[0])
  _238 = _1
  using: _1@Phi(bb64)
  _240 = _10
  using: _10@Phi(bb64)
  _239 = move _240 as isize (IntToInt)
  using: _240@Mir(bb66[3])
  _237 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _238, move _239) -> bb67
  using: _238@Mir(bb66[2]), _239@Mir(bb66[4])
bb67:
  _236 = (*_237)
  using: _237@Mir(bb66[5])
  _242 = _1
  using: _1@Phi(bb64)
  _244 = _9
  using: _9@Phi(bb48)
  _243 = move _244 as isize (IntToInt)
  using: _244@Mir(bb67[2])
  _241 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _242, move _243) -> bb68
  using: _242@Mir(bb67[1]), _243@Mir(bb67[3])
bb68:
  (*_241) = move _236
  using: _241@Mir(bb67[4]), _236@Mir(bb67[0])
  _245 = _230
  using: _230@Mir(bb66[1])
  _247 = _1
  using: _1@Phi(bb64)
  _249 = _10
  using: _10@Phi(bb64)
  _248 = move _249 as isize (IntToInt)
  using: _249@Mir(bb68[3])
  _246 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _247, move _248) -> bb69
  using: _247@Mir(bb68[2]), _248@Mir(bb68[4])
bb69:
  (*_246) = move _245 as u32 (IntToInt)
  using: _246@Mir(bb68[5]), _245@Mir(bb68[1])
  _250 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb48)
  assert(!move (_250.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb70
  using: _250@Entry, _9@Entry
bb70:
  _9 = move (_250.0: i32)
  using: _250@Mir(bb69[1])
  _251 = CheckedSub(_10, const 1_i32)
  using: _10@Phi(bb64)
  assert(!move (_251.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 1_i32) -> bb71
  using: _251@Entry, _10@Entry
bb71:
  _10 = move (_251.0: i32)
  using: _251@Mir(bb70[1])
  goto -> bb31
  using: 
bb72:
  _253 = _12
  using: _12@Phi(bb48)
  _254 = _11
  using: _11@Phi(bb32)
  _252 = Lt(move _253, move _254)
  using: _253@Mir(bb72[0]), _254@Mir(bb72[1])
  switchInt(move _252) -> [0: bb79, otherwise: bb73]
  using: _252@Mir(bb72[2])
bb73:
  _255 = _17
  using: _17@Mir(bb9[1])
  _257 = _16
  using: _16@Mir(bb8[0])
  _256 = move _257 as usize (IntToInt)
  using: _257@Mir(bb73[1])
  _258 = const 100_usize
  using: 
  _259 = Lt(_256, _258)
  using: _256@Mir(bb73[2]), _258@Mir(bb73[3])
  assert(move _259, "index out of bounds: the length is {} but the index is {}", move _258, _256) -> bb74
  using: _259@Entry, _258@Entry, _256@Entry
bb74:
  _20[_256] = move _255
  using: _256@Mir(bb73[2]), _255@Mir(bb73[0])
  _260 = _18
  using: _18@Mir(bb10[1])
  _262 = _16
  using: _16@Mir(bb8[0])
  _261 = move _262 as usize (IntToInt)
  using: _262@Mir(bb74[2])
  _263 = const 100_usize
  using: 
  _264 = Lt(_261, _263)
  using: _261@Mir(bb74[3]), _263@Mir(bb74[4])
  assert(move _264, "index out of bounds: the length is {} but the index is {}", move _263, _261) -> bb75
  using: _264@Entry, _263@Entry, _261@Entry
bb75:
  _21[_261] = move _260
  using: _261@Mir(bb74[3]), _260@Mir(bb74[1])
  _265 = _19
  using: _19@Phi(bb64)
  _266 = const 1_i32
  using: 
  _267 = CheckedAdd(_265, _266)
  using: _265@Mir(bb75[1]), _266@Mir(bb75[2])
  assert(!move (_267.1: bool), "attempt to compute `{} + {}`, which would overflow", move _265, move _266) -> bb76
  using: _267@Entry, _265@Entry, _266@Entry
bb76:
  _269 = _16
  using: _16@Mir(bb8[0])
  _268 = move _269 as usize (IntToInt)
  using: _269@Mir(bb76[0])
  _270 = const 100_usize
  using: 
  _271 = Lt(_268, _270)
  using: _268@Mir(bb76[1]), _270@Mir(bb76[2])
  assert(move _271, "index out of bounds: the length is {} but the index is {}", move _270, _268) -> bb77
  using: _271@Entry, _270@Entry, _268@Entry
bb77:
  _22[_268] = move (_267.0: i32)
  using: _268@Mir(bb76[1]), _267@Mir(bb75[3])
  _272 = CheckedAdd(_16, const 1_i32)
  using: _16@Mir(bb8[0])
  assert(!move (_272.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, const 1_i32) -> bb78
  using: _272@Entry, _16@Entry
bb78:
  _16 = move (_272.0: i32)
  using: _272@Mir(bb77[1])
  goto -> bb4
  using: 
bb79:
  _276 = _11
  using: _11@Phi(bb32)
  _277 = _17
  using: _17@Mir(bb9[1])
  _278 = CheckedSub(_276, _277)
  using: _276@Mir(bb79[0]), _277@Mir(bb79[1])
  assert(!move (_278.1: bool), "attempt to compute `{} - {}`, which would overflow", move _276, move _277) -> bb80
  using: _278@Entry, _276@Entry, _277@Entry
bb80:
  _275 = move (_278.0: i32)
  using: _278@Mir(bb79[2])
  _280 = _9
  using: _9@Phi(bb48)
  _281 = _11
  using: _11@Phi(bb32)
  _282 = CheckedSub(_280, _281)
  using: _280@Mir(bb80[1]), _281@Mir(bb80[2])
  assert(!move (_282.1: bool), "attempt to compute `{} - {}`, which would overflow", move _280, move _281) -> bb81
  using: _282@Entry, _280@Entry, _281@Entry
bb81:
  _279 = move (_282.0: i32)
  using: _282@Mir(bb80[3])
  _274 = Lt(move _275, move _279)
  using: _275@Mir(bb80[0]), _279@Mir(bb81[0])
  switchInt(move _274) -> [0: bb84, otherwise: bb82]
  using: _274@Mir(bb81[1])
bb82:
  _283 = _11
  using: _11@Phi(bb32)
  _284 = _17
  using: _17@Mir(bb9[1])
  _285 = CheckedSub(_283, _284)
  using: _283@Mir(bb82[0]), _284@Mir(bb82[1])
  assert(!move (_285.1: bool), "attempt to compute `{} - {}`, which would overflow", move _283, move _284) -> bb83
  using: _285@Entry, _283@Entry, _284@Entry
bb83:
  _273 = move (_285.0: i32)
  using: _285@Mir(bb82[2])
  goto -> bb86
  using: 
bb84:
  _286 = _9
  using: _9@Phi(bb48)
  _287 = _11
  using: _11@Phi(bb32)
  _288 = CheckedSub(_286, _287)
  using: _286@Mir(bb84[0]), _287@Mir(bb84[1])
  assert(!move (_288.1: bool), "attempt to compute `{} - {}`, which would overflow", move _286, move _287) -> bb85
  using: _288@Entry, _286@Entry, _287@Entry
bb85:
  _273 = move (_288.0: i32)
  using: _288@Mir(bb84[2])
  goto -> bb86
  using: 
bb86:
  _13 = move _273
  using: _273@Phi(bb86)
  _289 = _17
  using: _17@Phi(bb86)
  _291 = _9
  using: _9@Phi(bb86)
  _292 = _13
  using: _13@Mir(bb86[0])
  _293 = CheckedSub(_291, _292)
  using: _291@Mir(bb86[2]), _292@Mir(bb86[3])
  assert(!move (_293.1: bool), "attempt to compute `{} - {}`, which would overflow", move _291, move _292) -> bb87
  using: _293@Entry, _291@Entry, _292@Entry
bb87:
  _290 = move (_293.0: i32)
  using: _293@Mir(bb86[4])
  _294 = _13
  using: _13@Mir(bb86[0])
  goto -> bb88
  using: 
bb88:
  _296 = _294
  using: _294@Phi(bb88)
  _297 = const 0_i32
  using: 
  _295 = Gt(move _296, move _297)
  using: _296@Mir(bb88[0]), _297@Mir(bb88[1])
  switchInt(move _295) -> [0: bb97, otherwise: bb89]
  using: _295@Mir(bb88[2])
bb89:
  _301 = _1
  using: _1@Phi(bb88)
  _303 = _289
  using: _289@Phi(bb88)
  _302 = move _303 as isize (IntToInt)
  using: _303@Mir(bb89[1])
  _300 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _301, move _302) -> bb90
  using: _301@Mir(bb89[0]), _302@Mir(bb89[2])
bb90:
  _299 = (*_300)
  using: _300@Mir(bb89[3])
  _298 = move _299 as i32 (IntToInt)
  using: _299@Mir(bb90[0])
  _306 = _1
  using: _1@Phi(bb88)
  _308 = _290
  using: _290@Phi(bb88)
  _307 = move _308 as isize (IntToInt)
  using: _308@Mir(bb90[3])
  _305 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _306, move _307) -> bb91
  using: _306@Mir(bb90[2]), _307@Mir(bb90[4])
bb91:
  _304 = (*_305)
  using: _305@Mir(bb90[5])
  _310 = _1
  using: _1@Phi(bb88)
  _312 = _289
  using: _289@Phi(bb88)
  _311 = move _312 as isize (IntToInt)
  using: _312@Mir(bb91[2])
  _309 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _310, move _311) -> bb92
  using: _310@Mir(bb91[1]), _311@Mir(bb91[3])
bb92:
  (*_309) = move _304
  using: _309@Mir(bb91[4]), _304@Mir(bb91[0])
  _313 = _298
  using: _298@Mir(bb90[1])
  _315 = _1
  using: _1@Phi(bb88)
  _317 = _290
  using: _290@Phi(bb88)
  _316 = move _317 as isize (IntToInt)
  using: _317@Mir(bb92[3])
  _314 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _315, move _316) -> bb93
  using: _315@Mir(bb92[2]), _316@Mir(bb92[4])
bb93:
  (*_314) = move _313 as u32 (IntToInt)
  using: _314@Mir(bb92[5]), _313@Mir(bb92[1])
  _318 = CheckedAdd(_289, const 1_i32)
  using: _289@Phi(bb88)
  assert(!move (_318.1: bool), "attempt to compute `{} + {}`, which would overflow", _289, const 1_i32) -> bb94
  using: _318@Entry, _289@Entry
bb94:
  _289 = move (_318.0: i32)
  using: _318@Mir(bb93[1])
  _319 = CheckedAdd(_290, const 1_i32)
  using: _290@Phi(bb88)
  assert(!move (_319.1: bool), "attempt to compute `{} + {}`, which would overflow", _290, const 1_i32) -> bb95
  using: _319@Entry, _290@Entry
bb95:
  _290 = move (_319.0: i32)
  using: _319@Mir(bb94[1])
  _320 = CheckedSub(_294, const 1_i32)
  using: _294@Phi(bb88)
  assert(!move (_320.1: bool), "attempt to compute `{} - {}`, which would overflow", _294, const 1_i32) -> bb96
  using: _320@Entry, _294@Entry
bb96:
  _294 = move (_320.0: i32)
  using: _320@Mir(bb95[1])
  goto -> bb88
  using: 
bb97:
  _324 = _18
  using: _18@Mir(bb10[1])
  _325 = _12
  using: _12@Phi(bb48)
  _326 = CheckedSub(_324, _325)
  using: _324@Mir(bb97[0]), _325@Mir(bb97[1])
  assert(!move (_326.1: bool), "attempt to compute `{} - {}`, which would overflow", move _324, move _325) -> bb98
  using: _326@Entry, _324@Entry, _325@Entry
bb98:
  _323 = move (_326.0: i32)
  using: _326@Mir(bb97[2])
  _328 = _12
  using: _12@Phi(bb48)
  _329 = _10
  using: _10@Phi(bb64)
  _330 = CheckedSub(_328, _329)
  using: _328@Mir(bb98[1]), _329@Mir(bb98[2])
  assert(!move (_330.1: bool), "attempt to compute `{} - {}`, which would overflow", move _328, move _329) -> bb99
  using: _330@Entry, _328@Entry, _329@Entry
bb99:
  _327 = move (_330.0: i32)
  using: _330@Mir(bb98[3])
  _322 = Lt(move _323, move _327)
  using: _323@Mir(bb98[0]), _327@Mir(bb99[0])
  switchInt(move _322) -> [0: bb102, otherwise: bb100]
  using: _322@Mir(bb99[1])
bb100:
  _331 = _18
  using: _18@Mir(bb10[1])
  _332 = _12
  using: _12@Phi(bb48)
  _333 = CheckedSub(_331, _332)
  using: _331@Mir(bb100[0]), _332@Mir(bb100[1])
  assert(!move (_333.1: bool), "attempt to compute `{} - {}`, which would overflow", move _331, move _332) -> bb101
  using: _333@Entry, _331@Entry, _332@Entry
bb101:
  _321 = move (_333.0: i32)
  using: _333@Mir(bb100[2])
  goto -> bb104
  using: 
bb102:
  _334 = _12
  using: _12@Phi(bb48)
  _335 = _10
  using: _10@Phi(bb64)
  _336 = CheckedSub(_334, _335)
  using: _334@Mir(bb102[0]), _335@Mir(bb102[1])
  assert(!move (_336.1: bool), "attempt to compute `{} - {}`, which would overflow", move _334, move _335) -> bb103
  using: _336@Entry, _334@Entry, _335@Entry
bb103:
  _321 = move (_336.0: i32)
  using: _336@Mir(bb102[2])
  goto -> bb104
  using: 
bb104:
  _14 = move _321
  using: _321@Phi(bb104)
  _337 = _9
  using: _9@Phi(bb86)
  _340 = _18
  using: _18@Phi(bb104)
  _341 = _14
  using: _14@Mir(bb104[0])
  _342 = CheckedSub(_340, _341)
  using: _340@Mir(bb104[2]), _341@Mir(bb104[3])
  assert(!move (_342.1: bool), "attempt to compute `{} - {}`, which would overflow", move _340, move _341) -> bb105
  using: _342@Entry, _340@Entry, _341@Entry
bb105:
  _339 = move (_342.0: i32)
  using: _342@Mir(bb104[4])
  _343 = const 1_i32
  using: 
  _344 = CheckedAdd(_339, _343)
  using: _339@Mir(bb105[0]), _343@Mir(bb105[1])
  assert(!move (_344.1: bool), "attempt to compute `{} + {}`, which would overflow", move _339, move _343) -> bb106
  using: _344@Entry, _339@Entry, _343@Entry
bb106:
  _338 = move (_344.0: i32)
  using: _344@Mir(bb105[2])
  _345 = _14
  using: _14@Mir(bb104[0])
  goto -> bb107
  using: 
bb107:
  _347 = _345
  using: _345@Phi(bb107)
  _348 = const 0_i32
  using: 
  _346 = Gt(move _347, move _348)
  using: _347@Mir(bb107[0]), _348@Mir(bb107[1])
  switchInt(move _346) -> [0: bb116, otherwise: bb108]
  using: _346@Mir(bb107[2])
bb108:
  _352 = _1
  using: _1@Phi(bb107)
  _354 = _337
  using: _337@Phi(bb107)
  _353 = move _354 as isize (IntToInt)
  using: _354@Mir(bb108[1])
  _351 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _352, move _353) -> bb109
  using: _352@Mir(bb108[0]), _353@Mir(bb108[2])
bb109:
  _350 = (*_351)
  using: _351@Mir(bb108[3])
  _349 = move _350 as i32 (IntToInt)
  using: _350@Mir(bb109[0])
  _357 = _1
  using: _1@Phi(bb107)
  _359 = _338
  using: _338@Phi(bb107)
  _358 = move _359 as isize (IntToInt)
  using: _359@Mir(bb109[3])
  _356 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _357, move _358) -> bb110
  using: _357@Mir(bb109[2]), _358@Mir(bb109[4])
bb110:
  _355 = (*_356)
  using: _356@Mir(bb109[5])
  _361 = _1
  using: _1@Phi(bb107)
  _363 = _337
  using: _337@Phi(bb107)
  _362 = move _363 as isize (IntToInt)
  using: _363@Mir(bb110[2])
  _360 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _361, move _362) -> bb111
  using: _361@Mir(bb110[1]), _362@Mir(bb110[3])
bb111:
  (*_360) = move _355
  using: _360@Mir(bb110[4]), _355@Mir(bb110[0])
  _364 = _349
  using: _349@Mir(bb109[1])
  _366 = _1
  using: _1@Phi(bb107)
  _368 = _338
  using: _338@Phi(bb107)
  _367 = move _368 as isize (IntToInt)
  using: _368@Mir(bb111[3])
  _365 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _366, move _367) -> bb112
  using: _366@Mir(bb111[2]), _367@Mir(bb111[4])
bb112:
  (*_365) = move _364 as u32 (IntToInt)
  using: _365@Mir(bb111[5]), _364@Mir(bb111[1])
  _369 = CheckedAdd(_337, const 1_i32)
  using: _337@Phi(bb107)
  assert(!move (_369.1: bool), "attempt to compute `{} + {}`, which would overflow", _337, const 1_i32) -> bb113
  using: _369@Entry, _337@Entry
bb113:
  _337 = move (_369.0: i32)
  using: _369@Mir(bb112[1])
  _370 = CheckedAdd(_338, const 1_i32)
  using: _338@Phi(bb107)
  assert(!move (_370.1: bool), "attempt to compute `{} + {}`, which would overflow", _338, const 1_i32) -> bb114
  using: _370@Entry, _338@Entry
bb114:
  _338 = move (_370.0: i32)
  using: _370@Mir(bb113[1])
  _371 = CheckedSub(_345, const 1_i32)
  using: _345@Phi(bb107)
  assert(!move (_371.1: bool), "attempt to compute `{} - {}`, which would overflow", _345, const 1_i32) -> bb115
  using: _371@Entry, _345@Entry
bb115:
  _345 = move (_371.0: i32)
  using: _371@Mir(bb114[1])
  goto -> bb107
  using: 
bb116:
  _374 = _17
  using: _17@Phi(bb86)
  _375 = _9
  using: _9@Phi(bb86)
  _376 = CheckedAdd(_374, _375)
  using: _374@Mir(bb116[0]), _375@Mir(bb116[1])
  assert(!move (_376.1: bool), "attempt to compute `{} + {}`, which would overflow", move _374, move _375) -> bb117
  using: _376@Entry, _374@Entry, _375@Entry
bb117:
  _373 = move (_376.0: i32)
  using: _376@Mir(bb116[2])
  _377 = _11
  using: _11@Phi(bb86)
  _378 = CheckedSub(_373, _377)
  using: _373@Mir(bb117[0]), _377@Mir(bb117[1])
  assert(!move (_378.1: bool), "attempt to compute `{} - {}`, which would overflow", move _373, move _377) -> bb118
  using: _378@Entry, _373@Entry, _377@Entry
bb118:
  _372 = move (_378.0: i32)
  using: _378@Mir(bb117[2])
  _379 = const 1_i32
  using: 
  _380 = CheckedSub(_372, _379)
  using: _372@Mir(bb118[0]), _379@Mir(bb118[1])
  assert(!move (_380.1: bool), "attempt to compute `{} - {}`, which would overflow", move _372, move _379) -> bb119
  using: _380@Entry, _372@Entry, _379@Entry
bb119:
  _13 = move (_380.0: i32)
  using: _380@Mir(bb118[2])
  _382 = _18
  using: _18@Phi(bb104)
  _384 = _12
  using: _12@Phi(bb104)
  _385 = _10
  using: _10@Phi(bb104)
  _386 = CheckedSub(_384, _385)
  using: _384@Mir(bb119[2]), _385@Mir(bb119[3])
  assert(!move (_386.1: bool), "attempt to compute `{} - {}`, which would overflow", move _384, move _385) -> bb120
  using: _386@Entry, _384@Entry, _385@Entry
bb120:
  _383 = move (_386.0: i32)
  using: _386@Mir(bb119[4])
  _387 = CheckedSub(_382, _383)
  using: _382@Mir(bb119[1]), _383@Mir(bb120[0])
  assert(!move (_387.1: bool), "attempt to compute `{} - {}`, which would overflow", move _382, move _383) -> bb121
  using: _387@Entry, _382@Entry, _383@Entry
bb121:
  _381 = move (_387.0: i32)
  using: _387@Mir(bb120[1])
  _388 = const 1_i32
  using: 
  _389 = CheckedAdd(_381, _388)
  using: _381@Mir(bb121[0]), _388@Mir(bb121[1])
  assert(!move (_389.1: bool), "attempt to compute `{} + {}`, which would overflow", move _381, move _388) -> bb122
  using: _389@Entry, _381@Entry, _388@Entry
bb122:
  _14 = move (_389.0: i32)
  using: _389@Mir(bb121[2])
  _390 = _17
  using: _17@Phi(bb86)
  _391 = const 0_usize
  using: 
  _23[_391] = move _390
  using: _391@Mir(bb122[2]), _390@Mir(bb122[1])
  _392 = _13
  using: _13@Mir(bb119[0])
  _393 = const 0_usize
  using: 
  _24[_393] = move _392
  using: _393@Mir(bb122[5]), _392@Mir(bb122[4])
  _394 = _19
  using: _19@Phi(bb64)
  _395 = const 0_usize
  using: 
  _25[_395] = move _394
  using: _395@Mir(bb122[8]), _394@Mir(bb122[7])
  _396 = _14
  using: _14@Mir(bb122[0])
  _397 = const 1_usize
  using: 
  _23[_397] = move _396
  using: _397@Mir(bb122[11]), _396@Mir(bb122[10])
  _398 = _18
  using: _18@Phi(bb104)
  _399 = const 1_usize
  using: 
  _24[_399] = move _398
  using: _399@Mir(bb122[14]), _398@Mir(bb122[13])
  _400 = _19
  using: _19@Phi(bb64)
  _401 = const 1_usize
  using: 
  _25[_401] = move _400
  using: _401@Mir(bb122[17]), _400@Mir(bb122[16])
  _402 = _13
  using: _13@Mir(bb119[0])
  _403 = const 1_i32
  using: 
  _404 = CheckedAdd(_402, _403)
  using: _402@Mir(bb122[19]), _403@Mir(bb122[20])
  assert(!move (_404.1: bool), "attempt to compute `{} + {}`, which would overflow", move _402, move _403) -> bb123
  using: _404@Entry, _402@Entry, _403@Entry
bb123:
  _405 = const 2_usize
  using: 
  _23[_405] = move (_404.0: i32)
  using: _405@Mir(bb123[0]), _404@Mir(bb122[21])
  _406 = _14
  using: _14@Mir(bb122[0])
  _407 = const 1_i32
  using: 
  _408 = CheckedSub(_406, _407)
  using: _406@Mir(bb123[2]), _407@Mir(bb123[3])
  assert(!move (_408.1: bool), "attempt to compute `{} - {}`, which would overflow", move _406, move _407) -> bb124
  using: _408@Entry, _406@Entry, _407@Entry
bb124:
  _409 = const 2_usize
  using: 
  _24[_409] = move (_408.0: i32)
  using: _409@Mir(bb124[0]), _408@Mir(bb123[4])
  _410 = _19
  using: _19@Phi(bb64)
  _411 = const 1_i32
  using: 
  _412 = CheckedAdd(_410, _411)
  using: _410@Mir(bb124[2]), _411@Mir(bb124[3])
  assert(!move (_412.1: bool), "attempt to compute `{} + {}`, which would overflow", move _410, move _411) -> bb125
  using: _412@Entry, _410@Entry, _411@Entry
bb125:
  _413 = const 2_usize
  using: 
  _25[_413] = move (_412.0: i32)
  using: _413@Mir(bb125[0]), _412@Mir(bb124[4])
  _417 = const 0_usize
  using: 
  _416 = _24[_417]
  using: _24@Phi(bb4), _417@Mir(bb125[2])
  _419 = const 0_usize
  using: 
  _418 = _23[_419]
  using: _23@Phi(bb4), _419@Mir(bb125[4])
  _420 = CheckedSub(_416, _418)
  using: _416@Mir(bb125[3]), _418@Mir(bb125[5])
  assert(!move (_420.1: bool), "attempt to compute `{} - {}`, which would overflow", move _416, move _418) -> bb126
  using: _420@Entry, _416@Entry, _418@Entry
bb126:
  _415 = move (_420.0: i32)
  using: _420@Mir(bb125[6])
  _423 = const 1_usize
  using: 
  _422 = _24[_423]
  using: _24@Phi(bb4), _423@Mir(bb126[1])
  _425 = const 1_usize
  using: 
  _424 = _23[_425]
  using: _23@Phi(bb4), _425@Mir(bb126[3])
  _426 = CheckedSub(_422, _424)
  using: _422@Mir(bb126[2]), _424@Mir(bb126[4])
  assert(!move (_426.1: bool), "attempt to compute `{} - {}`, which would overflow", move _422, move _424) -> bb127
  using: _426@Entry, _422@Entry, _424@Entry
bb127:
  _421 = move (_426.0: i32)
  using: _426@Mir(bb126[5])
  _414 = Lt(move _415, move _421)
  using: _415@Mir(bb126[0]), _421@Mir(bb127[0])
  switchInt(move _414) -> [0: bb129, otherwise: bb128]
  using: _414@Mir(bb127[1])
bb128:
  _427 = const 0_i32
  using: 
  _429 = const 0_usize
  using: 
  _428 = _23[_429]
  using: _23@Phi(bb4), _429@Mir(bb128[1])
  _427 = move _428
  using: _428@Mir(bb128[2])
  _431 = const 1_usize
  using: 
  _430 = _23[_431]
  using: _23@Phi(bb4), _431@Mir(bb128[4])
  _432 = const 0_usize
  using: 
  _23[_432] = move _430
  using: _432@Mir(bb128[6]), _430@Mir(bb128[5])
  _433 = _427
  using: _427@Mir(bb128[3])
  _434 = const 1_usize
  using: 
  _23[_434] = move _433
  using: _434@Mir(bb128[9]), _433@Mir(bb128[8])
  _436 = const 0_usize
  using: 
  _435 = _24[_436]
  using: _24@Phi(bb4), _436@Mir(bb128[11])
  _427 = move _435
  using: _435@Mir(bb128[12])
  _438 = const 1_usize
  using: 
  _437 = _24[_438]
  using: _24@Phi(bb4), _438@Mir(bb128[14])
  _439 = const 0_usize
  using: 
  _24[_439] = move _437
  using: _439@Mir(bb128[16]), _437@Mir(bb128[15])
  _440 = _427
  using: _427@Mir(bb128[13])
  _441 = const 1_usize
  using: 
  _24[_441] = move _440
  using: _441@Mir(bb128[19]), _440@Mir(bb128[18])
  _443 = const 0_usize
  using: 
  _442 = _25[_443]
  using: _25@Phi(bb4), _443@Mir(bb128[21])
  _427 = move _442
  using: _442@Mir(bb128[22])
  _445 = const 1_usize
  using: 
  _444 = _25[_445]
  using: _25@Phi(bb4), _445@Mir(bb128[24])
  _446 = const 0_usize
  using: 
  _25[_446] = move _444
  using: _446@Mir(bb128[26]), _444@Mir(bb128[25])
  _447 = _427
  using: _427@Mir(bb128[23])
  _448 = const 1_usize
  using: 
  _25[_448] = move _447
  using: _448@Mir(bb128[29]), _447@Mir(bb128[28])
  goto -> bb129
  using: 
bb129:
  _452 = const 1_usize
  using: 
  _451 = _24[_452]
  using: _24@Phi(bb129), _452@Mir(bb129[0])
  _454 = const 1_usize
  using: 
  _453 = _23[_454]
  using: _23@Phi(bb129), _454@Mir(bb129[2])
  _455 = CheckedSub(_451, _453)
  using: _451@Mir(bb129[1]), _453@Mir(bb129[3])
  assert(!move (_455.1: bool), "attempt to compute `{} - {}`, which would overflow", move _451, move _453) -> bb130
  using: _455@Entry, _451@Entry, _453@Entry
bb130:
  _450 = move (_455.0: i32)
  using: _455@Mir(bb129[4])
  _458 = const 2_usize
  using: 
  _457 = _24[_458]
  using: _24@Phi(bb129), _458@Mir(bb130[1])
  _460 = const 2_usize
  using: 
  _459 = _23[_460]
  using: _23@Phi(bb129), _460@Mir(bb130[3])
  _461 = CheckedSub(_457, _459)
  using: _457@Mir(bb130[2]), _459@Mir(bb130[4])
  assert(!move (_461.1: bool), "attempt to compute `{} - {}`, which would overflow", move _457, move _459) -> bb131
  using: _461@Entry, _457@Entry, _459@Entry
bb131:
  _456 = move (_461.0: i32)
  using: _461@Mir(bb130[5])
  _449 = Lt(move _450, move _456)
  using: _450@Mir(bb130[0]), _456@Mir(bb131[0])
  switchInt(move _449) -> [0: bb133, otherwise: bb132]
  using: _449@Mir(bb131[1])
bb132:
  _462 = const 0_i32
  using: 
  _464 = const 1_usize
  using: 
  _463 = _23[_464]
  using: _23@Phi(bb129), _464@Mir(bb132[1])
  _462 = move _463
  using: _463@Mir(bb132[2])
  _466 = const 2_usize
  using: 
  _465 = _23[_466]
  using: _23@Phi(bb129), _466@Mir(bb132[4])
  _467 = const 1_usize
  using: 
  _23[_467] = move _465
  using: _467@Mir(bb132[6]), _465@Mir(bb132[5])
  _468 = _462
  using: _462@Mir(bb132[3])
  _469 = const 2_usize
  using: 
  _23[_469] = move _468
  using: _469@Mir(bb132[9]), _468@Mir(bb132[8])
  _471 = const 1_usize
  using: 
  _470 = _24[_471]
  using: _24@Phi(bb129), _471@Mir(bb132[11])
  _462 = move _470
  using: _470@Mir(bb132[12])
  _473 = const 2_usize
  using: 
  _472 = _24[_473]
  using: _24@Phi(bb129), _473@Mir(bb132[14])
  _474 = const 1_usize
  using: 
  _24[_474] = move _472
  using: _474@Mir(bb132[16]), _472@Mir(bb132[15])
  _475 = _462
  using: _462@Mir(bb132[13])
  _476 = const 2_usize
  using: 
  _24[_476] = move _475
  using: _476@Mir(bb132[19]), _475@Mir(bb132[18])
  _478 = const 1_usize
  using: 
  _477 = _25[_478]
  using: _25@Phi(bb129), _478@Mir(bb132[21])
  _462 = move _477
  using: _477@Mir(bb132[22])
  _480 = const 2_usize
  using: 
  _479 = _25[_480]
  using: _25@Phi(bb129), _480@Mir(bb132[24])
  _481 = const 1_usize
  using: 
  _25[_481] = move _479
  using: _481@Mir(bb132[26]), _479@Mir(bb132[25])
  _482 = _462
  using: _462@Mir(bb132[23])
  _483 = const 2_usize
  using: 
  _25[_483] = move _482
  using: _483@Mir(bb132[29]), _482@Mir(bb132[28])
  goto -> bb133
  using: 
bb133:
  _487 = const 0_usize
  using: 
  _486 = _24[_487]
  using: _24@Phi(bb133), _487@Mir(bb133[0])
  _489 = const 0_usize
  using: 
  _488 = _23[_489]
  using: _23@Phi(bb133), _489@Mir(bb133[2])
  _490 = CheckedSub(_486, _488)
  using: _486@Mir(bb133[1]), _488@Mir(bb133[3])
  assert(!move (_490.1: bool), "attempt to compute `{} - {}`, which would overflow", move _486, move _488) -> bb134
  using: _490@Entry, _486@Entry, _488@Entry
bb134:
  _485 = move (_490.0: i32)
  using: _490@Mir(bb133[4])
  _493 = const 1_usize
  using: 
  _492 = _24[_493]
  using: _24@Phi(bb133), _493@Mir(bb134[1])
  _495 = const 1_usize
  using: 
  _494 = _23[_495]
  using: _23@Phi(bb133), _495@Mir(bb134[3])
  _496 = CheckedSub(_492, _494)
  using: _492@Mir(bb134[2]), _494@Mir(bb134[4])
  assert(!move (_496.1: bool), "attempt to compute `{} - {}`, which would overflow", move _492, move _494) -> bb135
  using: _496@Entry, _492@Entry, _494@Entry
bb135:
  _491 = move (_496.0: i32)
  using: _496@Mir(bb134[5])
  _484 = Lt(move _485, move _491)
  using: _485@Mir(bb134[0]), _491@Mir(bb135[0])
  switchInt(move _484) -> [0: bb137, otherwise: bb136]
  using: _484@Mir(bb135[1])
bb136:
  _497 = const 0_i32
  using: 
  _499 = const 0_usize
  using: 
  _498 = _23[_499]
  using: _23@Phi(bb133), _499@Mir(bb136[1])
  _497 = move _498
  using: _498@Mir(bb136[2])
  _501 = const 1_usize
  using: 
  _500 = _23[_501]
  using: _23@Phi(bb133), _501@Mir(bb136[4])
  _502 = const 0_usize
  using: 
  _23[_502] = move _500
  using: _502@Mir(bb136[6]), _500@Mir(bb136[5])
  _503 = _497
  using: _497@Mir(bb136[3])
  _504 = const 1_usize
  using: 
  _23[_504] = move _503
  using: _504@Mir(bb136[9]), _503@Mir(bb136[8])
  _506 = const 0_usize
  using: 
  _505 = _24[_506]
  using: _24@Phi(bb133), _506@Mir(bb136[11])
  _497 = move _505
  using: _505@Mir(bb136[12])
  _508 = const 1_usize
  using: 
  _507 = _24[_508]
  using: _24@Phi(bb133), _508@Mir(bb136[14])
  _509 = const 0_usize
  using: 
  _24[_509] = move _507
  using: _509@Mir(bb136[16]), _507@Mir(bb136[15])
  _510 = _497
  using: _497@Mir(bb136[13])
  _511 = const 1_usize
  using: 
  _24[_511] = move _510
  using: _511@Mir(bb136[19]), _510@Mir(bb136[18])
  _513 = const 0_usize
  using: 
  _512 = _25[_513]
  using: _25@Phi(bb133), _513@Mir(bb136[21])
  _497 = move _512
  using: _512@Mir(bb136[22])
  _515 = const 1_usize
  using: 
  _514 = _25[_515]
  using: _25@Phi(bb133), _515@Mir(bb136[24])
  _516 = const 0_usize
  using: 
  _25[_516] = move _514
  using: _516@Mir(bb136[26]), _514@Mir(bb136[25])
  _517 = _497
  using: _497@Mir(bb136[23])
  _518 = const 1_usize
  using: 
  _25[_518] = move _517
  using: _518@Mir(bb136[29]), _517@Mir(bb136[28])
  goto -> bb137
  using: 
bb137:
  _520 = const 0_usize
  using: 
  _519 = _23[_520]
  using: _23@Phi(bb137), _520@Mir(bb137[0])
  _522 = _16
  using: _16@Mir(bb8[0])
  _521 = move _522 as usize (IntToInt)
  using: _522@Mir(bb137[2])
  _523 = const 100_usize
  using: 
  _524 = Lt(_521, _523)
  using: _521@Mir(bb137[3]), _523@Mir(bb137[4])
  assert(move _524, "index out of bounds: the length is {} but the index is {}", move _523, _521) -> bb138
  using: _524@Entry, _523@Entry, _521@Entry
bb138:
  _20[_521] = move _519
  using: _521@Mir(bb137[3]), _519@Mir(bb137[1])
  _526 = const 0_usize
  using: 
  _525 = _24[_526]
  using: _24@Phi(bb137), _526@Mir(bb138[1])
  _528 = _16
  using: _16@Mir(bb8[0])
  _527 = move _528 as usize (IntToInt)
  using: _528@Mir(bb138[3])
  _529 = const 100_usize
  using: 
  _530 = Lt(_527, _529)
  using: _527@Mir(bb138[4]), _529@Mir(bb138[5])
  assert(move _530, "index out of bounds: the length is {} but the index is {}", move _529, _527) -> bb139
  using: _530@Entry, _529@Entry, _527@Entry
bb139:
  _21[_527] = move _525
  using: _527@Mir(bb138[4]), _525@Mir(bb138[2])
  _532 = const 0_usize
  using: 
  _531 = _25[_532]
  using: _25@Phi(bb137), _532@Mir(bb139[1])
  _534 = _16
  using: _16@Mir(bb8[0])
  _533 = move _534 as usize (IntToInt)
  using: _534@Mir(bb139[3])
  _535 = const 100_usize
  using: 
  _536 = Lt(_533, _535)
  using: _533@Mir(bb139[4]), _535@Mir(bb139[5])
  assert(move _536, "index out of bounds: the length is {} but the index is {}", move _535, _533) -> bb140
  using: _536@Entry, _535@Entry, _533@Entry
bb140:
  _22[_533] = move _531
  using: _533@Mir(bb139[4]), _531@Mir(bb139[2])
  _537 = CheckedAdd(_16, const 1_i32)
  using: _16@Mir(bb8[0])
  assert(!move (_537.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, const 1_i32) -> bb141
  using: _537@Entry, _16@Entry
bb141:
  _16 = move (_537.0: i32)
  using: _537@Mir(bb140[1])
  _539 = const 1_usize
  using: 
  _538 = _23[_539]
  using: _23@Phi(bb137), _539@Mir(bb141[1])
  _541 = _16
  using: _16@Mir(bb141[0])
  _540 = move _541 as usize (IntToInt)
  using: _541@Mir(bb141[3])
  _542 = const 100_usize
  using: 
  _543 = Lt(_540, _542)
  using: _540@Mir(bb141[4]), _542@Mir(bb141[5])
  assert(move _543, "index out of bounds: the length is {} but the index is {}", move _542, _540) -> bb142
  using: _543@Entry, _542@Entry, _540@Entry
bb142:
  _20[_540] = move _538
  using: _540@Mir(bb141[4]), _538@Mir(bb141[2])
  _545 = const 1_usize
  using: 
  _544 = _24[_545]
  using: _24@Phi(bb137), _545@Mir(bb142[1])
  _547 = _16
  using: _16@Mir(bb141[0])
  _546 = move _547 as usize (IntToInt)
  using: _547@Mir(bb142[3])
  _548 = const 100_usize
  using: 
  _549 = Lt(_546, _548)
  using: _546@Mir(bb142[4]), _548@Mir(bb142[5])
  assert(move _549, "index out of bounds: the length is {} but the index is {}", move _548, _546) -> bb143
  using: _549@Entry, _548@Entry, _546@Entry
bb143:
  _21[_546] = move _544
  using: _546@Mir(bb142[4]), _544@Mir(bb142[2])
  _551 = const 1_usize
  using: 
  _550 = _25[_551]
  using: _25@Phi(bb137), _551@Mir(bb143[1])
  _553 = _16
  using: _16@Mir(bb141[0])
  _552 = move _553 as usize (IntToInt)
  using: _553@Mir(bb143[3])
  _554 = const 100_usize
  using: 
  _555 = Lt(_552, _554)
  using: _552@Mir(bb143[4]), _554@Mir(bb143[5])
  assert(move _555, "index out of bounds: the length is {} but the index is {}", move _554, _552) -> bb144
  using: _555@Entry, _554@Entry, _552@Entry
bb144:
  _22[_552] = move _550
  using: _552@Mir(bb143[4]), _550@Mir(bb143[2])
  _556 = CheckedAdd(_16, const 1_i32)
  using: _16@Mir(bb141[0])
  assert(!move (_556.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, const 1_i32) -> bb145
  using: _556@Entry, _16@Entry
bb145:
  _16 = move (_556.0: i32)
  using: _556@Mir(bb144[1])
  _558 = const 2_usize
  using: 
  _557 = _23[_558]
  using: _23@Phi(bb137), _558@Mir(bb145[1])
  _560 = _16
  using: _16@Mir(bb145[0])
  _559 = move _560 as usize (IntToInt)
  using: _560@Mir(bb145[3])
  _561 = const 100_usize
  using: 
  _562 = Lt(_559, _561)
  using: _559@Mir(bb145[4]), _561@Mir(bb145[5])
  assert(move _562, "index out of bounds: the length is {} but the index is {}", move _561, _559) -> bb146
  using: _562@Entry, _561@Entry, _559@Entry
bb146:
  _20[_559] = move _557
  using: _559@Mir(bb145[4]), _557@Mir(bb145[2])
  _564 = const 2_usize
  using: 
  _563 = _24[_564]
  using: _24@Phi(bb137), _564@Mir(bb146[1])
  _566 = _16
  using: _16@Mir(bb145[0])
  _565 = move _566 as usize (IntToInt)
  using: _566@Mir(bb146[3])
  _567 = const 100_usize
  using: 
  _568 = Lt(_565, _567)
  using: _565@Mir(bb146[4]), _567@Mir(bb146[5])
  assert(move _568, "index out of bounds: the length is {} but the index is {}", move _567, _565) -> bb147
  using: _568@Entry, _567@Entry, _565@Entry
bb147:
  _21[_565] = move _563
  using: _565@Mir(bb146[4]), _563@Mir(bb146[2])
  _570 = const 2_usize
  using: 
  _569 = _25[_570]
  using: _25@Phi(bb137), _570@Mir(bb147[1])
  _572 = _16
  using: _16@Mir(bb145[0])
  _571 = move _572 as usize (IntToInt)
  using: _572@Mir(bb147[3])
  _573 = const 100_usize
  using: 
  _574 = Lt(_571, _573)
  using: _571@Mir(bb147[4]), _573@Mir(bb147[5])
  assert(move _574, "index out of bounds: the length is {} but the index is {}", move _573, _571) -> bb148
  using: _574@Entry, _573@Entry, _571@Entry
bb148:
  _22[_571] = move _569
  using: _571@Mir(bb147[4]), _569@Mir(bb147[2])
  _575 = CheckedAdd(_16, const 1_i32)
  using: _16@Mir(bb145[0])
  assert(!move (_575.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, const 1_i32) -> bb149
  using: _575@Entry, _16@Entry
bb149:
  _16 = move (_575.0: i32)
  using: _575@Mir(bb148[1])
  goto -> bb4
  using: 
bb150:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 100] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 100] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 100] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 3] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 3] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 3] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:921:43: 922:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:922:62: 923:100 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:921:30: 924:50 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:925:43: 926:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:926:62: 927:100 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:925:30: 928:50 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:929:43: 931:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:931:62: 932:100 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:929:30: 933:50 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:942:45: 943:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:943:64: 945:102 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:942:32: 946:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:949:34: 949:55 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:951:34: 951:55 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:950:30: 950:51 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:952:30: 952:51 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:960:45: 961:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:961:64: 963:102 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:960:32: 964:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:967:34: 967:55 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:969:34: 969:55 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:968:30: 968:51 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:970:30: 970:51 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:976:47: 976:68 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:977:51: 977:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:977:22: 977:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:978:22: 978:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:997:30: 997:51 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:998:55: 998:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:998:26: 998:47 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:999:26: 999:47 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1013:30: 1013:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1015:30: 1015:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1014:26: 1014:49 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1016:26: 1016:49 (#0) by default
@DefId(0:45 ~ c2rust_lib[1043]::blocksort::mainSort)
bb0:
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = [const 0_i32; 256]
  using: 
  _14 = [const 0_u8; 256]
  using: 
  _15 = [const 0_i32; 256]
  using: 
  _16 = [const 0_i32; 256]
  using: 
  _17 = const 0_u8
  using: 
  _18 = const 0_i32
  using: 
  _19 = const 0_u16
  using: 
  _21 = _6
  using: _6@Entry
  _22 = const 4_i32
  using: 
  _20 = Ge(move _21, move _22)
  using: _21@Mir(bb0[12]), _22@Mir(bb0[13])
  switchInt(move _20) -> [0: bb2, otherwise: bb1]
  using: _20@Mir(bb0[14])
bb1:
  _25 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _24 = (*_25)
  using: _25@Mir(bb1[0])
  _29 = const b"        main sort initialise ...\n\x00"
  using: 
  _28 = &raw const (*_29)
  using: _29@Mir(bb1[2])
  _27 = move _28 as *const u8 (Pointer(ArrayToPointer))
  using: _28@Mir(bb1[3])
  _26 = move _27 as *const i8 (PtrToPtr)
  using: _27@Mir(bb1[4])
  _23 = blocksort::fprintf(move _24, move _26) -> bb2
  using: _24@Mir(bb1[1]), _26@Mir(bb1[5])
bb2:
  _8 = const 65536_i32
  using: 
  goto -> bb3
  using: 
bb3:
  _31 = _8
  using: _8@Phi(bb3)
  _32 = const 0_i32
  using: 
  _30 = Ge(move _31, move _32)
  using: _31@Mir(bb3[0]), _32@Mir(bb3[1])
  switchInt(move _30) -> [0: bb7, otherwise: bb4]
  using: _30@Mir(bb3[2])
bb4:
  _33 = const 0_i32
  using: 
  _35 = _4
  using: _4@Phi(bb3)
  _37 = _8
  using: _8@Phi(bb3)
  _36 = move _37 as isize (IntToInt)
  using: _37@Mir(bb4[2])
  _34 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _35, move _36) -> bb5
  using: _35@Mir(bb4[1]), _36@Mir(bb4[3])
bb5:
  (*_34) = move _33 as u32 (IntToInt)
  using: _34@Mir(bb4[4]), _33@Mir(bb4[0])
  _38 = CheckedSub(_8, const 1_i32)
  using: _8@Phi(bb3)
  assert(!move (_38.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_i32) -> bb6
  using: _38@Entry, _8@Entry
bb6:
  _8 = move (_38.0: i32)
  using: _38@Mir(bb5[1])
  goto -> bb3
  using: 
bb7:
  _42 = _2
  using: _2@Entry
  _43 = const 0_isize
  using: 
  _41 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _42, move _43) -> bb8
  using: _42@Mir(bb7[0]), _43@Mir(bb7[1])
bb8:
  _40 = (*_41)
  using: _41@Mir(bb7[2])
  _39 = move _40 as i32 (IntToInt)
  using: _40@Mir(bb8[0])
  _44 = const 8_i32
  using: 
  _45 = CheckedShl(_39, _44)
  using: _39@Mir(bb8[1]), _44@Mir(bb8[2])
  assert(!move (_45.1: bool), "attempt to shift left by `{}`, which would overflow", move _44) -> bb9
  using: _45@Entry, _39@Entry, _44@Entry
bb9:
  _9 = move (_45.0: i32)
  using: _45@Mir(bb8[3])
  _46 = _5
  using: _5@Entry
  _47 = const 1_i32
  using: 
  _48 = CheckedSub(_46, _47)
  using: _46@Mir(bb9[1]), _47@Mir(bb9[2])
  assert(!move (_48.1: bool), "attempt to compute `{} - {}`, which would overflow", move _46, move _47) -> bb10
  using: _48@Entry, _46@Entry, _47@Entry
bb10:
  _8 = move (_48.0: i32)
  using: _48@Mir(bb9[3])
  goto -> bb11
  using: 
bb11:
  _50 = _8
  using: _8@Phi(bb11)
  _51 = const 3_i32
  using: 
  _49 = Ge(move _50, move _51)
  using: _50@Mir(bb11[0]), _51@Mir(bb11[1])
  switchInt(move _49) -> [0: bb48, otherwise: bb12]
  using: _49@Mir(bb11[2])
bb12:
  _52 = const 0_i32
  using: 
  _54 = _3
  using: _3@Phi(bb11)
  _56 = _8
  using: _8@Phi(bb11)
  _55 = move _56 as isize (IntToInt)
  using: _56@Mir(bb12[2])
  _53 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _54, move _55) -> bb13
  using: _54@Mir(bb12[1]), _55@Mir(bb12[3])
bb13:
  (*_53) = move _52 as u16 (IntToInt)
  using: _53@Mir(bb12[4]), _52@Mir(bb12[0])
  _58 = _9
  using: _9@Phi(bb11)
  _59 = const 8_i32
  using: 
  _60 = CheckedShr(_58, _59)
  using: _58@Mir(bb13[1]), _59@Mir(bb13[2])
  assert(!move (_60.1: bool), "attempt to shift right by `{}`, which would overflow", move _59) -> bb14
  using: _60@Entry, _58@Entry, _59@Entry
bb14:
  _57 = move (_60.0: i32)
  using: _60@Mir(bb13[3])
  _66 = _2
  using: _2@Phi(bb11)
  _68 = _8
  using: _8@Phi(bb11)
  _67 = move _68 as isize (IntToInt)
  using: _68@Mir(bb14[2])
  _65 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _66, move _67) -> bb15
  using: _66@Mir(bb14[1]), _67@Mir(bb14[3])
bb15:
  _64 = (*_65)
  using: _65@Mir(bb14[4])
  _63 = move _64 as u16 (IntToInt)
  using: _64@Mir(bb15[0])
  _62 = move _63 as i32 (IntToInt)
  using: _63@Mir(bb15[1])
  _69 = const 8_i32
  using: 
  _70 = CheckedShl(_62, _69)
  using: _62@Mir(bb15[2]), _69@Mir(bb15[3])
  assert(!move (_70.1: bool), "attempt to shift left by `{}`, which would overflow", move _69) -> bb16
  using: _70@Entry, _62@Entry, _69@Entry
bb16:
  _61 = move (_70.0: i32)
  using: _70@Mir(bb15[4])
  _9 = BitOr(move _57, move _61)
  using: _57@Mir(bb14[0]), _61@Mir(bb16[0])
  _74 = _4
  using: _4@Phi(bb11)
  _76 = _9
  using: _9@Mir(bb16[1])
  _75 = move _76 as isize (IntToInt)
  using: _76@Mir(bb16[3])
  _73 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _74, move _75) -> bb17
  using: _74@Mir(bb16[2]), _75@Mir(bb16[4])
bb17:
  _72 = (*_73)
  using: _73@Mir(bb16[5])
  _71 = core::num::<impl u32>::wrapping_add(move _72, const 1_u32) -> bb18
  using: _72@Mir(bb17[0])
bb18:
  _78 = _4
  using: _4@Phi(bb11)
  _80 = _9
  using: _9@Mir(bb16[1])
  _79 = move _80 as isize (IntToInt)
  using: _80@Mir(bb18[1])
  _77 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _78, move _79) -> bb19
  using: _78@Mir(bb18[0]), _79@Mir(bb18[2])
bb19:
  (*_77) = move _71
  using: _77@Mir(bb18[3]), _71@Mir(bb17[1])
  _81 = const 0_i32
  using: 
  _83 = _3
  using: _3@Phi(bb11)
  _86 = _8
  using: _8@Phi(bb11)
  _87 = const 1_i32
  using: 
  _88 = CheckedSub(_86, _87)
  using: _86@Mir(bb19[3]), _87@Mir(bb19[4])
  assert(!move (_88.1: bool), "attempt to compute `{} - {}`, which would overflow", move _86, move _87) -> bb20
  using: _88@Entry, _86@Entry, _87@Entry
bb20:
  _85 = move (_88.0: i32)
  using: _88@Mir(bb19[5])
  _84 = move _85 as isize (IntToInt)
  using: _85@Mir(bb20[0])
  _82 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _83, move _84) -> bb21
  using: _83@Mir(bb19[2]), _84@Mir(bb20[1])
bb21:
  (*_82) = move _81 as u16 (IntToInt)
  using: _82@Mir(bb20[2]), _81@Mir(bb19[1])
  _90 = _9
  using: _9@Mir(bb16[1])
  _91 = const 8_i32
  using: 
  _92 = CheckedShr(_90, _91)
  using: _90@Mir(bb21[1]), _91@Mir(bb21[2])
  assert(!move (_92.1: bool), "attempt to shift right by `{}`, which would overflow", move _91) -> bb22
  using: _92@Entry, _90@Entry, _91@Entry
bb22:
  _89 = move (_92.0: i32)
  using: _92@Mir(bb21[3])
  _98 = _2
  using: _2@Phi(bb11)
  _101 = _8
  using: _8@Phi(bb11)
  _102 = const 1_i32
  using: 
  _103 = CheckedSub(_101, _102)
  using: _101@Mir(bb22[2]), _102@Mir(bb22[3])
  assert(!move (_103.1: bool), "attempt to compute `{} - {}`, which would overflow", move _101, move _102) -> bb23
  using: _103@Entry, _101@Entry, _102@Entry
bb23:
  _100 = move (_103.0: i32)
  using: _103@Mir(bb22[4])
  _99 = move _100 as isize (IntToInt)
  using: _100@Mir(bb23[0])
  _97 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _98, move _99) -> bb24
  using: _98@Mir(bb22[1]), _99@Mir(bb23[1])
bb24:
  _96 = (*_97)
  using: _97@Mir(bb23[2])
  _95 = move _96 as u16 (IntToInt)
  using: _96@Mir(bb24[0])
  _94 = move _95 as i32 (IntToInt)
  using: _95@Mir(bb24[1])
  _104 = const 8_i32
  using: 
  _105 = CheckedShl(_94, _104)
  using: _94@Mir(bb24[2]), _104@Mir(bb24[3])
  assert(!move (_105.1: bool), "attempt to shift left by `{}`, which would overflow", move _104) -> bb25
  using: _105@Entry, _94@Entry, _104@Entry
bb25:
  _93 = move (_105.0: i32)
  using: _105@Mir(bb24[4])
  _9 = BitOr(move _89, move _93)
  using: _89@Mir(bb22[0]), _93@Mir(bb25[0])
  _109 = _4
  using: _4@Phi(bb11)
  _111 = _9
  using: _9@Mir(bb25[1])
  _110 = move _111 as isize (IntToInt)
  using: _111@Mir(bb25[3])
  _108 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _109, move _110) -> bb26
  using: _109@Mir(bb25[2]), _110@Mir(bb25[4])
bb26:
  _107 = (*_108)
  using: _108@Mir(bb25[5])
  _106 = core::num::<impl u32>::wrapping_add(move _107, const 1_u32) -> bb27
  using: _107@Mir(bb26[0])
bb27:
  _113 = _4
  using: _4@Phi(bb11)
  _115 = _9
  using: _9@Mir(bb25[1])
  _114 = move _115 as isize (IntToInt)
  using: _115@Mir(bb27[1])
  _112 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _113, move _114) -> bb28
  using: _113@Mir(bb27[0]), _114@Mir(bb27[2])
bb28:
  (*_112) = move _106
  using: _112@Mir(bb27[3]), _106@Mir(bb26[1])
  _116 = const 0_i32
  using: 
  _118 = _3
  using: _3@Phi(bb11)
  _121 = _8
  using: _8@Phi(bb11)
  _122 = const 2_i32
  using: 
  _123 = CheckedSub(_121, _122)
  using: _121@Mir(bb28[3]), _122@Mir(bb28[4])
  assert(!move (_123.1: bool), "attempt to compute `{} - {}`, which would overflow", move _121, move _122) -> bb29
  using: _123@Entry, _121@Entry, _122@Entry
bb29:
  _120 = move (_123.0: i32)
  using: _123@Mir(bb28[5])
  _119 = move _120 as isize (IntToInt)
  using: _120@Mir(bb29[0])
  _117 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _118, move _119) -> bb30
  using: _118@Mir(bb28[2]), _119@Mir(bb29[1])
bb30:
  (*_117) = move _116 as u16 (IntToInt)
  using: _117@Mir(bb29[2]), _116@Mir(bb28[1])
  _125 = _9
  using: _9@Mir(bb25[1])
  _126 = const 8_i32
  using: 
  _127 = CheckedShr(_125, _126)
  using: _125@Mir(bb30[1]), _126@Mir(bb30[2])
  assert(!move (_127.1: bool), "attempt to shift right by `{}`, which would overflow", move _126) -> bb31
  using: _127@Entry, _125@Entry, _126@Entry
bb31:
  _124 = move (_127.0: i32)
  using: _127@Mir(bb30[3])
  _133 = _2
  using: _2@Phi(bb11)
  _136 = _8
  using: _8@Phi(bb11)
  _137 = const 2_i32
  using: 
  _138 = CheckedSub(_136, _137)
  using: _136@Mir(bb31[2]), _137@Mir(bb31[3])
  assert(!move (_138.1: bool), "attempt to compute `{} - {}`, which would overflow", move _136, move _137) -> bb32
  using: _138@Entry, _136@Entry, _137@Entry
bb32:
  _135 = move (_138.0: i32)
  using: _138@Mir(bb31[4])
  _134 = move _135 as isize (IntToInt)
  using: _135@Mir(bb32[0])
  _132 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _133, move _134) -> bb33
  using: _133@Mir(bb31[1]), _134@Mir(bb32[1])
bb33:
  _131 = (*_132)
  using: _132@Mir(bb32[2])
  _130 = move _131 as u16 (IntToInt)
  using: _131@Mir(bb33[0])
  _129 = move _130 as i32 (IntToInt)
  using: _130@Mir(bb33[1])
  _139 = const 8_i32
  using: 
  _140 = CheckedShl(_129, _139)
  using: _129@Mir(bb33[2]), _139@Mir(bb33[3])
  assert(!move (_140.1: bool), "attempt to shift left by `{}`, which would overflow", move _139) -> bb34
  using: _140@Entry, _129@Entry, _139@Entry
bb34:
  _128 = move (_140.0: i32)
  using: _140@Mir(bb33[4])
  _9 = BitOr(move _124, move _128)
  using: _124@Mir(bb31[0]), _128@Mir(bb34[0])
  _144 = _4
  using: _4@Phi(bb11)
  _146 = _9
  using: _9@Mir(bb34[1])
  _145 = move _146 as isize (IntToInt)
  using: _146@Mir(bb34[3])
  _143 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _144, move _145) -> bb35
  using: _144@Mir(bb34[2]), _145@Mir(bb34[4])
bb35:
  _142 = (*_143)
  using: _143@Mir(bb34[5])
  _141 = core::num::<impl u32>::wrapping_add(move _142, const 1_u32) -> bb36
  using: _142@Mir(bb35[0])
bb36:
  _148 = _4
  using: _4@Phi(bb11)
  _150 = _9
  using: _9@Mir(bb34[1])
  _149 = move _150 as isize (IntToInt)
  using: _150@Mir(bb36[1])
  _147 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _148, move _149) -> bb37
  using: _148@Mir(bb36[0]), _149@Mir(bb36[2])
bb37:
  (*_147) = move _141
  using: _147@Mir(bb36[3]), _141@Mir(bb35[1])
  _151 = const 0_i32
  using: 
  _153 = _3
  using: _3@Phi(bb11)
  _156 = _8
  using: _8@Phi(bb11)
  _157 = const 3_i32
  using: 
  _158 = CheckedSub(_156, _157)
  using: _156@Mir(bb37[3]), _157@Mir(bb37[4])
  assert(!move (_158.1: bool), "attempt to compute `{} - {}`, which would overflow", move _156, move _157) -> bb38
  using: _158@Entry, _156@Entry, _157@Entry
bb38:
  _155 = move (_158.0: i32)
  using: _158@Mir(bb37[5])
  _154 = move _155 as isize (IntToInt)
  using: _155@Mir(bb38[0])
  _152 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _153, move _154) -> bb39
  using: _153@Mir(bb37[2]), _154@Mir(bb38[1])
bb39:
  (*_152) = move _151 as u16 (IntToInt)
  using: _152@Mir(bb38[2]), _151@Mir(bb37[1])
  _160 = _9
  using: _9@Mir(bb34[1])
  _161 = const 8_i32
  using: 
  _162 = CheckedShr(_160, _161)
  using: _160@Mir(bb39[1]), _161@Mir(bb39[2])
  assert(!move (_162.1: bool), "attempt to shift right by `{}`, which would overflow", move _161) -> bb40
  using: _162@Entry, _160@Entry, _161@Entry
bb40:
  _159 = move (_162.0: i32)
  using: _162@Mir(bb39[3])
  _168 = _2
  using: _2@Phi(bb11)
  _171 = _8
  using: _8@Phi(bb11)
  _172 = const 3_i32
  using: 
  _173 = CheckedSub(_171, _172)
  using: _171@Mir(bb40[2]), _172@Mir(bb40[3])
  assert(!move (_173.1: bool), "attempt to compute `{} - {}`, which would overflow", move _171, move _172) -> bb41
  using: _173@Entry, _171@Entry, _172@Entry
bb41:
  _170 = move (_173.0: i32)
  using: _173@Mir(bb40[4])
  _169 = move _170 as isize (IntToInt)
  using: _170@Mir(bb41[0])
  _167 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _168, move _169) -> bb42
  using: _168@Mir(bb40[1]), _169@Mir(bb41[1])
bb42:
  _166 = (*_167)
  using: _167@Mir(bb41[2])
  _165 = move _166 as u16 (IntToInt)
  using: _166@Mir(bb42[0])
  _164 = move _165 as i32 (IntToInt)
  using: _165@Mir(bb42[1])
  _174 = const 8_i32
  using: 
  _175 = CheckedShl(_164, _174)
  using: _164@Mir(bb42[2]), _174@Mir(bb42[3])
  assert(!move (_175.1: bool), "attempt to shift left by `{}`, which would overflow", move _174) -> bb43
  using: _175@Entry, _164@Entry, _174@Entry
bb43:
  _163 = move (_175.0: i32)
  using: _175@Mir(bb42[4])
  _9 = BitOr(move _159, move _163)
  using: _159@Mir(bb40[0]), _163@Mir(bb43[0])
  _179 = _4
  using: _4@Phi(bb11)
  _181 = _9
  using: _9@Mir(bb43[1])
  _180 = move _181 as isize (IntToInt)
  using: _181@Mir(bb43[3])
  _178 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _179, move _180) -> bb44
  using: _179@Mir(bb43[2]), _180@Mir(bb43[4])
bb44:
  _177 = (*_178)
  using: _178@Mir(bb43[5])
  _176 = core::num::<impl u32>::wrapping_add(move _177, const 1_u32) -> bb45
  using: _177@Mir(bb44[0])
bb45:
  _183 = _4
  using: _4@Phi(bb11)
  _185 = _9
  using: _9@Mir(bb43[1])
  _184 = move _185 as isize (IntToInt)
  using: _185@Mir(bb45[1])
  _182 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _183, move _184) -> bb46
  using: _183@Mir(bb45[0]), _184@Mir(bb45[2])
bb46:
  (*_182) = move _176
  using: _182@Mir(bb45[3]), _176@Mir(bb44[1])
  _186 = const 4_i32
  using: 
  _187 = CheckedSub(_8, _186)
  using: _8@Phi(bb11), _186@Mir(bb46[1])
  assert(!move (_187.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, move _186) -> bb47
  using: _187@Entry, _8@Entry, _186@Entry
bb47:
  _8 = move (_187.0: i32)
  using: _187@Mir(bb46[2])
  goto -> bb11
  using: 
bb48:
  _189 = _8
  using: _8@Phi(bb48)
  _190 = const 0_i32
  using: 
  _188 = Ge(move _189, move _190)
  using: _189@Mir(bb48[0]), _190@Mir(bb48[1])
  switchInt(move _188) -> [0: bb58, otherwise: bb49]
  using: _188@Mir(bb48[2])
bb49:
  _191 = const 0_i32
  using: 
  _193 = _3
  using: _3@Phi(bb48)
  _195 = _8
  using: _8@Phi(bb48)
  _194 = move _195 as isize (IntToInt)
  using: _195@Mir(bb49[2])
  _192 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _193, move _194) -> bb50
  using: _193@Mir(bb49[1]), _194@Mir(bb49[3])
bb50:
  (*_192) = move _191 as u16 (IntToInt)
  using: _192@Mir(bb49[4]), _191@Mir(bb49[0])
  _197 = _9
  using: _9@Phi(bb48)
  _198 = const 8_i32
  using: 
  _199 = CheckedShr(_197, _198)
  using: _197@Mir(bb50[1]), _198@Mir(bb50[2])
  assert(!move (_199.1: bool), "attempt to shift right by `{}`, which would overflow", move _198) -> bb51
  using: _199@Entry, _197@Entry, _198@Entry
bb51:
  _196 = move (_199.0: i32)
  using: _199@Mir(bb50[3])
  _205 = _2
  using: _2@Phi(bb48)
  _207 = _8
  using: _8@Phi(bb48)
  _206 = move _207 as isize (IntToInt)
  using: _207@Mir(bb51[2])
  _204 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _205, move _206) -> bb52
  using: _205@Mir(bb51[1]), _206@Mir(bb51[3])
bb52:
  _203 = (*_204)
  using: _204@Mir(bb51[4])
  _202 = move _203 as u16 (IntToInt)
  using: _203@Mir(bb52[0])
  _201 = move _202 as i32 (IntToInt)
  using: _202@Mir(bb52[1])
  _208 = const 8_i32
  using: 
  _209 = CheckedShl(_201, _208)
  using: _201@Mir(bb52[2]), _208@Mir(bb52[3])
  assert(!move (_209.1: bool), "attempt to shift left by `{}`, which would overflow", move _208) -> bb53
  using: _209@Entry, _201@Entry, _208@Entry
bb53:
  _200 = move (_209.0: i32)
  using: _209@Mir(bb52[4])
  _9 = BitOr(move _196, move _200)
  using: _196@Mir(bb51[0]), _200@Mir(bb53[0])
  _213 = _4
  using: _4@Phi(bb48)
  _215 = _9
  using: _9@Mir(bb53[1])
  _214 = move _215 as isize (IntToInt)
  using: _215@Mir(bb53[3])
  _212 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _213, move _214) -> bb54
  using: _213@Mir(bb53[2]), _214@Mir(bb53[4])
bb54:
  _211 = (*_212)
  using: _212@Mir(bb53[5])
  _210 = core::num::<impl u32>::wrapping_add(move _211, const 1_u32) -> bb55
  using: _211@Mir(bb54[0])
bb55:
  _217 = _4
  using: _4@Phi(bb48)
  _219 = _9
  using: _9@Mir(bb53[1])
  _218 = move _219 as isize (IntToInt)
  using: _219@Mir(bb55[1])
  _216 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _217, move _218) -> bb56
  using: _217@Mir(bb55[0]), _218@Mir(bb55[2])
bb56:
  (*_216) = move _210
  using: _216@Mir(bb55[3]), _210@Mir(bb54[1])
  _220 = CheckedSub(_8, const 1_i32)
  using: _8@Phi(bb48)
  assert(!move (_220.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_i32) -> bb57
  using: _220@Entry, _8@Entry
bb57:
  _8 = move (_220.0: i32)
  using: _220@Mir(bb56[1])
  goto -> bb48
  using: 
bb58:
  _8 = const 0_i32
  using: 
  goto -> bb59
  using: 
bb59:
  _222 = _8
  using: _8@Phi(bb59)
  _223 = const 34_i32
  using: 
  _221 = Lt(move _222, move _223)
  using: _222@Mir(bb59[0]), _223@Mir(bb59[1])
  switchInt(move _221) -> [0: bb67, otherwise: bb60]
  using: _221@Mir(bb59[2])
bb60:
  _226 = _2
  using: _2@Phi(bb59)
  _228 = _8
  using: _8@Phi(bb59)
  _227 = move _228 as isize (IntToInt)
  using: _228@Mir(bb60[1])
  _225 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _226, move _227) -> bb61
  using: _226@Mir(bb60[0]), _227@Mir(bb60[2])
bb61:
  _224 = (*_225)
  using: _225@Mir(bb60[3])
  _230 = _2
  using: _2@Phi(bb59)
  _233 = _5
  using: _5@Phi(bb59)
  _234 = _8
  using: _8@Phi(bb59)
  _235 = CheckedAdd(_233, _234)
  using: _233@Mir(bb61[2]), _234@Mir(bb61[3])
  assert(!move (_235.1: bool), "attempt to compute `{} + {}`, which would overflow", move _233, move _234) -> bb62
  using: _235@Entry, _233@Entry, _234@Entry
bb62:
  _232 = move (_235.0: i32)
  using: _235@Mir(bb61[4])
  _231 = move _232 as isize (IntToInt)
  using: _232@Mir(bb62[0])
  _229 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _230, move _231) -> bb63
  using: _230@Mir(bb61[1]), _231@Mir(bb62[1])
bb63:
  (*_229) = move _224
  using: _229@Mir(bb62[2]), _224@Mir(bb61[0])
  _236 = const 0_i32
  using: 
  _238 = _3
  using: _3@Phi(bb59)
  _241 = _5
  using: _5@Phi(bb59)
  _242 = _8
  using: _8@Phi(bb59)
  _243 = CheckedAdd(_241, _242)
  using: _241@Mir(bb63[3]), _242@Mir(bb63[4])
  assert(!move (_243.1: bool), "attempt to compute `{} + {}`, which would overflow", move _241, move _242) -> bb64
  using: _243@Entry, _241@Entry, _242@Entry
bb64:
  _240 = move (_243.0: i32)
  using: _243@Mir(bb63[5])
  _239 = move _240 as isize (IntToInt)
  using: _240@Mir(bb64[0])
  _237 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _238, move _239) -> bb65
  using: _238@Mir(bb63[2]), _239@Mir(bb64[1])
bb65:
  (*_237) = move _236 as u16 (IntToInt)
  using: _237@Mir(bb64[2]), _236@Mir(bb63[1])
  _244 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb59)
  assert(!move (_244.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb66
  using: _244@Entry, _8@Entry
bb66:
  _8 = move (_244.0: i32)
  using: _244@Mir(bb65[1])
  goto -> bb59
  using: 
bb67:
  _246 = _6
  using: _6@Entry
  _247 = const 4_i32
  using: 
  _245 = Ge(move _246, move _247)
  using: _246@Mir(bb67[0]), _247@Mir(bb67[1])
  switchInt(move _245) -> [0: bb69, otherwise: bb68]
  using: _245@Mir(bb67[2])
bb68:
  _250 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _249 = (*_250)
  using: _250@Mir(bb68[0])
  _254 = const b"        bucket sorting ...\n\x00"
  using: 
  _253 = &raw const (*_254)
  using: _254@Mir(bb68[2])
  _252 = move _253 as *const u8 (Pointer(ArrayToPointer))
  using: _253@Mir(bb68[3])
  _251 = move _252 as *const i8 (PtrToPtr)
  using: _252@Mir(bb68[4])
  _248 = blocksort::fprintf(move _249, move _251) -> bb69
  using: _249@Mir(bb68[1]), _251@Mir(bb68[5])
bb69:
  _8 = const 1_i32
  using: 
  goto -> bb70
  using: 
bb70:
  _256 = _8
  using: _8@Phi(bb70)
  _257 = const 65536_i32
  using: 
  _255 = Le(move _256, move _257)
  using: _256@Mir(bb70[0]), _257@Mir(bb70[1])
  switchInt(move _255) -> [0: bb78, otherwise: bb71]
  using: _255@Mir(bb70[2])
bb71:
  _261 = _4
  using: _4@Phi(bb70)
  _263 = _8
  using: _8@Phi(bb70)
  _262 = move _263 as isize (IntToInt)
  using: _263@Mir(bb71[1])
  _260 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _261, move _262) -> bb72
  using: _261@Mir(bb71[0]), _262@Mir(bb71[2])
bb72:
  _259 = (*_260)
  using: _260@Mir(bb71[3])
  _266 = _4
  using: _4@Phi(bb70)
  _269 = _8
  using: _8@Phi(bb70)
  _270 = const 1_i32
  using: 
  _271 = CheckedSub(_269, _270)
  using: _269@Mir(bb72[2]), _270@Mir(bb72[3])
  assert(!move (_271.1: bool), "attempt to compute `{} - {}`, which would overflow", move _269, move _270) -> bb73
  using: _271@Entry, _269@Entry, _270@Entry
bb73:
  _268 = move (_271.0: i32)
  using: _271@Mir(bb72[4])
  _267 = move _268 as isize (IntToInt)
  using: _268@Mir(bb73[0])
  _265 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _266, move _267) -> bb74
  using: _266@Mir(bb72[1]), _267@Mir(bb73[1])
bb74:
  _264 = (*_265)
  using: _265@Mir(bb73[2])
  _258 = core::num::<impl u32>::wrapping_add(move _259, move _264) -> bb75
  using: _259@Mir(bb72[0]), _264@Mir(bb74[0])
bb75:
  _273 = _4
  using: _4@Phi(bb70)
  _275 = _8
  using: _8@Phi(bb70)
  _274 = move _275 as isize (IntToInt)
  using: _275@Mir(bb75[1])
  _272 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _273, move _274) -> bb76
  using: _273@Mir(bb75[0]), _274@Mir(bb75[2])
bb76:
  (*_272) = move _258
  using: _272@Mir(bb75[3]), _258@Mir(bb74[1])
  _276 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb70)
  assert(!move (_276.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb77
  using: _276@Entry, _8@Entry
bb77:
  _8 = move (_276.0: i32)
  using: _276@Mir(bb76[1])
  goto -> bb70
  using: 
bb78:
  _281 = _2
  using: _2@Phi(bb59)
  _282 = const 0_isize
  using: 
  _280 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _281, move _282) -> bb79
  using: _281@Mir(bb78[0]), _282@Mir(bb78[1])
bb79:
  _279 = (*_280)
  using: _280@Mir(bb78[2])
  _278 = move _279 as i32 (IntToInt)
  using: _279@Mir(bb79[0])
  _283 = const 8_i32
  using: 
  _284 = CheckedShl(_278, _283)
  using: _278@Mir(bb79[1]), _283@Mir(bb79[2])
  assert(!move (_284.1: bool), "attempt to shift left by `{}`, which would overflow", move _283) -> bb80
  using: _284@Entry, _278@Entry, _283@Entry
bb80:
  _277 = move (_284.0: i32)
  using: _284@Mir(bb79[3])
  _19 = move _277 as u16 (IntToInt)
  using: _277@Mir(bb80[0])
  _285 = _5
  using: _5@Phi(bb59)
  _286 = const 1_i32
  using: 
  _287 = CheckedSub(_285, _286)
  using: _285@Mir(bb80[2]), _286@Mir(bb80[3])
  assert(!move (_287.1: bool), "attempt to compute `{} - {}`, which would overflow", move _285, move _286) -> bb81
  using: _287@Entry, _285@Entry, _286@Entry
bb81:
  _8 = move (_287.0: i32)
  using: _287@Mir(bb80[4])
  goto -> bb82
  using: 
bb82:
  _289 = _8
  using: _8@Phi(bb82)
  _290 = const 3_i32
  using: 
  _288 = Ge(move _289, move _290)
  using: _289@Mir(bb82[0]), _290@Mir(bb82[1])
  switchInt(move _288) -> [0: bb119, otherwise: bb83]
  using: _288@Mir(bb82[2])
bb83:
  _294 = _19
  using: _19@Phi(bb82)
  _293 = move _294 as i32 (IntToInt)
  using: _294@Mir(bb83[0])
  _295 = const 8_i32
  using: 
  _296 = CheckedShr(_293, _295)
  using: _293@Mir(bb83[1]), _295@Mir(bb83[2])
  assert(!move (_296.1: bool), "attempt to shift right by `{}`, which would overflow", move _295) -> bb84
  using: _296@Entry, _293@Entry, _295@Entry
bb84:
  _292 = move (_296.0: i32)
  using: _296@Mir(bb83[3])
  _301 = _2
  using: _2@Phi(bb82)
  _303 = _8
  using: _8@Phi(bb82)
  _302 = move _303 as isize (IntToInt)
  using: _303@Mir(bb84[2])
  _300 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _301, move _302) -> bb85
  using: _301@Mir(bb84[1]), _302@Mir(bb84[3])
bb85:
  _299 = (*_300)
  using: _300@Mir(bb84[4])
  _298 = move _299 as i32 (IntToInt)
  using: _299@Mir(bb85[0])
  _304 = const 8_i32
  using: 
  _305 = CheckedShl(_298, _304)
  using: _298@Mir(bb85[1]), _304@Mir(bb85[2])
  assert(!move (_305.1: bool), "attempt to shift left by `{}`, which would overflow", move _304) -> bb86
  using: _305@Entry, _298@Entry, _304@Entry
bb86:
  _297 = move (_305.0: i32)
  using: _305@Mir(bb85[3])
  _291 = BitOr(move _292, move _297)
  using: _292@Mir(bb84[0]), _297@Mir(bb86[0])
  _19 = move _291 as u16 (IntToInt)
  using: _291@Mir(bb86[1])
  _309 = _4
  using: _4@Phi(bb82)
  _311 = _19
  using: _19@Mir(bb86[2])
  _310 = move _311 as isize (IntToInt)
  using: _311@Mir(bb86[4])
  _308 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _309, move _310) -> bb87
  using: _309@Mir(bb86[3]), _310@Mir(bb86[5])
bb87:
  _307 = (*_308)
  using: _308@Mir(bb86[6])
  _312 = const 1_u32
  using: 
  _306 = core::num::<impl u32>::wrapping_sub(move _307, move _312) -> bb88
  using: _307@Mir(bb87[0]), _312@Mir(bb87[1])
bb88:
  _9 = move _306 as i32 (IntToInt)
  using: _306@Mir(bb87[2])
  _313 = _9
  using: _9@Mir(bb88[0])
  _315 = _4
  using: _4@Phi(bb82)
  _317 = _19
  using: _19@Mir(bb86[2])
  _316 = move _317 as isize (IntToInt)
  using: _317@Mir(bb88[3])
  _314 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _315, move _316) -> bb89
  using: _315@Mir(bb88[2]), _316@Mir(bb88[4])
bb89:
  (*_314) = move _313 as u32 (IntToInt)
  using: _314@Mir(bb88[5]), _313@Mir(bb88[1])
  _318 = _8
  using: _8@Phi(bb82)
  _320 = _1
  using: _1@Phi(bb82)
  _322 = _9
  using: _9@Mir(bb88[0])
  _321 = move _322 as isize (IntToInt)
  using: _322@Mir(bb89[3])
  _319 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _320, move _321) -> bb90
  using: _320@Mir(bb89[2]), _321@Mir(bb89[4])
bb90:
  (*_319) = move _318 as u32 (IntToInt)
  using: _319@Mir(bb89[5]), _318@Mir(bb89[1])
  _326 = _19
  using: _19@Mir(bb86[2])
  _325 = move _326 as i32 (IntToInt)
  using: _326@Mir(bb90[1])
  _327 = const 8_i32
  using: 
  _328 = CheckedShr(_325, _327)
  using: _325@Mir(bb90[2]), _327@Mir(bb90[3])
  assert(!move (_328.1: bool), "attempt to shift right by `{}`, which would overflow", move _327) -> bb91
  using: _328@Entry, _325@Entry, _327@Entry
bb91:
  _324 = move (_328.0: i32)
  using: _328@Mir(bb90[4])
  _333 = _2
  using: _2@Phi(bb82)
  _336 = _8
  using: _8@Phi(bb82)
  _337 = const 1_i32
  using: 
  _338 = CheckedSub(_336, _337)
  using: _336@Mir(bb91[2]), _337@Mir(bb91[3])
  assert(!move (_338.1: bool), "attempt to compute `{} - {}`, which would overflow", move _336, move _337) -> bb92
  using: _338@Entry, _336@Entry, _337@Entry
bb92:
  _335 = move (_338.0: i32)
  using: _338@Mir(bb91[4])
  _334 = move _335 as isize (IntToInt)
  using: _335@Mir(bb92[0])
  _332 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _333, move _334) -> bb93
  using: _333@Mir(bb91[1]), _334@Mir(bb92[1])
bb93:
  _331 = (*_332)
  using: _332@Mir(bb92[2])
  _330 = move _331 as i32 (IntToInt)
  using: _331@Mir(bb93[0])
  _339 = const 8_i32
  using: 
  _340 = CheckedShl(_330, _339)
  using: _330@Mir(bb93[1]), _339@Mir(bb93[2])
  assert(!move (_340.1: bool), "attempt to shift left by `{}`, which would overflow", move _339) -> bb94
  using: _340@Entry, _330@Entry, _339@Entry
bb94:
  _329 = move (_340.0: i32)
  using: _340@Mir(bb93[3])
  _323 = BitOr(move _324, move _329)
  using: _324@Mir(bb91[0]), _329@Mir(bb94[0])
  _19 = move _323 as u16 (IntToInt)
  using: _323@Mir(bb94[1])
  _344 = _4
  using: _4@Phi(bb82)
  _346 = _19
  using: _19@Mir(bb94[2])
  _345 = move _346 as isize (IntToInt)
  using: _346@Mir(bb94[4])
  _343 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _344, move _345) -> bb95
  using: _344@Mir(bb94[3]), _345@Mir(bb94[5])
bb95:
  _342 = (*_343)
  using: _343@Mir(bb94[6])
  _347 = const 1_u32
  using: 
  _341 = core::num::<impl u32>::wrapping_sub(move _342, move _347) -> bb96
  using: _342@Mir(bb95[0]), _347@Mir(bb95[1])
bb96:
  _9 = move _341 as i32 (IntToInt)
  using: _341@Mir(bb95[2])
  _348 = _9
  using: _9@Mir(bb96[0])
  _350 = _4
  using: _4@Phi(bb82)
  _352 = _19
  using: _19@Mir(bb94[2])
  _351 = move _352 as isize (IntToInt)
  using: _352@Mir(bb96[3])
  _349 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _350, move _351) -> bb97
  using: _350@Mir(bb96[2]), _351@Mir(bb96[4])
bb97:
  (*_349) = move _348 as u32 (IntToInt)
  using: _349@Mir(bb96[5]), _348@Mir(bb96[1])
  _354 = _8
  using: _8@Phi(bb82)
  _355 = const 1_i32
  using: 
  _356 = CheckedSub(_354, _355)
  using: _354@Mir(bb97[1]), _355@Mir(bb97[2])
  assert(!move (_356.1: bool), "attempt to compute `{} - {}`, which would overflow", move _354, move _355) -> bb98
  using: _356@Entry, _354@Entry, _355@Entry
bb98:
  _353 = move (_356.0: i32)
  using: _356@Mir(bb97[3])
  _358 = _1
  using: _1@Phi(bb82)
  _360 = _9
  using: _9@Mir(bb96[0])
  _359 = move _360 as isize (IntToInt)
  using: _360@Mir(bb98[2])
  _357 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _358, move _359) -> bb99
  using: _358@Mir(bb98[1]), _359@Mir(bb98[3])
bb99:
  (*_357) = move _353 as u32 (IntToInt)
  using: _357@Mir(bb98[4]), _353@Mir(bb98[0])
  _364 = _19
  using: _19@Mir(bb94[2])
  _363 = move _364 as i32 (IntToInt)
  using: _364@Mir(bb99[1])
  _365 = const 8_i32
  using: 
  _366 = CheckedShr(_363, _365)
  using: _363@Mir(bb99[2]), _365@Mir(bb99[3])
  assert(!move (_366.1: bool), "attempt to shift right by `{}`, which would overflow", move _365) -> bb100
  using: _366@Entry, _363@Entry, _365@Entry
bb100:
  _362 = move (_366.0: i32)
  using: _366@Mir(bb99[4])
  _371 = _2
  using: _2@Phi(bb82)
  _374 = _8
  using: _8@Phi(bb82)
  _375 = const 2_i32
  using: 
  _376 = CheckedSub(_374, _375)
  using: _374@Mir(bb100[2]), _375@Mir(bb100[3])
  assert(!move (_376.1: bool), "attempt to compute `{} - {}`, which would overflow", move _374, move _375) -> bb101
  using: _376@Entry, _374@Entry, _375@Entry
bb101:
  _373 = move (_376.0: i32)
  using: _376@Mir(bb100[4])
  _372 = move _373 as isize (IntToInt)
  using: _373@Mir(bb101[0])
  _370 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _371, move _372) -> bb102
  using: _371@Mir(bb100[1]), _372@Mir(bb101[1])
bb102:
  _369 = (*_370)
  using: _370@Mir(bb101[2])
  _368 = move _369 as i32 (IntToInt)
  using: _369@Mir(bb102[0])
  _377 = const 8_i32
  using: 
  _378 = CheckedShl(_368, _377)
  using: _368@Mir(bb102[1]), _377@Mir(bb102[2])
  assert(!move (_378.1: bool), "attempt to shift left by `{}`, which would overflow", move _377) -> bb103
  using: _378@Entry, _368@Entry, _377@Entry
bb103:
  _367 = move (_378.0: i32)
  using: _378@Mir(bb102[3])
  _361 = BitOr(move _362, move _367)
  using: _362@Mir(bb100[0]), _367@Mir(bb103[0])
  _19 = move _361 as u16 (IntToInt)
  using: _361@Mir(bb103[1])
  _382 = _4
  using: _4@Phi(bb82)
  _384 = _19
  using: _19@Mir(bb103[2])
  _383 = move _384 as isize (IntToInt)
  using: _384@Mir(bb103[4])
  _381 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _382, move _383) -> bb104
  using: _382@Mir(bb103[3]), _383@Mir(bb103[5])
bb104:
  _380 = (*_381)
  using: _381@Mir(bb103[6])
  _385 = const 1_u32
  using: 
  _379 = core::num::<impl u32>::wrapping_sub(move _380, move _385) -> bb105
  using: _380@Mir(bb104[0]), _385@Mir(bb104[1])
bb105:
  _9 = move _379 as i32 (IntToInt)
  using: _379@Mir(bb104[2])
  _386 = _9
  using: _9@Mir(bb105[0])
  _388 = _4
  using: _4@Phi(bb82)
  _390 = _19
  using: _19@Mir(bb103[2])
  _389 = move _390 as isize (IntToInt)
  using: _390@Mir(bb105[3])
  _387 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _388, move _389) -> bb106
  using: _388@Mir(bb105[2]), _389@Mir(bb105[4])
bb106:
  (*_387) = move _386 as u32 (IntToInt)
  using: _387@Mir(bb105[5]), _386@Mir(bb105[1])
  _392 = _8
  using: _8@Phi(bb82)
  _393 = const 2_i32
  using: 
  _394 = CheckedSub(_392, _393)
  using: _392@Mir(bb106[1]), _393@Mir(bb106[2])
  assert(!move (_394.1: bool), "attempt to compute `{} - {}`, which would overflow", move _392, move _393) -> bb107
  using: _394@Entry, _392@Entry, _393@Entry
bb107:
  _391 = move (_394.0: i32)
  using: _394@Mir(bb106[3])
  _396 = _1
  using: _1@Phi(bb82)
  _398 = _9
  using: _9@Mir(bb105[0])
  _397 = move _398 as isize (IntToInt)
  using: _398@Mir(bb107[2])
  _395 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _396, move _397) -> bb108
  using: _396@Mir(bb107[1]), _397@Mir(bb107[3])
bb108:
  (*_395) = move _391 as u32 (IntToInt)
  using: _395@Mir(bb107[4]), _391@Mir(bb107[0])
  _402 = _19
  using: _19@Mir(bb103[2])
  _401 = move _402 as i32 (IntToInt)
  using: _402@Mir(bb108[1])
  _403 = const 8_i32
  using: 
  _404 = CheckedShr(_401, _403)
  using: _401@Mir(bb108[2]), _403@Mir(bb108[3])
  assert(!move (_404.1: bool), "attempt to shift right by `{}`, which would overflow", move _403) -> bb109
  using: _404@Entry, _401@Entry, _403@Entry
bb109:
  _400 = move (_404.0: i32)
  using: _404@Mir(bb108[4])
  _409 = _2
  using: _2@Phi(bb82)
  _412 = _8
  using: _8@Phi(bb82)
  _413 = const 3_i32
  using: 
  _414 = CheckedSub(_412, _413)
  using: _412@Mir(bb109[2]), _413@Mir(bb109[3])
  assert(!move (_414.1: bool), "attempt to compute `{} - {}`, which would overflow", move _412, move _413) -> bb110
  using: _414@Entry, _412@Entry, _413@Entry
bb110:
  _411 = move (_414.0: i32)
  using: _414@Mir(bb109[4])
  _410 = move _411 as isize (IntToInt)
  using: _411@Mir(bb110[0])
  _408 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _409, move _410) -> bb111
  using: _409@Mir(bb109[1]), _410@Mir(bb110[1])
bb111:
  _407 = (*_408)
  using: _408@Mir(bb110[2])
  _406 = move _407 as i32 (IntToInt)
  using: _407@Mir(bb111[0])
  _415 = const 8_i32
  using: 
  _416 = CheckedShl(_406, _415)
  using: _406@Mir(bb111[1]), _415@Mir(bb111[2])
  assert(!move (_416.1: bool), "attempt to shift left by `{}`, which would overflow", move _415) -> bb112
  using: _416@Entry, _406@Entry, _415@Entry
bb112:
  _405 = move (_416.0: i32)
  using: _416@Mir(bb111[3])
  _399 = BitOr(move _400, move _405)
  using: _400@Mir(bb109[0]), _405@Mir(bb112[0])
  _19 = move _399 as u16 (IntToInt)
  using: _399@Mir(bb112[1])
  _420 = _4
  using: _4@Phi(bb82)
  _422 = _19
  using: _19@Mir(bb112[2])
  _421 = move _422 as isize (IntToInt)
  using: _422@Mir(bb112[4])
  _419 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _420, move _421) -> bb113
  using: _420@Mir(bb112[3]), _421@Mir(bb112[5])
bb113:
  _418 = (*_419)
  using: _419@Mir(bb112[6])
  _423 = const 1_u32
  using: 
  _417 = core::num::<impl u32>::wrapping_sub(move _418, move _423) -> bb114
  using: _418@Mir(bb113[0]), _423@Mir(bb113[1])
bb114:
  _9 = move _417 as i32 (IntToInt)
  using: _417@Mir(bb113[2])
  _424 = _9
  using: _9@Mir(bb114[0])
  _426 = _4
  using: _4@Phi(bb82)
  _428 = _19
  using: _19@Mir(bb112[2])
  _427 = move _428 as isize (IntToInt)
  using: _428@Mir(bb114[3])
  _425 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _426, move _427) -> bb115
  using: _426@Mir(bb114[2]), _427@Mir(bb114[4])
bb115:
  (*_425) = move _424 as u32 (IntToInt)
  using: _425@Mir(bb114[5]), _424@Mir(bb114[1])
  _430 = _8
  using: _8@Phi(bb82)
  _431 = const 3_i32
  using: 
  _432 = CheckedSub(_430, _431)
  using: _430@Mir(bb115[1]), _431@Mir(bb115[2])
  assert(!move (_432.1: bool), "attempt to compute `{} - {}`, which would overflow", move _430, move _431) -> bb116
  using: _432@Entry, _430@Entry, _431@Entry
bb116:
  _429 = move (_432.0: i32)
  using: _432@Mir(bb115[3])
  _434 = _1
  using: _1@Phi(bb82)
  _436 = _9
  using: _9@Mir(bb114[0])
  _435 = move _436 as isize (IntToInt)
  using: _436@Mir(bb116[2])
  _433 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _434, move _435) -> bb117
  using: _434@Mir(bb116[1]), _435@Mir(bb116[3])
bb117:
  (*_433) = move _429 as u32 (IntToInt)
  using: _433@Mir(bb116[4]), _429@Mir(bb116[0])
  _437 = const 4_i32
  using: 
  _438 = CheckedSub(_8, _437)
  using: _8@Phi(bb82), _437@Mir(bb117[1])
  assert(!move (_438.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, move _437) -> bb118
  using: _438@Entry, _8@Entry, _437@Entry
bb118:
  _8 = move (_438.0: i32)
  using: _438@Mir(bb117[2])
  goto -> bb82
  using: 
bb119:
  _440 = _8
  using: _8@Phi(bb119)
  _441 = const 0_i32
  using: 
  _439 = Ge(move _440, move _441)
  using: _440@Mir(bb119[0]), _441@Mir(bb119[1])
  switchInt(move _439) -> [0: bb129, otherwise: bb120]
  using: _439@Mir(bb119[2])
bb120:
  _445 = _19
  using: _19@Phi(bb119)
  _444 = move _445 as i32 (IntToInt)
  using: _445@Mir(bb120[0])
  _446 = const 8_i32
  using: 
  _447 = CheckedShr(_444, _446)
  using: _444@Mir(bb120[1]), _446@Mir(bb120[2])
  assert(!move (_447.1: bool), "attempt to shift right by `{}`, which would overflow", move _446) -> bb121
  using: _447@Entry, _444@Entry, _446@Entry
bb121:
  _443 = move (_447.0: i32)
  using: _447@Mir(bb120[3])
  _452 = _2
  using: _2@Phi(bb119)
  _454 = _8
  using: _8@Phi(bb119)
  _453 = move _454 as isize (IntToInt)
  using: _454@Mir(bb121[2])
  _451 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _452, move _453) -> bb122
  using: _452@Mir(bb121[1]), _453@Mir(bb121[3])
bb122:
  _450 = (*_451)
  using: _451@Mir(bb121[4])
  _449 = move _450 as i32 (IntToInt)
  using: _450@Mir(bb122[0])
  _455 = const 8_i32
  using: 
  _456 = CheckedShl(_449, _455)
  using: _449@Mir(bb122[1]), _455@Mir(bb122[2])
  assert(!move (_456.1: bool), "attempt to shift left by `{}`, which would overflow", move _455) -> bb123
  using: _456@Entry, _449@Entry, _455@Entry
bb123:
  _448 = move (_456.0: i32)
  using: _456@Mir(bb122[3])
  _442 = BitOr(move _443, move _448)
  using: _443@Mir(bb121[0]), _448@Mir(bb123[0])
  _19 = move _442 as u16 (IntToInt)
  using: _442@Mir(bb123[1])
  _460 = _4
  using: _4@Phi(bb119)
  _462 = _19
  using: _19@Mir(bb123[2])
  _461 = move _462 as isize (IntToInt)
  using: _462@Mir(bb123[4])
  _459 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _460, move _461) -> bb124
  using: _460@Mir(bb123[3]), _461@Mir(bb123[5])
bb124:
  _458 = (*_459)
  using: _459@Mir(bb123[6])
  _463 = const 1_u32
  using: 
  _457 = core::num::<impl u32>::wrapping_sub(move _458, move _463) -> bb125
  using: _458@Mir(bb124[0]), _463@Mir(bb124[1])
bb125:
  _9 = move _457 as i32 (IntToInt)
  using: _457@Mir(bb124[2])
  _464 = _9
  using: _9@Mir(bb125[0])
  _466 = _4
  using: _4@Phi(bb119)
  _468 = _19
  using: _19@Mir(bb123[2])
  _467 = move _468 as isize (IntToInt)
  using: _468@Mir(bb125[3])
  _465 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _466, move _467) -> bb126
  using: _466@Mir(bb125[2]), _467@Mir(bb125[4])
bb126:
  (*_465) = move _464 as u32 (IntToInt)
  using: _465@Mir(bb125[5]), _464@Mir(bb125[1])
  _469 = _8
  using: _8@Phi(bb119)
  _471 = _1
  using: _1@Phi(bb119)
  _473 = _9
  using: _9@Mir(bb125[0])
  _472 = move _473 as isize (IntToInt)
  using: _473@Mir(bb126[3])
  _470 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _471, move _472) -> bb127
  using: _471@Mir(bb126[2]), _472@Mir(bb126[4])
bb127:
  (*_470) = move _469 as u32 (IntToInt)
  using: _470@Mir(bb126[5]), _469@Mir(bb126[1])
  _474 = CheckedSub(_8, const 1_i32)
  using: _8@Phi(bb119)
  assert(!move (_474.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_i32) -> bb128
  using: _474@Entry, _8@Entry
bb128:
  _8 = move (_474.0: i32)
  using: _474@Mir(bb127[1])
  goto -> bb119
  using: 
bb129:
  _8 = const 0_i32
  using: 
  goto -> bb130
  using: 
bb130:
  _476 = _8
  using: _8@Phi(bb130)
  _477 = const 255_i32
  using: 
  _475 = Le(move _476, move _477)
  using: _476@Mir(bb130[0]), _477@Mir(bb130[1])
  switchInt(move _475) -> [0: bb135, otherwise: bb131]
  using: _475@Mir(bb130[2])
bb131:
  _478 = const 0_i32
  using: 
  _480 = _8
  using: _8@Phi(bb130)
  _479 = move _480 as usize (IntToInt)
  using: _480@Mir(bb131[1])
  _481 = const 256_usize
  using: 
  _482 = Lt(_479, _481)
  using: _479@Mir(bb131[2]), _481@Mir(bb131[3])
  assert(move _482, "index out of bounds: the length is {} but the index is {}", move _481, _479) -> bb132
  using: _482@Entry, _481@Entry, _479@Entry
bb132:
  _14[_479] = move _478 as u8 (IntToInt)
  using: _479@Mir(bb131[2]), _478@Mir(bb131[0])
  _483 = _8
  using: _8@Phi(bb130)
  _485 = _8
  using: _8@Phi(bb130)
  _484 = move _485 as usize (IntToInt)
  using: _485@Mir(bb132[2])
  _486 = const 256_usize
  using: 
  _487 = Lt(_484, _486)
  using: _484@Mir(bb132[3]), _486@Mir(bb132[4])
  assert(move _487, "index out of bounds: the length is {} but the index is {}", move _486, _484) -> bb133
  using: _487@Entry, _486@Entry, _484@Entry
bb133:
  _13[_484] = move _483
  using: _484@Mir(bb132[3]), _483@Mir(bb132[1])
  _488 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb130)
  assert(!move (_488.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb134
  using: _488@Entry, _8@Entry
bb134:
  _8 = move (_488.0: i32)
  using: _488@Mir(bb133[1])
  goto -> bb130
  using: 
bb135:
  _489 = const 0_i32
  using: 
  _490 = const 1_i32
  using: 
  goto -> bb136
  using: 
bb136:
  _492 = const 3_i32
  using: 
  _493 = _490
  using: _490@Phi(bb136)
  _494 = CheckedMul(_492, _493)
  using: _492@Mir(bb136[0]), _493@Mir(bb136[1])
  assert(!move (_494.1: bool), "attempt to compute `{} * {}`, which would overflow", move _492, move _493) -> bb137
  using: _494@Entry, _492@Entry, _493@Entry
bb137:
  _491 = move (_494.0: i32)
  using: _494@Mir(bb136[2])
  _495 = const 1_i32
  using: 
  _496 = CheckedAdd(_491, _495)
  using: _491@Mir(bb137[0]), _495@Mir(bb137[1])
  assert(!move (_496.1: bool), "attempt to compute `{} + {}`, which would overflow", move _491, move _495) -> bb138
  using: _496@Entry, _491@Entry, _495@Entry
bb138:
  _490 = move (_496.0: i32)
  using: _496@Mir(bb137[2])
  _499 = _490
  using: _490@Mir(bb138[0])
  _500 = const 256_i32
  using: 
  _498 = Le(move _499, move _500)
  using: _499@Mir(bb138[1]), _500@Mir(bb138[2])
  _497 = Not(move _498)
  using: _498@Mir(bb138[3])
  switchInt(move _497) -> [0: bb136, otherwise: bb139]
  using: _497@Mir(bb138[4])
bb139:
  _501 = _490
  using: _490@Phi(bb139)
  _502 = const 3_i32
  using: 
  _503 = const false
  using: 
  _504 = Eq(_501, const i32::MIN)
  using: _501@Mir(bb139[0])
  _505 = BitAnd(move _503, move _504)
  using: _503@Mir(bb139[2]), _504@Mir(bb139[3])
  assert(!move _505, "attempt to compute `{} / {}`, which would overflow", _501, _502) -> bb140
  using: _505@Entry, _501@Entry, _502@Entry
bb140:
  _490 = Div(move _501, move _502)
  using: _501@Mir(bb139[0]), _502@Mir(bb139[1])
  _506 = _490
  using: _490@Mir(bb140[0])
  _8 = move _506
  using: _506@Mir(bb140[1])
  goto -> bb141
  using: 
bb141:
  _508 = _8
  using: _8@Phi(bb141)
  _509 = const 255_i32
  using: 
  _507 = Le(move _508, move _509)
  using: _508@Mir(bb141[0]), _509@Mir(bb141[1])
  switchInt(move _507) -> [0: bb170, otherwise: bb142]
  using: _507@Mir(bb141[2])
bb142:
  _512 = _8
  using: _8@Phi(bb141)
  _511 = move _512 as usize (IntToInt)
  using: _512@Mir(bb142[0])
  _513 = const 256_usize
  using: 
  _514 = Lt(_511, _513)
  using: _511@Mir(bb142[1]), _513@Mir(bb142[2])
  assert(move _514, "index out of bounds: the length is {} but the index is {}", move _513, _511) -> bb143
  using: _514@Entry, _513@Entry, _511@Entry
bb143:
  _510 = _13[_511]
  using: _13@Phi(bb141), _511@Mir(bb142[1])
  _489 = move _510
  using: _510@Mir(bb143[0])
  _515 = _8
  using: _8@Phi(bb141)
  _9 = move _515
  using: _515@Mir(bb143[2])
  goto -> bb144
  using: 
bb144:
  _520 = _4
  using: _4@Phi(bb144)
  _527 = _9
  using: _9@Phi(bb144)
  _528 = _490
  using: _490@Phi(bb144)
  _529 = CheckedSub(_527, _528)
  using: _527@Mir(bb144[1]), _528@Mir(bb144[2])
  assert(!move (_529.1: bool), "attempt to compute `{} - {}`, which would overflow", move _527, move _528) -> bb145
  using: _529@Entry, _527@Entry, _528@Entry
bb145:
  _526 = move (_529.0: i32)
  using: _529@Mir(bb144[3])
  _525 = move _526 as usize (IntToInt)
  using: _526@Mir(bb145[0])
  _530 = const 256_usize
  using: 
  _531 = Lt(_525, _530)
  using: _525@Mir(bb145[1]), _530@Mir(bb145[2])
  assert(move _531, "index out of bounds: the length is {} but the index is {}", move _530, _525) -> bb146
  using: _531@Entry, _530@Entry, _525@Entry
bb146:
  _524 = _13[_525]
  using: _13@Phi(bb144), _525@Mir(bb145[1])
  _532 = const 1_i32
  using: 
  _533 = CheckedAdd(_524, _532)
  using: _524@Mir(bb146[0]), _532@Mir(bb146[1])
  assert(!move (_533.1: bool), "attempt to compute `{} + {}`, which would overflow", move _524, move _532) -> bb147
  using: _533@Entry, _524@Entry, _532@Entry
bb147:
  _523 = move (_533.0: i32)
  using: _533@Mir(bb146[2])
  _534 = const 8_i32
  using: 
  _535 = CheckedShl(_523, _534)
  using: _523@Mir(bb147[0]), _534@Mir(bb147[1])
  assert(!move (_535.1: bool), "attempt to shift left by `{}`, which would overflow", move _534) -> bb148
  using: _535@Entry, _523@Entry, _534@Entry
bb148:
  _522 = move (_535.0: i32)
  using: _535@Mir(bb147[2])
  _521 = move _522 as isize (IntToInt)
  using: _522@Mir(bb148[0])
  _519 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _520, move _521) -> bb149
  using: _520@Mir(bb144[0]), _521@Mir(bb148[1])
bb149:
  _518 = (*_519)
  using: _519@Mir(bb148[2])
  _538 = _4
  using: _4@Phi(bb144)
  _544 = _9
  using: _9@Phi(bb144)
  _545 = _490
  using: _490@Phi(bb144)
  _546 = CheckedSub(_544, _545)
  using: _544@Mir(bb149[2]), _545@Mir(bb149[3])
  assert(!move (_546.1: bool), "attempt to compute `{} - {}`, which would overflow", move _544, move _545) -> bb150
  using: _546@Entry, _544@Entry, _545@Entry
bb150:
  _543 = move (_546.0: i32)
  using: _546@Mir(bb149[4])
  _542 = move _543 as usize (IntToInt)
  using: _543@Mir(bb150[0])
  _547 = const 256_usize
  using: 
  _548 = Lt(_542, _547)
  using: _542@Mir(bb150[1]), _547@Mir(bb150[2])
  assert(move _548, "index out of bounds: the length is {} but the index is {}", move _547, _542) -> bb151
  using: _548@Entry, _547@Entry, _542@Entry
bb151:
  _541 = _13[_542]
  using: _13@Phi(bb144), _542@Mir(bb150[1])
  _549 = const 8_i32
  using: 
  _550 = CheckedShl(_541, _549)
  using: _541@Mir(bb151[0]), _549@Mir(bb151[1])
  assert(!move (_550.1: bool), "attempt to shift left by `{}`, which would overflow", move _549) -> bb152
  using: _550@Entry, _541@Entry, _549@Entry
bb152:
  _540 = move (_550.0: i32)
  using: _550@Mir(bb151[2])
  _539 = move _540 as isize (IntToInt)
  using: _540@Mir(bb152[0])
  _537 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _538, move _539) -> bb153
  using: _538@Mir(bb149[1]), _539@Mir(bb152[1])
bb153:
  _536 = (*_537)
  using: _537@Mir(bb152[2])
  _517 = core::num::<impl u32>::wrapping_sub(move _518, move _536) -> bb154
  using: _518@Mir(bb149[0]), _536@Mir(bb153[0])
bb154:
  _554 = _4
  using: _4@Phi(bb144)
  _558 = _489
  using: _489@Phi(bb144)
  _559 = const 1_i32
  using: 
  _560 = CheckedAdd(_558, _559)
  using: _558@Mir(bb154[1]), _559@Mir(bb154[2])
  assert(!move (_560.1: bool), "attempt to compute `{} + {}`, which would overflow", move _558, move _559) -> bb155
  using: _560@Entry, _558@Entry, _559@Entry
bb155:
  _557 = move (_560.0: i32)
  using: _560@Mir(bb154[3])
  _561 = const 8_i32
  using: 
  _562 = CheckedShl(_557, _561)
  using: _557@Mir(bb155[0]), _561@Mir(bb155[1])
  assert(!move (_562.1: bool), "attempt to shift left by `{}`, which would overflow", move _561) -> bb156
  using: _562@Entry, _557@Entry, _561@Entry
bb156:
  _556 = move (_562.0: i32)
  using: _562@Mir(bb155[2])
  _555 = move _556 as isize (IntToInt)
  using: _556@Mir(bb156[0])
  _553 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _554, move _555) -> bb157
  using: _554@Mir(bb154[0]), _555@Mir(bb156[1])
bb157:
  _552 = (*_553)
  using: _553@Mir(bb156[2])
  _565 = _4
  using: _4@Phi(bb144)
  _568 = _489
  using: _489@Phi(bb144)
  _569 = const 8_i32
  using: 
  _570 = CheckedShl(_568, _569)
  using: _568@Mir(bb157[2]), _569@Mir(bb157[3])
  assert(!move (_570.1: bool), "attempt to shift left by `{}`, which would overflow", move _569) -> bb158
  using: _570@Entry, _568@Entry, _569@Entry
bb158:
  _567 = move (_570.0: i32)
  using: _570@Mir(bb157[4])
  _566 = move _567 as isize (IntToInt)
  using: _567@Mir(bb158[0])
  _564 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _565, move _566) -> bb159
  using: _565@Mir(bb157[1]), _566@Mir(bb158[1])
bb159:
  _563 = (*_564)
  using: _564@Mir(bb158[2])
  _551 = core::num::<impl u32>::wrapping_sub(move _552, move _563) -> bb160
  using: _552@Mir(bb157[0]), _563@Mir(bb159[0])
bb160:
  _516 = Gt(move _517, move _551)
  using: _517@Mir(bb153[1]), _551@Mir(bb159[1])
  switchInt(move _516) -> [0: bb167, otherwise: bb161]
  using: _516@Mir(bb160[0])
bb161:
  _574 = _9
  using: _9@Phi(bb144)
  _575 = _490
  using: _490@Phi(bb144)
  _576 = CheckedSub(_574, _575)
  using: _574@Mir(bb161[0]), _575@Mir(bb161[1])
  assert(!move (_576.1: bool), "attempt to compute `{} - {}`, which would overflow", move _574, move _575) -> bb162
  using: _576@Entry, _574@Entry, _575@Entry
bb162:
  _573 = move (_576.0: i32)
  using: _576@Mir(bb161[2])
  _572 = move _573 as usize (IntToInt)
  using: _573@Mir(bb162[0])
  _577 = const 256_usize
  using: 
  _578 = Lt(_572, _577)
  using: _572@Mir(bb162[1]), _577@Mir(bb162[2])
  assert(move _578, "index out of bounds: the length is {} but the index is {}", move _577, _572) -> bb163
  using: _578@Entry, _577@Entry, _572@Entry
bb163:
  _571 = _13[_572]
  using: _13@Phi(bb144), _572@Mir(bb162[1])
  _580 = _9
  using: _9@Phi(bb144)
  _579 = move _580 as usize (IntToInt)
  using: _580@Mir(bb163[1])
  _581 = const 256_usize
  using: 
  _582 = Lt(_579, _581)
  using: _579@Mir(bb163[2]), _581@Mir(bb163[3])
  assert(move _582, "index out of bounds: the length is {} but the index is {}", move _581, _579) -> bb164
  using: _582@Entry, _581@Entry, _579@Entry
bb164:
  _13[_579] = move _571
  using: _579@Mir(bb163[2]), _571@Mir(bb163[0])
  _583 = _9
  using: _9@Phi(bb144)
  _584 = _490
  using: _490@Phi(bb144)
  _585 = CheckedSub(_583, _584)
  using: _583@Mir(bb164[1]), _584@Mir(bb164[2])
  assert(!move (_585.1: bool), "attempt to compute `{} - {}`, which would overflow", move _583, move _584) -> bb165
  using: _585@Entry, _583@Entry, _584@Entry
bb165:
  _9 = move (_585.0: i32)
  using: _585@Mir(bb164[3])
  _587 = _9
  using: _9@Mir(bb165[0])
  _589 = _490
  using: _490@Phi(bb144)
  _590 = const 1_i32
  using: 
  _591 = CheckedSub(_589, _590)
  using: _589@Mir(bb165[2]), _590@Mir(bb165[3])
  assert(!move (_591.1: bool), "attempt to compute `{} - {}`, which would overflow", move _589, move _590) -> bb166
  using: _591@Entry, _589@Entry, _590@Entry
bb166:
  _588 = move (_591.0: i32)
  using: _591@Mir(bb165[4])
  _586 = Le(move _587, move _588)
  using: _587@Mir(bb165[1]), _588@Mir(bb166[0])
  switchInt(move _586) -> [0: bb144, otherwise: bb167]
  using: _586@Mir(bb166[1])
bb167:
  _592 = _489
  using: _489@Phi(bb144)
  _594 = _9
  using: _9@Phi(bb167)
  _593 = move _594 as usize (IntToInt)
  using: _594@Mir(bb167[1])
  _595 = const 256_usize
  using: 
  _596 = Lt(_593, _595)
  using: _593@Mir(bb167[2]), _595@Mir(bb167[3])
  assert(move _596, "index out of bounds: the length is {} but the index is {}", move _595, _593) -> bb168
  using: _596@Entry, _595@Entry, _593@Entry
bb168:
  _13[_593] = move _592
  using: _593@Mir(bb167[2]), _592@Mir(bb167[0])
  _597 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb141)
  assert(!move (_597.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb169
  using: _597@Entry, _8@Entry
bb169:
  _8 = move (_597.0: i32)
  using: _597@Mir(bb168[1])
  goto -> bb141
  using: 
bb170:
  _600 = _490
  using: _490@Phi(bb167)
  _601 = const 1_i32
  using: 
  _599 = Ne(move _600, move _601)
  using: _600@Mir(bb170[0]), _601@Mir(bb170[1])
  _598 = Not(move _599)
  using: _599@Mir(bb170[2])
  switchInt(move _598) -> [0: bb139, otherwise: bb171]
  using: _598@Mir(bb170[3])
bb171:
  _18 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  goto -> bb172
  using: 
bb172:
  _603 = _8
  using: _8@Phi(bb172)
  _604 = const 255_i32
  using: 
  _602 = Le(move _603, move _604)
  using: _603@Mir(bb172[0]), _604@Mir(bb172[1])
  switchInt(move _602) -> [0: bb313, otherwise: bb173]
  using: _602@Mir(bb172[2])
bb173:
  _607 = _8
  using: _8@Phi(bb172)
  _606 = move _607 as usize (IntToInt)
  using: _607@Mir(bb173[0])
  _608 = const 256_usize
  using: 
  _609 = Lt(_606, _608)
  using: _606@Mir(bb173[1]), _608@Mir(bb173[2])
  assert(move _609, "index out of bounds: the length is {} but the index is {}", move _608, _606) -> bb174
  using: _609@Entry, _608@Entry, _606@Entry
bb174:
  _605 = _13[_606]
  using: _13@Phi(bb172), _606@Mir(bb173[1])
  _11 = move _605
  using: _605@Mir(bb174[0])
  _9 = const 0_i32
  using: 
  goto -> bb175
  using: 
bb175:
  _611 = _9
  using: _9@Phi(bb175)
  _612 = const 255_i32
  using: 
  _610 = Le(move _611, move _612)
  using: _611@Mir(bb175[0]), _612@Mir(bb175[1])
  switchInt(move _610) -> [0: bb199, otherwise: bb176]
  using: _610@Mir(bb175[2])
bb176:
  _614 = _9
  using: _9@Phi(bb175)
  _615 = _11
  using: _11@Phi(bb175)
  _613 = Ne(move _614, move _615)
  using: _614@Mir(bb176[0]), _615@Mir(bb176[1])
  switchInt(move _613) -> [0: bb197, otherwise: bb177]
  using: _613@Mir(bb176[2])
bb177:
  _617 = _11
  using: _11@Phi(bb175)
  _618 = const 8_i32
  using: 
  _619 = CheckedShl(_617, _618)
  using: _617@Mir(bb177[0]), _618@Mir(bb177[1])
  assert(!move (_619.1: bool), "attempt to shift left by `{}`, which would overflow", move _618) -> bb178
  using: _619@Entry, _617@Entry, _618@Entry
bb178:
  _616 = move (_619.0: i32)
  using: _619@Mir(bb177[2])
  _620 = _9
  using: _9@Phi(bb175)
  _621 = CheckedAdd(_616, _620)
  using: _616@Mir(bb178[0]), _620@Mir(bb178[1])
  assert(!move (_621.1: bool), "attempt to compute `{} + {}`, which would overflow", move _616, move _620) -> bb179
  using: _621@Entry, _616@Entry, _620@Entry
bb179:
  _12 = move (_621.0: i32)
  using: _621@Mir(bb178[2])
  _625 = _4
  using: _4@Phi(bb175)
  _627 = _12
  using: _12@Mir(bb179[0])
  _626 = move _627 as isize (IntToInt)
  using: _627@Mir(bb179[2])
  _624 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _625, move _626) -> bb180
  using: _625@Mir(bb179[1]), _626@Mir(bb179[3])
bb180:
  _623 = (*_624)
  using: _624@Mir(bb179[4])
  _628 = const 2097152_u32
  using: 
  _622 = BitAnd(move _623, move _628)
  using: _623@Mir(bb180[0]), _628@Mir(bb180[1])
  switchInt(move _622) -> [0: bb181, otherwise: bb195]
  using: _622@Mir(bb180[2])
bb181:
  _633 = _4
  using: _4@Phi(bb175)
  _635 = _12
  using: _12@Mir(bb179[0])
  _634 = move _635 as isize (IntToInt)
  using: _635@Mir(bb181[1])
  _632 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _633, move _634) -> bb182
  using: _633@Mir(bb181[0]), _634@Mir(bb181[2])
bb182:
  _631 = (*_632)
  using: _632@Mir(bb181[3])
  _636 = const 4292870143_u32
  using: 
  _630 = BitAnd(move _631, move _636)
  using: _631@Mir(bb182[0]), _636@Mir(bb182[1])
  _629 = move _630 as i32 (IntToInt)
  using: _630@Mir(bb182[2])
  _642 = _4
  using: _4@Phi(bb175)
  _645 = _12
  using: _12@Mir(bb179[0])
  _646 = const 1_i32
  using: 
  _647 = CheckedAdd(_645, _646)
  using: _645@Mir(bb182[5]), _646@Mir(bb182[6])
  assert(!move (_647.1: bool), "attempt to compute `{} + {}`, which would overflow", move _645, move _646) -> bb183
  using: _647@Entry, _645@Entry, _646@Entry
bb183:
  _644 = move (_647.0: i32)
  using: _647@Mir(bb182[7])
  _643 = move _644 as isize (IntToInt)
  using: _644@Mir(bb183[0])
  _641 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _642, move _643) -> bb184
  using: _642@Mir(bb182[4]), _643@Mir(bb183[1])
bb184:
  _640 = (*_641)
  using: _641@Mir(bb183[2])
  _648 = const 4292870143_u32
  using: 
  _639 = BitAnd(move _640, move _648)
  using: _640@Mir(bb184[0]), _648@Mir(bb184[1])
  _649 = const 1_u32
  using: 
  _638 = core::num::<impl u32>::wrapping_sub(move _639, move _649) -> bb185
  using: _639@Mir(bb184[2]), _649@Mir(bb184[3])
bb185:
  _637 = move _638 as i32 (IntToInt)
  using: _638@Mir(bb184[4])
  _651 = _637
  using: _637@Mir(bb185[0])
  _652 = _629
  using: _629@Mir(bb182[3])
  _650 = Gt(move _651, move _652)
  using: _651@Mir(bb185[1]), _652@Mir(bb185[2])
  switchInt(move _650) -> [0: bb195, otherwise: bb186]
  using: _650@Mir(bb185[3])
bb186:
  _654 = _6
  using: _6@Phi(bb175)
  _655 = const 4_i32
  using: 
  _653 = Ge(move _654, move _655)
  using: _654@Mir(bb186[0]), _655@Mir(bb186[1])
  switchInt(move _653) -> [0: bb190, otherwise: bb187]
  using: _653@Mir(bb186[2])
bb187:
  _658 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _657 = (*_658)
  using: _658@Mir(bb187[0])
  _662 = const b"        qsort [0x%x, 0x%x]   done %d   this %d\n\x00"
  using: 
  _661 = &raw const (*_662)
  using: _662@Mir(bb187[2])
  _660 = move _661 as *const u8 (Pointer(ArrayToPointer))
  using: _661@Mir(bb187[3])
  _659 = move _660 as *const i8 (PtrToPtr)
  using: _660@Mir(bb187[4])
  _663 = _11
  using: _11@Phi(bb175)
  _664 = _9
  using: _9@Phi(bb175)
  _665 = _18
  using: _18@Phi(bb175)
  _668 = _637
  using: _637@Mir(bb185[0])
  _669 = _629
  using: _629@Mir(bb182[3])
  _670 = CheckedSub(_668, _669)
  using: _668@Mir(bb187[9]), _669@Mir(bb187[10])
  assert(!move (_670.1: bool), "attempt to compute `{} - {}`, which would overflow", move _668, move _669) -> bb188
  using: _670@Entry, _668@Entry, _669@Entry
bb188:
  _667 = move (_670.0: i32)
  using: _670@Mir(bb187[11])
  _671 = const 1_i32
  using: 
  _672 = CheckedAdd(_667, _671)
  using: _667@Mir(bb188[0]), _671@Mir(bb188[1])
  assert(!move (_672.1: bool), "attempt to compute `{} + {}`, which would overflow", move _667, move _671) -> bb189
  using: _672@Entry, _667@Entry, _671@Entry
bb189:
  _666 = move (_672.0: i32)
  using: _672@Mir(bb188[2])
  _656 = blocksort::fprintf(move _657, move _659, move _663, move _664, move _665, move _666) -> bb190
  using: _657@Mir(bb187[1]), _659@Mir(bb187[5]), _663@Mir(bb187[6]), _664@Mir(bb187[7]), _665@Mir(bb187[8]), _666@Mir(bb189[0])
bb190:
  _674 = _1
  using: _1@Phi(bb175)
  _675 = _2
  using: _2@Phi(bb175)
  _676 = _3
  using: _3@Phi(bb175)
  _677 = _5
  using: _5@Phi(bb175)
  _678 = _629
  using: _629@Phi(bb190)
  _679 = _637
  using: _637@Phi(bb190)
  _680 = const 2_i32
  using: 
  _681 = _7
  using: _7@Phi(bb175)
  _673 = blocksort::mainQSort3(move _674, move _675, move _676, move _677, move _678, move _679, move _680, move _681) -> bb191
  using: _674@Mir(bb190[0]), _675@Mir(bb190[1]), _676@Mir(bb190[2]), _677@Mir(bb190[3]), _678@Mir(bb190[4]), _679@Mir(bb190[5]), _680@Mir(bb190[6]), _681@Mir(bb190[7])
bb191:
  _684 = _637
  using: _637@Phi(bb190)
  _685 = _629
  using: _629@Phi(bb190)
  _686 = CheckedSub(_684, _685)
  using: _684@Mir(bb191[0]), _685@Mir(bb191[1])
  assert(!move (_686.1: bool), "attempt to compute `{} - {}`, which would overflow", move _684, move _685) -> bb192
  using: _686@Entry, _684@Entry, _685@Entry
bb192:
  _683 = move (_686.0: i32)
  using: _686@Mir(bb191[2])
  _687 = const 1_i32
  using: 
  _688 = CheckedAdd(_683, _687)
  using: _683@Mir(bb192[0]), _687@Mir(bb192[1])
  assert(!move (_688.1: bool), "attempt to compute `{} + {}`, which would overflow", move _683, move _687) -> bb193
  using: _688@Entry, _683@Entry, _687@Entry
bb193:
  _682 = move (_688.0: i32)
  using: _688@Mir(bb192[2])
  _689 = CheckedAdd(_18, _682)
  using: _18@Phi(bb190), _682@Mir(bb193[0])
  assert(!move (_689.1: bool), "attempt to compute `{} + {}`, which would overflow", _18, move _682) -> bb194
  using: _689@Entry, _18@Entry, _682@Entry
bb194:
  _18 = move (_689.0: i32)
  using: _689@Mir(bb193[1])
  _691 = (*_7)
  using: _7@Phi(bb175)
  _692 = const 0_i32
  using: 
  _690 = Lt(move _691, move _692)
  using: _691@Mir(bb194[1]), _692@Mir(bb194[2])
  switchInt(move _690) -> [0: bb195, otherwise: bb316]
  using: _690@Mir(bb194[3])
bb195:
  _693 = const 2097152_i32
  using: 
  _695 = _4
  using: _4@Phi(bb195)
  _697 = _12
  using: _12@Phi(bb195)
  _696 = move _697 as isize (IntToInt)
  using: _697@Mir(bb195[2])
  _694 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _695, move _696) -> bb196
  using: _695@Mir(bb195[1]), _696@Mir(bb195[3])
bb196:
  (*_694) = move _693 as u32 (IntToInt)
  using: _694@Mir(bb195[4]), _693@Mir(bb195[0])
  goto -> bb197
  using: 
bb197:
  _698 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb197)
  assert(!move (_698.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb198
  using: _698@Entry, _9@Entry
bb198:
  _9 = move (_698.0: i32)
  using: _698@Mir(bb197[0])
  goto -> bb175
  using: 
bb199:
  _701 = _11
  using: _11@Phi(bb197)
  _700 = move _701 as usize (IntToInt)
  using: _701@Mir(bb199[0])
  _702 = const 256_usize
  using: 
  _703 = Lt(_700, _702)
  using: _700@Mir(bb199[1]), _702@Mir(bb199[2])
  assert(move _703, "index out of bounds: the length is {} but the index is {}", move _702, _700) -> bb200
  using: _703@Entry, _702@Entry, _700@Entry
bb200:
  _699 = _14[_700]
  using: _14@Phi(bb172), _700@Mir(bb199[1])
  switchInt(move _699) -> [0: bb202, otherwise: bb201]
  using: _699@Mir(bb200[0])
bb201:
  _705 = const 1006_i32
  using: 
  _704 = bzlib::BZ2_bz__AssertH__fail(move _705) -> bb202
  using: _705@Mir(bb201[0])
bb202:
  _9 = const 0_i32
  using: 
  goto -> bb203
  using: 
bb203:
  _707 = _9
  using: _9@Phi(bb203)
  _708 = const 255_i32
  using: 
  _706 = Le(move _707, move _708)
  using: _707@Mir(bb203[0]), _708@Mir(bb203[1])
  switchInt(move _706) -> [0: bb216, otherwise: bb204]
  using: _706@Mir(bb203[2])
bb204:
  _712 = _4
  using: _4@Phi(bb203)
  _716 = _9
  using: _9@Phi(bb203)
  _717 = const 8_i32
  using: 
  _718 = CheckedShl(_716, _717)
  using: _716@Mir(bb204[1]), _717@Mir(bb204[2])
  assert(!move (_718.1: bool), "attempt to shift left by `{}`, which would overflow", move _717) -> bb205
  using: _718@Entry, _716@Entry, _717@Entry
bb205:
  _715 = move (_718.0: i32)
  using: _718@Mir(bb204[3])
  _719 = _11
  using: _11@Phi(bb203)
  _720 = CheckedAdd(_715, _719)
  using: _715@Mir(bb205[0]), _719@Mir(bb205[1])
  assert(!move (_720.1: bool), "attempt to compute `{} + {}`, which would overflow", move _715, move _719) -> bb206
  using: _720@Entry, _715@Entry, _719@Entry
bb206:
  _714 = move (_720.0: i32)
  using: _720@Mir(bb205[2])
  _713 = move _714 as isize (IntToInt)
  using: _714@Mir(bb206[0])
  _711 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _712, move _713) -> bb207
  using: _712@Mir(bb204[0]), _713@Mir(bb206[1])
bb207:
  _710 = (*_711)
  using: _711@Mir(bb206[2])
  _721 = const 4292870143_u32
  using: 
  _709 = BitAnd(move _710, move _721)
  using: _710@Mir(bb207[0]), _721@Mir(bb207[1])
  _723 = _9
  using: _9@Phi(bb203)
  _722 = move _723 as usize (IntToInt)
  using: _723@Mir(bb207[3])
  _724 = const 256_usize
  using: 
  _725 = Lt(_722, _724)
  using: _722@Mir(bb207[4]), _724@Mir(bb207[5])
  assert(move _725, "index out of bounds: the length is {} but the index is {}", move _724, _722) -> bb208
  using: _725@Entry, _724@Entry, _722@Entry
bb208:
  _15[_722] = move _709 as i32 (IntToInt)
  using: _722@Mir(bb207[4]), _709@Mir(bb207[2])
  _730 = _4
  using: _4@Phi(bb203)
  _735 = _9
  using: _9@Phi(bb203)
  _736 = const 8_i32
  using: 
  _737 = CheckedShl(_735, _736)
  using: _735@Mir(bb208[2]), _736@Mir(bb208[3])
  assert(!move (_737.1: bool), "attempt to shift left by `{}`, which would overflow", move _736) -> bb209
  using: _737@Entry, _735@Entry, _736@Entry
bb209:
  _734 = move (_737.0: i32)
  using: _737@Mir(bb208[4])
  _738 = _11
  using: _11@Phi(bb203)
  _739 = CheckedAdd(_734, _738)
  using: _734@Mir(bb209[0]), _738@Mir(bb209[1])
  assert(!move (_739.1: bool), "attempt to compute `{} + {}`, which would overflow", move _734, move _738) -> bb210
  using: _739@Entry, _734@Entry, _738@Entry
bb210:
  _733 = move (_739.0: i32)
  using: _739@Mir(bb209[2])
  _740 = const 1_i32
  using: 
  _741 = CheckedAdd(_733, _740)
  using: _733@Mir(bb210[0]), _740@Mir(bb210[1])
  assert(!move (_741.1: bool), "attempt to compute `{} + {}`, which would overflow", move _733, move _740) -> bb211
  using: _741@Entry, _733@Entry, _740@Entry
bb211:
  _732 = move (_741.0: i32)
  using: _741@Mir(bb210[2])
  _731 = move _732 as isize (IntToInt)
  using: _732@Mir(bb211[0])
  _729 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _730, move _731) -> bb212
  using: _730@Mir(bb208[1]), _731@Mir(bb211[1])
bb212:
  _728 = (*_729)
  using: _729@Mir(bb211[2])
  _742 = const 4292870143_u32
  using: 
  _727 = BitAnd(move _728, move _742)
  using: _728@Mir(bb212[0]), _742@Mir(bb212[1])
  _743 = const 1_u32
  using: 
  _726 = core::num::<impl u32>::wrapping_sub(move _727, move _743) -> bb213
  using: _727@Mir(bb212[2]), _743@Mir(bb212[3])
bb213:
  _745 = _9
  using: _9@Phi(bb203)
  _744 = move _745 as usize (IntToInt)
  using: _745@Mir(bb213[0])
  _746 = const 256_usize
  using: 
  _747 = Lt(_744, _746)
  using: _744@Mir(bb213[1]), _746@Mir(bb213[2])
  assert(move _747, "index out of bounds: the length is {} but the index is {}", move _746, _744) -> bb214
  using: _747@Entry, _746@Entry, _744@Entry
bb214:
  _16[_744] = move _726 as i32 (IntToInt)
  using: _744@Mir(bb213[1]), _726@Mir(bb212[4])
  _748 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb203)
  assert(!move (_748.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb215
  using: _748@Entry, _9@Entry
bb215:
  _9 = move (_748.0: i32)
  using: _748@Mir(bb214[1])
  goto -> bb203
  using: 
bb216:
  _752 = _4
  using: _4@Phi(bb203)
  _755 = _11
  using: _11@Phi(bb203)
  _756 = const 8_i32
  using: 
  _757 = CheckedShl(_755, _756)
  using: _755@Mir(bb216[1]), _756@Mir(bb216[2])
  assert(!move (_757.1: bool), "attempt to shift left by `{}`, which would overflow", move _756) -> bb217
  using: _757@Entry, _755@Entry, _756@Entry
bb217:
  _754 = move (_757.0: i32)
  using: _757@Mir(bb216[3])
  _753 = move _754 as isize (IntToInt)
  using: _754@Mir(bb217[0])
  _751 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _752, move _753) -> bb218
  using: _752@Mir(bb216[0]), _753@Mir(bb217[1])
bb218:
  _750 = (*_751)
  using: _751@Mir(bb217[2])
  _758 = const 4292870143_u32
  using: 
  _749 = BitAnd(move _750, move _758)
  using: _750@Mir(bb218[0]), _758@Mir(bb218[1])
  _9 = move _749 as i32 (IntToInt)
  using: _749@Mir(bb218[2])
  goto -> bb219
  using: 
bb219:
  _760 = _9
  using: _9@Phi(bb219)
  _763 = _11
  using: _11@Phi(bb203)
  _762 = move _763 as usize (IntToInt)
  using: _763@Mir(bb219[1])
  _764 = const 256_usize
  using: 
  _765 = Lt(_762, _764)
  using: _762@Mir(bb219[2]), _764@Mir(bb219[3])
  assert(move _765, "index out of bounds: the length is {} but the index is {}", move _764, _762) -> bb220
  using: _765@Entry, _764@Entry, _762@Entry
bb220:
  _761 = _15[_762]
  using: _15@Phi(bb219), _762@Mir(bb219[2])
  _759 = Lt(move _760, move _761)
  using: _760@Mir(bb219[0]), _761@Mir(bb220[0])
  switchInt(move _759) -> [0: bb237, otherwise: bb221]
  using: _759@Mir(bb220[1])
bb221:
  _769 = _1
  using: _1@Phi(bb219)
  _771 = _9
  using: _9@Phi(bb219)
  _770 = move _771 as isize (IntToInt)
  using: _771@Mir(bb221[1])
  _768 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _769, move _770) -> bb222
  using: _769@Mir(bb221[0]), _770@Mir(bb221[2])
bb222:
  _767 = (*_768)
  using: _768@Mir(bb221[3])
  _772 = const 1_u32
  using: 
  _766 = core::num::<impl u32>::wrapping_sub(move _767, move _772) -> bb223
  using: _767@Mir(bb222[0]), _772@Mir(bb222[1])
bb223:
  _10 = move _766 as i32 (IntToInt)
  using: _766@Mir(bb222[2])
  _774 = _10
  using: _10@Mir(bb223[0])
  _775 = const 0_i32
  using: 
  _773 = Lt(move _774, move _775)
  using: _774@Mir(bb223[1]), _775@Mir(bb223[2])
  switchInt(move _773) -> [0: bb226, otherwise: bb224]
  using: _773@Mir(bb223[3])
bb224:
  _776 = _5
  using: _5@Phi(bb219)
  _777 = CheckedAdd(_10, _776)
  using: _10@Mir(bb223[0]), _776@Mir(bb224[0])
  assert(!move (_777.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, move _776) -> bb225
  using: _777@Entry, _10@Entry, _776@Entry
bb225:
  _10 = move (_777.0: i32)
  using: _777@Mir(bb224[1])
  goto -> bb226
  using: 
bb226:
  _780 = _2
  using: _2@Phi(bb219)
  _782 = _10
  using: _10@Phi(bb226)
  _781 = move _782 as isize (IntToInt)
  using: _782@Mir(bb226[1])
  _779 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _780, move _781) -> bb227
  using: _780@Mir(bb226[0]), _781@Mir(bb226[2])
bb227:
  _778 = (*_779)
  using: _779@Mir(bb226[3])
  _17 = move _778
  using: _778@Mir(bb227[0])
  _785 = _17
  using: _17@Mir(bb227[1])
  _784 = move _785 as usize (IntToInt)
  using: _785@Mir(bb227[2])
  _786 = const 256_usize
  using: 
  _787 = Lt(_784, _786)
  using: _784@Mir(bb227[3]), _786@Mir(bb227[4])
  assert(move _787, "index out of bounds: the length is {} but the index is {}", move _786, _784) -> bb228
  using: _787@Entry, _786@Entry, _784@Entry
bb228:
  _783 = _14[_784]
  using: _14@Phi(bb219), _784@Mir(bb227[3])
  switchInt(move _783) -> [0: bb229, otherwise: bb235]
  using: _783@Mir(bb228[0])
bb229:
  _790 = _17
  using: _17@Mir(bb227[1])
  _789 = move _790 as usize (IntToInt)
  using: _790@Mir(bb229[0])
  _791 = const 256_usize
  using: 
  _792 = Lt(_789, _791)
  using: _789@Mir(bb229[1]), _791@Mir(bb229[2])
  assert(move _792, "index out of bounds: the length is {} but the index is {}", move _791, _789) -> bb230
  using: _792@Entry, _791@Entry, _789@Entry
bb230:
  _788 = _15[_789]
  using: _15@Phi(bb219), _789@Mir(bb229[1])
  _795 = _17
  using: _17@Mir(bb227[1])
  _794 = move _795 as usize (IntToInt)
  using: _795@Mir(bb230[1])
  _796 = const 256_usize
  using: 
  _797 = Lt(_794, _796)
  using: _794@Mir(bb230[2]), _796@Mir(bb230[3])
  assert(move _797, "index out of bounds: the length is {} but the index is {}", move _796, _794) -> bb231
  using: _797@Entry, _796@Entry, _794@Entry
bb231:
  _793 = _15[_794]
  using: _15@Phi(bb219), _794@Mir(bb230[2])
  _798 = CheckedAdd(_793, const 1_i32)
  using: _793@Mir(bb231[0])
  assert(!move (_798.1: bool), "attempt to compute `{} + {}`, which would overflow", move _793, const 1_i32) -> bb232
  using: _798@Entry, _793@Entry
bb232:
  _800 = _17
  using: _17@Mir(bb227[1])
  _799 = move _800 as usize (IntToInt)
  using: _800@Mir(bb232[0])
  _801 = const 256_usize
  using: 
  _802 = Lt(_799, _801)
  using: _799@Mir(bb232[1]), _801@Mir(bb232[2])
  assert(move _802, "index out of bounds: the length is {} but the index is {}", move _801, _799) -> bb233
  using: _802@Entry, _801@Entry, _799@Entry
bb233:
  _15[_799] = move (_798.0: i32)
  using: _799@Mir(bb232[1]), _798@Mir(bb231[1])
  _803 = _10
  using: _10@Phi(bb226)
  _805 = _1
  using: _1@Phi(bb219)
  _807 = _788
  using: _788@Mir(bb230[0])
  _806 = move _807 as isize (IntToInt)
  using: _807@Mir(bb233[3])
  _804 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _805, move _806) -> bb234
  using: _805@Mir(bb233[2]), _806@Mir(bb233[4])
bb234:
  (*_804) = move _803 as u32 (IntToInt)
  using: _804@Mir(bb233[5]), _803@Mir(bb233[1])
  goto -> bb235
  using: 
bb235:
  _808 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb219)
  assert(!move (_808.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb236
  using: _808@Entry, _9@Entry
bb236:
  _9 = move (_808.0: i32)
  using: _808@Mir(bb235[0])
  goto -> bb219
  using: 
bb237:
  _813 = _4
  using: _4@Phi(bb203)
  _817 = _11
  using: _11@Phi(bb203)
  _818 = const 1_i32
  using: 
  _819 = CheckedAdd(_817, _818)
  using: _817@Mir(bb237[1]), _818@Mir(bb237[2])
  assert(!move (_819.1: bool), "attempt to compute `{} + {}`, which would overflow", move _817, move _818) -> bb238
  using: _819@Entry, _817@Entry, _818@Entry
bb238:
  _816 = move (_819.0: i32)
  using: _819@Mir(bb237[3])
  _820 = const 8_i32
  using: 
  _821 = CheckedShl(_816, _820)
  using: _816@Mir(bb238[0]), _820@Mir(bb238[1])
  assert(!move (_821.1: bool), "attempt to shift left by `{}`, which would overflow", move _820) -> bb239
  using: _821@Entry, _816@Entry, _820@Entry
bb239:
  _815 = move (_821.0: i32)
  using: _821@Mir(bb238[2])
  _814 = move _815 as isize (IntToInt)
  using: _815@Mir(bb239[0])
  _812 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _813, move _814) -> bb240
  using: _813@Mir(bb237[0]), _814@Mir(bb239[1])
bb240:
  _811 = (*_812)
  using: _812@Mir(bb239[2])
  _822 = const 4292870143_u32
  using: 
  _810 = BitAnd(move _811, move _822)
  using: _811@Mir(bb240[0]), _822@Mir(bb240[1])
  _823 = const 1_u32
  using: 
  _809 = core::num::<impl u32>::wrapping_sub(move _810, move _823) -> bb241
  using: _810@Mir(bb240[2]), _823@Mir(bb240[3])
bb241:
  _9 = move _809 as i32 (IntToInt)
  using: _809@Mir(bb240[4])
  goto -> bb242
  using: 
bb242:
  _825 = _9
  using: _9@Phi(bb242)
  _828 = _11
  using: _11@Phi(bb203)
  _827 = move _828 as usize (IntToInt)
  using: _828@Mir(bb242[1])
  _829 = const 256_usize
  using: 
  _830 = Lt(_827, _829)
  using: _827@Mir(bb242[2]), _829@Mir(bb242[3])
  assert(move _830, "index out of bounds: the length is {} but the index is {}", move _829, _827) -> bb243
  using: _830@Entry, _829@Entry, _827@Entry
bb243:
  _826 = _16[_827]
  using: _16@Phi(bb242), _827@Mir(bb242[2])
  _824 = Gt(move _825, move _826)
  using: _825@Mir(bb242[0]), _826@Mir(bb243[0])
  switchInt(move _824) -> [0: bb260, otherwise: bb244]
  using: _824@Mir(bb243[1])
bb244:
  _834 = _1
  using: _1@Phi(bb242)
  _836 = _9
  using: _9@Phi(bb242)
  _835 = move _836 as isize (IntToInt)
  using: _836@Mir(bb244[1])
  _833 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _834, move _835) -> bb245
  using: _834@Mir(bb244[0]), _835@Mir(bb244[2])
bb245:
  _832 = (*_833)
  using: _833@Mir(bb244[3])
  _837 = const 1_u32
  using: 
  _831 = core::num::<impl u32>::wrapping_sub(move _832, move _837) -> bb246
  using: _832@Mir(bb245[0]), _837@Mir(bb245[1])
bb246:
  _10 = move _831 as i32 (IntToInt)
  using: _831@Mir(bb245[2])
  _839 = _10
  using: _10@Mir(bb246[0])
  _840 = const 0_i32
  using: 
  _838 = Lt(move _839, move _840)
  using: _839@Mir(bb246[1]), _840@Mir(bb246[2])
  switchInt(move _838) -> [0: bb249, otherwise: bb247]
  using: _838@Mir(bb246[3])
bb247:
  _841 = _5
  using: _5@Phi(bb242)
  _842 = CheckedAdd(_10, _841)
  using: _10@Mir(bb246[0]), _841@Mir(bb247[0])
  assert(!move (_842.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, move _841) -> bb248
  using: _842@Entry, _10@Entry, _841@Entry
bb248:
  _10 = move (_842.0: i32)
  using: _842@Mir(bb247[1])
  goto -> bb249
  using: 
bb249:
  _845 = _2
  using: _2@Phi(bb242)
  _847 = _10
  using: _10@Phi(bb249)
  _846 = move _847 as isize (IntToInt)
  using: _847@Mir(bb249[1])
  _844 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _845, move _846) -> bb250
  using: _845@Mir(bb249[0]), _846@Mir(bb249[2])
bb250:
  _843 = (*_844)
  using: _844@Mir(bb249[3])
  _17 = move _843
  using: _843@Mir(bb250[0])
  _850 = _17
  using: _17@Mir(bb250[1])
  _849 = move _850 as usize (IntToInt)
  using: _850@Mir(bb250[2])
  _851 = const 256_usize
  using: 
  _852 = Lt(_849, _851)
  using: _849@Mir(bb250[3]), _851@Mir(bb250[4])
  assert(move _852, "index out of bounds: the length is {} but the index is {}", move _851, _849) -> bb251
  using: _852@Entry, _851@Entry, _849@Entry
bb251:
  _848 = _14[_849]
  using: _14@Phi(bb242), _849@Mir(bb250[3])
  switchInt(move _848) -> [0: bb252, otherwise: bb258]
  using: _848@Mir(bb251[0])
bb252:
  _855 = _17
  using: _17@Mir(bb250[1])
  _854 = move _855 as usize (IntToInt)
  using: _855@Mir(bb252[0])
  _856 = const 256_usize
  using: 
  _857 = Lt(_854, _856)
  using: _854@Mir(bb252[1]), _856@Mir(bb252[2])
  assert(move _857, "index out of bounds: the length is {} but the index is {}", move _856, _854) -> bb253
  using: _857@Entry, _856@Entry, _854@Entry
bb253:
  _853 = _16[_854]
  using: _16@Phi(bb242), _854@Mir(bb252[1])
  _860 = _17
  using: _17@Mir(bb250[1])
  _859 = move _860 as usize (IntToInt)
  using: _860@Mir(bb253[1])
  _861 = const 256_usize
  using: 
  _862 = Lt(_859, _861)
  using: _859@Mir(bb253[2]), _861@Mir(bb253[3])
  assert(move _862, "index out of bounds: the length is {} but the index is {}", move _861, _859) -> bb254
  using: _862@Entry, _861@Entry, _859@Entry
bb254:
  _858 = _16[_859]
  using: _16@Phi(bb242), _859@Mir(bb253[2])
  _863 = CheckedSub(_858, const 1_i32)
  using: _858@Mir(bb254[0])
  assert(!move (_863.1: bool), "attempt to compute `{} - {}`, which would overflow", move _858, const 1_i32) -> bb255
  using: _863@Entry, _858@Entry
bb255:
  _865 = _17
  using: _17@Mir(bb250[1])
  _864 = move _865 as usize (IntToInt)
  using: _865@Mir(bb255[0])
  _866 = const 256_usize
  using: 
  _867 = Lt(_864, _866)
  using: _864@Mir(bb255[1]), _866@Mir(bb255[2])
  assert(move _867, "index out of bounds: the length is {} but the index is {}", move _866, _864) -> bb256
  using: _867@Entry, _866@Entry, _864@Entry
bb256:
  _16[_864] = move (_863.0: i32)
  using: _864@Mir(bb255[1]), _863@Mir(bb254[1])
  _868 = _10
  using: _10@Phi(bb249)
  _870 = _1
  using: _1@Phi(bb242)
  _872 = _853
  using: _853@Mir(bb253[0])
  _871 = move _872 as isize (IntToInt)
  using: _872@Mir(bb256[3])
  _869 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _870, move _871) -> bb257
  using: _870@Mir(bb256[2]), _871@Mir(bb256[4])
bb257:
  (*_869) = move _868 as u32 (IntToInt)
  using: _869@Mir(bb256[5]), _868@Mir(bb256[1])
  goto -> bb258
  using: 
bb258:
  _873 = CheckedSub(_9, const 1_i32)
  using: _9@Phi(bb242)
  assert(!move (_873.1: bool), "attempt to compute `{} - {}`, which would overflow", _9, const 1_i32) -> bb259
  using: _873@Entry, _9@Entry
bb259:
  _9 = move (_873.0: i32)
  using: _873@Mir(bb258[0])
  goto -> bb242
  using: 
bb260:
  _880 = _11
  using: _11@Phi(bb203)
  _879 = move _880 as usize (IntToInt)
  using: _880@Mir(bb260[0])
  _881 = const 256_usize
  using: 
  _882 = Lt(_879, _881)
  using: _879@Mir(bb260[1]), _881@Mir(bb260[2])
  assert(move _882, "index out of bounds: the length is {} but the index is {}", move _881, _879) -> bb264
  using: _882@Entry, _881@Entry, _879@Entry
bb261:
  _875 = const true
  using: 
  goto -> bb263
  using: 
bb262:
  _894 = _11
  using: _11@Phi(bb203)
  _893 = move _894 as usize (IntToInt)
  using: _894@Mir(bb262[0])
  _895 = const 256_usize
  using: 
  _896 = Lt(_893, _895)
  using: _893@Mir(bb262[1]), _895@Mir(bb262[2])
  assert(move _896, "index out of bounds: the length is {} but the index is {}", move _895, _893) -> bb270
  using: _896@Entry, _895@Entry, _893@Entry
bb263:
  _874 = Not(move _875)
  using: _875@Phi(bb263)
  switchInt(move _874) -> [0: bb274, otherwise: bb273]
  using: _874@Mir(bb263[0])
bb264:
  _878 = _15[_879]
  using: _15@Phi(bb235), _879@Mir(bb260[1])
  _883 = const 1_i32
  using: 
  _884 = CheckedSub(_878, _883)
  using: _878@Mir(bb264[0]), _883@Mir(bb264[1])
  assert(!move (_884.1: bool), "attempt to compute `{} - {}`, which would overflow", move _878, move _883) -> bb265
  using: _884@Entry, _878@Entry, _883@Entry
bb265:
  _877 = move (_884.0: i32)
  using: _884@Mir(bb264[2])
  _887 = _11
  using: _11@Phi(bb203)
  _886 = move _887 as usize (IntToInt)
  using: _887@Mir(bb265[1])
  _888 = const 256_usize
  using: 
  _889 = Lt(_886, _888)
  using: _886@Mir(bb265[2]), _888@Mir(bb265[3])
  assert(move _889, "index out of bounds: the length is {} but the index is {}", move _888, _886) -> bb266
  using: _889@Entry, _888@Entry, _886@Entry
bb266:
  _885 = _16[_886]
  using: _16@Phi(bb258), _886@Mir(bb265[2])
  _876 = Eq(move _877, move _885)
  using: _877@Mir(bb265[0]), _885@Mir(bb266[0])
  switchInt(move _876) -> [0: bb262, otherwise: bb261]
  using: _876@Mir(bb266[1])
bb267:
  _890 = const false
  using: 
  goto -> bb269
  using: 
bb268:
  _901 = _11
  using: _11@Phi(bb203)
  _900 = move _901 as usize (IntToInt)
  using: _901@Mir(bb268[0])
  _902 = const 256_usize
  using: 
  _903 = Lt(_900, _902)
  using: _900@Mir(bb268[1]), _902@Mir(bb268[2])
  assert(move _903, "index out of bounds: the length is {} but the index is {}", move _902, _900) -> bb271
  using: _903@Entry, _902@Entry, _900@Entry
bb269:
  _875 = move _890
  using: _890@Phi(bb269)
  goto -> bb263
  using: 
bb270:
  _892 = _15[_893]
  using: _15@Phi(bb235), _893@Mir(bb262[1])
  _897 = const 0_i32
  using: 
  _891 = Eq(move _892, move _897)
  using: _892@Mir(bb270[0]), _897@Mir(bb270[1])
  switchInt(move _891) -> [0: bb267, otherwise: bb268]
  using: _891@Mir(bb270[2])
bb271:
  _899 = _16[_900]
  using: _16@Phi(bb258), _900@Mir(bb268[1])
  _905 = _5
  using: _5@Phi(bb249)
  _906 = const 1_i32
  using: 
  _907 = CheckedSub(_905, _906)
  using: _905@Mir(bb271[1]), _906@Mir(bb271[2])
  assert(!move (_907.1: bool), "attempt to compute `{} - {}`, which would overflow", move _905, move _906) -> bb272
  using: _907@Entry, _905@Entry, _906@Entry
bb272:
  _904 = move (_907.0: i32)
  using: _907@Mir(bb271[3])
  _898 = Eq(move _899, move _904)
  using: _899@Mir(bb271[0]), _904@Mir(bb272[0])
  _890 = move _898
  using: _898@Mir(bb272[1])
  goto -> bb269
  using: 
bb273:
  _909 = const 1007_i32
  using: 
  _908 = bzlib::BZ2_bz__AssertH__fail(move _909) -> bb274
  using: _909@Mir(bb273[0])
bb274:
  _9 = const 0_i32
  using: 
  goto -> bb275
  using: 
bb275:
  _911 = _9
  using: _9@Phi(bb275)
  _912 = const 255_i32
  using: 
  _910 = Le(move _911, move _912)
  using: _911@Mir(bb275[0]), _912@Mir(bb275[1])
  switchInt(move _910) -> [0: bb281, otherwise: bb276]
  using: _910@Mir(bb275[2])
bb276:
  _913 = const 2097152_i32
  using: 
  _915 = _4
  using: _4@Phi(bb275)
  _919 = _9
  using: _9@Phi(bb275)
  _920 = const 8_i32
  using: 
  _921 = CheckedShl(_919, _920)
  using: _919@Mir(bb276[2]), _920@Mir(bb276[3])
  assert(!move (_921.1: bool), "attempt to shift left by `{}`, which would overflow", move _920) -> bb277
  using: _921@Entry, _919@Entry, _920@Entry
bb277:
  _918 = move (_921.0: i32)
  using: _921@Mir(bb276[4])
  _922 = _11
  using: _11@Phi(bb275)
  _923 = CheckedAdd(_918, _922)
  using: _918@Mir(bb277[0]), _922@Mir(bb277[1])
  assert(!move (_923.1: bool), "attempt to compute `{} + {}`, which would overflow", move _918, move _922) -> bb278
  using: _923@Entry, _918@Entry, _922@Entry
bb278:
  _917 = move (_923.0: i32)
  using: _923@Mir(bb277[2])
  _916 = move _917 as isize (IntToInt)
  using: _917@Mir(bb278[0])
  _914 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _915, move _916) -> bb279
  using: _915@Mir(bb276[1]), _916@Mir(bb278[1])
bb279:
  (*_914) = move _913 as u32 (IntToInt)
  using: _914@Mir(bb278[2]), _913@Mir(bb276[0])
  _924 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb275)
  assert(!move (_924.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb280
  using: _924@Entry, _9@Entry
bb280:
  _9 = move (_924.0: i32)
  using: _924@Mir(bb279[1])
  goto -> bb275
  using: 
bb281:
  _925 = const 1_i32
  using: 
  _927 = _11
  using: _11@Phi(bb275)
  _926 = move _927 as usize (IntToInt)
  using: _927@Mir(bb281[1])
  _928 = const 256_usize
  using: 
  _929 = Lt(_926, _928)
  using: _926@Mir(bb281[2]), _928@Mir(bb281[3])
  assert(move _929, "index out of bounds: the length is {} but the index is {}", move _928, _926) -> bb282
  using: _929@Entry, _928@Entry, _926@Entry
bb282:
  _14[_926] = move _925 as u8 (IntToInt)
  using: _926@Mir(bb281[2]), _925@Mir(bb281[0])
  _931 = _8
  using: _8@Phi(bb172)
  _932 = const 255_i32
  using: 
  _930 = Lt(move _931, move _932)
  using: _931@Mir(bb282[1]), _932@Mir(bb282[2])
  switchInt(move _930) -> [0: bb311, otherwise: bb283]
  using: _930@Mir(bb282[3])
bb283:
  _937 = _4
  using: _4@Phi(bb275)
  _940 = _11
  using: _11@Phi(bb275)
  _941 = const 8_i32
  using: 
  _942 = CheckedShl(_940, _941)
  using: _940@Mir(bb283[1]), _941@Mir(bb283[2])
  assert(!move (_942.1: bool), "attempt to shift left by `{}`, which would overflow", move _941) -> bb284
  using: _942@Entry, _940@Entry, _941@Entry
bb284:
  _939 = move (_942.0: i32)
  using: _942@Mir(bb283[3])
  _938 = move _939 as isize (IntToInt)
  using: _939@Mir(bb284[0])
  _936 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _937, move _938) -> bb285
  using: _937@Mir(bb283[0]), _938@Mir(bb284[1])
bb285:
  _935 = (*_936)
  using: _936@Mir(bb284[2])
  _943 = const 4292870143_u32
  using: 
  _934 = BitAnd(move _935, move _943)
  using: _935@Mir(bb285[0]), _943@Mir(bb285[1])
  _933 = move _934 as i32 (IntToInt)
  using: _934@Mir(bb285[2])
  _949 = _4
  using: _4@Phi(bb275)
  _953 = _11
  using: _11@Phi(bb275)
  _954 = const 1_i32
  using: 
  _955 = CheckedAdd(_953, _954)
  using: _953@Mir(bb285[5]), _954@Mir(bb285[6])
  assert(!move (_955.1: bool), "attempt to compute `{} + {}`, which would overflow", move _953, move _954) -> bb286
  using: _955@Entry, _953@Entry, _954@Entry
bb286:
  _952 = move (_955.0: i32)
  using: _955@Mir(bb285[7])
  _956 = const 8_i32
  using: 
  _957 = CheckedShl(_952, _956)
  using: _952@Mir(bb286[0]), _956@Mir(bb286[1])
  assert(!move (_957.1: bool), "attempt to shift left by `{}`, which would overflow", move _956) -> bb287
  using: _957@Entry, _952@Entry, _956@Entry
bb287:
  _951 = move (_957.0: i32)
  using: _957@Mir(bb286[2])
  _950 = move _951 as isize (IntToInt)
  using: _951@Mir(bb287[0])
  _948 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _949, move _950) -> bb288
  using: _949@Mir(bb285[4]), _950@Mir(bb287[1])
bb288:
  _947 = (*_948)
  using: _948@Mir(bb287[2])
  _958 = const 4292870143_u32
  using: 
  _946 = BitAnd(move _947, move _958)
  using: _947@Mir(bb288[0]), _958@Mir(bb288[1])
  _960 = _933
  using: _933@Mir(bb285[3])
  _959 = move _960 as u32 (IntToInt)
  using: _960@Mir(bb288[3])
  _945 = core::num::<impl u32>::wrapping_sub(move _946, move _959) -> bb289
  using: _946@Mir(bb288[2]), _959@Mir(bb288[4])
bb289:
  _944 = move _945 as i32 (IntToInt)
  using: _945@Mir(bb288[5])
  _961 = const 0_i32
  using: 
  goto -> bb290
  using: 
bb290:
  _964 = _944
  using: _944@Mir(bb289[0])
  _965 = _961
  using: _961@Phi(bb290)
  _966 = CheckedShr(_964, _965)
  using: _964@Mir(bb290[0]), _965@Mir(bb290[1])
  assert(!move (_966.1: bool), "attempt to shift right by `{}`, which would overflow", move _965) -> bb291
  using: _966@Entry, _964@Entry, _965@Entry
bb291:
  _963 = move (_966.0: i32)
  using: _966@Mir(bb290[2])
  _967 = const 65534_i32
  using: 
  _962 = Gt(move _963, move _967)
  using: _963@Mir(bb291[0]), _967@Mir(bb291[1])
  switchInt(move _962) -> [0: bb294, otherwise: bb292]
  using: _962@Mir(bb291[2])
bb292:
  _968 = CheckedAdd(_961, const 1_i32)
  using: _961@Phi(bb290)
  assert(!move (_968.1: bool), "attempt to compute `{} + {}`, which would overflow", _961, const 1_i32) -> bb293
  using: _968@Entry, _961@Entry
bb293:
  _961 = move (_968.0: i32)
  using: _968@Mir(bb292[0])
  goto -> bb290
  using: 
bb294:
  _969 = _944
  using: _944@Mir(bb289[0])
  _970 = const 1_i32
  using: 
  _971 = CheckedSub(_969, _970)
  using: _969@Mir(bb294[0]), _970@Mir(bb294[1])
  assert(!move (_971.1: bool), "attempt to compute `{} - {}`, which would overflow", move _969, move _970) -> bb295
  using: _971@Entry, _969@Entry, _970@Entry
bb295:
  _9 = move (_971.0: i32)
  using: _971@Mir(bb294[2])
  goto -> bb296
  using: 
bb296:
  _973 = _9
  using: _9@Phi(bb296)
  _974 = const 0_i32
  using: 
  _972 = Ge(move _973, move _974)
  using: _973@Mir(bb296[0]), _974@Mir(bb296[1])
  switchInt(move _972) -> [0: bb307, otherwise: bb297]
  using: _972@Mir(bb296[2])
bb297:
  _978 = _1
  using: _1@Phi(bb296)
  _981 = _933
  using: _933@Phi(bb296)
  _982 = _9
  using: _9@Phi(bb296)
  _983 = CheckedAdd(_981, _982)
  using: _981@Mir(bb297[1]), _982@Mir(bb297[2])
  assert(!move (_983.1: bool), "attempt to compute `{} + {}`, which would overflow", move _981, move _982) -> bb298
  using: _983@Entry, _981@Entry, _982@Entry
bb298:
  _980 = move (_983.0: i32)
  using: _983@Mir(bb297[3])
  _979 = move _980 as isize (IntToInt)
  using: _980@Mir(bb298[0])
  _977 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _978, move _979) -> bb299
  using: _978@Mir(bb297[0]), _979@Mir(bb298[1])
bb299:
  _976 = (*_977)
  using: _977@Mir(bb298[2])
  _975 = move _976 as i32 (IntToInt)
  using: _976@Mir(bb299[0])
  _986 = _9
  using: _9@Phi(bb296)
  _987 = _961
  using: _961@Phi(bb296)
  _988 = CheckedShr(_986, _987)
  using: _986@Mir(bb299[2]), _987@Mir(bb299[3])
  assert(!move (_988.1: bool), "attempt to shift right by `{}`, which would overflow", move _987) -> bb300
  using: _988@Entry, _986@Entry, _987@Entry
bb300:
  _985 = move (_988.0: i32)
  using: _988@Mir(bb299[4])
  _984 = move _985 as u16 (IntToInt)
  using: _985@Mir(bb300[0])
  _989 = _984
  using: _984@Mir(bb300[1])
  _991 = _3
  using: _3@Phi(bb296)
  _993 = _975
  using: _975@Mir(bb299[1])
  _992 = move _993 as isize (IntToInt)
  using: _993@Mir(bb300[4])
  _990 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _991, move _992) -> bb301
  using: _991@Mir(bb300[3]), _992@Mir(bb300[5])
bb301:
  (*_990) = move _989
  using: _990@Mir(bb300[6]), _989@Mir(bb300[2])
  _995 = _975
  using: _975@Mir(bb299[1])
  _996 = const 34_i32
  using: 
  _994 = Lt(move _995, move _996)
  using: _995@Mir(bb301[1]), _996@Mir(bb301[2])
  switchInt(move _994) -> [0: bb305, otherwise: bb302]
  using: _994@Mir(bb301[3])
bb302:
  _997 = _984
  using: _984@Mir(bb300[1])
  _999 = _3
  using: _3@Phi(bb296)
  _1002 = _975
  using: _975@Mir(bb299[1])
  _1003 = _5
  using: _5@Phi(bb296)
  _1004 = CheckedAdd(_1002, _1003)
  using: _1002@Mir(bb302[2]), _1003@Mir(bb302[3])
  assert(!move (_1004.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1002, move _1003) -> bb303
  using: _1004@Entry, _1002@Entry, _1003@Entry
bb303:
  _1001 = move (_1004.0: i32)
  using: _1004@Mir(bb302[4])
  _1000 = move _1001 as isize (IntToInt)
  using: _1001@Mir(bb303[0])
  _998 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _999, move _1000) -> bb304
  using: _999@Mir(bb302[1]), _1000@Mir(bb303[1])
bb304:
  (*_998) = move _997
  using: _998@Mir(bb303[2]), _997@Mir(bb302[0])
  goto -> bb305
  using: 
bb305:
  _1005 = CheckedSub(_9, const 1_i32)
  using: _9@Phi(bb296)
  assert(!move (_1005.1: bool), "attempt to compute `{} - {}`, which would overflow", _9, const 1_i32) -> bb306
  using: _1005@Entry, _9@Entry
bb306:
  _9 = move (_1005.0: i32)
  using: _1005@Mir(bb305[0])
  goto -> bb296
  using: 
bb307:
  _1010 = _944
  using: _944@Mir(bb289[0])
  _1011 = const 1_i32
  using: 
  _1012 = CheckedSub(_1010, _1011)
  using: _1010@Mir(bb307[0]), _1011@Mir(bb307[1])
  assert(!move (_1012.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1010, move _1011) -> bb308
  using: _1012@Entry, _1010@Entry, _1011@Entry
bb308:
  _1009 = move (_1012.0: i32)
  using: _1012@Mir(bb307[2])
  _1013 = _961
  using: _961@Phi(bb296)
  _1014 = CheckedShr(_1009, _1013)
  using: _1009@Mir(bb308[0]), _1013@Mir(bb308[1])
  assert(!move (_1014.1: bool), "attempt to shift right by `{}`, which would overflow", move _1013) -> bb309
  using: _1014@Entry, _1009@Entry, _1013@Entry
bb309:
  _1008 = move (_1014.0: i32)
  using: _1014@Mir(bb308[2])
  _1015 = const 65535_i32
  using: 
  _1007 = Le(move _1008, move _1015)
  using: _1008@Mir(bb309[0]), _1015@Mir(bb309[1])
  _1006 = Not(move _1007)
  using: _1007@Mir(bb309[2])
  switchInt(move _1006) -> [0: bb311, otherwise: bb310]
  using: _1006@Mir(bb309[3])
bb310:
  _1017 = const 1002_i32
  using: 
  _1016 = bzlib::BZ2_bz__AssertH__fail(move _1017) -> bb311
  using: _1017@Mir(bb310[0])
bb311:
  _1018 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb172)
  assert(!move (_1018.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb312
  using: _1018@Entry, _8@Entry
bb312:
  _8 = move (_1018.0: i32)
  using: _1018@Mir(bb311[0])
  goto -> bb172
  using: 
bb313:
  _1020 = _6
  using: _6@Phi(bb197)
  _1021 = const 4_i32
  using: 
  _1019 = Ge(move _1020, move _1021)
  using: _1020@Mir(bb313[0]), _1021@Mir(bb313[1])
  switchInt(move _1019) -> [0: bb316, otherwise: bb314]
  using: _1019@Mir(bb313[2])
bb314:
  _1024 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _1023 = (*_1024)
  using: _1024@Mir(bb314[0])
  _1028 = const b"        %d pointers, %d sorted, %d scanned\n\x00"
  using: 
  _1027 = &raw const (*_1028)
  using: _1028@Mir(bb314[2])
  _1026 = move _1027 as *const u8 (Pointer(ArrayToPointer))
  using: _1027@Mir(bb314[3])
  _1025 = move _1026 as *const i8 (PtrToPtr)
  using: _1026@Mir(bb314[4])
  _1029 = _5
  using: _5@Phi(bb311)
  _1030 = _18
  using: _18@Phi(bb197)
  _1032 = _5
  using: _5@Phi(bb311)
  _1033 = _18
  using: _18@Phi(bb197)
  _1034 = CheckedSub(_1032, _1033)
  using: _1032@Mir(bb314[8]), _1033@Mir(bb314[9])
  assert(!move (_1034.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1032, move _1033) -> bb315
  using: _1034@Entry, _1032@Entry, _1033@Entry
bb315:
  _1031 = move (_1034.0: i32)
  using: _1034@Mir(bb314[10])
  _1022 = blocksort::fprintf(move _1023, move _1025, move _1029, move _1030, move _1031) -> bb316
  using: _1023@Mir(bb314[1]), _1025@Mir(bb314[5]), _1029@Mir(bb314[6]), _1030@Mir(bb314[7]), _1031@Mir(bb315[0])
bb316:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 256] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 256] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 256] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 256] is not supported
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:1119:9: 1121:49 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1126:15: 1126:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1130:17: 1130:58 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1134:19: 1134:37 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1137:25: 1137:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1139:43: 1139:61 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:1139:63: 1139:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1139:15: 1139:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1140:19: 1140:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1144:25: 1144:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1146:43: 1146:61 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:1146:63: 1146:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1146:15: 1146:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1147:19: 1147:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1151:25: 1151:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1153:43: 1153:61 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:1153:63: 1153:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1153:15: 1153:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1154:19: 1154:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1158:25: 1158:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1160:43: 1160:61 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:1160:63: 1160:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1160:15: 1160:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1164:19: 1164:37 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1167:25: 1167:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1169:43: 1169:61 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:1169:63: 1169:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1169:15: 1169:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1177:55: 1177:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1177:16: 1177:45 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1178:19: 1178:48 (#0) by default
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:1182:9: 1184:49 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1189:43: 1189:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1190:59: 1193:71 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/blocksort.rs:1190:40: 1193:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1189:15: 1189:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1198:18: 1198:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1204:26: 1204:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1207:20: 1208:37 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1208:39: 1209:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1210:15: 1210:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1211:14: 1211:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1214:26: 1214:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1217:20: 1218:37 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1218:39: 1219:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1220:15: 1220:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1221:14: 1221:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1224:26: 1224:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1227:20: 1228:37 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1228:39: 1229:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1230:15: 1230:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1231:14: 1231:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1234:26: 1234:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1237:20: 1238:37 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1238:39: 1239:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1240:15: 1240:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1241:14: 1241:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1247:26: 1247:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1250:20: 1251:37 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1251:39: 1252:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1253:15: 1253:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1254:14: 1254:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1280:26: 1283:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1283:64: 1293:81 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1283:45: 1293:82 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1295:30: 1297:47 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1297:68: 1303:85 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1297:49: 1303:86 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1339:26: 1339:45 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1343:32: 1343:51 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1347:32: 1347:80 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1349:56: 1351:86 (#0) by default
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:1355:29: 1359:72 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1367:23: 1367:42 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1384:24: 1384:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1388:24: 1389:71 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1391:48: 1392:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1397:20: 1397:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1402:23: 1403:40 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1403:42: 1404:80 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1407:25: 1407:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1411:22: 1411:46 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1416:20: 1417:37 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1419:44: 1420:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1423:23: 1424:40 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1424:42: 1425:80 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1428:25: 1428:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1432:22: 1432:46 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1444:19: 1444:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1489:24: 1489:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1493:24: 1494:41 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/blocksort.rs:1496:48: 1496:93 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1503:26: 1503:56 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1505:27: 1505:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1509:31: 1509:67 (#0) by default
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:1521:9: 1524:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:54 ~ c2rust_lib[1043]::blocksort::BZ2_blockSort)
bb0:
  _2 = ((*_1).8: *mut u32)
  using: _1@Entry
  _3 = ((*_1).9: *mut u8)
  using: _1@Entry
  _4 = ((*_1).6: *mut u32)
  using: _1@Entry
  _5 = ((*_1).17: i32)
  using: _1@Entry
  _6 = ((*_1).28: i32)
  using: _1@Entry
  _7 = ((*_1).12: i32)
  using: _1@Entry
  _8 = const {0x0 as *mut u16}
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _13 = _5
  using: _5@Mir(bb0[3])
  _14 = const 10000_i32
  using: 
  _12 = Lt(move _13, move _14)
  using: _13@Mir(bb0[10]), _14@Mir(bb0[11])
  switchInt(move _12) -> [0: bb2, otherwise: bb1]
  using: _12@Mir(bb0[12])
bb1:
  _16 = ((*_1).4: *mut u32)
  using: _1@Entry
  _17 = ((*_1).5: *mut u32)
  using: _1@Entry
  _18 = _4
  using: _4@Mir(bb0[2])
  _19 = _5
  using: _5@Mir(bb0[3])
  _20 = _6
  using: _6@Mir(bb0[4])
  _15 = blocksort::fallbackSort(move _16, move _17, move _18, move _19, move _20) -> bb26
  using: _16@Mir(bb1[0]), _17@Mir(bb1[1]), _18@Mir(bb1[2]), _19@Mir(bb1[3]), _20@Mir(bb1[4])
bb2:
  _21 = _5
  using: _5@Mir(bb0[3])
  _22 = const 34_i32
  using: 
  _23 = CheckedAdd(_21, _22)
  using: _21@Mir(bb2[0]), _22@Mir(bb2[1])
  assert(!move (_23.1: bool), "attempt to compute `{} + {}`, which would overflow", move _21, move _22) -> bb3
  using: _23@Entry, _21@Entry, _22@Entry
bb3:
  _11 = move (_23.0: i32)
  using: _23@Mir(bb2[2])
  _25 = _11
  using: _11@Mir(bb3[0])
  _26 = const 1_i32
  using: 
  _24 = BitAnd(move _25, move _26)
  using: _25@Mir(bb3[1]), _26@Mir(bb3[2])
  switchInt(move _24) -> [0: bb6, otherwise: bb4]
  using: _24@Mir(bb3[3])
bb4:
  _27 = CheckedAdd(_11, const 1_i32)
  using: _11@Mir(bb3[0])
  assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb5
  using: _27@Entry, _11@Entry
bb5:
  _11 = move (_27.0: i32)
  using: _27@Mir(bb4[0])
  goto -> bb6
  using: 
bb6:
  _31 = _3
  using: _3@Mir(bb0[1])
  _33 = _11
  using: _11@Phi(bb6)
  _32 = move _33 as isize (IntToInt)
  using: _33@Mir(bb6[1])
  _30 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _31, move _32) -> bb7
  using: _31@Mir(bb6[0]), _32@Mir(bb6[2])
bb7:
  _29 = &mut (*_30)
  using: _30@Mir(bb6[3])
  _28 = &raw mut (*_29)
  using: _29@Mir(bb7[0])
  _8 = move _28 as *mut u16 (PtrToPtr)
  using: _28@Mir(bb7[1])
  _35 = _7
  using: _7@Mir(bb0[5])
  _36 = const 1_i32
  using: 
  _34 = Lt(move _35, move _36)
  using: _35@Mir(bb7[3]), _36@Mir(bb7[4])
  switchInt(move _34) -> [0: bb9, otherwise: bb8]
  using: _34@Mir(bb7[5])
bb8:
  _7 = const 1_i32
  using: 
  goto -> bb9
  using: 
bb9:
  _38 = _7
  using: _7@Phi(bb9)
  _39 = const 100_i32
  using: 
  _37 = Gt(move _38, move _39)
  using: _38@Mir(bb9[0]), _39@Mir(bb9[1])
  switchInt(move _37) -> [0: bb11, otherwise: bb10]
  using: _37@Mir(bb9[2])
bb10:
  _7 = const 100_i32
  using: 
  goto -> bb11
  using: 
bb11:
  _40 = _5
  using: _5@Mir(bb0[3])
  _43 = _7
  using: _7@Phi(bb11)
  _44 = const 1_i32
  using: 
  _45 = CheckedSub(_43, _44)
  using: _43@Mir(bb11[1]), _44@Mir(bb11[2])
  assert(!move (_45.1: bool), "attempt to compute `{} - {}`, which would overflow", move _43, move _44) -> bb12
  using: _45@Entry, _43@Entry, _44@Entry
bb12:
  _42 = move (_45.0: i32)
  using: _45@Mir(bb11[3])
  _46 = const 3_i32
  using: 
  _47 = const false
  using: 
  _48 = Eq(_42, const i32::MIN)
  using: _42@Mir(bb12[0])
  _49 = BitAnd(move _47, move _48)
  using: _47@Mir(bb12[2]), _48@Mir(bb12[3])
  assert(!move _49, "attempt to compute `{} / {}`, which would overflow", _42, _46) -> bb13
  using: _49@Entry, _42@Entry, _46@Entry
bb13:
  _41 = Div(move _42, move _46)
  using: _42@Mir(bb12[0]), _46@Mir(bb12[1])
  _50 = CheckedMul(_40, _41)
  using: _40@Mir(bb11[0]), _41@Mir(bb13[0])
  assert(!move (_50.1: bool), "attempt to compute `{} * {}`, which would overflow", move _40, move _41) -> bb14
  using: _50@Entry, _40@Entry, _41@Entry
bb14:
  _10 = move (_50.0: i32)
  using: _50@Mir(bb13[1])
  _51 = _10
  using: _10@Mir(bb14[0])
  _9 = move _51
  using: _51@Mir(bb14[1])
  _53 = _2
  using: _2@Mir(bb0[0])
  _54 = _3
  using: _3@Mir(bb0[1])
  _55 = _8
  using: _8@Mir(bb7[2])
  _56 = _4
  using: _4@Mir(bb0[2])
  _57 = _5
  using: _5@Mir(bb0[3])
  _58 = _6
  using: _6@Mir(bb0[4])
  _60 = &mut _9
  using: _9@Mir(bb14[2])
  _59 = &raw mut (*_60)
  using: _60@Mir(bb14[9])
  _52 = blocksort::mainSort(move _53, move _54, move _55, move _56, move _57, move _58, move _59) -> bb15
  using: _53@Mir(bb14[3]), _54@Mir(bb14[4]), _55@Mir(bb14[5]), _56@Mir(bb14[6]), _57@Mir(bb14[7]), _58@Mir(bb14[8]), _59@Mir(bb14[10])
bb15:
  _62 = _6
  using: _6@Mir(bb0[4])
  _63 = const 3_i32
  using: 
  _61 = Ge(move _62, move _63)
  using: _62@Mir(bb15[0]), _63@Mir(bb15[1])
  switchInt(move _61) -> [0: bb22, otherwise: bb16]
  using: _61@Mir(bb15[2])
bb16:
  _66 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _65 = (*_66)
  using: _66@Mir(bb16[0])
  _70 = const b"      %d work, %d block, ratio %5.2f\n\x00"
  using: 
  _69 = &raw const (*_70)
  using: _70@Mir(bb16[2])
  _68 = move _69 as *const u8 (Pointer(ArrayToPointer))
  using: _69@Mir(bb16[3])
  _67 = move _68 as *const i8 (PtrToPtr)
  using: _68@Mir(bb16[4])
  _72 = _10
  using: _10@Mir(bb14[0])
  _73 = _9
  using: _9@Mir(bb14[2])
  _74 = CheckedSub(_72, _73)
  using: _72@Mir(bb16[6]), _73@Mir(bb16[7])
  assert(!move (_74.1: bool), "attempt to compute `{} - {}`, which would overflow", move _72, move _73) -> bb17
  using: _74@Entry, _72@Entry, _73@Entry
bb17:
  _71 = move (_74.0: i32)
  using: _74@Mir(bb16[8])
  _75 = _5
  using: _5@Mir(bb0[3])
  _80 = _10
  using: _10@Mir(bb14[0])
  _81 = _9
  using: _9@Mir(bb14[2])
  _82 = CheckedSub(_80, _81)
  using: _80@Mir(bb17[2]), _81@Mir(bb17[3])
  assert(!move (_82.1: bool), "attempt to compute `{} - {}`, which would overflow", move _80, move _81) -> bb18
  using: _82@Entry, _80@Entry, _81@Entry
bb18:
  _79 = move (_82.0: i32)
  using: _82@Mir(bb17[4])
  _78 = move _79 as f32 (IntToFloat)
  using: _79@Mir(bb18[0])
  _86 = _5
  using: _5@Mir(bb0[3])
  _87 = const 0_i32
  using: 
  _85 = Eq(move _86, move _87)
  using: _86@Mir(bb18[2]), _87@Mir(bb18[3])
  switchInt(move _85) -> [0: bb20, otherwise: bb19]
  using: _85@Mir(bb18[4])
bb19:
  _84 = const 1_i32
  using: 
  goto -> bb21
  using: 
bb20:
  _84 = _5
  using: _5@Mir(bb0[3])
  goto -> bb21
  using: 
bb21:
  _83 = move _84 as f32 (IntToFloat)
  using: _84@Phi(bb21)
  _77 = Div(move _78, move _83)
  using: _78@Mir(bb18[1]), _83@Mir(bb21[0])
  _76 = move _77 as f64 (FloatToFloat)
  using: _77@Mir(bb21[1])
  _64 = blocksort::fprintf(move _65, move _67, move _71, move _75, move _76) -> bb22
  using: _65@Mir(bb16[1]), _67@Mir(bb16[5]), _71@Mir(bb17[0]), _75@Mir(bb17[1]), _76@Mir(bb21[2])
bb22:
  _89 = _9
  using: _9@Phi(bb22)
  _90 = const 0_i32
  using: 
  _88 = Lt(move _89, move _90)
  using: _89@Mir(bb22[0]), _90@Mir(bb22[1])
  switchInt(move _88) -> [0: bb26, otherwise: bb23]
  using: _88@Mir(bb22[2])
bb23:
  _92 = _6
  using: _6@Mir(bb0[4])
  _93 = const 2_i32
  using: 
  _91 = Ge(move _92, move _93)
  using: _92@Mir(bb23[0]), _93@Mir(bb23[1])
  switchInt(move _91) -> [0: bb25, otherwise: bb24]
  using: _91@Mir(bb23[2])
bb24:
  _96 = const {alloc13: *mut *mut blocksort::__sFILE}
  using: 
  _95 = (*_96)
  using: _96@Mir(bb24[0])
  _100 = const b"    too repetitive; using fallback sorting algorithm\n\x00"
  using: 
  _99 = &raw const (*_100)
  using: _100@Mir(bb24[2])
  _98 = move _99 as *const u8 (Pointer(ArrayToPointer))
  using: _99@Mir(bb24[3])
  _97 = move _98 as *const i8 (PtrToPtr)
  using: _98@Mir(bb24[4])
  _94 = blocksort::fprintf(move _95, move _97) -> bb25
  using: _95@Mir(bb24[1]), _97@Mir(bb24[5])
bb25:
  _102 = ((*_1).4: *mut u32)
  using: _1@Entry
  _103 = ((*_1).5: *mut u32)
  using: _1@Entry
  _104 = _4
  using: _4@Mir(bb0[2])
  _105 = _5
  using: _5@Phi(bb22)
  _106 = _6
  using: _6@Mir(bb0[4])
  _101 = blocksort::fallbackSort(move _102, move _103, move _104, move _105, move _106) -> bb26
  using: _102@Mir(bb25[0]), _103@Mir(bb25[1]), _104@Mir(bb25[2]), _105@Mir(bb25[3]), _106@Mir(bb25[4])
bb26:
  _107 = const 1_i32
  using: 
  ((*_1).7: i32) = Neg(move _107)
  using: _1@Phi(bb26), _107@Mir(bb26[0])
  _11 = const 0_i32
  using: 
  goto -> bb27
  using: 
bb27:
  _109 = _11
  using: _11@Phi(bb27)
  _110 = ((*_1).17: i32)
  using: _1@Phi(bb26)
  _108 = Lt(move _109, move _110)
  using: _109@Mir(bb27[0]), _110@Mir(bb27[1])
  switchInt(move _108) -> [0: bb33, otherwise: bb28]
  using: _108@Mir(bb27[2])
bb28:
  _114 = _2
  using: _2@Phi(bb27)
  _116 = _11
  using: _11@Phi(bb27)
  _115 = move _116 as isize (IntToInt)
  using: _116@Mir(bb28[1])
  _113 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _114, move _115) -> bb29
  using: _114@Mir(bb28[0]), _115@Mir(bb28[2])
bb29:
  _112 = (*_113)
  using: _113@Mir(bb28[3])
  _117 = const 0_u32
  using: 
  _111 = Eq(move _112, move _117)
  using: _112@Mir(bb29[0]), _117@Mir(bb29[1])
  switchInt(move _111) -> [0: bb31, otherwise: bb30]
  using: _111@Mir(bb29[2])
bb30:
  _118 = _11
  using: _11@Phi(bb27)
  ((*_1).7: i32) = move _118
  using: _1@Phi(bb26), _118@Mir(bb30[0])
  goto -> bb33
  using: 
bb31:
  _119 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb27)
  assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb32
  using: _119@Entry, _11@Entry
bb32:
  _11 = move (_119.0: i32)
  using: _119@Mir(bb31[0])
  goto -> bb27
  using: 
bb33:
  _122 = ((*_1).7: i32)
  using: _1@Phi(bb33)
  _123 = const -1_i32
  using: 
  _121 = Ne(move _122, move _123)
  using: _122@Mir(bb33[0]), _123@Mir(bb33[1])
  _120 = Not(move _121)
  using: _121@Mir(bb33[2])
  switchInt(move _120) -> [0: bb35, otherwise: bb34]
  using: _120@Mir(bb33[3])
bb34:
  _125 = const 1003_i32
  using: 
  _124 = bzlib::BZ2_bz__AssertH__fail(move _125) -> bb35
  using: _125@Mir(bb34[0])
bb35:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1566:25: 1566:43 (#0) by default
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:1580:13: 1587:48 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call blocksort::fprintf @ workspace/bzip2/rust/blocksort.rs:1591:17: 1593:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/blocksort.rs:1601:17: 1601:35 (#0) by default
@DefId(0:142 ~ c2rust_lib[1043]::bzip2::isascii)
bb0:
  _4 = _1
  using: _1@Entry
  _5 = const -128_i32
  using: 
  _3 = BitAnd(move _4, move _5)
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1])
  _6 = const 0_i32
  using: 
  _2 = Eq(move _3, move _6)
  using: _3@Mir(bb0[2]), _6@Mir(bb0[3])
  _0 = move _2 as i32 (IntToInt)
  using: _2@Mir(bb0[4])
  return
  using: _0@Mir(bb0[5])
@DefId(0:143 ~ c2rust_lib[1043]::bzip2::__istype)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = bzip2::isascii(move _4) -> bb1
  using: _4@Mir(bb0[0])
bb1:
  switchInt(move _3) -> [0: bb4, otherwise: bb2]
  using: _3@Mir(bb0[1])
bb2:
  _9 = const {alloc152: *mut bzip2::_RuneLocale}
  using: 
  _11 = _1
  using: _1@Entry
  _10 = move _11 as usize (IntToInt)
  using: _11@Mir(bb2[1])
  _12 = const 256_usize
  using: 
  _13 = Lt(_10, _12)
  using: _10@Mir(bb2[2]), _12@Mir(bb2[3])
  assert(move _13, "index out of bounds: the length is {} but the index is {}", move _12, _10) -> bb3
  using: _13@Entry, _12@Entry, _10@Entry
bb3:
  _8 = ((*_9).5: [u32; 256])[_10]
  using: _9@Mir(bb2[0]), _10@Mir(bb2[2])
  _7 = move _8 as u64 (IntToInt)
  using: _8@Mir(bb3[0])
  _14 = _2
  using: _2@Entry
  _6 = BitAnd(move _7, move _14)
  using: _7@Mir(bb3[1]), _14@Mir(bb3[2])
  _5 = Ne(move _6, const 0_u64)
  using: _6@Mir(bb3[3])
  _0 = move _5 as i32 (IntToInt)
  using: _5@Mir(bb3[4])
  goto -> bb6
  using: 
bb4:
  _17 = _1
  using: _1@Entry
  _18 = _2
  using: _2@Entry
  _16 = bzip2::__maskrune(move _17, move _18) -> bb5
  using: _17@Mir(bb4[0]), _18@Mir(bb4[1])
bb5:
  _15 = Ne(move _16, const 0_i32)
  using: _16@Mir(bb4[2])
  _0 = move _15 as i32 (IntToInt)
  using: _15@Mir(bb5[0])
  goto -> bb6
  using: 
bb6:
  return
  using: _0@Phi(bb6)
rewrite call bzip2::__maskrune @ workspace/bzip2/rust/bzip2.rs:291:22: 291:40 (#0) by default
@DefId(0:144 ~ c2rust_lib[1043]::bzip2::isspace)
bb0:
  _2 = _1
  using: _1@Entry
  _3 = const 16384_u64
  using: 
  _0 = bzip2::__istype(move _2, move _3) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1])
bb1:
  return
  using: _0@Mir(bb0[2])
@DefId(0:175 ~ c2rust_lib[1043]::bzip2::uInt64_from_UInt32s)
bb0:
  _6 = _3
  using: _3@Entry
  _7 = const 24_i32
  using: 
  _8 = CheckedShr(_6, _7)
  using: _6@Mir(bb0[0]), _7@Mir(bb0[1])
  assert(!move (_8.1: bool), "attempt to shift right by `{}`, which would overflow", move _7) -> bb1
  using: _8@Entry, _6@Entry, _7@Entry
bb1:
  _5 = move (_8.0: u32)
  using: _8@Mir(bb0[2])
  _9 = const 255_u32
  using: 
  _4 = BitAnd(move _5, move _9)
  using: _5@Mir(bb1[0]), _9@Mir(bb1[1])
  _10 = const 7_usize
  using: 
  ((*_1).0: [u8; 8])[_10] = move _4 as u8 (IntToInt)
  using: _1@Entry, _10@Mir(bb1[3]), _4@Mir(bb1[2])
  _13 = _3
  using: _3@Entry
  _14 = const 16_i32
  using: 
  _15 = CheckedShr(_13, _14)
  using: _13@Mir(bb1[5]), _14@Mir(bb1[6])
  assert(!move (_15.1: bool), "attempt to shift right by `{}`, which would overflow", move _14) -> bb2
  using: _15@Entry, _13@Entry, _14@Entry
bb2:
  _12 = move (_15.0: u32)
  using: _15@Mir(bb1[7])
  _16 = const 255_u32
  using: 
  _11 = BitAnd(move _12, move _16)
  using: _12@Mir(bb2[0]), _16@Mir(bb2[1])
  _17 = const 6_usize
  using: 
  ((*_1).0: [u8; 8])[_17] = move _11 as u8 (IntToInt)
  using: _1@Entry, _17@Mir(bb2[3]), _11@Mir(bb2[2])
  _20 = _3
  using: _3@Entry
  _21 = const 8_i32
  using: 
  _22 = CheckedShr(_20, _21)
  using: _20@Mir(bb2[5]), _21@Mir(bb2[6])
  assert(!move (_22.1: bool), "attempt to shift right by `{}`, which would overflow", move _21) -> bb3
  using: _22@Entry, _20@Entry, _21@Entry
bb3:
  _19 = move (_22.0: u32)
  using: _22@Mir(bb2[7])
  _23 = const 255_u32
  using: 
  _18 = BitAnd(move _19, move _23)
  using: _19@Mir(bb3[0]), _23@Mir(bb3[1])
  _24 = const 5_usize
  using: 
  ((*_1).0: [u8; 8])[_24] = move _18 as u8 (IntToInt)
  using: _1@Entry, _24@Mir(bb3[3]), _18@Mir(bb3[2])
  _26 = _3
  using: _3@Entry
  _27 = const 255_u32
  using: 
  _25 = BitAnd(move _26, move _27)
  using: _26@Mir(bb3[5]), _27@Mir(bb3[6])
  _28 = const 4_usize
  using: 
  ((*_1).0: [u8; 8])[_28] = move _25 as u8 (IntToInt)
  using: _1@Entry, _28@Mir(bb3[8]), _25@Mir(bb3[7])
  _31 = _2
  using: _2@Entry
  _32 = const 24_i32
  using: 
  _33 = CheckedShr(_31, _32)
  using: _31@Mir(bb3[10]), _32@Mir(bb3[11])
  assert(!move (_33.1: bool), "attempt to shift right by `{}`, which would overflow", move _32) -> bb4
  using: _33@Entry, _31@Entry, _32@Entry
bb4:
  _30 = move (_33.0: u32)
  using: _33@Mir(bb3[12])
  _34 = const 255_u32
  using: 
  _29 = BitAnd(move _30, move _34)
  using: _30@Mir(bb4[0]), _34@Mir(bb4[1])
  _35 = const 3_usize
  using: 
  ((*_1).0: [u8; 8])[_35] = move _29 as u8 (IntToInt)
  using: _1@Entry, _35@Mir(bb4[3]), _29@Mir(bb4[2])
  _38 = _2
  using: _2@Entry
  _39 = const 16_i32
  using: 
  _40 = CheckedShr(_38, _39)
  using: _38@Mir(bb4[5]), _39@Mir(bb4[6])
  assert(!move (_40.1: bool), "attempt to shift right by `{}`, which would overflow", move _39) -> bb5
  using: _40@Entry, _38@Entry, _39@Entry
bb5:
  _37 = move (_40.0: u32)
  using: _40@Mir(bb4[7])
  _41 = const 255_u32
  using: 
  _36 = BitAnd(move _37, move _41)
  using: _37@Mir(bb5[0]), _41@Mir(bb5[1])
  _42 = const 2_usize
  using: 
  ((*_1).0: [u8; 8])[_42] = move _36 as u8 (IntToInt)
  using: _1@Entry, _42@Mir(bb5[3]), _36@Mir(bb5[2])
  _45 = _2
  using: _2@Entry
  _46 = const 8_i32
  using: 
  _47 = CheckedShr(_45, _46)
  using: _45@Mir(bb5[5]), _46@Mir(bb5[6])
  assert(!move (_47.1: bool), "attempt to shift right by `{}`, which would overflow", move _46) -> bb6
  using: _47@Entry, _45@Entry, _46@Entry
bb6:
  _44 = move (_47.0: u32)
  using: _47@Mir(bb5[7])
  _48 = const 255_u32
  using: 
  _43 = BitAnd(move _44, move _48)
  using: _44@Mir(bb6[0]), _48@Mir(bb6[1])
  _49 = const 1_usize
  using: 
  ((*_1).0: [u8; 8])[_49] = move _43 as u8 (IntToInt)
  using: _1@Entry, _49@Mir(bb6[3]), _43@Mir(bb6[2])
  _51 = _2
  using: _2@Entry
  _52 = const 255_u32
  using: 
  _50 = BitAnd(move _51, move _52)
  using: _51@Mir(bb6[5]), _52@Mir(bb6[6])
  _53 = const 0_usize
  using: 
  ((*_1).0: [u8; 8])[_53] = move _50 as u8 (IntToInt)
  using: _1@Entry, _53@Mir(bb6[8]), _50@Mir(bb6[7])
  return
  using: _0@Entry
@DefId(0:176 ~ c2rust_lib[1043]::bzip2::uInt64_to_double)
bb0:
  _2 = const 0_i32
  using: 
  _3 = const 1f64
  using: 
  _0 = const 0f64
  using: 
  _2 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _2
  using: _2@Phi(bb1)
  _6 = const 8_i32
  using: 
  _4 = Lt(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb5, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _8 = _3
  using: _3@Phi(bb1)
  _12 = _2
  using: _2@Phi(bb1)
  _11 = move _12 as usize (IntToInt)
  using: _12@Mir(bb2[1])
  _13 = const 8_usize
  using: 
  _14 = Lt(_11, _13)
  using: _11@Mir(bb2[2]), _13@Mir(bb2[3])
  assert(move _14, "index out of bounds: the length is {} but the index is {}", move _13, _11) -> bb3
  using: _14@Entry, _13@Entry, _11@Entry
bb3:
  _10 = ((*_1).0: [u8; 8])[_11]
  using: _1@Phi(bb1), _11@Mir(bb2[2])
  _9 = move _10 as f64 (IntToFloat)
  using: _10@Mir(bb3[0])
  _7 = Mul(move _8, move _9)
  using: _8@Mir(bb2[0]), _9@Mir(bb3[1])
  _0 = Add(_0, move _7)
  using: _7@Mir(bb3[2])
  _3 = Mul(_3, const 256f64)
  using: 
  _15 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb1)
  assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb4
  using: _15@Entry, _2@Entry
bb4:
  _2 = move (_15.0: i32)
  using: _15@Mir(bb3[5])
  goto -> bb1
  using: 
bb5:
  return
  using: _0@Mir(bb3[3])
@DefId(0:177 ~ c2rust_lib[1043]::bzip2::uInt64_isZero)
bb0:
  _2 = const 0_i32
  using: 
  _2 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _4 = _2
  using: _2@Phi(bb1)
  _5 = const 8_i32
  using: 
  _3 = Lt(move _4, move _5)
  using: _4@Mir(bb1[0]), _5@Mir(bb1[1])
  switchInt(move _3) -> [0: bb7, otherwise: bb2]
  using: _3@Mir(bb1[2])
bb2:
  _10 = _2
  using: _2@Phi(bb1)
  _9 = move _10 as usize (IntToInt)
  using: _10@Mir(bb2[0])
  _11 = const 8_usize
  using: 
  _12 = Lt(_9, _11)
  using: _9@Mir(bb2[1]), _11@Mir(bb2[2])
  assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _9) -> bb3
  using: _12@Entry, _11@Entry, _9@Entry
bb3:
  _8 = ((*_1).0: [u8; 8])[_9]
  using: _1@Phi(bb1), _9@Mir(bb2[1])
  _7 = move _8 as i32 (IntToInt)
  using: _8@Mir(bb3[0])
  _13 = const 0_i32
  using: 
  _6 = Ne(move _7, move _13)
  using: _7@Mir(bb3[1]), _13@Mir(bb3[2])
  switchInt(move _6) -> [0: bb5, otherwise: bb4]
  using: _6@Mir(bb3[3])
bb4:
  _0 = const 0_u8
  using: 
  goto -> bb8
  using: 
bb5:
  _14 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb1)
  assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb6
  using: _14@Entry, _2@Entry
bb6:
  _2 = move (_14.0: i32)
  using: _14@Mir(bb5[0])
  goto -> bb1
  using: 
bb7:
  _0 = const 1_u8
  using: 
  goto -> bb8
  using: 
bb8:
  return
  using: _0@Phi(bb8)
@DefId(0:178 ~ c2rust_lib[1043]::bzip2::uInt64_qrm10)
bb0:
  _2 = const 0_u32
  using: 
  _3 = const 0_u32
  using: 
  _4 = const 0_i32
  using: 
  _2 = const 0_u32
  using: 
  _4 = const 7_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _6 = _4
  using: _4@Phi(bb1)
  _7 = const 0_i32
  using: 
  _5 = Ge(move _6, move _7)
  using: _6@Mir(bb1[0]), _7@Mir(bb1[1])
  switchInt(move _5) -> [0: bb10, otherwise: bb2]
  using: _5@Mir(bb1[2])
bb2:
  _10 = _2
  using: _2@Phi(bb1)
  _11 = const 256_u32
  using: 
  _9 = core::num::<impl u32>::wrapping_mul(move _10, move _11) -> bb3
  using: _10@Mir(bb2[0]), _11@Mir(bb2[1])
bb3:
  _15 = _4
  using: _4@Phi(bb1)
  _14 = move _15 as usize (IntToInt)
  using: _15@Mir(bb3[0])
  _16 = const 8_usize
  using: 
  _17 = Lt(_14, _16)
  using: _14@Mir(bb3[1]), _16@Mir(bb3[2])
  assert(move _17, "index out of bounds: the length is {} but the index is {}", move _16, _14) -> bb4
  using: _17@Entry, _16@Entry, _14@Entry
bb4:
  _13 = ((*_1).0: [u8; 8])[_14]
  using: _1@Phi(bb1), _14@Mir(bb3[1])
  _12 = move _13 as u32 (IntToInt)
  using: _13@Mir(bb4[0])
  _8 = core::num::<impl u32>::wrapping_add(move _9, move _12) -> bb5
  using: _9@Mir(bb2[2]), _12@Mir(bb4[1])
bb5:
  _3 = move _8
  using: _8@Mir(bb4[2])
  _19 = _3
  using: _3@Mir(bb5[0])
  _20 = const 10_u32
  using: 
  _18 = core::num::<impl u32>::wrapping_div(move _19, move _20) -> bb6
  using: _19@Mir(bb5[1]), _20@Mir(bb5[2])
bb6:
  _22 = _4
  using: _4@Phi(bb1)
  _21 = move _22 as usize (IntToInt)
  using: _22@Mir(bb6[0])
  _23 = const 8_usize
  using: 
  _24 = Lt(_21, _23)
  using: _21@Mir(bb6[1]), _23@Mir(bb6[2])
  assert(move _24, "index out of bounds: the length is {} but the index is {}", move _23, _21) -> bb7
  using: _24@Entry, _23@Entry, _21@Entry
bb7:
  ((*_1).0: [u8; 8])[_21] = move _18 as u8 (IntToInt)
  using: _1@Phi(bb1), _21@Mir(bb6[1]), _18@Mir(bb5[3])
  _26 = _3
  using: _3@Mir(bb5[0])
  _27 = const 10_u32
  using: 
  _25 = core::num::<impl u32>::wrapping_rem(move _26, move _27) -> bb8
  using: _26@Mir(bb7[1]), _27@Mir(bb7[2])
bb8:
  _2 = move _25
  using: _25@Mir(bb7[3])
  _28 = CheckedSub(_4, const 1_i32)
  using: _4@Phi(bb1)
  assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 1_i32) -> bb9
  using: _28@Entry, _4@Entry
bb9:
  _4 = move (_28.0: i32)
  using: _28@Mir(bb8[1])
  goto -> bb1
  using: 
bb10:
  _29 = _2
  using: _2@Phi(bb1)
  _0 = move _29 as i32 (IntToInt)
  using: _29@Mir(bb10[0])
  return
  using: _0@Mir(bb10[1])
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzip2.rs:404:17: 405:55 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzip2.rs:405:56: 407:86 (#0) by default
rewrite call core::num::<impl u32>::wrapping_div @ workspace/bzip2/rust/bzip2.rs:409:17: 409:80 (#0) by default
rewrite call core::num::<impl u32>::wrapping_rem @ workspace/bzip2/rust/bzip2.rs:410:19: 410:82 (#0) by default
@DefId(0:179 ~ c2rust_lib[1043]::bzip2::uInt64_toAscii)
bb0:
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = [const 0_u8; 32]
  using: 
  _6 = const 0_i32
  using: 
  _7 = (*_2)
  using: _2@Entry
  goto -> bb1
  using: 
bb1:
  _10 = &mut _7
  using: _7@Phi(bb1)
  _9 = &raw mut (*_10)
  using: _10@Mir(bb1[0])
  _8 = bzip2::uInt64_qrm10(move _9) -> bb2
  using: _9@Mir(bb1[1])
bb2:
  _4 = move _8
  using: _8@Mir(bb1[2])
  _12 = _4
  using: _4@Mir(bb2[0])
  _13 = const 48_i32
  using: 
  _14 = CheckedAdd(_12, _13)
  using: _12@Mir(bb2[1]), _13@Mir(bb2[2])
  assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", move _12, move _13) -> bb3
  using: _14@Entry, _12@Entry, _13@Entry
bb3:
  _11 = move (_14.0: i32)
  using: _14@Mir(bb2[3])
  _16 = _6
  using: _6@Phi(bb1)
  _15 = move _16 as usize (IntToInt)
  using: _16@Mir(bb3[1])
  _17 = const 32_usize
  using: 
  _18 = Lt(_15, _17)
  using: _15@Mir(bb3[2]), _17@Mir(bb3[3])
  assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _15) -> bb4
  using: _18@Entry, _17@Entry, _15@Entry
bb4:
  _5[_15] = move _11 as u8 (IntToInt)
  using: _15@Mir(bb3[2]), _11@Mir(bb3[0])
  _19 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb1)
  assert(!move (_19.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb5
  using: _19@Entry, _6@Entry
bb5:
  _6 = move (_19.0: i32)
  using: _19@Mir(bb4[1])
  _24 = &mut _7
  using: _7@Phi(bb1)
  _23 = &raw mut (*_24)
  using: _24@Mir(bb5[1])
  _22 = bzip2::uInt64_isZero(move _23) -> bb6
  using: _23@Mir(bb5[2])
bb6:
  _21 = Eq(move _22, const 0_u8)
  using: _22@Mir(bb5[3])
  _20 = Not(move _21)
  using: _21@Mir(bb6[0])
  switchInt(move _20) -> [0: bb1, otherwise: bb7]
  using: _20@Mir(bb6[1])
bb7:
  _25 = const 0_i32
  using: 
  _27 = _1
  using: _1@Entry
  _29 = _6
  using: _6@Mir(bb5[0])
  _28 = move _29 as isize (IntToInt)
  using: _29@Mir(bb7[2])
  _26 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _27, move _28) -> bb8
  using: _27@Mir(bb7[1]), _28@Mir(bb7[3])
bb8:
  (*_26) = move _25 as i8 (IntToInt)
  using: _26@Mir(bb7[4]), _25@Mir(bb7[0])
  _3 = const 0_i32
  using: 
  goto -> bb9
  using: 
bb9:
  _31 = _3
  using: _3@Phi(bb9)
  _32 = _6
  using: _6@Phi(bb9)
  _30 = Lt(move _31, move _32)
  using: _31@Mir(bb9[0]), _32@Mir(bb9[1])
  switchInt(move _30) -> [0: bb16, otherwise: bb10]
  using: _30@Mir(bb9[2])
bb10:
  _37 = _6
  using: _6@Phi(bb9)
  _38 = _3
  using: _3@Phi(bb9)
  _39 = CheckedSub(_37, _38)
  using: _37@Mir(bb10[0]), _38@Mir(bb10[1])
  assert(!move (_39.1: bool), "attempt to compute `{} - {}`, which would overflow", move _37, move _38) -> bb11
  using: _39@Entry, _37@Entry, _38@Entry
bb11:
  _36 = move (_39.0: i32)
  using: _39@Mir(bb10[2])
  _40 = const 1_i32
  using: 
  _41 = CheckedSub(_36, _40)
  using: _36@Mir(bb11[0]), _40@Mir(bb11[1])
  assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", move _36, move _40) -> bb12
  using: _41@Entry, _36@Entry, _40@Entry
bb12:
  _35 = move (_41.0: i32)
  using: _41@Mir(bb11[2])
  _34 = move _35 as usize (IntToInt)
  using: _35@Mir(bb12[0])
  _42 = const 32_usize
  using: 
  _43 = Lt(_34, _42)
  using: _34@Mir(bb12[1]), _42@Mir(bb12[2])
  assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _34) -> bb13
  using: _43@Entry, _42@Entry, _34@Entry
bb13:
  _33 = _5[_34]
  using: _5@Phi(bb9), _34@Mir(bb12[1])
  _45 = _1
  using: _1@Phi(bb9)
  _47 = _3
  using: _3@Phi(bb9)
  _46 = move _47 as isize (IntToInt)
  using: _47@Mir(bb13[2])
  _44 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _45, move _46) -> bb14
  using: _45@Mir(bb13[1]), _46@Mir(bb13[3])
bb14:
  (*_44) = move _33 as i8 (IntToInt)
  using: _44@Mir(bb13[4]), _33@Mir(bb13[0])
  _48 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb9)
  assert(!move (_48.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb15
  using: _48@Entry, _3@Entry
bb15:
  _3 = move (_48.0: i32)
  using: _48@Mir(bb14[1])
  goto -> bb9
  using: 
bb16:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 32] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:431:13: 431:34 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:434:17: 434:35 (#0) by default
@DefId(0:182 ~ c2rust_lib[1043]::bzip2::myfeof)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = bzip2::fgetc(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  _5 = _2
  using: _2@Mir(bb0[1])
  _6 = const -1_i32
  using: 
  _4 = Eq(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb3, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _0 = const 1_u8
  using: 
  goto -> bb5
  using: 
bb3:
  _8 = _2
  using: _2@Mir(bb0[1])
  _9 = _1
  using: _1@Entry
  _7 = bzip2::ungetc(move _8, move _9) -> bb4
  using: _8@Mir(bb3[0]), _9@Mir(bb3[1])
bb4:
  _0 = const 0_u8
  using: 
  goto -> bb5
  using: 
bb5:
  return
  using: _0@Phi(bb5)
rewrite call bzip2::fgetc @ workspace/bzip2/rust/bzip2.rs:444:24: 444:32 (#0) by default
rewrite call bzip2::ungetc @ workspace/bzip2/rust/bzip2.rs:446:5: 446:17 (#0) by default
@DefId(0:183 ~ c2rust_lib[1043]::bzip2::compressStream)
bb0:
  _4 = const {0x0 as *mut std::ffi::c_void}
  using: 
  _5 = [const 0_u8; 5000]
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_u32
  using: 
  _8 = const 0_u32
  using: 
  _9 = const 0_u32
  using: 
  _10 = const 0_u32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  _17 = _1
  using: _1@Entry
  _16 = bzip2::ferror(move _17) -> bb1
  using: _17@Mir(bb0[10])
bb1:
  _15 = Ne(move _16, const 0_i32)
  using: _16@Mir(bb0[11])
  _14 = Not(move _15)
  using: _15@Mir(bb1[0])
  switchInt(move _14) -> [0: bb74, otherwise: bb2]
  using: _14@Mir(bb1[1])
bb2:
  _21 = _2
  using: _2@Entry
  _20 = bzip2::ferror(move _21) -> bb3
  using: _21@Mir(bb2[0])
bb3:
  _19 = Ne(move _20, const 0_i32)
  using: _20@Mir(bb2[1])
  _18 = Not(move _19)
  using: _19@Mir(bb3[0])
  switchInt(move _18) -> [0: bb74, otherwise: bb4]
  using: _18@Mir(bb3[1])
bb4:
  _24 = &mut _11
  using: _11@Mir(bb0[7])
  _23 = &raw mut (*_24)
  using: _24@Mir(bb4[0])
  _25 = _2
  using: _2@Entry
  _27 = const {alloc171: *mut i32}
  using: 
  _26 = (*_27)
  using: _27@Mir(bb4[3])
  _29 = const {alloc172: *mut i32}
  using: 
  _28 = (*_29)
  using: _29@Mir(bb4[5])
  _31 = const {alloc173: *mut i32}
  using: 
  _30 = (*_31)
  using: _31@Mir(bb4[7])
  _22 = bzlib::BZ2_bzWriteOpen(move _23, move _25, move _26, move _28, move _30) -> bb5
  using: _23@Mir(bb4[1]), _25@Mir(bb4[2]), _26@Mir(bb4[4]), _28@Mir(bb4[6]), _30@Mir(bb4[8])
bb5:
  _4 = move _22
  using: _22@Mir(bb4[9])
  _33 = _11
  using: _11@Mir(bb0[7])
  _34 = const 0_i32
  using: 
  _32 = Ne(move _33, move _34)
  using: _33@Mir(bb5[1]), _34@Mir(bb5[2])
  switchInt(move _32) -> [0: bb7, otherwise: bb6]
  using: _32@Mir(bb5[3])
bb6:
  _3 = const 660242869387099075_u64
  using: 
  goto -> bb68
  using: 
bb7:
  _37 = const {alloc172: *mut i32}
  using: 
  _36 = (*_37)
  using: _37@Mir(bb7[0])
  _38 = const 2_i32
  using: 
  _35 = Ge(move _36, move _38)
  using: _36@Mir(bb7[1]), _38@Mir(bb7[2])
  switchInt(move _35) -> [0: bb9, otherwise: bb8]
  using: _35@Mir(bb7[3])
bb8:
  _41 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _40 = (*_41)
  using: _41@Mir(bb8[0])
  _45 = const b"\n\x00"
  using: 
  _44 = &raw const (*_45)
  using: _45@Mir(bb8[2])
  _43 = move _44 as *const u8 (Pointer(ArrayToPointer))
  using: _44@Mir(bb8[3])
  _42 = move _43 as *const i8 (PtrToPtr)
  using: _43@Mir(bb8[4])
  _39 = bzip2::fprintf(move _40, move _42) -> bb9
  using: _40@Mir(bb8[1]), _42@Mir(bb8[5])
bb9:
  _47 = _1
  using: _1@Phi(bb9)
  _46 = bzip2::myfeof(move _47) -> bb10
  using: _47@Mir(bb9[0])
bb10:
  switchInt(move _46) -> [0: bb12, otherwise: bb11]
  using: _46@Mir(bb9[1])
bb11:
  _3 = const 13242334135786603907_u64
  using: 
  goto -> bb23
  using: 
bb12:
  _52 = &mut _5
  using: _5@Phi(bb9)
  _51 = move _52 as &mut [u8] (Pointer(Unsize))
  using: _52@Mir(bb12[0])
  _50 = core::slice::<impl [u8]>::as_mut_ptr(move _51) -> bb13
  using: _51@Mir(bb12[1])
bb13:
  _49 = move _50 as *mut std::ffi::c_void (PtrToPtr)
  using: _50@Mir(bb12[2])
  _54 = std::mem::size_of::<u8>() -> bb14
  using: 
bb14:
  _53 = move _54 as u64 (IntToInt)
  using: _54@Mir(bb13[1])
  _55 = const 5000_u64
  using: 
  _56 = _1
  using: _1@Phi(bb9)
  _48 = bzip2::fread(move _49, move _53, move _55, move _56) -> bb15
  using: _49@Mir(bb13[0]), _53@Mir(bb14[0]), _55@Mir(bb14[1]), _56@Mir(bb14[2])
bb15:
  _6 = move _48 as i32 (IntToInt)
  using: _48@Mir(bb14[3])
  _58 = _1
  using: _1@Phi(bb9)
  _57 = bzip2::ferror(move _58) -> bb16
  using: _58@Mir(bb15[1])
bb16:
  switchInt(move _57) -> [0: bb18, otherwise: bb17]
  using: _57@Mir(bb15[2])
bb17:
  _3 = const 18225113528933273530_u64
  using: 
  goto -> bb23
  using: 
bb18:
  _60 = _6
  using: _6@Mir(bb15[0])
  _61 = const 0_i32
  using: 
  _59 = Gt(move _60, move _61)
  using: _60@Mir(bb18[0]), _61@Mir(bb18[1])
  switchInt(move _59) -> [0: bb21, otherwise: bb19]
  using: _59@Mir(bb18[2])
bb19:
  _64 = &mut _11
  using: _11@Phi(bb9)
  _63 = &raw mut (*_64)
  using: _64@Mir(bb19[0])
  _65 = _4
  using: _4@Phi(bb9)
  _69 = &mut _5
  using: _5@Phi(bb9)
  _68 = move _69 as &mut [u8] (Pointer(Unsize))
  using: _69@Mir(bb19[3])
  _67 = core::slice::<impl [u8]>::as_mut_ptr(move _68) -> bb20
  using: _68@Mir(bb19[4])
bb20:
  _66 = move _67 as *mut std::ffi::c_void (PtrToPtr)
  using: _67@Mir(bb19[5])
  _70 = _6
  using: _6@Mir(bb15[0])
  _62 = bzlib::BZ2_bzWrite(move _63, move _65, move _66, move _70) -> bb21
  using: _63@Mir(bb19[1]), _65@Mir(bb19[2]), _66@Mir(bb20[0]), _70@Mir(bb20[1])
bb21:
  _72 = _11
  using: _11@Phi(bb21)
  _73 = const 0_i32
  using: 
  _71 = Ne(move _72, move _73)
  using: _72@Mir(bb21[0]), _73@Mir(bb21[1])
  switchInt(move _71) -> [0: bb9, otherwise: bb22]
  using: _71@Mir(bb21[2])
bb22:
  _3 = const 660242869387099075_u64
  using: 
  goto -> bb23
  using: 
bb23:
  switchInt(_3) -> [18225113528933273530: bb68, 660242869387099075: bb68, otherwise: bb24]
  using: _3@Phi(bb23)
bb24:
  _76 = &mut _11
  using: _11@Phi(bb23)
  _75 = &raw mut (*_76)
  using: _76@Mir(bb24[0])
  _77 = _4
  using: _4@Phi(bb23)
  _78 = const 0_i32
  using: 
  _80 = &mut _7
  using: _7@Mir(bb0[3])
  _79 = &raw mut (*_80)
  using: _80@Mir(bb24[4])
  _82 = &mut _8
  using: _8@Mir(bb0[4])
  _81 = &raw mut (*_82)
  using: _82@Mir(bb24[6])
  _84 = &mut _9
  using: _9@Mir(bb0[5])
  _83 = &raw mut (*_84)
  using: _84@Mir(bb24[8])
  _86 = &mut _10
  using: _10@Mir(bb0[6])
  _85 = &raw mut (*_86)
  using: _86@Mir(bb24[10])
  _74 = bzlib::BZ2_bzWriteClose64(move _75, move _77, move _78, move _79, move _81, move _83, move _85) -> bb25
  using: _75@Mir(bb24[1]), _77@Mir(bb24[2]), _78@Mir(bb24[3]), _79@Mir(bb24[5]), _81@Mir(bb24[7]), _83@Mir(bb24[9]), _85@Mir(bb24[11])
bb25:
  _88 = _11
  using: _11@Phi(bb23)
  _89 = const 0_i32
  using: 
  _87 = Ne(move _88, move _89)
  using: _88@Mir(bb25[0]), _89@Mir(bb25[1])
  switchInt(move _87) -> [0: bb27, otherwise: bb26]
  using: _87@Mir(bb25[2])
bb26:
  _3 = const 660242869387099075_u64
  using: 
  goto -> bb68
  using: 
bb27:
  _91 = _2
  using: _2@Entry
  _90 = bzip2::ferror(move _91) -> bb28
  using: _91@Mir(bb27[0])
bb28:
  switchInt(move _90) -> [0: bb30, otherwise: bb29]
  using: _90@Mir(bb27[1])
bb29:
  _3 = const 18225113528933273530_u64
  using: 
  goto -> bb68
  using: 
bb30:
  _93 = _2
  using: _2@Entry
  _92 = bzip2::fflush(move _93) -> bb31
  using: _93@Mir(bb30[0])
bb31:
  _13 = move _92
  using: _92@Mir(bb30[1])
  _95 = _13
  using: _13@Mir(bb31[0])
  _96 = const -1_i32
  using: 
  _94 = Eq(move _95, move _96)
  using: _95@Mir(bb31[1]), _96@Mir(bb31[2])
  switchInt(move _94) -> [0: bb33, otherwise: bb32]
  using: _94@Mir(bb31[3])
bb32:
  _3 = const 18225113528933273530_u64
  using: 
  goto -> bb68
  using: 
bb33:
  _98 = _2
  using: _2@Entry
  _100 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _99 = (*_100)
  using: _100@Mir(bb33[1])
  _97 = Ne(move _98, move _99)
  using: _98@Mir(bb33[0]), _99@Mir(bb33[2])
  switchInt(move _97) -> [0: bb42, otherwise: bb34]
  using: _97@Mir(bb33[3])
bb34:
  _102 = _2
  using: _2@Entry
  _101 = bzip2::fileno(move _102) -> bb35
  using: _102@Mir(bb34[0])
bb35:
  _104 = _101
  using: _101@Mir(bb34[1])
  _105 = const 0_i32
  using: 
  _103 = Lt(move _104, move _105)
  using: _104@Mir(bb35[0]), _105@Mir(bb35[1])
  switchInt(move _103) -> [0: bb37, otherwise: bb36]
  using: _103@Mir(bb35[2])
bb36:
  _3 = const 18225113528933273530_u64
  using: 
  goto -> bb43
  using: 
bb37:
  _107 = _101
  using: _101@Mir(bb34[1])
  _106 = bzip2::applySavedFileAttrToOutputFile(move _107) -> bb38
  using: _107@Mir(bb37[0])
bb38:
  _109 = _2
  using: _2@Entry
  _108 = bzip2::fclose(move _109) -> bb39
  using: _109@Mir(bb38[0])
bb39:
  _13 = move _108
  using: _108@Mir(bb38[1])
  _110 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_110) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _110@Mir(bb39[1])
  _112 = _13
  using: _13@Mir(bb39[0])
  _113 = const -1_i32
  using: 
  _111 = Eq(move _112, move _113)
  using: _112@Mir(bb39[3]), _113@Mir(bb39[4])
  switchInt(move _111) -> [0: bb41, otherwise: bb40]
  using: _111@Mir(bb39[5])
bb40:
  _3 = const 18225113528933273530_u64
  using: 
  goto -> bb43
  using: 
bb41:
  _3 = const 17281240262373992796_u64
  using: 
  goto -> bb43
  using: 
bb42:
  _3 = const 17281240262373992796_u64
  using: 
  goto -> bb43
  using: 
bb43:
  switchInt(_3) -> [18225113528933273530: bb68, otherwise: bb44]
  using: _3@Phi(bb43)
bb44:
  _114 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_114) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _114@Mir(bb44[0])
  _116 = _1
  using: _1@Phi(bb23)
  _115 = bzip2::ferror(move _116) -> bb45
  using: _116@Mir(bb44[2])
bb45:
  switchInt(move _115) -> [0: bb47, otherwise: bb46]
  using: _115@Mir(bb44[3])
bb46:
  _3 = const 18225113528933273530_u64
  using: 
  goto -> bb68
  using: 
bb47:
  _118 = _1
  using: _1@Phi(bb23)
  _117 = bzip2::fclose(move _118) -> bb48
  using: _118@Mir(bb47[0])
bb48:
  _13 = move _117
  using: _117@Mir(bb47[1])
  _120 = _13
  using: _13@Mir(bb48[0])
  _121 = const -1_i32
  using: 
  _119 = Eq(move _120, move _121)
  using: _120@Mir(bb48[1]), _121@Mir(bb48[2])
  switchInt(move _119) -> [0: bb50, otherwise: bb49]
  using: _119@Mir(bb48[3])
bb49:
  _3 = const 18225113528933273530_u64
  using: 
  goto -> bb68
  using: 
bb50:
  _124 = const {alloc172: *mut i32}
  using: 
  _123 = (*_124)
  using: _124@Mir(bb50[0])
  _125 = const 1_i32
  using: 
  _122 = Ge(move _123, move _125)
  using: _123@Mir(bb50[1]), _125@Mir(bb50[2])
  switchInt(move _122) -> [0: bb67, otherwise: bb51]
  using: _122@Mir(bb50[3])
bb51:
  _128 = _7
  using: _7@Mir(bb0[3])
  _129 = const 0_u32
  using: 
  _127 = Eq(move _128, move _129)
  using: _128@Mir(bb51[0]), _129@Mir(bb51[1])
  switchInt(move _127) -> [0: bb52, otherwise: bb53]
  using: _127@Mir(bb51[2])
bb52:
  _126 = const false
  using: 
  goto -> bb54
  using: 
bb53:
  _131 = _8
  using: _8@Mir(bb0[4])
  _132 = const 0_u32
  using: 
  _130 = Eq(move _131, move _132)
  using: _131@Mir(bb53[0]), _132@Mir(bb53[1])
  _126 = move _130
  using: _130@Mir(bb53[2])
  goto -> bb54
  using: 
bb54:
  switchInt(move _126) -> [0: bb56, otherwise: bb55]
  using: _126@Phi(bb54)
bb55:
  _135 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _134 = (*_135)
  using: _135@Mir(bb55[0])
  _139 = const b" no data compressed.\n\x00"
  using: 
  _138 = &raw const (*_139)
  using: _139@Mir(bb55[2])
  _137 = move _138 as *const u8 (Pointer(ArrayToPointer))
  using: _138@Mir(bb55[3])
  _136 = move _137 as *const i8 (PtrToPtr)
  using: _137@Mir(bb55[4])
  _133 = bzip2::fprintf(move _134, move _136) -> bb67
  using: _134@Mir(bb55[1]), _136@Mir(bb55[5])
bb56:
  _140 = [const 0_i8; 32]
  using: 
  _141 = [const 0_i8; 32]
  using: 
  _143 = [const 0_u8; 8]
  using: 
  Deinit(_142)
  using: 
  (_142.0: [u8; 8]) = move _143
  using: _143@Mir(bb56[2])
  _145 = [const 0_u8; 8]
  using: 
  Deinit(_144)
  using: 
  (_144.0: [u8; 8]) = move _145
  using: _145@Mir(bb56[5])
  _146 = const 0f64
  using: 
  _147 = const 0f64
  using: 
  _150 = &mut _142
  using: _142@Mir(bb56[3])
  _149 = &raw mut (*_150)
  using: _150@Mir(bb56[10])
  _151 = _7
  using: _7@Mir(bb0[3])
  _152 = _8
  using: _8@Phi(bb54)
  _148 = bzip2::uInt64_from_UInt32s(move _149, move _151, move _152) -> bb57
  using: _149@Mir(bb56[11]), _151@Mir(bb56[12]), _152@Mir(bb56[13])
bb57:
  _155 = &mut _144
  using: _144@Mir(bb56[6])
  _154 = &raw mut (*_155)
  using: _155@Mir(bb57[0])
  _156 = _9
  using: _9@Mir(bb0[5])
  _157 = _10
  using: _10@Mir(bb0[6])
  _153 = bzip2::uInt64_from_UInt32s(move _154, move _156, move _157) -> bb58
  using: _154@Mir(bb57[1]), _156@Mir(bb57[2]), _157@Mir(bb57[3])
bb58:
  _160 = &mut _142
  using: _142@Mir(bb56[3])
  _159 = &raw mut (*_160)
  using: _160@Mir(bb58[0])
  _158 = bzip2::uInt64_to_double(move _159) -> bb59
  using: _159@Mir(bb58[1])
bb59:
  _146 = move _158
  using: _158@Mir(bb58[2])
  _163 = &mut _144
  using: _144@Mir(bb56[6])
  _162 = &raw mut (*_163)
  using: _163@Mir(bb59[1])
  _161 = bzip2::uInt64_to_double(move _162) -> bb60
  using: _162@Mir(bb59[2])
bb60:
  _147 = move _161
  using: _161@Mir(bb59[3])
  _167 = &mut _140
  using: _140@Mir(bb56[0])
  _166 = move _167 as &mut [i8] (Pointer(Unsize))
  using: _167@Mir(bb60[1])
  _165 = core::slice::<impl [i8]>::as_mut_ptr(move _166) -> bb61
  using: _166@Mir(bb60[2])
bb61:
  _169 = &mut _142
  using: _142@Mir(bb56[3])
  _168 = &raw mut (*_169)
  using: _169@Mir(bb61[0])
  _164 = bzip2::uInt64_toAscii(move _165, move _168) -> bb62
  using: _165@Mir(bb60[3]), _168@Mir(bb61[1])
bb62:
  _173 = &mut _141
  using: _141@Mir(bb56[1])
  _172 = move _173 as &mut [i8] (Pointer(Unsize))
  using: _173@Mir(bb62[0])
  _171 = core::slice::<impl [i8]>::as_mut_ptr(move _172) -> bb63
  using: _172@Mir(bb62[1])
bb63:
  _175 = &mut _144
  using: _144@Mir(bb56[6])
  _174 = &raw mut (*_175)
  using: _175@Mir(bb63[0])
  _170 = bzip2::uInt64_toAscii(move _171, move _174) -> bb64
  using: _171@Mir(bb62[2]), _174@Mir(bb63[1])
bb64:
  _178 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _177 = (*_178)
  using: _178@Mir(bb64[0])
  _182 = const b"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\n\x00"
  using: 
  _181 = &raw const (*_182)
  using: _182@Mir(bb64[2])
  _180 = move _181 as *const u8 (Pointer(ArrayToPointer))
  using: _181@Mir(bb64[3])
  _179 = move _180 as *const i8 (PtrToPtr)
  using: _180@Mir(bb64[4])
  _184 = _146
  using: _146@Mir(bb59[0])
  _185 = _147
  using: _147@Mir(bb60[0])
  _183 = Div(move _184, move _185)
  using: _184@Mir(bb64[6]), _185@Mir(bb64[7])
  _188 = _147
  using: _147@Mir(bb60[0])
  _187 = Mul(const 8f64, move _188)
  using: _188@Mir(bb64[9])
  _189 = _146
  using: _146@Mir(bb59[0])
  _186 = Div(move _187, move _189)
  using: _187@Mir(bb64[10]), _189@Mir(bb64[11])
  _193 = _147
  using: _147@Mir(bb60[0])
  _194 = _146
  using: _146@Mir(bb59[0])
  _192 = Div(move _193, move _194)
  using: _193@Mir(bb64[13]), _194@Mir(bb64[14])
  _191 = Sub(const 1f64, move _192)
  using: _192@Mir(bb64[15])
  _190 = Mul(const 100f64, move _191)
  using: _191@Mir(bb64[16])
  _197 = &mut _140
  using: _140@Mir(bb56[0])
  _196 = move _197 as &mut [i8] (Pointer(Unsize))
  using: _197@Mir(bb64[18])
  _195 = core::slice::<impl [i8]>::as_mut_ptr(move _196) -> bb65
  using: _196@Mir(bb64[19])
bb65:
  _200 = &mut _141
  using: _141@Mir(bb56[1])
  _199 = move _200 as &mut [i8] (Pointer(Unsize))
  using: _200@Mir(bb65[0])
  _198 = core::slice::<impl [i8]>::as_mut_ptr(move _199) -> bb66
  using: _199@Mir(bb65[1])
bb66:
  _176 = bzip2::fprintf(move _177, move _179, move _183, move _186, move _190, move _195, move _198) -> bb67
  using: _177@Mir(bb64[1]), _179@Mir(bb64[5]), _183@Mir(bb64[8]), _186@Mir(bb64[12]), _190@Mir(bb64[17]), _195@Mir(bb64[20]), _198@Mir(bb65[2])
bb67:
  return
  using: _0@Entry
bb68:
  switchInt(_3) -> [18225113528933273530: bb74, otherwise: bb69]
  using: _3@Phi(bb68)
bb69:
  _203 = &mut _12
  using: _12@Mir(bb0[8])
  _202 = &raw mut (*_203)
  using: _203@Mir(bb69[0])
  _204 = _4
  using: _4@Phi(bb68)
  _205 = const 1_i32
  using: 
  _207 = &mut _7
  using: _7@Phi(bb68)
  _206 = &raw mut (*_207)
  using: _207@Mir(bb69[4])
  _209 = &mut _8
  using: _8@Phi(bb68)
  _208 = &raw mut (*_209)
  using: _209@Mir(bb69[6])
  _211 = &mut _9
  using: _9@Phi(bb68)
  _210 = &raw mut (*_211)
  using: _211@Mir(bb69[8])
  _213 = &mut _10
  using: _10@Phi(bb68)
  _212 = &raw mut (*_213)
  using: _213@Mir(bb69[10])
  _201 = bzlib::BZ2_bzWriteClose64(move _202, move _204, move _205, move _206, move _208, move _210, move _212) -> bb70
  using: _202@Mir(bb69[1]), _204@Mir(bb69[2]), _205@Mir(bb69[3]), _206@Mir(bb69[5]), _208@Mir(bb69[7]), _210@Mir(bb69[9]), _212@Mir(bb69[11])
bb70:
  switchInt(_11) -> [4294967287: bb72, 4294967293: bb73, 4294967290: bb74, otherwise: bb71]
  using: _11@Phi(bb68)
bb71:
  _3 = const 4323399205346619401_u64
  using: 
  _220 = const b"compress:unexpected error\x00"
  using: 
  _219 = &raw const (*_220)
  using: _220@Mir(bb71[1])
  _218 = move _219 as *const u8 (Pointer(ArrayToPointer))
  using: _219@Mir(bb71[2])
  _217 = move _218 as *const i8 (PtrToPtr)
  using: _218@Mir(bb71[3])
  _216 = bzip2::panic(move _217)
  using: _217@Mir(bb71[4])
bb72:
  _3 = const 5122324059762049690_u64
  using: 
  _214 = bzip2::configError()
  using: 
bb73:
  _3 = const 2380987886157893679_u64
  using: 
  _215 = bzip2::outOfMemory()
  using: 
bb74:
  _221 = bzip2::ioError()
  using: 
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 5000] is not supported
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:463:10: 463:24 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:464:14: 464:29 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:472:21: 473:83 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:486:31: 486:61 (#0) by default
rewrite call bzip2::fread @ workspace/bzip2/rust/bzip2.rs:485:25: 487:92 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:489:24: 489:38 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:514:35: 514:50 (#0) by default
rewrite call bzip2::fflush @ workspace/bzip2/rust/bzip2.rs:517:35: 517:50 (#0) by default
rewrite call bzip2::fileno @ workspace/bzip2/rust/bzip2.rs:522:57: 522:72 (#0) by default
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:527:47: 527:62 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:546:44: 546:58 (#0) by default
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:550:51: 550:65 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:566:57: 571:97 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i8; 32] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i8; 32] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_142) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 8] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_144) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 8] is not supported
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:609:57: 627:87 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:192 ~ c2rust_lib[1043]::bzip2::uncompressStream)
bb0:
  _4 = const {0x0 as *mut std::ffi::c_void}
  using: 
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = [const 0_u8; 5000]
  using: 
  _12 = [const 0_u8; 5000]
  using: 
  _13 = const 0_i32
  using: 
  _14 = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: 
  _15 = const {0x0 as *mut u8}
  using: 
  _16 = const 0_i32
  using: 
  _13 = move _16
  using: _16@Mir(bb0[12])
  _9 = const 0_i32
  using: 
  _20 = _2
  using: _2@Entry
  _19 = bzip2::ferror(move _20) -> bb1
  using: _20@Mir(bb0[15])
bb1:
  _18 = Ne(move _19, const 0_i32)
  using: _19@Mir(bb0[16])
  _17 = Not(move _18)
  using: _18@Mir(bb1[0])
  switchInt(move _17) -> [0: bb118, otherwise: bb2]
  using: _17@Mir(bb1[1])
bb2:
  _24 = _1
  using: _1@Entry
  _23 = bzip2::ferror(move _24) -> bb3
  using: _24@Mir(bb2[0])
bb3:
  _22 = Ne(move _23, const 0_i32)
  using: _23@Mir(bb2[1])
  _21 = Not(move _22)
  using: _22@Mir(bb3[0])
  switchInt(move _21) -> [0: bb118, otherwise: bb4]
  using: _21@Mir(bb3[1])
bb4:
  _27 = &mut _5
  using: _5@Phi(bb4)
  _26 = &raw mut (*_27)
  using: _27@Mir(bb4[0])
  _28 = _1
  using: _1@Phi(bb4)
  _30 = const {alloc172: *mut i32}
  using: 
  _29 = (*_30)
  using: _30@Mir(bb4[3])
  _33 = const {alloc193: *mut u8}
  using: 
  _32 = (*_33)
  using: _33@Mir(bb4[5])
  _31 = move _32 as i32 (IntToInt)
  using: _32@Mir(bb4[6])
  _37 = &mut _12
  using: _12@Mir(bb0[8])
  _36 = move _37 as &mut [u8] (Pointer(Unsize))
  using: _37@Mir(bb4[8])
  _35 = core::slice::<impl [u8]>::as_mut_ptr(move _36) -> bb5
  using: _36@Mir(bb4[9])
bb5:
  _34 = move _35 as *mut std::ffi::c_void (PtrToPtr)
  using: _35@Mir(bb4[10])
  _38 = _13
  using: _13@Phi(bb4)
  _25 = bzlib::BZ2_bzReadOpen(move _26, move _28, move _29, move _31, move _34, move _38) -> bb6
  using: _26@Mir(bb4[1]), _28@Mir(bb4[2]), _29@Mir(bb4[4]), _31@Mir(bb4[7]), _34@Mir(bb5[0]), _38@Mir(bb5[1])
bb6:
  _4 = move _25
  using: _25@Mir(bb5[2])
  _41 = _4
  using: _4@Mir(bb6[0])
  _40 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _41) -> bb10
  using: _41@Mir(bb6[1])
bb7:
  _39 = const true
  using: 
  goto -> bb9
  using: 
bb8:
  _43 = _5
  using: _5@Phi(bb4)
  _44 = const 0_i32
  using: 
  _42 = Ne(move _43, move _44)
  using: _43@Mir(bb8[0]), _44@Mir(bb8[1])
  _39 = move _42
  using: _42@Mir(bb8[2])
  goto -> bb9
  using: 
bb9:
  switchInt(move _39) -> [0: bb12, otherwise: bb11]
  using: _39@Phi(bb9)
bb10:
  switchInt(move _40) -> [0: bb8, otherwise: bb7]
  using: _40@Mir(bb6[2])
bb11:
  _3 = const 673979509383251364_u64
  using: 
  goto -> bb52
  using: 
bb12:
  _45 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb4)
  assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb13
  using: _45@Entry, _9@Entry
bb13:
  _9 = move (_45.0: i32)
  using: _45@Mir(bb12[0])
  goto -> bb14
  using: 
bb14:
  _47 = _5
  using: _5@Phi(bb14)
  _48 = const 0_i32
  using: 
  _46 = Eq(move _47, move _48)
  using: _47@Mir(bb14[0]), _48@Mir(bb14[1])
  switchInt(move _46) -> [0: bb32, otherwise: bb15]
  using: _46@Mir(bb14[2])
bb15:
  _51 = &mut _5
  using: _5@Phi(bb14)
  _50 = &raw mut (*_51)
  using: _51@Mir(bb15[0])
  _52 = _4
  using: _4@Phi(bb14)
  _56 = &mut _11
  using: _11@Phi(bb14)
  _55 = move _56 as &mut [u8] (Pointer(Unsize))
  using: _56@Mir(bb15[3])
  _54 = core::slice::<impl [u8]>::as_mut_ptr(move _55) -> bb16
  using: _55@Mir(bb15[4])
bb16:
  _53 = move _54 as *mut std::ffi::c_void (PtrToPtr)
  using: _54@Mir(bb15[5])
  _57 = const 5000_i32
  using: 
  _49 = bzlib::BZ2_bzRead(move _50, move _52, move _53, move _57) -> bb17
  using: _50@Mir(bb15[1]), _52@Mir(bb15[2]), _53@Mir(bb16[0]), _57@Mir(bb16[1])
bb17:
  _8 = move _49
  using: _49@Mir(bb16[2])
  _59 = _5
  using: _5@Phi(bb14)
  _60 = const -5_i32
  using: 
  _58 = Eq(move _59, move _60)
  using: _59@Mir(bb17[1]), _60@Mir(bb17[2])
  switchInt(move _58) -> [0: bb19, otherwise: bb18]
  using: _58@Mir(bb17[3])
bb18:
  _3 = const 18063049917807660484_u64
  using: 
  goto -> bb52
  using: 
bb19:
  _64 = _5
  using: _5@Phi(bb14)
  _65 = const 0_i32
  using: 
  _63 = Eq(move _64, move _65)
  using: _64@Mir(bb19[0]), _65@Mir(bb19[1])
  switchInt(move _63) -> [0: bb24, otherwise: bb23]
  using: _63@Mir(bb19[2])
bb20:
  _61 = const false
  using: 
  goto -> bb22
  using: 
bb21:
  _70 = _8
  using: _8@Mir(bb17[0])
  _71 = const 0_i32
  using: 
  _69 = Gt(move _70, move _71)
  using: _70@Mir(bb21[0]), _71@Mir(bb21[1])
  _61 = move _69
  using: _69@Mir(bb21[2])
  goto -> bb22
  using: 
bb22:
  switchInt(move _61) -> [0: bb29, otherwise: bb26]
  using: _61@Phi(bb22)
bb23:
  _62 = const true
  using: 
  goto -> bb25
  using: 
bb24:
  _67 = _5
  using: _5@Phi(bb14)
  _68 = const 4_i32
  using: 
  _66 = Eq(move _67, move _68)
  using: _67@Mir(bb24[0]), _68@Mir(bb24[1])
  _62 = move _66
  using: _66@Mir(bb24[2])
  goto -> bb25
  using: 
bb25:
  switchInt(move _62) -> [0: bb20, otherwise: bb21]
  using: _62@Phi(bb25)
bb26:
  _76 = &mut _11
  using: _11@Phi(bb14)
  _75 = move _76 as &mut [u8] (Pointer(Unsize))
  using: _76@Mir(bb26[0])
  _74 = core::slice::<impl [u8]>::as_mut_ptr(move _75) -> bb27
  using: _75@Mir(bb26[1])
bb27:
  _73 = move _74 as *const std::ffi::c_void (PtrToPtr)
  using: _74@Mir(bb26[2])
  _78 = std::mem::size_of::<u8>() -> bb28
  using: 
bb28:
  _77 = move _78 as u64 (IntToInt)
  using: _78@Mir(bb27[1])
  _80 = _8
  using: _8@Phi(bb22)
  _79 = move _80 as u64 (IntToInt)
  using: _80@Mir(bb28[1])
  _81 = _2
  using: _2@Phi(bb14)
  _72 = bzip2::fwrite(move _73, move _77, move _79, move _81) -> bb29
  using: _73@Mir(bb27[0]), _77@Mir(bb28[0]), _79@Mir(bb28[2]), _81@Mir(bb28[3])
bb29:
  _83 = _2
  using: _2@Phi(bb29)
  _82 = bzip2::ferror(move _83) -> bb30
  using: _83@Mir(bb29[0])
bb30:
  switchInt(move _82) -> [0: bb14, otherwise: bb31]
  using: _82@Mir(bb29[1])
bb31:
  _3 = const 5049394217699438129_u64
  using: 
  goto -> bb52
  using: 
bb32:
  _85 = _5
  using: _5@Phi(bb25)
  _86 = const 4_i32
  using: 
  _84 = Ne(move _85, move _86)
  using: _85@Mir(bb32[0]), _86@Mir(bb32[1])
  switchInt(move _84) -> [0: bb34, otherwise: bb33]
  using: _84@Mir(bb32[2])
bb33:
  _3 = const 673979509383251364_u64
  using: 
  goto -> bb52
  using: 
bb34:
  _89 = &mut _5
  using: _5@Phi(bb25)
  _88 = &raw mut (*_89)
  using: _89@Mir(bb34[0])
  _90 = _4
  using: _4@Phi(bb14)
  _92 = &mut _14
  using: _14@Phi(bb4)
  _91 = &raw mut (*_92)
  using: _92@Mir(bb34[3])
  _94 = &mut _13
  using: _13@Phi(bb4)
  _93 = &raw mut (*_94)
  using: _94@Mir(bb34[5])
  _87 = bzlib::BZ2_bzReadGetUnused(move _88, move _90, move _91, move _93) -> bb35
  using: _88@Mir(bb34[1]), _90@Mir(bb34[2]), _91@Mir(bb34[4]), _93@Mir(bb34[6])
bb35:
  _96 = _5
  using: _5@Phi(bb25)
  _97 = const 0_i32
  using: 
  _95 = Ne(move _96, move _97)
  using: _96@Mir(bb35[0]), _97@Mir(bb35[1])
  switchInt(move _95) -> [0: bb37, otherwise: bb36]
  using: _95@Mir(bb35[2])
bb36:
  _102 = const b"decompress:bzReadGetUnused\x00"
  using: 
  _101 = &raw const (*_102)
  using: _102@Mir(bb36[0])
  _100 = move _101 as *const u8 (Pointer(ArrayToPointer))
  using: _101@Mir(bb36[1])
  _99 = move _100 as *const i8 (PtrToPtr)
  using: _100@Mir(bb36[2])
  _98 = bzip2::panic(move _99)
  using: _99@Mir(bb36[3])
bb37:
  _103 = _14
  using: _14@Phi(bb4)
  _15 = move _103 as *mut u8 (PtrToPtr)
  using: _103@Mir(bb37[0])
  _10 = const 0_i32
  using: 
  goto -> bb38
  using: 
bb38:
  _105 = _10
  using: _10@Phi(bb38)
  _106 = _13
  using: _13@Phi(bb4)
  _104 = Lt(move _105, move _106)
  using: _105@Mir(bb38[0]), _106@Mir(bb38[1])
  switchInt(move _104) -> [0: bb43, otherwise: bb39]
  using: _104@Mir(bb38[2])
bb39:
  _109 = _15
  using: _15@Phi(bb38)
  _111 = _10
  using: _10@Phi(bb38)
  _110 = move _111 as isize (IntToInt)
  using: _111@Mir(bb39[1])
  _108 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _109, move _110) -> bb40
  using: _109@Mir(bb39[0]), _110@Mir(bb39[2])
bb40:
  _107 = (*_108)
  using: _108@Mir(bb39[3])
  _113 = _10
  using: _10@Phi(bb38)
  _112 = move _113 as usize (IntToInt)
  using: _113@Mir(bb40[1])
  _114 = const 5000_usize
  using: 
  _115 = Lt(_112, _114)
  using: _112@Mir(bb40[2]), _114@Mir(bb40[3])
  assert(move _115, "index out of bounds: the length is {} but the index is {}", move _114, _112) -> bb41
  using: _115@Entry, _114@Entry, _112@Entry
bb41:
  _12[_112] = move _107
  using: _112@Mir(bb40[2]), _107@Mir(bb40[0])
  _116 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb38)
  assert(!move (_116.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb42
  using: _116@Entry, _10@Entry
bb42:
  _10 = move (_116.0: i32)
  using: _116@Mir(bb41[1])
  goto -> bb38
  using: 
bb43:
  _119 = &mut _5
  using: _5@Phi(bb25)
  _118 = &raw mut (*_119)
  using: _119@Mir(bb43[0])
  _120 = _4
  using: _4@Phi(bb14)
  _117 = bzlib::BZ2_bzReadClose(move _118, move _120) -> bb44
  using: _118@Mir(bb43[1]), _120@Mir(bb43[2])
bb44:
  _122 = _5
  using: _5@Phi(bb25)
  _123 = const 0_i32
  using: 
  _121 = Ne(move _122, move _123)
  using: _122@Mir(bb44[0]), _123@Mir(bb44[1])
  switchInt(move _121) -> [0: bb46, otherwise: bb45]
  using: _121@Mir(bb44[2])
bb45:
  _128 = const b"decompress:bzReadGetUnused\x00"
  using: 
  _127 = &raw const (*_128)
  using: _128@Mir(bb45[0])
  _126 = move _127 as *const u8 (Pointer(ArrayToPointer))
  using: _127@Mir(bb45[1])
  _125 = move _126 as *const i8 (PtrToPtr)
  using: _126@Mir(bb45[2])
  _124 = bzip2::panic(move _125)
  using: _125@Mir(bb45[3])
bb46:
  _131 = _13
  using: _13@Phi(bb4)
  _132 = const 0_i32
  using: 
  _130 = Eq(move _131, move _132)
  using: _131@Mir(bb46[0]), _132@Mir(bb46[1])
  switchInt(move _130) -> [0: bb47, otherwise: bb48]
  using: _130@Mir(bb46[2])
bb47:
  _129 = const false
  using: 
  goto -> bb49
  using: 
bb48:
  _136 = _1
  using: _1@Phi(bb4)
  _135 = bzip2::myfeof(move _136) -> bb50
  using: _136@Mir(bb48[0])
bb49:
  switchInt(move _129) -> [0: bb4, otherwise: bb51]
  using: _129@Phi(bb49)
bb50:
  _134 = move _135 as i32 (IntToInt)
  using: _135@Mir(bb48[1])
  _133 = Ne(move _134, const 0_i32)
  using: _134@Mir(bb50[0])
  _129 = move _133
  using: _133@Mir(bb50[1])
  goto -> bb49
  using: 
bb51:
  _3 = const 926243229934402080_u64
  using: 
  goto -> bb52
  using: 
bb52:
  switchInt(_3) -> [5049394217699438129: bb118, otherwise: bb53]
  using: _3@Phi(bb52)
bb53:
  switchInt(_3) -> [18063049917807660484: bb54, otherwise: bb73]
  using: _3@Phi(bb52)
bb54:
  _138 = const {alloc194: *mut u8}
  using: 
  _137 = (*_138)
  using: _138@Mir(bb54[0])
  switchInt(move _137) -> [0: bb72, otherwise: bb55]
  using: _137@Mir(bb54[1])
bb55:
  _140 = _1
  using: _1@Phi(bb52)
  _139 = bzip2::rewind(move _140) -> bb56
  using: _140@Mir(bb55[0])
bb56:
  _142 = _1
  using: _1@Phi(bb56)
  _141 = bzip2::myfeof(move _142) -> bb57
  using: _142@Mir(bb56[0])
bb57:
  switchInt(move _141) -> [0: bb59, otherwise: bb58]
  using: _141@Mir(bb56[1])
bb58:
  _3 = const 926243229934402080_u64
  using: 
  goto -> bb73
  using: 
bb59:
  _147 = &mut _11
  using: _11@Phi(bb56)
  _146 = move _147 as &mut [u8] (Pointer(Unsize))
  using: _147@Mir(bb59[0])
  _145 = core::slice::<impl [u8]>::as_mut_ptr(move _146) -> bb60
  using: _146@Mir(bb59[1])
bb60:
  _144 = move _145 as *mut std::ffi::c_void (PtrToPtr)
  using: _145@Mir(bb59[2])
  _149 = std::mem::size_of::<u8>() -> bb61
  using: 
bb61:
  _148 = move _149 as u64 (IntToInt)
  using: _149@Mir(bb60[1])
  _150 = const 5000_u64
  using: 
  _151 = _1
  using: _1@Phi(bb56)
  _143 = bzip2::fread(move _144, move _148, move _150, move _151) -> bb62
  using: _144@Mir(bb60[0]), _148@Mir(bb61[0]), _150@Mir(bb61[1]), _151@Mir(bb61[2])
bb62:
  _8 = move _143 as i32 (IntToInt)
  using: _143@Mir(bb61[3])
  _153 = _1
  using: _1@Phi(bb56)
  _152 = bzip2::ferror(move _153) -> bb63
  using: _153@Mir(bb62[1])
bb63:
  switchInt(move _152) -> [0: bb65, otherwise: bb64]
  using: _152@Mir(bb62[2])
bb64:
  _3 = const 5049394217699438129_u64
  using: 
  goto -> bb73
  using: 
bb65:
  _155 = _8
  using: _8@Mir(bb62[0])
  _156 = const 0_i32
  using: 
  _154 = Gt(move _155, move _156)
  using: _155@Mir(bb65[0]), _156@Mir(bb65[1])
  switchInt(move _154) -> [0: bb69, otherwise: bb66]
  using: _154@Mir(bb65[2])
bb66:
  _161 = &mut _11
  using: _11@Phi(bb56)
  _160 = move _161 as &mut [u8] (Pointer(Unsize))
  using: _161@Mir(bb66[0])
  _159 = core::slice::<impl [u8]>::as_mut_ptr(move _160) -> bb67
  using: _160@Mir(bb66[1])
bb67:
  _158 = move _159 as *const std::ffi::c_void (PtrToPtr)
  using: _159@Mir(bb66[2])
  _163 = std::mem::size_of::<u8>() -> bb68
  using: 
bb68:
  _162 = move _163 as u64 (IntToInt)
  using: _163@Mir(bb67[1])
  _165 = _8
  using: _8@Mir(bb62[0])
  _164 = move _165 as u64 (IntToInt)
  using: _165@Mir(bb68[1])
  _166 = _2
  using: _2@Phi(bb56)
  _157 = bzip2::fwrite(move _158, move _162, move _164, move _166) -> bb69
  using: _158@Mir(bb67[0]), _162@Mir(bb68[0]), _164@Mir(bb68[2]), _166@Mir(bb68[3])
bb69:
  _168 = _2
  using: _2@Phi(bb69)
  _167 = bzip2::ferror(move _168) -> bb70
  using: _168@Mir(bb69[0])
bb70:
  switchInt(move _167) -> [0: bb56, otherwise: bb71]
  using: _167@Mir(bb69[1])
bb71:
  _3 = const 5049394217699438129_u64
  using: 
  goto -> bb73
  using: 
bb72:
  _3 = const 673979509383251364_u64
  using: 
  goto -> bb73
  using: 
bb73:
  switchInt(_3) -> [5049394217699438129: bb118, otherwise: bb74]
  using: _3@Phi(bb73)
bb74:
  switchInt(_3) -> [673979509383251364: bb76, otherwise: bb75]
  using: _3@Phi(bb73)
bb75:
  _215 = _1
  using: _1@Phi(bb73)
  _214 = bzip2::ferror(move _215) -> bb93
  using: _215@Mir(bb75[0])
bb76:
  _171 = &mut _6
  using: _6@Mir(bb0[2])
  _170 = &raw mut (*_171)
  using: _171@Mir(bb76[0])
  _172 = _4
  using: _4@Phi(bb52)
  _169 = bzlib::BZ2_bzReadClose(move _170, move _172) -> bb77
  using: _170@Mir(bb76[1]), _172@Mir(bb76[2])
bb77:
  switchInt(_5) -> [4294967287: bb79, 4294967290: bb118, 4294967292: bb80, 4294967293: bb81, 4294967289: bb82, 4294967291: bb83, otherwise: bb78]
  using: _5@Phi(bb52)
bb78:
  _3 = const 6455255476181645667_u64
  using: 
  _211 = const b"decompress:unexpected error\x00"
  using: 
  _210 = &raw const (*_211)
  using: _211@Mir(bb78[1])
  _209 = move _210 as *const u8 (Pointer(ArrayToPointer))
  using: _210@Mir(bb78[2])
  _208 = move _209 as *const i8 (PtrToPtr)
  using: _209@Mir(bb78[3])
  _207 = bzip2::panic(move _208)
  using: _208@Mir(bb78[4])
bb79:
  _3 = const 3642457097893642164_u64
  using: 
  _173 = bzip2::configError()
  using: 
bb80:
  _3 = const 10766414566319669440_u64
  using: 
  _174 = bzip2::crcError()
  using: 
bb81:
  _3 = const 16178635849926953562_u64
  using: 
  _175 = bzip2::outOfMemory()
  using: 
bb82:
  _3 = const 5517467152645906530_u64
  using: 
  _176 = bzip2::compressedStreamEOF()
  using: 
bb83:
  _3 = const 7372986856480808103_u64
  using: 
  _178 = _1
  using: _1@Phi(bb73)
  _180 = const {alloc195: *mut *mut blocksort::__sFILE}
  using: 
  _179 = (*_180)
  using: _180@Mir(bb83[2])
  _177 = Ne(move _178, move _179)
  using: _178@Mir(bb83[1]), _179@Mir(bb83[3])
  switchInt(move _177) -> [0: bb85, otherwise: bb84]
  using: _177@Mir(bb83[4])
bb84:
  _182 = _1
  using: _1@Phi(bb73)
  _181 = bzip2::fclose(move _182) -> bb85
  using: _182@Mir(bb84[0])
bb85:
  _184 = _2
  using: _2@Phi(bb114)
  _186 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _185 = (*_186)
  using: _186@Mir(bb85[1])
  _183 = Ne(move _184, move _185)
  using: _184@Mir(bb85[0]), _185@Mir(bb85[2])
  switchInt(move _183) -> [0: bb87, otherwise: bb86]
  using: _183@Mir(bb85[3])
bb86:
  _188 = _2
  using: _2@Phi(bb114)
  _187 = bzip2::fclose(move _188) -> bb87
  using: _188@Mir(bb86[0])
bb87:
  _190 = _9
  using: _9@Phi(bb52)
  _191 = const 1_i32
  using: 
  _189 = Eq(move _190, move _191)
  using: _190@Mir(bb87[0]), _191@Mir(bb87[1])
  switchInt(move _189) -> [0: bb89, otherwise: bb88]
  using: _189@Mir(bb87[2])
bb88:
  _0 = const 0_u8
  using: 
  goto -> bb119
  using: 
bb89:
  _193 = const {alloc196: *mut u8}
  using: 
  _192 = (*_193)
  using: _193@Mir(bb89[0])
  switchInt(move _192) -> [0: bb92, otherwise: bb90]
  using: _192@Mir(bb89[1])
bb90:
  _196 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _195 = (*_196)
  using: _196@Mir(bb90[0])
  _200 = const b"\n%s: %s: trailing garbage after EOF ignored\n\x00"
  using: 
  _199 = &raw const (*_200)
  using: _200@Mir(bb90[2])
  _198 = move _199 as *const u8 (Pointer(ArrayToPointer))
  using: _199@Mir(bb90[3])
  _197 = move _198 as *const i8 (PtrToPtr)
  using: _198@Mir(bb90[4])
  _202 = const {alloc197: *mut *mut i8}
  using: 
  _201 = (*_202)
  using: _202@Mir(bb90[6])
  _206 = const {alloc198: *mut [i8; 1034]}
  using: 
  _205 = &mut (*_206)
  using: _206@Mir(bb90[8])
  _204 = move _205 as &mut [i8] (Pointer(Unsize))
  using: _205@Mir(bb90[9])
  _203 = core::slice::<impl [i8]>::as_mut_ptr(move _204) -> bb91
  using: _204@Mir(bb90[10])
bb91:
  _194 = bzip2::fprintf(move _195, move _197, move _201, move _203) -> bb92
  using: _195@Mir(bb90[1]), _197@Mir(bb90[5]), _201@Mir(bb90[7]), _203@Mir(bb90[11])
bb92:
  _0 = const 1_u8
  using: 
  goto -> bb119
  using: 
bb93:
  _213 = Ne(move _214, const 0_i32)
  using: _214@Mir(bb75[1])
  _212 = Not(move _213)
  using: _213@Mir(bb93[0])
  switchInt(move _212) -> [0: bb118, otherwise: bb94]
  using: _212@Mir(bb93[1])
bb94:
  _217 = _2
  using: _2@Phi(bb73)
  _219 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _218 = (*_219)
  using: _219@Mir(bb94[1])
  _216 = Ne(move _217, move _218)
  using: _217@Mir(bb94[0]), _218@Mir(bb94[2])
  switchInt(move _216) -> [0: bb100, otherwise: bb95]
  using: _216@Mir(bb94[3])
bb95:
  _221 = _2
  using: _2@Phi(bb73)
  _220 = bzip2::fileno(move _221) -> bb96
  using: _221@Mir(bb95[0])
bb96:
  _223 = _220
  using: _220@Mir(bb95[1])
  _224 = const 0_i32
  using: 
  _222 = Lt(move _223, move _224)
  using: _223@Mir(bb96[0]), _224@Mir(bb96[1])
  switchInt(move _222) -> [0: bb98, otherwise: bb97]
  using: _222@Mir(bb96[2])
bb97:
  _3 = const 5049394217699438129_u64
  using: 
  goto -> bb101
  using: 
bb98:
  _226 = _220
  using: _220@Mir(bb95[1])
  _225 = bzip2::applySavedFileAttrToOutputFile(move _226) -> bb99
  using: _226@Mir(bb98[0])
bb99:
  _3 = const 14832935472441733737_u64
  using: 
  goto -> bb101
  using: 
bb100:
  _3 = const 14832935472441733737_u64
  using: 
  goto -> bb101
  using: 
bb101:
  switchInt(_3) -> [5049394217699438129: bb118, otherwise: bb102]
  using: _3@Phi(bb101)
bb102:
  _228 = _1
  using: _1@Phi(bb73)
  _227 = bzip2::fclose(move _228) -> bb103
  using: _228@Mir(bb102[0])
bb103:
  _7 = move _227
  using: _227@Mir(bb102[1])
  _231 = _7
  using: _7@Mir(bb103[0])
  _232 = const -1_i32
  using: 
  _230 = Eq(move _231, move _232)
  using: _231@Mir(bb103[1]), _232@Mir(bb103[2])
  _229 = Not(move _230)
  using: _230@Mir(bb103[3])
  switchInt(move _229) -> [0: bb118, otherwise: bb104]
  using: _229@Mir(bb103[4])
bb104:
  _236 = _2
  using: _2@Phi(bb101)
  _235 = bzip2::ferror(move _236) -> bb105
  using: _236@Mir(bb104[0])
bb105:
  _234 = Ne(move _235, const 0_i32)
  using: _235@Mir(bb104[1])
  _233 = Not(move _234)
  using: _234@Mir(bb105[0])
  switchInt(move _233) -> [0: bb118, otherwise: bb106]
  using: _233@Mir(bb105[1])
bb106:
  _238 = _2
  using: _2@Phi(bb101)
  _237 = bzip2::fflush(move _238) -> bb107
  using: _238@Mir(bb106[0])
bb107:
  _7 = move _237
  using: _237@Mir(bb106[1])
  _241 = _7
  using: _7@Mir(bb107[0])
  _242 = const 0_i32
  using: 
  _240 = Ne(move _241, move _242)
  using: _241@Mir(bb107[1]), _242@Mir(bb107[2])
  _239 = Not(move _240)
  using: _240@Mir(bb107[3])
  switchInt(move _239) -> [0: bb118, otherwise: bb108]
  using: _239@Mir(bb107[4])
bb108:
  _244 = _2
  using: _2@Phi(bb101)
  _246 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _245 = (*_246)
  using: _246@Mir(bb108[1])
  _243 = Ne(move _244, move _245)
  using: _244@Mir(bb108[0]), _245@Mir(bb108[2])
  switchInt(move _243) -> [0: bb113, otherwise: bb109]
  using: _243@Mir(bb108[3])
bb109:
  _248 = _2
  using: _2@Phi(bb101)
  _247 = bzip2::fclose(move _248) -> bb110
  using: _248@Mir(bb109[0])
bb110:
  _7 = move _247
  using: _247@Mir(bb109[1])
  _249 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_249) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _249@Mir(bb110[1])
  _251 = _7
  using: _7@Mir(bb110[0])
  _252 = const -1_i32
  using: 
  _250 = Eq(move _251, move _252)
  using: _251@Mir(bb110[3]), _252@Mir(bb110[4])
  switchInt(move _250) -> [0: bb112, otherwise: bb111]
  using: _250@Mir(bb110[5])
bb111:
  _3 = const 5049394217699438129_u64
  using: 
  goto -> bb114
  using: 
bb112:
  _3 = const 14775119014532381840_u64
  using: 
  goto -> bb114
  using: 
bb113:
  _3 = const 14775119014532381840_u64
  using: 
  goto -> bb114
  using: 
bb114:
  switchInt(_3) -> [5049394217699438129: bb118, otherwise: bb115]
  using: _3@Phi(bb114)
bb115:
  _253 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_253) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _253@Mir(bb115[0])
  _256 = const {alloc172: *mut i32}
  using: 
  _255 = (*_256)
  using: _256@Mir(bb115[2])
  _257 = const 2_i32
  using: 
  _254 = Ge(move _255, move _257)
  using: _255@Mir(bb115[3]), _257@Mir(bb115[4])
  switchInt(move _254) -> [0: bb117, otherwise: bb116]
  using: _254@Mir(bb115[5])
bb116:
  _260 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _259 = (*_260)
  using: _260@Mir(bb116[0])
  _264 = const b"\n    \x00"
  using: 
  _263 = &raw const (*_264)
  using: _264@Mir(bb116[2])
  _262 = move _263 as *const u8 (Pointer(ArrayToPointer))
  using: _263@Mir(bb116[3])
  _261 = move _262 as *const i8 (PtrToPtr)
  using: _262@Mir(bb116[4])
  _258 = bzip2::fprintf(move _259, move _261) -> bb117
  using: _259@Mir(bb116[1]), _261@Mir(bb116[5])
bb117:
  _0 = const 1_u8
  using: 
  goto -> bb119
  using: 
bb118:
  _265 = bzip2::ioError()
  using: 
bb119:
  return
  using: _0@Phi(bb119)
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 5000] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 5000] is not supported
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:712:10: 712:24 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:713:14: 713:29 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:743:36: 743:66 (#0) by default
rewrite call bzip2::fwrite @ workspace/bzip2/rust/bzip2.rs:742:29: 745:43 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:747:28: 747:42 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:765:57: 765:75 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::rewind @ workspace/bzip2/rust/bzip2.rs:785:33: 785:48 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:798:47: 798:77 (#0) by default
rewrite call bzip2::fread @ workspace/bzip2/rust/bzip2.rs:796:41: 801:82 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:803:40: 803:55 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:810:48: 810:78 (#0) by default
rewrite call bzip2::fwrite @ workspace/bzip2/rust/bzip2.rs:808:41: 813:55 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:815:40: 815:54 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:1141:42: 1141:57 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1059:57: 1059:72 (#0) by default
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1062:57: 1062:71 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1071:61: 1078:89 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fileno @ workspace/bzip2/rust/bzip2.rs:1144:49: 1144:63 (#0) by default
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1160:55: 1160:70 (#0) by default
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:1164:58: 1164:72 (#0) by default
rewrite call bzip2::fflush @ workspace/bzip2/rust/bzip2.rs:1166:63: 1166:77 (#0) by default
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1174:69: 1174:83 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1212:73: 1217:113 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:197 ~ c2rust_lib[1043]::bzip2::testStream)
bb0:
  _3 = const {0x0 as *mut std::ffi::c_void}
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _9 = [const 0_u8; 5000]
  using: 
  _10 = [const 0_u8; 5000]
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: 
  _13 = const {0x0 as *mut u8}
  using: 
  _14 = const 0_i32
  using: 
  _11 = move _14
  using: _14@Mir(bb0[11])
  _7 = const 0_i32
  using: 
  _18 = _1
  using: _1@Entry
  _17 = bzip2::ferror(move _18) -> bb1
  using: _18@Mir(bb0[14])
bb1:
  _16 = Ne(move _17, const 0_i32)
  using: _17@Mir(bb0[15])
  _15 = Not(move _16)
  using: _16@Mir(bb1[0])
  switchInt(move _15) -> [0: bb65, otherwise: bb2]
  using: _15@Mir(bb1[1])
bb2:
  _21 = &mut _4
  using: _4@Phi(bb2)
  _20 = &raw mut (*_21)
  using: _21@Mir(bb2[0])
  _22 = _1
  using: _1@Phi(bb2)
  _24 = const {alloc172: *mut i32}
  using: 
  _23 = (*_24)
  using: _24@Mir(bb2[3])
  _27 = const {alloc193: *mut u8}
  using: 
  _26 = (*_27)
  using: _27@Mir(bb2[5])
  _25 = move _26 as i32 (IntToInt)
  using: _26@Mir(bb2[6])
  _31 = &mut _10
  using: _10@Mir(bb0[7])
  _30 = move _31 as &mut [u8] (Pointer(Unsize))
  using: _31@Mir(bb2[8])
  _29 = core::slice::<impl [u8]>::as_mut_ptr(move _30) -> bb3
  using: _30@Mir(bb2[9])
bb3:
  _28 = move _29 as *mut std::ffi::c_void (PtrToPtr)
  using: _29@Mir(bb2[10])
  _32 = _11
  using: _11@Phi(bb2)
  _19 = bzlib::BZ2_bzReadOpen(move _20, move _22, move _23, move _25, move _28, move _32) -> bb4
  using: _20@Mir(bb2[1]), _22@Mir(bb2[2]), _23@Mir(bb2[4]), _25@Mir(bb2[7]), _28@Mir(bb3[0]), _32@Mir(bb3[1])
bb4:
  _3 = move _19
  using: _19@Mir(bb3[2])
  _35 = _3
  using: _3@Mir(bb4[0])
  _34 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _35) -> bb8
  using: _35@Mir(bb4[1])
bb5:
  _33 = const true
  using: 
  goto -> bb7
  using: 
bb6:
  _37 = _4
  using: _4@Phi(bb2)
  _38 = const 0_i32
  using: 
  _36 = Ne(move _37, move _38)
  using: _37@Mir(bb6[0]), _38@Mir(bb6[1])
  _33 = move _36
  using: _36@Mir(bb6[2])
  goto -> bb7
  using: 
bb7:
  switchInt(move _33) -> [0: bb10, otherwise: bb9]
  using: _33@Phi(bb7)
bb8:
  switchInt(move _34) -> [0: bb6, otherwise: bb5]
  using: _34@Mir(bb4[2])
bb9:
  _2 = const 10905486111603547446_u64
  using: 
  goto -> bb37
  using: 
bb10:
  _39 = CheckedAdd(_7, const 1_i32)
  using: _7@Phi(bb2)
  assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> bb11
  using: _39@Entry, _7@Entry
bb11:
  _7 = move (_39.0: i32)
  using: _39@Mir(bb10[0])
  goto -> bb12
  using: 
bb12:
  _41 = _4
  using: _4@Phi(bb12)
  _42 = const 0_i32
  using: 
  _40 = Eq(move _41, move _42)
  using: _41@Mir(bb12[0]), _42@Mir(bb12[1])
  switchInt(move _40) -> [0: bb17, otherwise: bb13]
  using: _40@Mir(bb12[2])
bb13:
  _45 = &mut _4
  using: _4@Phi(bb12)
  _44 = &raw mut (*_45)
  using: _45@Mir(bb13[0])
  _46 = _3
  using: _3@Phi(bb12)
  _50 = &mut _9
  using: _9@Phi(bb12)
  _49 = move _50 as &mut [u8] (Pointer(Unsize))
  using: _50@Mir(bb13[3])
  _48 = core::slice::<impl [u8]>::as_mut_ptr(move _49) -> bb14
  using: _49@Mir(bb13[4])
bb14:
  _47 = move _48 as *mut std::ffi::c_void (PtrToPtr)
  using: _48@Mir(bb13[5])
  _51 = const 5000_i32
  using: 
  _43 = bzlib::BZ2_bzRead(move _44, move _46, move _47, move _51) -> bb15
  using: _44@Mir(bb13[1]), _46@Mir(bb13[2]), _47@Mir(bb14[0]), _51@Mir(bb14[1])
bb15:
  _53 = _4
  using: _4@Phi(bb12)
  _54 = const -5_i32
  using: 
  _52 = Eq(move _53, move _54)
  using: _53@Mir(bb15[0]), _54@Mir(bb15[1])
  switchInt(move _52) -> [0: bb12, otherwise: bb16]
  using: _52@Mir(bb15[2])
bb16:
  _2 = const 10905486111603547446_u64
  using: 
  goto -> bb37
  using: 
bb17:
  _56 = _4
  using: _4@Phi(bb12)
  _57 = const 4_i32
  using: 
  _55 = Ne(move _56, move _57)
  using: _56@Mir(bb17[0]), _57@Mir(bb17[1])
  switchInt(move _55) -> [0: bb19, otherwise: bb18]
  using: _55@Mir(bb17[2])
bb18:
  _2 = const 10905486111603547446_u64
  using: 
  goto -> bb37
  using: 
bb19:
  _60 = &mut _4
  using: _4@Phi(bb12)
  _59 = &raw mut (*_60)
  using: _60@Mir(bb19[0])
  _61 = _3
  using: _3@Phi(bb12)
  _63 = &mut _12
  using: _12@Phi(bb2)
  _62 = &raw mut (*_63)
  using: _63@Mir(bb19[3])
  _65 = &mut _11
  using: _11@Phi(bb2)
  _64 = &raw mut (*_65)
  using: _65@Mir(bb19[5])
  _58 = bzlib::BZ2_bzReadGetUnused(move _59, move _61, move _62, move _64) -> bb20
  using: _59@Mir(bb19[1]), _61@Mir(bb19[2]), _62@Mir(bb19[4]), _64@Mir(bb19[6])
bb20:
  _67 = _4
  using: _4@Phi(bb12)
  _68 = const 0_i32
  using: 
  _66 = Ne(move _67, move _68)
  using: _67@Mir(bb20[0]), _68@Mir(bb20[1])
  switchInt(move _66) -> [0: bb22, otherwise: bb21]
  using: _66@Mir(bb20[2])
bb21:
  _73 = const b"test:bzReadGetUnused\x00"
  using: 
  _72 = &raw const (*_73)
  using: _73@Mir(bb21[0])
  _71 = move _72 as *const u8 (Pointer(ArrayToPointer))
  using: _72@Mir(bb21[1])
  _70 = move _71 as *const i8 (PtrToPtr)
  using: _71@Mir(bb21[2])
  _69 = bzip2::panic(move _70)
  using: _70@Mir(bb21[3])
bb22:
  _74 = _12
  using: _12@Phi(bb2)
  _13 = move _74 as *mut u8 (PtrToPtr)
  using: _74@Mir(bb22[0])
  _8 = const 0_i32
  using: 
  goto -> bb23
  using: 
bb23:
  _76 = _8
  using: _8@Phi(bb23)
  _77 = _11
  using: _11@Phi(bb2)
  _75 = Lt(move _76, move _77)
  using: _76@Mir(bb23[0]), _77@Mir(bb23[1])
  switchInt(move _75) -> [0: bb28, otherwise: bb24]
  using: _75@Mir(bb23[2])
bb24:
  _80 = _13
  using: _13@Phi(bb23)
  _82 = _8
  using: _8@Phi(bb23)
  _81 = move _82 as isize (IntToInt)
  using: _82@Mir(bb24[1])
  _79 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _80, move _81) -> bb25
  using: _80@Mir(bb24[0]), _81@Mir(bb24[2])
bb25:
  _78 = (*_79)
  using: _79@Mir(bb24[3])
  _84 = _8
  using: _8@Phi(bb23)
  _83 = move _84 as usize (IntToInt)
  using: _84@Mir(bb25[1])
  _85 = const 5000_usize
  using: 
  _86 = Lt(_83, _85)
  using: _83@Mir(bb25[2]), _85@Mir(bb25[3])
  assert(move _86, "index out of bounds: the length is {} but the index is {}", move _85, _83) -> bb26
  using: _86@Entry, _85@Entry, _83@Entry
bb26:
  _10[_83] = move _78
  using: _83@Mir(bb25[2]), _78@Mir(bb25[0])
  _87 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb23)
  assert(!move (_87.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb27
  using: _87@Entry, _8@Entry
bb27:
  _8 = move (_87.0: i32)
  using: _87@Mir(bb26[1])
  goto -> bb23
  using: 
bb28:
  _90 = &mut _4
  using: _4@Phi(bb12)
  _89 = &raw mut (*_90)
  using: _90@Mir(bb28[0])
  _91 = _3
  using: _3@Phi(bb12)
  _88 = bzlib::BZ2_bzReadClose(move _89, move _91) -> bb29
  using: _89@Mir(bb28[1]), _91@Mir(bb28[2])
bb29:
  _93 = _4
  using: _4@Phi(bb12)
  _94 = const 0_i32
  using: 
  _92 = Ne(move _93, move _94)
  using: _93@Mir(bb29[0]), _94@Mir(bb29[1])
  switchInt(move _92) -> [0: bb31, otherwise: bb30]
  using: _92@Mir(bb29[2])
bb30:
  _99 = const b"test:bzReadGetUnused\x00"
  using: 
  _98 = &raw const (*_99)
  using: _99@Mir(bb30[0])
  _97 = move _98 as *const u8 (Pointer(ArrayToPointer))
  using: _98@Mir(bb30[1])
  _96 = move _97 as *const i8 (PtrToPtr)
  using: _97@Mir(bb30[2])
  _95 = bzip2::panic(move _96)
  using: _96@Mir(bb30[3])
bb31:
  _102 = _11
  using: _11@Phi(bb2)
  _103 = const 0_i32
  using: 
  _101 = Eq(move _102, move _103)
  using: _102@Mir(bb31[0]), _103@Mir(bb31[1])
  switchInt(move _101) -> [0: bb32, otherwise: bb33]
  using: _101@Mir(bb31[2])
bb32:
  _100 = const false
  using: 
  goto -> bb34
  using: 
bb33:
  _107 = _1
  using: _1@Phi(bb2)
  _106 = bzip2::myfeof(move _107) -> bb35
  using: _107@Mir(bb33[0])
bb34:
  switchInt(move _100) -> [0: bb2, otherwise: bb36]
  using: _100@Phi(bb34)
bb35:
  _105 = move _106 as i32 (IntToInt)
  using: _106@Mir(bb33[1])
  _104 = Ne(move _105, const 0_i32)
  using: _105@Mir(bb35[0])
  _100 = move _104
  using: _104@Mir(bb35[1])
  goto -> bb34
  using: 
bb36:
  _2 = const 15125582407903384992_u64
  using: 
  goto -> bb37
  using: 
bb37:
  switchInt(_2) -> [15125582407903384992: bb39, otherwise: bb38]
  using: _2@Phi(bb37)
bb38:
  _131 = &mut _5
  using: _5@Mir(bb0[2])
  _130 = &raw mut (*_131)
  using: _131@Mir(bb38[0])
  _132 = _3
  using: _3@Phi(bb37)
  _129 = bzlib::BZ2_bzReadClose(move _130, move _132) -> bb46
  using: _130@Mir(bb38[1]), _132@Mir(bb38[2])
bb39:
  _111 = _1
  using: _1@Phi(bb59)
  _110 = bzip2::ferror(move _111) -> bb40
  using: _111@Mir(bb39[0])
bb40:
  _109 = Ne(move _110, const 0_i32)
  using: _110@Mir(bb39[1])
  _108 = Not(move _109)
  using: _109@Mir(bb40[0])
  switchInt(move _108) -> [0: bb65, otherwise: bb41]
  using: _108@Mir(bb40[1])
bb41:
  _113 = _1
  using: _1@Phi(bb59)
  _112 = bzip2::fclose(move _113) -> bb42
  using: _113@Mir(bb41[0])
bb42:
  _6 = move _112
  using: _112@Mir(bb41[1])
  _116 = _6
  using: _6@Mir(bb42[0])
  _117 = const -1_i32
  using: 
  _115 = Eq(move _116, move _117)
  using: _116@Mir(bb42[1]), _117@Mir(bb42[2])
  _114 = Not(move _115)
  using: _115@Mir(bb42[3])
  switchInt(move _114) -> [0: bb65, otherwise: bb43]
  using: _114@Mir(bb42[4])
bb43:
  _120 = const {alloc172: *mut i32}
  using: 
  _119 = (*_120)
  using: _120@Mir(bb43[0])
  _121 = const 2_i32
  using: 
  _118 = Ge(move _119, move _121)
  using: _119@Mir(bb43[1]), _121@Mir(bb43[2])
  switchInt(move _118) -> [0: bb45, otherwise: bb44]
  using: _118@Mir(bb43[3])
bb44:
  _124 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _123 = (*_124)
  using: _124@Mir(bb44[0])
  _128 = const b"\n    \x00"
  using: 
  _127 = &raw const (*_128)
  using: _128@Mir(bb44[2])
  _126 = move _127 as *const u8 (Pointer(ArrayToPointer))
  using: _127@Mir(bb44[3])
  _125 = move _126 as *const i8 (PtrToPtr)
  using: _126@Mir(bb44[4])
  _122 = bzip2::fprintf(move _123, move _125) -> bb45
  using: _123@Mir(bb44[1]), _125@Mir(bb44[5])
bb45:
  _0 = const 1_u8
  using: 
  goto -> bb66
  using: 
bb46:
  _135 = const {alloc172: *mut i32}
  using: 
  _134 = (*_135)
  using: _135@Mir(bb46[0])
  _136 = const 0_i32
  using: 
  _133 = Eq(move _134, move _136)
  using: _134@Mir(bb46[1]), _136@Mir(bb46[2])
  switchInt(move _133) -> [0: bb49, otherwise: bb47]
  using: _133@Mir(bb46[3])
bb47:
  _139 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _138 = (*_139)
  using: _139@Mir(bb47[0])
  _143 = const b"%s: %s: \x00"
  using: 
  _142 = &raw const (*_143)
  using: _143@Mir(bb47[2])
  _141 = move _142 as *const u8 (Pointer(ArrayToPointer))
  using: _142@Mir(bb47[3])
  _140 = move _141 as *const i8 (PtrToPtr)
  using: _141@Mir(bb47[4])
  _145 = const {alloc197: *mut *mut i8}
  using: 
  _144 = (*_145)
  using: _145@Mir(bb47[6])
  _149 = const {alloc198: *mut [i8; 1034]}
  using: 
  _148 = &mut (*_149)
  using: _149@Mir(bb47[8])
  _147 = move _148 as &mut [i8] (Pointer(Unsize))
  using: _148@Mir(bb47[9])
  _146 = core::slice::<impl [i8]>::as_mut_ptr(move _147) -> bb48
  using: _147@Mir(bb47[10])
bb48:
  _137 = bzip2::fprintf(move _138, move _140, move _144, move _146) -> bb49
  using: _138@Mir(bb47[1]), _140@Mir(bb47[5]), _144@Mir(bb47[7]), _146@Mir(bb47[11])
bb49:
  switchInt(_4) -> [4294967287: bb51, 4294967290: bb65, 4294967292: bb52, 4294967293: bb54, 4294967289: bb55, 4294967291: bb57, otherwise: bb50]
  using: _4@Phi(bb37)
bb50:
  _2 = const 6101827300316655396_u64
  using: 
  _195 = const b"test:unexpected error\x00"
  using: 
  _194 = &raw const (*_195)
  using: _195@Mir(bb50[1])
  _193 = move _194 as *const u8 (Pointer(ArrayToPointer))
  using: _194@Mir(bb50[2])
  _192 = move _193 as *const i8 (PtrToPtr)
  using: _193@Mir(bb50[3])
  _191 = bzip2::panic(move _192)
  using: _192@Mir(bb50[4])
bb51:
  _2 = const 18238374633732057650_u64
  using: 
  _150 = bzip2::configError()
  using: 
bb52:
  _2 = const 11224962462315262049_u64
  using: 
  _153 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _152 = (*_153)
  using: _153@Mir(bb52[1])
  _157 = const b"data integrity (CRC) error in data\n\x00"
  using: 
  _156 = &raw const (*_157)
  using: _157@Mir(bb52[3])
  _155 = move _156 as *const u8 (Pointer(ArrayToPointer))
  using: _156@Mir(bb52[4])
  _154 = move _155 as *const i8 (PtrToPtr)
  using: _155@Mir(bb52[5])
  _151 = bzip2::fprintf(move _152, move _154) -> bb53
  using: _152@Mir(bb52[2]), _154@Mir(bb52[6])
bb53:
  _0 = const 0_u8
  using: 
  goto -> bb66
  using: 
bb54:
  _2 = const 13802719682174684861_u64
  using: 
  _158 = bzip2::outOfMemory()
  using: 
bb55:
  _2 = const 10380742613918245393_u64
  using: 
  _161 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _160 = (*_161)
  using: _161@Mir(bb55[1])
  _165 = const b"file ends unexpectedly\n\x00"
  using: 
  _164 = &raw const (*_165)
  using: _165@Mir(bb55[3])
  _163 = move _164 as *const u8 (Pointer(ArrayToPointer))
  using: _164@Mir(bb55[4])
  _162 = move _163 as *const i8 (PtrToPtr)
  using: _163@Mir(bb55[5])
  _159 = bzip2::fprintf(move _160, move _162) -> bb56
  using: _160@Mir(bb55[2]), _162@Mir(bb55[6])
bb56:
  _0 = const 0_u8
  using: 
  goto -> bb66
  using: 
bb57:
  _2 = const 2539039579982765382_u64
  using: 
  _167 = _1
  using: _1@Phi(bb37)
  _169 = const {alloc195: *mut *mut blocksort::__sFILE}
  using: 
  _168 = (*_169)
  using: _169@Mir(bb57[2])
  _166 = Ne(move _167, move _168)
  using: _167@Mir(bb57[1]), _168@Mir(bb57[3])
  switchInt(move _166) -> [0: bb59, otherwise: bb58]
  using: _166@Mir(bb57[4])
bb58:
  _171 = _1
  using: _1@Phi(bb37)
  _170 = bzip2::fclose(move _171) -> bb59
  using: _171@Mir(bb58[0])
bb59:
  _173 = _7
  using: _7@Phi(bb37)
  _174 = const 1_i32
  using: 
  _172 = Eq(move _173, move _174)
  using: _173@Mir(bb59[0]), _174@Mir(bb59[1])
  switchInt(move _172) -> [0: bb62, otherwise: bb60]
  using: _172@Mir(bb59[2])
bb60:
  _177 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _176 = (*_177)
  using: _177@Mir(bb60[0])
  _181 = const b"bad magic number (file not created by bzip2)\n\x00"
  using: 
  _180 = &raw const (*_181)
  using: _181@Mir(bb60[2])
  _179 = move _180 as *const u8 (Pointer(ArrayToPointer))
  using: _180@Mir(bb60[3])
  _178 = move _179 as *const i8 (PtrToPtr)
  using: _179@Mir(bb60[4])
  _175 = bzip2::fprintf(move _176, move _178) -> bb61
  using: _176@Mir(bb60[1]), _178@Mir(bb60[5])
bb61:
  _0 = const 0_u8
  using: 
  goto -> bb66
  using: 
bb62:
  _183 = const {alloc196: *mut u8}
  using: 
  _182 = (*_183)
  using: _183@Mir(bb62[0])
  switchInt(move _182) -> [0: bb64, otherwise: bb63]
  using: _182@Mir(bb62[1])
bb63:
  _186 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _185 = (*_186)
  using: _186@Mir(bb63[0])
  _190 = const b"trailing garbage after EOF ignored\n\x00"
  using: 
  _189 = &raw const (*_190)
  using: _190@Mir(bb63[2])
  _188 = move _189 as *const u8 (Pointer(ArrayToPointer))
  using: _189@Mir(bb63[3])
  _187 = move _188 as *const i8 (PtrToPtr)
  using: _188@Mir(bb63[4])
  _184 = bzip2::fprintf(move _185, move _187) -> bb64
  using: _185@Mir(bb63[1]), _187@Mir(bb63[5])
bb64:
  _0 = const 1_u8
  using: 
  goto -> bb66
  using: 
bb65:
  _196 = bzip2::ioError()
  using: 
bb66:
  return
  using: _0@Phi(bb66)
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 5000] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 5000] is not supported
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:1259:10: 1259:25 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:1298:53: 1298:71 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::ferror @ workspace/bzip2/rust/bzip2.rs:1314:22: 1314:37 (#0) by default
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1315:27: 1315:42 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1318:29: 1320:69 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1329:21: 1332:49 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1412:33: 1415:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1470:33: 1472:86 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1518:58: 1518:73 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1520:37: 1523:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1527:41: 1530:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:202 ~ c2rust_lib[1043]::bzip2::setExit)
bb0:
  _3 = _1
  using: _1@Entry
  _5 = const {alloc256: *mut i32}
  using: 
  _4 = (*_5)
  using: _5@Mir(bb0[1])
  _2 = Gt(move _3, move _4)
  using: _3@Mir(bb0[0]), _4@Mir(bb0[2])
  switchInt(move _2) -> [0: bb2, otherwise: bb1]
  using: _2@Mir(bb0[3])
bb1:
  _6 = _1
  using: _1@Entry
  _7 = const {alloc256: *mut i32}
  using: 
  (*_7) = move _6
  using: _7@Mir(bb1[1]), _6@Mir(bb1[0])
  goto -> bb2
  using: 
bb2:
  return
  using: _0@Entry
@DefId(0:203 ~ c2rust_lib[1043]::bzip2::cadvise)
bb0:
  _2 = const {alloc196: *mut u8}
  using: 
  _1 = (*_2)
  using: _2@Mir(bb0[0])
  switchInt(move _1) -> [0: bb2, otherwise: bb1]
  using: _1@Mir(bb0[1])
bb1:
  _5 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _4 = (*_5)
  using: _5@Mir(bb1[0])
  _9 = const b"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n\x00"
  using: 
  _8 = &raw const (*_9)
  using: _9@Mir(bb1[2])
  _7 = move _8 as *const u8 (Pointer(ArrayToPointer))
  using: _8@Mir(bb1[3])
  _6 = move _7 as *const i8 (PtrToPtr)
  using: _7@Mir(bb1[4])
  _3 = bzip2::fprintf(move _4, move _6) -> bb2
  using: _4@Mir(bb1[1]), _6@Mir(bb1[5])
bb2:
  return
  using: _0@Entry
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1605:9: 1607:65 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:204 ~ c2rust_lib[1043]::bzip2::showFileNames)
bb0:
  _2 = const {alloc196: *mut u8}
  using: 
  _1 = (*_2)
  using: _2@Mir(bb0[0])
  switchInt(move _1) -> [0: bb4, otherwise: bb1]
  using: _1@Mir(bb0[1])
bb1:
  _5 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _4 = (*_5)
  using: _5@Mir(bb1[0])
  _9 = const b"\tInput file = %s, output file = %s\n\x00"
  using: 
  _8 = &raw const (*_9)
  using: _9@Mir(bb1[2])
  _7 = move _8 as *const u8 (Pointer(ArrayToPointer))
  using: _8@Mir(bb1[3])
  _6 = move _7 as *const i8 (PtrToPtr)
  using: _7@Mir(bb1[4])
  _13 = const {alloc198: *mut [i8; 1034]}
  using: 
  _12 = &mut (*_13)
  using: _13@Mir(bb1[6])
  _11 = move _12 as &mut [i8] (Pointer(Unsize))
  using: _12@Mir(bb1[7])
  _10 = core::slice::<impl [i8]>::as_mut_ptr(move _11) -> bb2
  using: _11@Mir(bb1[8])
bb2:
  _17 = const {alloc263: *mut [i8; 1034]}
  using: 
  _16 = &mut (*_17)
  using: _17@Mir(bb2[0])
  _15 = move _16 as &mut [i8] (Pointer(Unsize))
  using: _16@Mir(bb2[1])
  _14 = core::slice::<impl [i8]>::as_mut_ptr(move _15) -> bb3
  using: _15@Mir(bb2[2])
bb3:
  _3 = bzip2::fprintf(move _4, move _6, move _10, move _14) -> bb4
  using: _4@Mir(bb1[1]), _6@Mir(bb1[5]), _10@Mir(bb1[9]), _14@Mir(bb2[3])
bb4:
  return
  using: _0@Entry
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1613:9: 1616:38 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:205 ~ c2rust_lib[1043]::bzip2::cleanUpAndFail)
bb0:
  _2 = const 0_i32
  using: 
  Deinit(_4)
  using: 
  (_4.0: i64) = const 0_i64
  using: 
  (_4.1: i64) = const 0_i64
  using: 
  Deinit(_5)
  using: 
  (_5.0: i64) = const 0_i64
  using: 
  (_5.1: i64) = const 0_i64
  using: 
  Deinit(_6)
  using: 
  (_6.0: i64) = const 0_i64
  using: 
  (_6.1: i64) = const 0_i64
  using: 
  Deinit(_7)
  using: 
  (_7.0: i64) = const 0_i64
  using: 
  (_7.1: i64) = const 0_i64
  using: 
  _8 = [const 0_i64; 2]
  using: 
  Deinit(_3)
  using: 
  (_3.0: i32) = const 0_i32
  using: 
  (_3.1: u16) = const 0_u16
  using: 
  (_3.2: u16) = const 0_u16
  using: 
  (_3.3: u64) = const 0_u64
  using: 
  (_3.4: u32) = const 0_u32
  using: 
  (_3.5: u32) = const 0_u32
  using: 
  (_3.6: i32) = const 0_i32
  using: 
  (_3.7: bzip2::timespec) = move _4
  using: _4@Mir(bb0[1])
  (_3.8: bzip2::timespec) = move _5
  using: _5@Mir(bb0[4])
  (_3.9: bzip2::timespec) = move _6
  using: _6@Mir(bb0[7])
  (_3.10: bzip2::timespec) = move _7
  using: _7@Mir(bb0[10])
  (_3.11: i64) = const 0_i64
  using: 
  (_3.12: i64) = const 0_i64
  using: 
  (_3.13: i32) = const 0_i32
  using: 
  (_3.14: u32) = const 0_u32
  using: 
  (_3.15: u32) = const 0_u32
  using: 
  (_3.16: i32) = const 0_i32
  using: 
  (_3.17: [i64; 2]) = move _8
  using: _8@Mir(bb0[13])
  _13 = const {alloc267: *mut i32}
  using: 
  _12 = (*_13)
  using: _13@Mir(bb0[33])
  _14 = const 3_i32
  using: 
  _11 = Eq(move _12, move _14)
  using: _12@Mir(bb0[34]), _14@Mir(bb0[35])
  switchInt(move _11) -> [0: bb4, otherwise: bb5]
  using: _11@Mir(bb0[36])
bb1:
  _9 = const false
  using: 
  goto -> bb3
  using: 
bb2:
  _22 = const {alloc269: *mut u8}
  using: 
  _21 = (*_22)
  using: _22@Mir(bb2[0])
  _20 = move _21 as i32 (IntToInt)
  using: _21@Mir(bb2[1])
  _19 = Ne(move _20, const 0_i32)
  using: _20@Mir(bb2[2])
  _9 = move _19
  using: _19@Mir(bb2[3])
  goto -> bb3
  using: 
bb3:
  switchInt(move _9) -> [0: bb26, otherwise: bb7]
  using: _9@Phi(bb3)
bb4:
  _10 = const false
  using: 
  goto -> bb6
  using: 
bb5:
  _17 = const {alloc268: *mut i32}
  using: 
  _16 = (*_17)
  using: _17@Mir(bb5[0])
  _18 = const 3_i32
  using: 
  _15 = Ne(move _16, move _18)
  using: _16@Mir(bb5[1]), _18@Mir(bb5[2])
  _10 = move _15
  using: _15@Mir(bb5[3])
  goto -> bb6
  using: 
bb6:
  switchInt(move _10) -> [0: bb1, otherwise: bb2]
  using: _10@Phi(bb6)
bb7:
  _28 = const {alloc198: *mut [i8; 1034]}
  using: 
  _27 = &mut (*_28)
  using: _28@Mir(bb7[0])
  _26 = move _27 as &mut [i8] (Pointer(Unsize))
  using: _27@Mir(bb7[1])
  _25 = core::slice::<impl [i8]>::as_mut_ptr(move _26) -> bb8
  using: _26@Mir(bb7[2])
bb8:
  _24 = move _25 as *const i8 (Pointer(MutToConstPointer))
  using: _25@Mir(bb7[3])
  _30 = &mut _3
  using: _3@Mir(bb0[14])
  _29 = &raw mut (*_30)
  using: _30@Mir(bb8[1])
  _23 = bzip2::stat(move _24, move _29) -> bb9
  using: _24@Mir(bb8[0]), _29@Mir(bb8[2])
bb9:
  _2 = move _23
  using: _23@Mir(bb8[3])
  _32 = _2
  using: _2@Mir(bb9[0])
  _33 = const 0_i32
  using: 
  _31 = Eq(move _32, move _33)
  using: _32@Mir(bb9[1]), _33@Mir(bb9[2])
  switchInt(move _31) -> [0: bb21, otherwise: bb10]
  using: _31@Mir(bb9[3])
bb10:
  _35 = const {alloc196: *mut u8}
  using: 
  _34 = (*_35)
  using: _35@Mir(bb10[0])
  switchInt(move _34) -> [0: bb13, otherwise: bb11]
  using: _34@Mir(bb10[1])
bb11:
  _38 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _37 = (*_38)
  using: _38@Mir(bb11[0])
  _42 = const b"%s: Deleting output file %s, if it exists.\n\x00"
  using: 
  _41 = &raw const (*_42)
  using: _42@Mir(bb11[2])
  _40 = move _41 as *const u8 (Pointer(ArrayToPointer))
  using: _41@Mir(bb11[3])
  _39 = move _40 as *const i8 (PtrToPtr)
  using: _40@Mir(bb11[4])
  _44 = const {alloc197: *mut *mut i8}
  using: 
  _43 = (*_44)
  using: _44@Mir(bb11[6])
  _48 = const {alloc263: *mut [i8; 1034]}
  using: 
  _47 = &mut (*_48)
  using: _48@Mir(bb11[8])
  _46 = move _47 as &mut [i8] (Pointer(Unsize))
  using: _47@Mir(bb11[9])
  _45 = core::slice::<impl [i8]>::as_mut_ptr(move _46) -> bb12
  using: _46@Mir(bb11[10])
bb12:
  _36 = bzip2::fprintf(move _37, move _39, move _43, move _45) -> bb13
  using: _37@Mir(bb11[1]), _39@Mir(bb11[5]), _43@Mir(bb11[7]), _45@Mir(bb11[11])
bb13:
  _52 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  _51 = (*_52)
  using: _52@Mir(bb13[0])
  _50 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _51) -> bb14
  using: _51@Mir(bb13[1])
bb14:
  _49 = Not(move _50)
  using: _50@Mir(bb13[2])
  switchInt(move _49) -> [0: bb16, otherwise: bb15]
  using: _49@Mir(bb14[0])
bb15:
  _55 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  _54 = (*_55)
  using: _55@Mir(bb15[0])
  _53 = bzip2::fclose(move _54) -> bb17
  using: _54@Mir(bb15[1])
bb16:
  _59 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  _58 = (*_59)
  using: _59@Mir(bb16[0])
  _57 = move _58 as usize (PointerExposeAddress)
  using: _58@Mir(bb16[1])
  _56 = Eq(move _57, const 0_usize)
  using: _57@Mir(bb16[2])
  assume(move _56)
  using: _56@Mir(bb16[3])
  goto -> bb17
  using: 
bb17:
  _65 = const {alloc263: *mut [i8; 1034]}
  using: 
  _64 = &mut (*_65)
  using: _65@Mir(bb17[0])
  _63 = move _64 as &mut [i8] (Pointer(Unsize))
  using: _64@Mir(bb17[1])
  _62 = core::slice::<impl [i8]>::as_mut_ptr(move _63) -> bb18
  using: _63@Mir(bb17[2])
bb18:
  _61 = move _62 as *const i8 (Pointer(MutToConstPointer))
  using: _62@Mir(bb17[3])
  _60 = bzip2::remove(move _61) -> bb19
  using: _61@Mir(bb18[0])
bb19:
  _2 = move _60
  using: _60@Mir(bb18[1])
  _67 = _2
  using: _2@Mir(bb19[0])
  _68 = const 0_i32
  using: 
  _66 = Ne(move _67, move _68)
  using: _67@Mir(bb19[1]), _68@Mir(bb19[2])
  switchInt(move _66) -> [0: bb26, otherwise: bb20]
  using: _66@Mir(bb19[3])
bb20:
  _71 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _70 = (*_71)
  using: _71@Mir(bb20[0])
  _75 = const b"%s: WARNING: deletion of output file (apparently) failed.\n\x00"
  using: 
  _74 = &raw const (*_75)
  using: _75@Mir(bb20[2])
  _73 = move _74 as *const u8 (Pointer(ArrayToPointer))
  using: _74@Mir(bb20[3])
  _72 = move _73 as *const i8 (PtrToPtr)
  using: _73@Mir(bb20[4])
  _77 = const {alloc197: *mut *mut i8}
  using: 
  _76 = (*_77)
  using: _77@Mir(bb20[6])
  _69 = bzip2::fprintf(move _70, move _72, move _76) -> bb26
  using: _70@Mir(bb20[1]), _72@Mir(bb20[5]), _76@Mir(bb20[7])
bb21:
  _80 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _79 = (*_80)
  using: _80@Mir(bb21[0])
  _84 = const b"%s: WARNING: deletion of output file suppressed\n\x00"
  using: 
  _83 = &raw const (*_84)
  using: _84@Mir(bb21[2])
  _82 = move _83 as *const u8 (Pointer(ArrayToPointer))
  using: _83@Mir(bb21[3])
  _81 = move _82 as *const i8 (PtrToPtr)
  using: _82@Mir(bb21[4])
  _86 = const {alloc197: *mut *mut i8}
  using: 
  _85 = (*_86)
  using: _86@Mir(bb21[6])
  _78 = bzip2::fprintf(move _79, move _81, move _85) -> bb22
  using: _79@Mir(bb21[1]), _81@Mir(bb21[5]), _85@Mir(bb21[7])
bb22:
  _89 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _88 = (*_89)
  using: _89@Mir(bb22[0])
  _93 = const b"%s:    since input file no longer exists.  Output file\n\x00"
  using: 
  _92 = &raw const (*_93)
  using: _93@Mir(bb22[2])
  _91 = move _92 as *const u8 (Pointer(ArrayToPointer))
  using: _92@Mir(bb22[3])
  _90 = move _91 as *const i8 (PtrToPtr)
  using: _91@Mir(bb22[4])
  _95 = const {alloc197: *mut *mut i8}
  using: 
  _94 = (*_95)
  using: _95@Mir(bb22[6])
  _87 = bzip2::fprintf(move _88, move _90, move _94) -> bb23
  using: _88@Mir(bb22[1]), _90@Mir(bb22[5]), _94@Mir(bb22[7])
bb23:
  _98 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _97 = (*_98)
  using: _98@Mir(bb23[0])
  _102 = const b"%s:    `%s\' may be incomplete.\n\x00"
  using: 
  _101 = &raw const (*_102)
  using: _102@Mir(bb23[2])
  _100 = move _101 as *const u8 (Pointer(ArrayToPointer))
  using: _101@Mir(bb23[3])
  _99 = move _100 as *const i8 (PtrToPtr)
  using: _100@Mir(bb23[4])
  _104 = const {alloc197: *mut *mut i8}
  using: 
  _103 = (*_104)
  using: _104@Mir(bb23[6])
  _108 = const {alloc263: *mut [i8; 1034]}
  using: 
  _107 = &mut (*_108)
  using: _108@Mir(bb23[8])
  _106 = move _107 as &mut [i8] (Pointer(Unsize))
  using: _107@Mir(bb23[9])
  _105 = core::slice::<impl [i8]>::as_mut_ptr(move _106) -> bb24
  using: _106@Mir(bb23[10])
bb24:
  _96 = bzip2::fprintf(move _97, move _99, move _103, move _105) -> bb25
  using: _97@Mir(bb23[1]), _99@Mir(bb23[5]), _103@Mir(bb23[7]), _105@Mir(bb23[11])
bb25:
  _111 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _110 = (*_111)
  using: _111@Mir(bb25[0])
  _115 = const b"%s:    I suggest doing an integrity test (bzip2 -tv) of it.\n\x00"
  using: 
  _114 = &raw const (*_115)
  using: _115@Mir(bb25[2])
  _113 = move _114 as *const u8 (Pointer(ArrayToPointer))
  using: _114@Mir(bb25[3])
  _112 = move _113 as *const i8 (PtrToPtr)
  using: _113@Mir(bb25[4])
  _117 = const {alloc197: *mut *mut i8}
  using: 
  _116 = (*_117)
  using: _117@Mir(bb25[6])
  _109 = bzip2::fprintf(move _110, move _112, move _116) -> bb26
  using: _110@Mir(bb25[1]), _112@Mir(bb25[5]), _116@Mir(bb25[7])
bb26:
  _122 = const {alloc196: *mut u8}
  using: 
  _121 = (*_122)
  using: _122@Mir(bb26[0])
  _120 = move _121 as i32 (IntToInt)
  using: _121@Mir(bb26[1])
  switchInt(move _120) -> [0: bb30, otherwise: bb31]
  using: _120@Mir(bb26[2])
bb27:
  _118 = const false
  using: 
  goto -> bb29
  using: 
bb28:
  _129 = const {alloc271: *mut i32}
  using: 
  _128 = (*_129)
  using: _129@Mir(bb28[0])
  _131 = const {alloc270: *mut i32}
  using: 
  _130 = (*_131)
  using: _131@Mir(bb28[2])
  _127 = Lt(move _128, move _130)
  using: _128@Mir(bb28[1]), _130@Mir(bb28[3])
  _118 = move _127
  using: _127@Mir(bb28[4])
  goto -> bb29
  using: 
bb29:
  switchInt(move _118) -> [0: bb35, otherwise: bb33]
  using: _118@Phi(bb29)
bb30:
  _119 = const false
  using: 
  goto -> bb32
  using: 
bb31:
  _125 = const {alloc270: *mut i32}
  using: 
  _124 = (*_125)
  using: _125@Mir(bb31[0])
  _126 = const 0_i32
  using: 
  _123 = Gt(move _124, move _126)
  using: _124@Mir(bb31[1]), _126@Mir(bb31[2])
  _119 = move _123
  using: _123@Mir(bb31[3])
  goto -> bb32
  using: 
bb32:
  switchInt(move _119) -> [0: bb27, otherwise: bb28]
  using: _119@Phi(bb32)
bb33:
  _134 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _133 = (*_134)
  using: _134@Mir(bb33[0])
  _138 = const b"%s: WARNING: some files have not been processed:\n%s:    %d specified on command line, %d not processed yet.\n\n\x00"
  using: 
  _137 = &raw const (*_138)
  using: _138@Mir(bb33[2])
  _136 = move _137 as *const u8 (Pointer(ArrayToPointer))
  using: _137@Mir(bb33[3])
  _135 = move _136 as *const i8 (PtrToPtr)
  using: _136@Mir(bb33[4])
  _140 = const {alloc197: *mut *mut i8}
  using: 
  _139 = (*_140)
  using: _140@Mir(bb33[6])
  _142 = const {alloc197: *mut *mut i8}
  using: 
  _141 = (*_142)
  using: _142@Mir(bb33[8])
  _144 = const {alloc270: *mut i32}
  using: 
  _143 = (*_144)
  using: _144@Mir(bb33[10])
  _147 = const {alloc270: *mut i32}
  using: 
  _146 = (*_147)
  using: _147@Mir(bb33[12])
  _149 = const {alloc271: *mut i32}
  using: 
  _148 = (*_149)
  using: _149@Mir(bb33[14])
  _150 = CheckedSub(_146, _148)
  using: _146@Mir(bb33[13]), _148@Mir(bb33[15])
  assert(!move (_150.1: bool), "attempt to compute `{} - {}`, which would overflow", move _146, move _148) -> bb34
  using: _150@Entry, _146@Entry, _148@Entry
bb34:
  _145 = move (_150.0: i32)
  using: _150@Mir(bb33[16])
  _132 = bzip2::fprintf(move _133, move _135, move _139, move _141, move _143, move _145) -> bb35
  using: _133@Mir(bb33[1]), _135@Mir(bb33[5]), _139@Mir(bb33[7]), _141@Mir(bb33[9]), _143@Mir(bb33[11]), _145@Mir(bb34[0])
bb35:
  _152 = _1
  using: _1@Entry
  _151 = bzip2::setExit(move _152) -> bb36
  using: _152@Mir(bb35[0])
bb36:
  _155 = const {alloc256: *mut i32}
  using: 
  _154 = (*_155)
  using: _155@Mir(bb36[0])
  _153 = bzip2::exit(move _154)
  using: _154@Mir(bb36[1])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_4) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_5) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_6) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_7) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_3) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i64; 2] is not supported
rewrite call bzip2::stat @ workspace/bzip2/rust/bzip2.rs:1648:18: 1648:57 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1651:17: 1654:46 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1657:17: 1657:47 (#0) by default
rewrite call bzip2::remove @ workspace/bzip2/rust/bzip2.rs:1659:22: 1659:50 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1661:17: 1663:83 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1666:13: 1668:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1669:13: 1671:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1672:13: 1674:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1675:13: 1677:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1682:9: 1685:64 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:1688:5: 1688:20 (#0) by default
@DefId(0:207 ~ c2rust_lib[1043]::bzip2::panic)
bb0:
  _4 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _3 = (*_4)
  using: _4@Mir(bb0[0])
  _8 = const b"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to:\n\tbzip2-devel@sourceware.org\n\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _10 = const {alloc197: *mut *mut i8}
  using: 
  _9 = (*_10)
  using: _10@Mir(bb0[6])
  _11 = _1
  using: _1@Entry
  _2 = bzip2::fprintf(move _3, move _5, move _9, move _11) -> bb1
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5]), _9@Mir(bb0[7]), _11@Mir(bb0[8])
bb1:
  _12 = bzip2::showFileNames() -> bb2
  using: 
bb2:
  _14 = const 3_i32
  using: 
  _13 = bzip2::cleanUpAndFail(move _14)
  using: _14@Mir(bb2[0])
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1692:5: 1694:74 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:208 ~ c2rust_lib[1043]::bzip2::crcError)
bb0:
  _3 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _2 = (*_3)
  using: _3@Mir(bb0[0])
  _7 = const b"\n%s: Data integrity error when decompressing.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[3])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[4])
  _9 = const {alloc197: *mut *mut i8}
  using: 
  _8 = (*_9)
  using: _9@Mir(bb0[6])
  _1 = bzip2::fprintf(move _2, move _4, move _8) -> bb1
  using: _2@Mir(bb0[1]), _4@Mir(bb0[5]), _8@Mir(bb0[7])
bb1:
  _10 = bzip2::showFileNames() -> bb2
  using: 
bb2:
  _11 = bzip2::cadvise() -> bb3
  using: 
bb3:
  _13 = const 2_i32
  using: 
  _12 = bzip2::cleanUpAndFail(move _13)
  using: _13@Mir(bb3[0])
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1700:5: 1702:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:209 ~ c2rust_lib[1043]::bzip2::compressedStreamEOF)
bb0:
  _2 = const {alloc196: *mut u8}
  using: 
  _1 = (*_2)
  using: _2@Mir(bb0[0])
  switchInt(move _1) -> [0: bb5, otherwise: bb1]
  using: _1@Mir(bb0[1])
bb1:
  _5 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _4 = (*_5)
  using: _5@Mir(bb1[0])
  _9 = const b"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n\x00"
  using: 
  _8 = &raw const (*_9)
  using: _9@Mir(bb1[2])
  _7 = move _8 as *const u8 (Pointer(ArrayToPointer))
  using: _8@Mir(bb1[3])
  _6 = move _7 as *const i8 (PtrToPtr)
  using: _7@Mir(bb1[4])
  _11 = const {alloc197: *mut *mut i8}
  using: 
  _10 = (*_11)
  using: _11@Mir(bb1[6])
  _3 = bzip2::fprintf(move _4, move _6, move _10) -> bb2
  using: _4@Mir(bb1[1]), _6@Mir(bb1[5]), _10@Mir(bb1[7])
bb2:
  _15 = const {alloc197: *mut *mut i8}
  using: 
  _14 = (*_15)
  using: _15@Mir(bb2[0])
  _13 = move _14 as *const i8 (Pointer(MutToConstPointer))
  using: _14@Mir(bb2[1])
  _12 = bzip2::perror(move _13) -> bb3
  using: _13@Mir(bb2[2])
bb3:
  _16 = bzip2::showFileNames() -> bb4
  using: 
bb4:
  _17 = bzip2::cadvise() -> bb5
  using: 
bb5:
  _19 = const 2_i32
  using: 
  _18 = bzip2::cleanUpAndFail(move _19)
  using: _19@Mir(bb5[0])
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1710:9: 1712:75 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::perror @ workspace/bzip2/rust/bzip2.rs:1713:9: 1713:25 (#0) by default
@DefId(0:210 ~ c2rust_lib[1043]::bzip2::ioError)
bb0:
  _3 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _2 = (*_3)
  using: _3@Mir(bb0[0])
  _7 = const b"\n%s: I/O or other error, bailing out.  Possible reason follows.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[3])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[4])
  _9 = const {alloc197: *mut *mut i8}
  using: 
  _8 = (*_9)
  using: _9@Mir(bb0[6])
  _1 = bzip2::fprintf(move _2, move _4, move _8) -> bb1
  using: _2@Mir(bb0[1]), _4@Mir(bb0[5]), _8@Mir(bb0[7])
bb1:
  _13 = const {alloc197: *mut *mut i8}
  using: 
  _12 = (*_13)
  using: _13@Mir(bb1[0])
  _11 = move _12 as *const i8 (Pointer(MutToConstPointer))
  using: _12@Mir(bb1[1])
  _10 = bzip2::perror(move _11) -> bb2
  using: _11@Mir(bb1[2])
bb2:
  _14 = bzip2::showFileNames() -> bb3
  using: 
bb3:
  _16 = const 1_i32
  using: 
  _15 = bzip2::cleanUpAndFail(move _16)
  using: _16@Mir(bb3[0])
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1721:5: 1723:71 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::perror @ workspace/bzip2/rust/bzip2.rs:1724:5: 1724:21 (#0) by default
@DefId(0:211 ~ c2rust_lib[1043]::bzip2::mySignalCatcher)
bb0:
  _4 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _3 = (*_4)
  using: _4@Mir(bb0[0])
  _8 = const b"\n%s: Control-C or similar caught, quitting.\n\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _10 = const {alloc197: *mut *mut i8}
  using: 
  _9 = (*_10)
  using: _10@Mir(bb0[6])
  _2 = bzip2::fprintf(move _3, move _5, move _9) -> bb1
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5]), _9@Mir(bb0[7])
bb1:
  _12 = const 1_i32
  using: 
  _11 = bzip2::cleanUpAndFail(move _12)
  using: _12@Mir(bb1[0])
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1730:5: 1732:58 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:212 ~ c2rust_lib[1043]::bzip2::mySIGSEGVorSIGBUScatcher)
bb0:
  _2 = const {0x0 as *const i8}
  using: 
  _5 = const {alloc268: *mut i32}
  using: 
  _4 = (*_5)
  using: _5@Mir(bb0[1])
  _6 = const 1_i32
  using: 
  _3 = Eq(move _4, move _6)
  using: _4@Mir(bb0[2]), _6@Mir(bb0[3])
  switchInt(move _3) -> [0: bb2, otherwise: bb1]
  using: _3@Mir(bb0[4])
bb1:
  _9 = const b": Caught a SIGSEGV or SIGBUS whilst compressing.\n\n   Possible causes are (most likely first):\n   (1) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (2) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (3) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (1) and (2).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (1)\n   or (2), feel free to report it to: bzip2-devel@sourceware.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n\x00"
  using: 
  _8 = &raw const (*_9)
  using: _9@Mir(bb1[0])
  _7 = move _8 as *const u8 (Pointer(ArrayToPointer))
  using: _8@Mir(bb1[1])
  _2 = move _7 as *const i8 (PtrToPtr)
  using: _7@Mir(bb1[2])
  goto -> bb3
  using: 
bb2:
  _12 = const b": Caught a SIGSEGV or SIGBUS whilst decompressing.\n\n   Possible causes are (most likely first):\n   (1) The compressed data is corrupted, and bzip2\'s usual checks\n       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n   (2) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (3) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (4) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (2) and (3).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (2)\n   or (3), feel free to report it to: bzip2-devel@sourceware.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n\x00"
  using: 
  _11 = &raw const (*_12)
  using: _12@Mir(bb2[0])
  _10 = move _11 as *const u8 (Pointer(ArrayToPointer))
  using: _11@Mir(bb2[1])
  _2 = move _10 as *const i8 (PtrToPtr)
  using: _10@Mir(bb2[2])
  goto -> bb3
  using: 
bb3:
  _14 = const 2_i32
  using: 
  _19 = const b"\n\x00"
  using: 
  _18 = &raw const (*_19)
  using: _19@Mir(bb3[1])
  _17 = move _18 as *const u8 (Pointer(ArrayToPointer))
  using: _18@Mir(bb3[2])
  _16 = move _17 as *const i8 (PtrToPtr)
  using: _17@Mir(bb3[3])
  _15 = move _16 as *const std::ffi::c_void (PtrToPtr)
  using: _16@Mir(bb3[4])
  _20 = const 1_u64
  using: 
  _13 = bzip2::write(move _14, move _15, move _20) -> bb4
  using: _14@Mir(bb3[0]), _15@Mir(bb3[5]), _20@Mir(bb3[6])
bb4:
  _22 = const 2_i32
  using: 
  _25 = const {alloc197: *mut *mut i8}
  using: 
  _24 = (*_25)
  using: _25@Mir(bb4[1])
  _23 = move _24 as *const std::ffi::c_void (PtrToPtr)
  using: _24@Mir(bb4[2])
  _29 = const {alloc197: *mut *mut i8}
  using: 
  _28 = (*_29)
  using: _29@Mir(bb4[4])
  _27 = move _28 as *const i8 (Pointer(MutToConstPointer))
  using: _28@Mir(bb4[5])
  _26 = bzip2::strlen(move _27) -> bb5
  using: _27@Mir(bb4[6])
bb5:
  _21 = bzip2::write(move _22, move _23, move _26) -> bb6
  using: _22@Mir(bb4[0]), _23@Mir(bb4[3]), _26@Mir(bb4[7])
bb6:
  _31 = const 2_i32
  using: 
  _33 = _2
  using: _2@Phi(bb3)
  _32 = move _33 as *const std::ffi::c_void (PtrToPtr)
  using: _33@Mir(bb6[1])
  _35 = _2
  using: _2@Phi(bb3)
  _34 = bzip2::strlen(move _35) -> bb7
  using: _35@Mir(bb6[3])
bb7:
  _30 = bzip2::write(move _31, move _32, move _34) -> bb8
  using: _31@Mir(bb6[0]), _32@Mir(bb6[2]), _34@Mir(bb6[4])
bb8:
  _38 = const b"\tInput file = \x00"
  using: 
  _37 = &raw const (*_38)
  using: _38@Mir(bb8[0])
  _36 = move _37 as *const u8 (Pointer(ArrayToPointer))
  using: _37@Mir(bb8[1])
  _2 = move _36 as *const i8 (PtrToPtr)
  using: _36@Mir(bb8[2])
  _40 = const 2_i32
  using: 
  _42 = _2
  using: _2@Mir(bb8[3])
  _41 = move _42 as *const std::ffi::c_void (PtrToPtr)
  using: _42@Mir(bb8[5])
  _44 = _2
  using: _2@Mir(bb8[3])
  _43 = bzip2::strlen(move _44) -> bb9
  using: _44@Mir(bb8[7])
bb9:
  _39 = bzip2::write(move _40, move _41, move _43) -> bb10
  using: _40@Mir(bb8[4]), _41@Mir(bb8[6]), _43@Mir(bb8[8])
bb10:
  _46 = const 2_i32
  using: 
  _51 = const {alloc198: *mut [i8; 1034]}
  using: 
  _50 = &mut (*_51)
  using: _51@Mir(bb10[1])
  _49 = move _50 as &mut [i8] (Pointer(Unsize))
  using: _50@Mir(bb10[2])
  _48 = core::slice::<impl [i8]>::as_mut_ptr(move _49) -> bb11
  using: _49@Mir(bb10[3])
bb11:
  _47 = move _48 as *const std::ffi::c_void (PtrToPtr)
  using: _48@Mir(bb10[4])
  _57 = const {alloc198: *mut [i8; 1034]}
  using: 
  _56 = &mut (*_57)
  using: _57@Mir(bb11[1])
  _55 = move _56 as &mut [i8] (Pointer(Unsize))
  using: _56@Mir(bb11[2])
  _54 = core::slice::<impl [i8]>::as_mut_ptr(move _55) -> bb12
  using: _55@Mir(bb11[3])
bb12:
  _53 = move _54 as *const i8 (Pointer(MutToConstPointer))
  using: _54@Mir(bb11[4])
  _52 = bzip2::strlen(move _53) -> bb13
  using: _53@Mir(bb12[0])
bb13:
  _45 = bzip2::write(move _46, move _47, move _52) -> bb14
  using: _46@Mir(bb10[0]), _47@Mir(bb11[0]), _52@Mir(bb12[1])
bb14:
  _59 = const 2_i32
  using: 
  _64 = const b"\n\x00"
  using: 
  _63 = &raw const (*_64)
  using: _64@Mir(bb14[1])
  _62 = move _63 as *const u8 (Pointer(ArrayToPointer))
  using: _63@Mir(bb14[2])
  _61 = move _62 as *const i8 (PtrToPtr)
  using: _62@Mir(bb14[3])
  _60 = move _61 as *const std::ffi::c_void (PtrToPtr)
  using: _61@Mir(bb14[4])
  _65 = const 1_u64
  using: 
  _58 = bzip2::write(move _59, move _60, move _65) -> bb15
  using: _59@Mir(bb14[0]), _60@Mir(bb14[5]), _65@Mir(bb14[6])
bb15:
  _68 = const b"\tOutput file = \x00"
  using: 
  _67 = &raw const (*_68)
  using: _68@Mir(bb15[0])
  _66 = move _67 as *const u8 (Pointer(ArrayToPointer))
  using: _67@Mir(bb15[1])
  _2 = move _66 as *const i8 (PtrToPtr)
  using: _66@Mir(bb15[2])
  _70 = const 2_i32
  using: 
  _72 = _2
  using: _2@Mir(bb15[3])
  _71 = move _72 as *const std::ffi::c_void (PtrToPtr)
  using: _72@Mir(bb15[5])
  _74 = _2
  using: _2@Mir(bb15[3])
  _73 = bzip2::strlen(move _74) -> bb16
  using: _74@Mir(bb15[7])
bb16:
  _69 = bzip2::write(move _70, move _71, move _73) -> bb17
  using: _70@Mir(bb15[4]), _71@Mir(bb15[6]), _73@Mir(bb15[8])
bb17:
  _76 = const 2_i32
  using: 
  _81 = const {alloc263: *mut [i8; 1034]}
  using: 
  _80 = &mut (*_81)
  using: _81@Mir(bb17[1])
  _79 = move _80 as &mut [i8] (Pointer(Unsize))
  using: _80@Mir(bb17[2])
  _78 = core::slice::<impl [i8]>::as_mut_ptr(move _79) -> bb18
  using: _79@Mir(bb17[3])
bb18:
  _77 = move _78 as *const std::ffi::c_void (PtrToPtr)
  using: _78@Mir(bb17[4])
  _87 = const {alloc263: *mut [i8; 1034]}
  using: 
  _86 = &mut (*_87)
  using: _87@Mir(bb18[1])
  _85 = move _86 as &mut [i8] (Pointer(Unsize))
  using: _86@Mir(bb18[2])
  _84 = core::slice::<impl [i8]>::as_mut_ptr(move _85) -> bb19
  using: _85@Mir(bb18[3])
bb19:
  _83 = move _84 as *const i8 (Pointer(MutToConstPointer))
  using: _84@Mir(bb18[4])
  _82 = bzip2::strlen(move _83) -> bb20
  using: _83@Mir(bb19[0])
bb20:
  _75 = bzip2::write(move _76, move _77, move _82) -> bb21
  using: _76@Mir(bb17[0]), _77@Mir(bb18[0]), _82@Mir(bb19[1])
bb21:
  _89 = const 2_i32
  using: 
  _94 = const b"\n\x00"
  using: 
  _93 = &raw const (*_94)
  using: _94@Mir(bb21[1])
  _92 = move _93 as *const u8 (Pointer(ArrayToPointer))
  using: _93@Mir(bb21[2])
  _91 = move _92 as *const i8 (PtrToPtr)
  using: _92@Mir(bb21[3])
  _90 = move _91 as *const std::ffi::c_void (PtrToPtr)
  using: _91@Mir(bb21[4])
  _95 = const 1_u64
  using: 
  _88 = bzip2::write(move _89, move _90, move _95) -> bb22
  using: _89@Mir(bb21[0]), _90@Mir(bb21[5]), _95@Mir(bb21[6])
bb22:
  _98 = const {alloc268: *mut i32}
  using: 
  _97 = (*_98)
  using: _98@Mir(bb22[0])
  _99 = const 1_i32
  using: 
  _96 = Eq(move _97, move _99)
  using: _97@Mir(bb22[1]), _99@Mir(bb22[2])
  switchInt(move _96) -> [0: bb24, otherwise: bb23]
  using: _96@Mir(bb22[3])
bb23:
  _101 = const 3_i32
  using: 
  _100 = bzip2::setExit(move _101) -> bb25
  using: _101@Mir(bb23[0])
bb24:
  _103 = const 2_i32
  using: 
  _102 = bzip2::setExit(move _103) -> bb25
  using: _103@Mir(bb24[0])
bb25:
  _106 = const {alloc256: *mut i32}
  using: 
  _105 = (*_106)
  using: _106@Mir(bb25[0])
  _104 = bzip2::_exit(move _105)
  using: _105@Mir(bb25[1])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1747:5: 1749:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1751:11: 1751:27 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1750:5: 1751:28 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1752:73: 1752:84 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1752:5: 1752:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1754:73: 1754:84 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1754:5: 1754:85 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1756:11: 1756:38 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1755:5: 1756:39 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1757:5: 1759:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1761:73: 1761:84 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1761:5: 1761:85 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1763:11: 1763:39 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1762:5: 1763:40 (#0) by default
rewrite call bzip2::write @ workspace/bzip2/rust/bzip2.rs:1764:5: 1766:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::_exit @ workspace/bzip2/rust/bzip2.rs:1772:5: 1772:21 (#0) by default
@DefId(0:213 ~ c2rust_lib[1043]::bzip2::outOfMemory)
bb0:
  _3 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _2 = (*_3)
  using: _3@Mir(bb0[0])
  _7 = const b"\n%s: couldn\'t allocate enough memory\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[3])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[4])
  _9 = const {alloc197: *mut *mut i8}
  using: 
  _8 = (*_9)
  using: _9@Mir(bb0[6])
  _1 = bzip2::fprintf(move _2, move _4, move _8) -> bb1
  using: _2@Mir(bb0[1]), _4@Mir(bb0[5]), _8@Mir(bb0[7])
bb1:
  _10 = bzip2::showFileNames() -> bb2
  using: 
bb2:
  _12 = const 1_i32
  using: 
  _11 = bzip2::cleanUpAndFail(move _12)
  using: _12@Mir(bb2[0])
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1776:5: 1778:55 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:214 ~ c2rust_lib[1043]::bzip2::configError)
bb0:
  _3 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _2 = (*_3)
  using: _3@Mir(bb0[0])
  _7 = const b"bzip2: I\'m not configured correctly for this platform!\n\tI require Int32, Int16 and Char to have sizes\n\tof 4, 2 and 1 bytes to run properly, and they don\'t.\n\tProbably you can fix this by defining them correctly,\n\tand recompiling.  Bye!\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[3])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[4])
  _1 = bzip2::fprintf(move _2, move _4) -> bb1
  using: _2@Mir(bb0[1]), _4@Mir(bb0[5])
bb1:
  _9 = const 3_i32
  using: 
  _8 = bzip2::setExit(move _9) -> bb2
  using: _9@Mir(bb1[0])
bb2:
  _12 = const {alloc256: *mut i32}
  using: 
  _11 = (*_12)
  using: _12@Mir(bb2[0])
  _10 = bzip2::exit(move _11)
  using: _11@Mir(bb2[1])
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1784:5: 1786:61 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:1788:5: 1788:20 (#0) by default
@DefId(0:215 ~ c2rust_lib[1043]::bzip2::pad)
bb0:
  _2 = const 0_i32
  using: 
  _7 = _1
  using: _1@Entry
  _6 = move _7 as *const i8 (Pointer(MutToConstPointer))
  using: _7@Mir(bb0[1])
  _5 = bzip2::strlen(move _6) -> bb1
  using: _6@Mir(bb0[2])
bb1:
  _4 = move _5 as i32 (IntToInt)
  using: _5@Mir(bb0[3])
  _9 = const {alloc326: *mut i32}
  using: 
  _8 = (*_9)
  using: _9@Mir(bb1[1])
  _3 = Ge(move _4, move _8)
  using: _4@Mir(bb1[0]), _8@Mir(bb1[2])
  switchInt(move _3) -> [0: bb2, otherwise: bb9]
  using: _3@Mir(bb1[3])
bb2:
  _2 = const 1_i32
  using: 
  goto -> bb3
  using: 
bb3:
  _11 = _2
  using: _2@Phi(bb3)
  _14 = const {alloc326: *mut i32}
  using: 
  _13 = (*_14)
  using: _14@Mir(bb3[1])
  _18 = _1
  using: _1@Entry
  _17 = move _18 as *const i8 (Pointer(MutToConstPointer))
  using: _18@Mir(bb3[3])
  _16 = bzip2::strlen(move _17) -> bb4
  using: _17@Mir(bb3[4])
bb4:
  _15 = move _16 as i32 (IntToInt)
  using: _16@Mir(bb3[5])
  _19 = CheckedSub(_13, _15)
  using: _13@Mir(bb3[2]), _15@Mir(bb4[0])
  assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", move _13, move _15) -> bb5
  using: _19@Entry, _13@Entry, _15@Entry
bb5:
  _12 = move (_19.0: i32)
  using: _19@Mir(bb4[1])
  _10 = Le(move _11, move _12)
  using: _11@Mir(bb3[0]), _12@Mir(bb5[0])
  switchInt(move _10) -> [0: bb9, otherwise: bb6]
  using: _10@Mir(bb5[1])
bb6:
  _22 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _21 = (*_22)
  using: _22@Mir(bb6[0])
  _26 = const b" \x00"
  using: 
  _25 = &raw const (*_26)
  using: _26@Mir(bb6[2])
  _24 = move _25 as *const u8 (Pointer(ArrayToPointer))
  using: _25@Mir(bb6[3])
  _23 = move _24 as *const i8 (PtrToPtr)
  using: _24@Mir(bb6[4])
  _20 = bzip2::fprintf(move _21, move _23) -> bb7
  using: _21@Mir(bb6[1]), _23@Mir(bb6[5])
bb7:
  _27 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb3)
  assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb8
  using: _27@Entry, _2@Entry
bb8:
  _2 = move (_27.0: i32)
  using: _27@Mir(bb7[0])
  goto -> bb3
  using: 
bb9:
  return
  using: _0@Entry
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1800:8: 1800:17 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1802:34: 1802:43 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1803:9: 1803:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:216 ~ c2rust_lib[1043]::bzip2::copyFileName)
bb0:
  _6 = _2
  using: _2@Entry
  _5 = move _6 as *const i8 (Pointer(MutToConstPointer))
  using: _6@Mir(bb0[0])
  _4 = bzip2::strlen(move _5) -> bb1
  using: _5@Mir(bb0[1])
bb1:
  _7 = const 1024_u64
  using: 
  _3 = Gt(move _4, move _7)
  using: _4@Mir(bb0[2]), _7@Mir(bb1[0])
  switchInt(move _3) -> [0: bb5, otherwise: bb2]
  using: _3@Mir(bb1[1])
bb2:
  _10 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _9 = (*_10)
  using: _10@Mir(bb2[0])
  _14 = const b"bzip2: file name\n`%s\'\nis suspiciously (more than %d chars) long.\nTry using a reasonable file name instead.  Sorry! :-)\n\x00"
  using: 
  _13 = &raw const (*_14)
  using: _14@Mir(bb2[2])
  _12 = move _13 as *const u8 (Pointer(ArrayToPointer))
  using: _13@Mir(bb2[3])
  _11 = move _12 as *const i8 (PtrToPtr)
  using: _12@Mir(bb2[4])
  _15 = _2
  using: _2@Entry
  _16 = const 1024_i32
  using: 
  _8 = bzip2::fprintf(move _9, move _11, move _15, move _16) -> bb3
  using: _9@Mir(bb2[1]), _11@Mir(bb2[5]), _15@Mir(bb2[6]), _16@Mir(bb2[7])
bb3:
  _18 = const 1_i32
  using: 
  _17 = bzip2::setExit(move _18) -> bb4
  using: _18@Mir(bb3[0])
bb4:
  _21 = const {alloc256: *mut i32}
  using: 
  _20 = (*_21)
  using: _21@Mir(bb4[0])
  _19 = bzip2::exit(move _20)
  using: _20@Mir(bb4[1])
bb5:
  _23 = _1
  using: _1@Entry
  _25 = _2
  using: _2@Entry
  _24 = move _25 as *const i8 (Pointer(MutToConstPointer))
  using: _25@Mir(bb5[1])
  _26 = const 1024_u64
  using: 
  _22 = bzip2::strncpy(move _23, move _24, move _26) -> bb6
  using: _23@Mir(bb5[0]), _24@Mir(bb5[2]), _26@Mir(bb5[3])
bb6:
  _27 = const 0_i32
  using: 
  _29 = _1
  using: _1@Entry
  _30 = const 1024_isize
  using: 
  _28 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _29, move _30) -> bb7
  using: _29@Mir(bb6[1]), _30@Mir(bb6[2])
bb7:
  (*_28) = move _27 as i8 (IntToInt)
  using: _28@Mir(bb6[3]), _27@Mir(bb6[0])
  return
  using: _0@Entry
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:1809:8: 1809:20 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:1811:9: 1814:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:1816:9: 1816:24 (#0) by default
rewrite call bzip2::strncpy @ workspace/bzip2/rust/bzip2.rs:1818:5: 1819:96 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:1820:9: 1820:83 (#0) by default
@DefId(0:217 ~ c2rust_lib[1043]::bzip2::fileExists)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = move _4 as *const i8 (Pointer(MutToConstPointer))
  using: _4@Mir(bb0[0])
  _8 = const b"rb\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _2 = bzip2::fopen(move _3, move _5) -> bb1
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5])
bb1:
  _11 = _2
  using: _2@Mir(bb0[6])
  _12 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _10 = Ne(move _11, move _12)
  using: _11@Mir(bb1[0]), _12@Mir(bb1[1])
  _9 = move _10 as i32 (IntToInt)
  using: _10@Mir(bb1[2])
  _0 = move _9 as u8 (IntToInt)
  using: _9@Mir(bb1[3])
  _15 = _2
  using: _2@Mir(bb0[6])
  _14 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _15) -> bb2
  using: _15@Mir(bb1[5])
bb2:
  _13 = Not(move _14)
  using: _14@Mir(bb1[6])
  switchInt(move _13) -> [0: bb4, otherwise: bb3]
  using: _13@Mir(bb2[0])
bb3:
  _17 = _2
  using: _2@Mir(bb0[6])
  _16 = bzip2::fclose(move _17) -> bb5
  using: _17@Mir(bb3[0])
bb4:
  _20 = _2
  using: _2@Mir(bb0[6])
  _19 = move _20 as usize (PointerExposeAddress)
  using: _20@Mir(bb4[0])
  _18 = Eq(move _19, const 0_usize)
  using: _19@Mir(bb4[1])
  assume(move _18)
  using: _18@Mir(bb4[2])
  goto -> bb5
  using: 
bb5:
  return
  using: _0@Mir(bb1[4])
rewrite call bzip2::fopen @ workspace/bzip2/rust/bzip2.rs:1826:9: 1826:75 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:1829:25: 1829:36 (#0) by default
@DefId(0:218 ~ c2rust_lib[1043]::bzip2::fopen_output_safely)
bb0:
  _3 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _4 = const 0_i32
  using: 
  _7 = _1
  using: _1@Entry
  _6 = move _7 as *const i8 (Pointer(MutToConstPointer))
  using: _7@Mir(bb0[2])
  _8 = const 2561_i32
  using: 
  _9 = const 384_i32
  using: 
  _5 = bzip2::open(move _6, move _8, move _9) -> bb1
  using: _6@Mir(bb0[3]), _8@Mir(bb0[4]), _9@Mir(bb0[5])
bb1:
  _4 = move _5
  using: _5@Mir(bb0[6])
  _11 = _4
  using: _4@Mir(bb1[0])
  _12 = const -1_i32
  using: 
  _10 = Eq(move _11, move _12)
  using: _11@Mir(bb1[1]), _12@Mir(bb1[2])
  switchInt(move _10) -> [0: bb3, otherwise: bb2]
  using: _10@Mir(bb1[3])
bb2:
  _0 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  goto -> bb8
  using: 
bb3:
  _14 = _4
  using: _4@Mir(bb1[0])
  _15 = _2
  using: _2@Entry
  _13 = bzip2::fdopen(move _14, move _15) -> bb4
  using: _14@Mir(bb3[0]), _15@Mir(bb3[1])
bb4:
  _3 = move _13
  using: _13@Mir(bb3[2])
  _17 = _3
  using: _3@Mir(bb4[0])
  _16 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _17) -> bb5
  using: _17@Mir(bb4[1])
bb5:
  switchInt(move _16) -> [0: bb7, otherwise: bb6]
  using: _16@Mir(bb4[2])
bb6:
  _20 = _3
  using: _3@Mir(bb4[0])
  _19 = move _20 as usize (PointerExposeAddress)
  using: _20@Mir(bb6[0])
  _18 = Eq(move _19, const 0_usize)
  using: _19@Mir(bb6[1])
  assume(move _18)
  using: _18@Mir(bb6[2])
  _22 = _4
  using: _4@Mir(bb1[0])
  _21 = bzip2::close(move _22) -> bb7
  using: _22@Mir(bb6[4])
bb7:
  _0 = _3
  using: _3@Phi(bb7)
  goto -> bb8
  using: 
bb8:
  return
  using: _0@Phi(bb8)
rewrite call bzip2::open @ workspace/bzip2/rust/bzip2.rs:1848:9: 1850:74 (#0) by default
rewrite call bzip2::fdopen @ workspace/bzip2/rust/bzip2.rs:1852:10: 1852:26 (#0) by default
rewrite call bzip2::close @ workspace/bzip2/rust/bzip2.rs:1853:65: 1853:74 (#0) by default
@DefId(0:219 ~ c2rust_lib[1043]::bzip2::notAStandardFile)
bb0:
  _2 = const 0_i32
  using: 
  Deinit(_4)
  using: 
  (_4.0: i64) = const 0_i64
  using: 
  (_4.1: i64) = const 0_i64
  using: 
  Deinit(_5)
  using: 
  (_5.0: i64) = const 0_i64
  using: 
  (_5.1: i64) = const 0_i64
  using: 
  Deinit(_6)
  using: 
  (_6.0: i64) = const 0_i64
  using: 
  (_6.1: i64) = const 0_i64
  using: 
  Deinit(_7)
  using: 
  (_7.0: i64) = const 0_i64
  using: 
  (_7.1: i64) = const 0_i64
  using: 
  _8 = [const 0_i64; 2]
  using: 
  Deinit(_3)
  using: 
  (_3.0: i32) = const 0_i32
  using: 
  (_3.1: u16) = const 0_u16
  using: 
  (_3.2: u16) = const 0_u16
  using: 
  (_3.3: u64) = const 0_u64
  using: 
  (_3.4: u32) = const 0_u32
  using: 
  (_3.5: u32) = const 0_u32
  using: 
  (_3.6: i32) = const 0_i32
  using: 
  (_3.7: bzip2::timespec) = move _4
  using: _4@Mir(bb0[1])
  (_3.8: bzip2::timespec) = move _5
  using: _5@Mir(bb0[4])
  (_3.9: bzip2::timespec) = move _6
  using: _6@Mir(bb0[7])
  (_3.10: bzip2::timespec) = move _7
  using: _7@Mir(bb0[10])
  (_3.11: i64) = const 0_i64
  using: 
  (_3.12: i64) = const 0_i64
  using: 
  (_3.13: i32) = const 0_i32
  using: 
  (_3.14: u32) = const 0_u32
  using: 
  (_3.15: u32) = const 0_u32
  using: 
  (_3.16: i32) = const 0_i32
  using: 
  (_3.17: [i64; 2]) = move _8
  using: _8@Mir(bb0[13])
  _11 = _1
  using: _1@Entry
  _10 = move _11 as *const i8 (Pointer(MutToConstPointer))
  using: _11@Mir(bb0[33])
  _13 = &mut _3
  using: _3@Mir(bb0[14])
  _12 = &raw mut (*_13)
  using: _13@Mir(bb0[35])
  _9 = bzip2::lstat(move _10, move _12) -> bb1
  using: _10@Mir(bb0[34]), _12@Mir(bb0[36])
bb1:
  _2 = move _9
  using: _9@Mir(bb0[37])
  _15 = _2
  using: _2@Mir(bb1[0])
  _16 = const 0_i32
  using: 
  _14 = Ne(move _15, move _16)
  using: _15@Mir(bb1[1]), _16@Mir(bb1[2])
  switchInt(move _14) -> [0: bb3, otherwise: bb2]
  using: _14@Mir(bb1[3])
bb2:
  _0 = const 1_u8
  using: 
  goto -> bb6
  using: 
bb3:
  _20 = (_3.1: u16)
  using: _3@Mir(bb0[14])
  _19 = move _20 as i32 (IntToInt)
  using: _20@Mir(bb3[0])
  _21 = const 61440_i32
  using: 
  _18 = BitAnd(move _19, move _21)
  using: _19@Mir(bb3[1]), _21@Mir(bb3[2])
  _22 = const 32768_i32
  using: 
  _17 = Eq(move _18, move _22)
  using: _18@Mir(bb3[3]), _22@Mir(bb3[4])
  switchInt(move _17) -> [0: bb5, otherwise: bb4]
  using: _17@Mir(bb3[5])
bb4:
  _0 = const 0_u8
  using: 
  goto -> bb6
  using: 
bb5:
  _0 = const 1_u8
  using: 
  goto -> bb6
  using: 
bb6:
  return
  using: _0@Phi(bb6)
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_4) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_5) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_6) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_7) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_3) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i64; 2] is not supported
rewrite call bzip2::lstat @ workspace/bzip2/rust/bzip2.rs:1881:9: 1881:34 (#0) by default
@DefId(0:221 ~ c2rust_lib[1043]::bzip2::countHardLinks)
bb0:
  _2 = const 0_i32
  using: 
  Deinit(_4)
  using: 
  (_4.0: i64) = const 0_i64
  using: 
  (_4.1: i64) = const 0_i64
  using: 
  Deinit(_5)
  using: 
  (_5.0: i64) = const 0_i64
  using: 
  (_5.1: i64) = const 0_i64
  using: 
  Deinit(_6)
  using: 
  (_6.0: i64) = const 0_i64
  using: 
  (_6.1: i64) = const 0_i64
  using: 
  Deinit(_7)
  using: 
  (_7.0: i64) = const 0_i64
  using: 
  (_7.1: i64) = const 0_i64
  using: 
  _8 = [const 0_i64; 2]
  using: 
  Deinit(_3)
  using: 
  (_3.0: i32) = const 0_i32
  using: 
  (_3.1: u16) = const 0_u16
  using: 
  (_3.2: u16) = const 0_u16
  using: 
  (_3.3: u64) = const 0_u64
  using: 
  (_3.4: u32) = const 0_u32
  using: 
  (_3.5: u32) = const 0_u32
  using: 
  (_3.6: i32) = const 0_i32
  using: 
  (_3.7: bzip2::timespec) = move _4
  using: _4@Mir(bb0[1])
  (_3.8: bzip2::timespec) = move _5
  using: _5@Mir(bb0[4])
  (_3.9: bzip2::timespec) = move _6
  using: _6@Mir(bb0[7])
  (_3.10: bzip2::timespec) = move _7
  using: _7@Mir(bb0[10])
  (_3.11: i64) = const 0_i64
  using: 
  (_3.12: i64) = const 0_i64
  using: 
  (_3.13: i32) = const 0_i32
  using: 
  (_3.14: u32) = const 0_u32
  using: 
  (_3.15: u32) = const 0_u32
  using: 
  (_3.16: i32) = const 0_i32
  using: 
  (_3.17: [i64; 2]) = move _8
  using: _8@Mir(bb0[13])
  _11 = _1
  using: _1@Entry
  _10 = move _11 as *const i8 (Pointer(MutToConstPointer))
  using: _11@Mir(bb0[33])
  _13 = &mut _3
  using: _3@Mir(bb0[14])
  _12 = &raw mut (*_13)
  using: _13@Mir(bb0[35])
  _9 = bzip2::lstat(move _10, move _12) -> bb1
  using: _10@Mir(bb0[34]), _12@Mir(bb0[36])
bb1:
  _2 = move _9
  using: _9@Mir(bb0[37])
  _15 = _2
  using: _2@Mir(bb1[0])
  _16 = const 0_i32
  using: 
  _14 = Ne(move _15, move _16)
  using: _15@Mir(bb1[1]), _16@Mir(bb1[2])
  switchInt(move _14) -> [0: bb3, otherwise: bb2]
  using: _14@Mir(bb1[3])
bb2:
  _0 = const 0_i32
  using: 
  goto -> bb5
  using: 
bb3:
  _18 = (_3.2: u16)
  using: _3@Mir(bb0[14])
  _17 = move _18 as i32 (IntToInt)
  using: _18@Mir(bb3[0])
  _19 = const 1_i32
  using: 
  _20 = CheckedSub(_17, _19)
  using: _17@Mir(bb3[1]), _19@Mir(bb3[2])
  assert(!move (_20.1: bool), "attempt to compute `{} - {}`, which would overflow", move _17, move _19) -> bb4
  using: _20@Entry, _17@Entry, _19@Entry
bb4:
  _0 = move (_20.0: i32)
  using: _20@Mir(bb3[3])
  goto -> bb5
  using: 
bb5:
  return
  using: _0@Phi(bb5)
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_4) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_5) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_6) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_7) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_3) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i64; 2] is not supported
rewrite call bzip2::lstat @ workspace/bzip2/rust/bzip2.rs:1914:9: 1914:34 (#0) by default
@DefId(0:225 ~ c2rust_lib[1043]::bzip2::saveInputFileMetaInfo)
bb0:
  _2 = const 0_i32
  using: 
  _5 = _1
  using: _1@Entry
  _4 = move _5 as *const i8 (Pointer(MutToConstPointer))
  using: _5@Mir(bb0[1])
  _8 = const {alloc371: *mut bzip2::stat}
  using: 
  _7 = &mut (*_8)
  using: _8@Mir(bb0[3])
  _6 = &raw mut (*_7)
  using: _7@Mir(bb0[4])
  _3 = bzip2::stat(move _4, move _6) -> bb1
  using: _4@Mir(bb0[2]), _6@Mir(bb0[5])
bb1:
  _2 = move _3
  using: _3@Mir(bb0[6])
  _10 = _2
  using: _2@Mir(bb1[0])
  _11 = const 0_i32
  using: 
  _9 = Ne(move _10, move _11)
  using: _10@Mir(bb1[1]), _11@Mir(bb1[2])
  switchInt(move _9) -> [0: bb3, otherwise: bb2]
  using: _9@Mir(bb1[3])
bb2:
  _12 = bzip2::ioError()
  using: 
bb3:
  return
  using: _0@Entry
rewrite call bzip2::stat @ workspace/bzip2/rust/bzip2.rs:1963:14: 1963:46 (#0) by default
@DefId(0:226 ~ c2rust_lib[1043]::bzip2::applySavedTimeInfoToOutputFile)
bb0:
  _2 = const 0_i32
  using: 
  Deinit(_3)
  using: 
  (_3.0: i64) = const 0_i64
  using: 
  (_3.1: i64) = const 0_i64
  using: 
  _5 = const {alloc371: *mut bzip2::stat}
  using: 
  _4 = (((*_5).7: bzip2::timespec).0: i64)
  using: _5@Mir(bb0[4])
  (_3.0: i64) = move _4
  using: _4@Mir(bb0[5])
  _7 = const {alloc371: *mut bzip2::stat}
  using: 
  _6 = (((*_7).8: bzip2::timespec).0: i64)
  using: _7@Mir(bb0[7])
  (_3.1: i64) = move _6
  using: _6@Mir(bb0[8])
  _10 = _1
  using: _1@Entry
  _9 = move _10 as *const i8 (Pointer(MutToConstPointer))
  using: _10@Mir(bb0[10])
  _12 = &mut _3
  using: _3@Mir(bb0[1])
  _11 = &raw const (*_12)
  using: _12@Mir(bb0[12])
  _8 = bzip2::utime(move _9, move _11) -> bb1
  using: _9@Mir(bb0[11]), _11@Mir(bb0[13])
bb1:
  _2 = move _8
  using: _8@Mir(bb0[14])
  _14 = _2
  using: _2@Mir(bb1[0])
  _15 = const 0_i32
  using: 
  _13 = Ne(move _14, move _15)
  using: _14@Mir(bb1[1]), _15@Mir(bb1[2])
  switchInt(move _13) -> [0: bb3, otherwise: bb2]
  using: _13@Mir(bb1[3])
bb2:
  _16 = bzip2::ioError()
  using: 
bb3:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_3) is ignored
rewrite call bzip2::utime @ workspace/bzip2/rust/bzip2.rs:1971:14: 1971:42 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:227 ~ c2rust_lib[1043]::bzip2::applySavedFileAttrToOutputFile)
bb0:
  _2 = const 0_i32
  using: 
  _4 = _1
  using: _1@Entry
  _6 = const {alloc371: *mut bzip2::stat}
  using: 
  _5 = ((*_6).1: u16)
  using: _6@Mir(bb0[2])
  _3 = bzip2::fchmod(move _4, move _5) -> bb1
  using: _4@Mir(bb0[1]), _5@Mir(bb0[3])
bb1:
  _2 = move _3
  using: _3@Mir(bb0[4])
  _8 = _2
  using: _2@Mir(bb1[0])
  _9 = const 0_i32
  using: 
  _7 = Ne(move _8, move _9)
  using: _8@Mir(bb1[1]), _9@Mir(bb1[2])
  switchInt(move _7) -> [0: bb3, otherwise: bb2]
  using: _7@Mir(bb1[3])
bb2:
  _10 = bzip2::ioError()
  using: 
bb3:
  _12 = _1
  using: _1@Entry
  _14 = const {alloc371: *mut bzip2::stat}
  using: 
  _13 = ((*_14).4: u32)
  using: _14@Mir(bb3[1])
  _16 = const {alloc371: *mut bzip2::stat}
  using: 
  _15 = ((*_16).5: u32)
  using: _16@Mir(bb3[3])
  _11 = bzip2::fchown(move _12, move _13, move _15) -> bb4
  using: _12@Mir(bb3[0]), _13@Mir(bb3[2]), _15@Mir(bb3[4])
bb4:
  return
  using: _0@Entry
rewrite call bzip2::fchmod @ workspace/bzip2/rust/bzip2.rs:1976:14: 1976:46 (#0) by default
rewrite call bzip2::fchown @ workspace/bzip2/rust/bzip2.rs:1978:5: 1978:57 (#0) by default
@DefId(0:228 ~ c2rust_lib[1043]::bzip2::containsDubiousChars)
bb0:
  _0 = const 0_u8
  using: 
  return
  using: _0@Mir(bb0[0])
@DefId(0:233 ~ c2rust_lib[1043]::bzip2::hasSuffix)
bb0:
  _6 = _1
  using: _1@Entry
  _5 = move _6 as *const i8 (Pointer(MutToConstPointer))
  using: _6@Mir(bb0[0])
  _4 = bzip2::strlen(move _5) -> bb1
  using: _5@Mir(bb0[1])
bb1:
  _3 = move _4 as i32 (IntToInt)
  using: _4@Mir(bb0[2])
  _9 = _2
  using: _2@Entry
  _8 = bzip2::strlen(move _9) -> bb2
  using: _9@Mir(bb1[1])
bb2:
  _7 = move _8 as i32 (IntToInt)
  using: _8@Mir(bb1[2])
  _11 = _3
  using: _3@Mir(bb1[0])
  _12 = _7
  using: _7@Mir(bb2[0])
  _10 = Lt(move _11, move _12)
  using: _11@Mir(bb2[1]), _12@Mir(bb2[2])
  switchInt(move _10) -> [0: bb4, otherwise: bb3]
  using: _10@Mir(bb2[3])
bb3:
  _0 = const 0_u8
  using: 
  goto -> bb11
  using: 
bb4:
  _18 = _1
  using: _1@Entry
  _20 = _3
  using: _3@Mir(bb1[0])
  _19 = move _20 as isize (IntToInt)
  using: _20@Mir(bb4[1])
  _17 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _18, move _19) -> bb5
  using: _18@Mir(bb4[0]), _19@Mir(bb4[2])
bb5:
  _23 = _7
  using: _7@Mir(bb2[0])
  _22 = move _23 as isize (IntToInt)
  using: _23@Mir(bb5[0])
  _24 = Eq(_22, const isize::MIN)
  using: _22@Mir(bb5[1])
  assert(!move _24, "attempt to negate `{}`, which would overflow", _22) -> bb6
  using: _24@Entry, _22@Entry
bb6:
  _21 = Neg(move _22)
  using: _22@Mir(bb5[1])
  _16 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _17, move _21) -> bb7
  using: _17@Mir(bb4[3]), _21@Mir(bb6[0])
bb7:
  _15 = move _16 as *const i8 (Pointer(MutToConstPointer))
  using: _16@Mir(bb6[1])
  _25 = _2
  using: _2@Entry
  _14 = bzip2::strcmp(move _15, move _25) -> bb8
  using: _15@Mir(bb7[0]), _25@Mir(bb7[1])
bb8:
  _26 = const 0_i32
  using: 
  _13 = Eq(move _14, move _26)
  using: _14@Mir(bb7[2]), _26@Mir(bb8[0])
  switchInt(move _13) -> [0: bb10, otherwise: bb9]
  using: _13@Mir(bb8[1])
bb9:
  _0 = const 1_u8
  using: 
  goto -> bb11
  using: 
bb10:
  _0 = const 0_u8
  using: 
  goto -> bb11
  using: 
bb11:
  return
  using: _0@Phi(bb11)
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:2006:25: 2006:34 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:2007:25: 2007:39 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2009:17: 2009:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2009:37: 2009:59 (#0) by default
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2009:8: 2009:68 (#0) by default
@DefId(0:234 ~ c2rust_lib[1043]::bzip2::mapSuffix)
bb0:
  _5 = _1
  using: _1@Entry
  _6 = _2
  using: _2@Entry
  _4 = bzip2::hasSuffix(move _5, move _6) -> bb1
  using: _5@Mir(bb0[0]), _6@Mir(bb0[1])
bb1:
  switchInt(move _4) -> [0: bb2, otherwise: bb3]
  using: _4@Mir(bb0[2])
bb2:
  _0 = const 0_u8
  using: 
  goto -> bb9
  using: 
bb3:
  _7 = const 0_i32
  using: 
  _9 = _1
  using: _1@Entry
  _14 = _1
  using: _1@Entry
  _13 = move _14 as *const i8 (Pointer(MutToConstPointer))
  using: _14@Mir(bb3[2])
  _12 = bzip2::strlen(move _13) -> bb4
  using: _13@Mir(bb3[3])
bb4:
  _16 = _2
  using: _2@Entry
  _15 = bzip2::strlen(move _16) -> bb5
  using: _16@Mir(bb4[0])
bb5:
  _11 = core::num::<impl u64>::wrapping_sub(move _12, move _15) -> bb6
  using: _12@Mir(bb3[4]), _15@Mir(bb4[1])
bb6:
  _10 = move _11 as isize (IntToInt)
  using: _11@Mir(bb5[0])
  _8 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _9, move _10) -> bb7
  using: _9@Mir(bb3[1]), _10@Mir(bb6[0])
bb7:
  (*_8) = move _7 as i8 (IntToInt)
  using: _8@Mir(bb6[1]), _7@Mir(bb3[0])
  _18 = _1
  using: _1@Entry
  _19 = _3
  using: _3@Entry
  _17 = bzip2::strcat(move _18, move _19) -> bb8
  using: _18@Mir(bb7[1]), _19@Mir(bb7[2])
bb8:
  _0 = const 1_u8
  using: 
  goto -> bb9
  using: 
bb9:
  return
  using: _0@Phi(bb9)
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:2019:18: 2019:30 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:2019:44: 2019:61 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/bzip2/rust/bzip2.rs:2019:31: 2019:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2019:11: 2019:72 (#0) by default
rewrite call bzip2::strcat @ workspace/bzip2/rust/bzip2.rs:2021:5: 2021:28 (#0) by default
@DefId(0:235 ~ c2rust_lib[1043]::bzip2::compress)
bb0:
  _2 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _3 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  Deinit(_7)
  using: 
  (_7.0: i64) = const 0_i64
  using: 
  (_7.1: i64) = const 0_i64
  using: 
  Deinit(_8)
  using: 
  (_8.0: i64) = const 0_i64
  using: 
  (_8.1: i64) = const 0_i64
  using: 
  Deinit(_9)
  using: 
  (_9.0: i64) = const 0_i64
  using: 
  (_9.1: i64) = const 0_i64
  using: 
  Deinit(_10)
  using: 
  (_10.0: i64) = const 0_i64
  using: 
  (_10.1: i64) = const 0_i64
  using: 
  _11 = [const 0_i64; 2]
  using: 
  Deinit(_6)
  using: 
  (_6.0: i32) = const 0_i32
  using: 
  (_6.1: u16) = const 0_u16
  using: 
  (_6.2: u16) = const 0_u16
  using: 
  (_6.3: u64) = const 0_u64
  using: 
  (_6.4: u32) = const 0_u32
  using: 
  (_6.5: u32) = const 0_u32
  using: 
  (_6.6: i32) = const 0_i32
  using: 
  (_6.7: bzip2::timespec) = move _7
  using: _7@Mir(bb0[4])
  (_6.8: bzip2::timespec) = move _8
  using: _8@Mir(bb0[7])
  (_6.9: bzip2::timespec) = move _9
  using: _9@Mir(bb0[10])
  (_6.10: bzip2::timespec) = move _10
  using: _10@Mir(bb0[13])
  (_6.11: i64) = const 0_i64
  using: 
  (_6.12: i64) = const 0_i64
  using: 
  (_6.13: i32) = const 0_i32
  using: 
  (_6.14: u32) = const 0_u32
  using: 
  (_6.15: u32) = const 0_u32
  using: 
  (_6.16: i32) = const 0_i32
  using: 
  (_6.17: [i64; 2]) = move _11
  using: _11@Mir(bb0[16])
  _12 = const 0_i32
  using: 
  _13 = const {alloc269: *mut u8}
  using: 
  (*_13) = move _12 as u8 (IntToInt)
  using: _13@Mir(bb0[37]), _12@Mir(bb0[36])
  _16 = _1
  using: _1@Entry
  _15 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _16) -> bb4
  using: _16@Mir(bb0[39])
bb1:
  _14 = const false
  using: 
  goto -> bb3
  using: 
bb2:
  _19 = const {alloc267: *mut i32}
  using: 
  _18 = (*_19)
  using: _19@Mir(bb2[0])
  _20 = const 1_i32
  using: 
  _17 = Ne(move _18, move _20)
  using: _18@Mir(bb2[1]), _20@Mir(bb2[2])
  _14 = move _17
  using: _17@Mir(bb2[3])
  goto -> bb3
  using: 
bb3:
  switchInt(move _14) -> [0: bb6, otherwise: bb5]
  using: _14@Phi(bb3)
bb4:
  switchInt(move _15) -> [0: bb1, otherwise: bb2]
  using: _15@Mir(bb0[40])
bb5:
  _25 = const b"compress: bad modes\n\x00"
  using: 
  _24 = &raw const (*_25)
  using: _25@Mir(bb5[0])
  _23 = move _24 as *const u8 (Pointer(ArrayToPointer))
  using: _24@Mir(bb5[1])
  _22 = move _23 as *const i8 (PtrToPtr)
  using: _23@Mir(bb5[2])
  _21 = bzip2::panic(move _22)
  using: _22@Mir(bb5[3])
bb6:
  _26 = const {alloc267: *mut i32}
  using: 
  switchInt((*_26)) -> [1: bb7, 3: bb11, 2: bb17, otherwise: bb21]
  using: _26@Mir(bb6[0])
bb7:
  _31 = const {alloc198: *mut [i8; 1034]}
  using: 
  _30 = &mut (*_31)
  using: _31@Mir(bb7[0])
  _29 = move _30 as &mut [i8] (Pointer(Unsize))
  using: _30@Mir(bb7[1])
  _28 = core::slice::<impl [i8]>::as_mut_ptr(move _29) -> bb8
  using: _29@Mir(bb7[2])
bb8:
  _36 = const b"(stdin)\x00"
  using: 
  _35 = &raw const (*_36)
  using: _36@Mir(bb8[0])
  _34 = move _35 as *const u8 (Pointer(ArrayToPointer))
  using: _35@Mir(bb8[1])
  _33 = move _34 as *const i8 (PtrToPtr)
  using: _34@Mir(bb8[2])
  _32 = move _33 as *mut i8 (PtrToPtr)
  using: _33@Mir(bb8[3])
  _27 = bzip2::copyFileName(move _28, move _32) -> bb9
  using: _28@Mir(bb7[3]), _32@Mir(bb8[4])
bb9:
  _41 = const {alloc263: *mut [i8; 1034]}
  using: 
  _40 = &mut (*_41)
  using: _41@Mir(bb9[0])
  _39 = move _40 as &mut [i8] (Pointer(Unsize))
  using: _40@Mir(bb9[1])
  _38 = core::slice::<impl [i8]>::as_mut_ptr(move _39) -> bb10
  using: _39@Mir(bb9[2])
bb10:
  _46 = const b"(stdout)\x00"
  using: 
  _45 = &raw const (*_46)
  using: _46@Mir(bb10[0])
  _44 = move _45 as *const u8 (Pointer(ArrayToPointer))
  using: _45@Mir(bb10[1])
  _43 = move _44 as *const i8 (PtrToPtr)
  using: _44@Mir(bb10[2])
  _42 = move _43 as *mut i8 (PtrToPtr)
  using: _43@Mir(bb10[3])
  _37 = bzip2::copyFileName(move _38, move _42) -> bb21
  using: _38@Mir(bb9[3]), _42@Mir(bb10[4])
bb11:
  _51 = const {alloc198: *mut [i8; 1034]}
  using: 
  _50 = &mut (*_51)
  using: _51@Mir(bb11[0])
  _49 = move _50 as &mut [i8] (Pointer(Unsize))
  using: _50@Mir(bb11[1])
  _48 = core::slice::<impl [i8]>::as_mut_ptr(move _49) -> bb12
  using: _49@Mir(bb11[2])
bb12:
  _52 = _1
  using: _1@Entry
  _47 = bzip2::copyFileName(move _48, move _52) -> bb13
  using: _48@Mir(bb11[3]), _52@Mir(bb12[0])
bb13:
  _57 = const {alloc263: *mut [i8; 1034]}
  using: 
  _56 = &mut (*_57)
  using: _57@Mir(bb13[0])
  _55 = move _56 as &mut [i8] (Pointer(Unsize))
  using: _56@Mir(bb13[1])
  _54 = core::slice::<impl [i8]>::as_mut_ptr(move _55) -> bb14
  using: _55@Mir(bb13[2])
bb14:
  _58 = _1
  using: _1@Entry
  _53 = bzip2::copyFileName(move _54, move _58) -> bb15
  using: _54@Mir(bb13[3]), _58@Mir(bb14[0])
bb15:
  _63 = const {alloc263: *mut [i8; 1034]}
  using: 
  _62 = &mut (*_63)
  using: _63@Mir(bb15[0])
  _61 = move _62 as &mut [i8] (Pointer(Unsize))
  using: _62@Mir(bb15[1])
  _60 = core::slice::<impl [i8]>::as_mut_ptr(move _61) -> bb16
  using: _61@Mir(bb15[2])
bb16:
  _67 = const b".bz2\x00"
  using: 
  _66 = &raw const (*_67)
  using: _67@Mir(bb16[0])
  _65 = move _66 as *const u8 (Pointer(ArrayToPointer))
  using: _66@Mir(bb16[1])
  _64 = move _65 as *const i8 (PtrToPtr)
  using: _65@Mir(bb16[2])
  _59 = bzip2::strcat(move _60, move _64) -> bb21
  using: _60@Mir(bb15[3]), _64@Mir(bb16[3])
bb17:
  _72 = const {alloc198: *mut [i8; 1034]}
  using: 
  _71 = &mut (*_72)
  using: _72@Mir(bb17[0])
  _70 = move _71 as &mut [i8] (Pointer(Unsize))
  using: _71@Mir(bb17[1])
  _69 = core::slice::<impl [i8]>::as_mut_ptr(move _70) -> bb18
  using: _70@Mir(bb17[2])
bb18:
  _73 = _1
  using: _1@Entry
  _68 = bzip2::copyFileName(move _69, move _73) -> bb19
  using: _69@Mir(bb17[3]), _73@Mir(bb18[0])
bb19:
  _78 = const {alloc263: *mut [i8; 1034]}
  using: 
  _77 = &mut (*_78)
  using: _78@Mir(bb19[0])
  _76 = move _77 as &mut [i8] (Pointer(Unsize))
  using: _77@Mir(bb19[1])
  _75 = core::slice::<impl [i8]>::as_mut_ptr(move _76) -> bb20
  using: _76@Mir(bb19[2])
bb20:
  _83 = const b"(stdout)\x00"
  using: 
  _82 = &raw const (*_83)
  using: _83@Mir(bb20[0])
  _81 = move _82 as *const u8 (Pointer(ArrayToPointer))
  using: _82@Mir(bb20[1])
  _80 = move _81 as *const i8 (PtrToPtr)
  using: _81@Mir(bb20[2])
  _79 = move _80 as *mut i8 (PtrToPtr)
  using: _80@Mir(bb20[3])
  _74 = bzip2::copyFileName(move _75, move _79) -> bb21
  using: _75@Mir(bb19[3]), _79@Mir(bb20[4])
bb21:
  _87 = const {alloc267: *mut i32}
  using: 
  _86 = (*_87)
  using: _87@Mir(bb21[0])
  _88 = const 1_i32
  using: 
  _85 = Ne(move _86, move _88)
  using: _86@Mir(bb21[1]), _88@Mir(bb21[2])
  switchInt(move _85) -> [0: bb22, otherwise: bb23]
  using: _85@Mir(bb21[3])
bb22:
  _84 = const false
  using: 
  goto -> bb24
  using: 
bb23:
  _95 = const {alloc198: *mut [i8; 1034]}
  using: 
  _94 = &mut (*_95)
  using: _95@Mir(bb23[0])
  _93 = move _94 as &mut [i8] (Pointer(Unsize))
  using: _94@Mir(bb23[1])
  _92 = core::slice::<impl [i8]>::as_mut_ptr(move _93) -> bb25
  using: _93@Mir(bb23[2])
bb24:
  switchInt(move _84) -> [0: bb31, otherwise: bb27]
  using: _84@Phi(bb24)
bb25:
  _91 = bzip2::containsDubiousChars(move _92) -> bb26
  using: _92@Mir(bb23[3])
bb26:
  _90 = move _91 as i32 (IntToInt)
  using: _91@Mir(bb25[0])
  _89 = Ne(move _90, const 0_i32)
  using: _90@Mir(bb26[0])
  _84 = move _89
  using: _89@Mir(bb26[1])
  goto -> bb24
  using: 
bb27:
  _97 = const {alloc196: *mut u8}
  using: 
  _96 = (*_97)
  using: _97@Mir(bb27[0])
  switchInt(move _96) -> [0: bb30, otherwise: bb28]
  using: _96@Mir(bb27[1])
bb28:
  _100 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _99 = (*_100)
  using: _100@Mir(bb28[0])
  _104 = const b"%s: There are no files matching `%s\'.\n\x00"
  using: 
  _103 = &raw const (*_104)
  using: _104@Mir(bb28[2])
  _102 = move _103 as *const u8 (Pointer(ArrayToPointer))
  using: _103@Mir(bb28[3])
  _101 = move _102 as *const i8 (PtrToPtr)
  using: _102@Mir(bb28[4])
  _106 = const {alloc197: *mut *mut i8}
  using: 
  _105 = (*_106)
  using: _106@Mir(bb28[6])
  _110 = const {alloc198: *mut [i8; 1034]}
  using: 
  _109 = &mut (*_110)
  using: _110@Mir(bb28[8])
  _108 = move _109 as &mut [i8] (Pointer(Unsize))
  using: _109@Mir(bb28[9])
  _107 = core::slice::<impl [i8]>::as_mut_ptr(move _108) -> bb29
  using: _108@Mir(bb28[10])
bb29:
  _98 = bzip2::fprintf(move _99, move _101, move _105, move _107) -> bb30
  using: _99@Mir(bb28[1]), _101@Mir(bb28[5]), _105@Mir(bb28[7]), _107@Mir(bb28[11])
bb30:
  _112 = const 1_i32
  using: 
  _111 = bzip2::setExit(move _112) -> bb177
  using: _112@Mir(bb30[0])
bb31:
  _116 = const {alloc267: *mut i32}
  using: 
  _115 = (*_116)
  using: _116@Mir(bb31[0])
  _117 = const 1_i32
  using: 
  _114 = Ne(move _115, move _117)
  using: _115@Mir(bb31[1]), _117@Mir(bb31[2])
  switchInt(move _114) -> [0: bb32, otherwise: bb33]
  using: _114@Mir(bb31[3])
bb32:
  _113 = const false
  using: 
  goto -> bb34
  using: 
bb33:
  _123 = const {alloc198: *mut [i8; 1034]}
  using: 
  _122 = &mut (*_123)
  using: _123@Mir(bb33[0])
  _121 = move _122 as &mut [i8] (Pointer(Unsize))
  using: _122@Mir(bb33[1])
  _120 = core::slice::<impl [i8]>::as_mut_ptr(move _121) -> bb35
  using: _121@Mir(bb33[2])
bb34:
  switchInt(move _113) -> [0: bb42, otherwise: bb37]
  using: _113@Phi(bb34)
bb35:
  _119 = bzip2::fileExists(move _120) -> bb36
  using: _120@Mir(bb33[3])
bb36:
  _118 = Eq(move _119, const 0_u8)
  using: _119@Mir(bb35[0])
  _113 = move _118
  using: _118@Mir(bb36[0])
  goto -> bb34
  using: 
bb37:
  _126 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _125 = (*_126)
  using: _126@Mir(bb37[0])
  _130 = const b"%s: Can\'t open input file %s: %s.\n\x00"
  using: 
  _129 = &raw const (*_130)
  using: _130@Mir(bb37[2])
  _128 = move _129 as *const u8 (Pointer(ArrayToPointer))
  using: _129@Mir(bb37[3])
  _127 = move _128 as *const i8 (PtrToPtr)
  using: _128@Mir(bb37[4])
  _132 = const {alloc197: *mut *mut i8}
  using: 
  _131 = (*_132)
  using: _132@Mir(bb37[6])
  _136 = const {alloc198: *mut [i8; 1034]}
  using: 
  _135 = &mut (*_136)
  using: _136@Mir(bb37[8])
  _134 = move _135 as &mut [i8] (Pointer(Unsize))
  using: _135@Mir(bb37[9])
  _133 = core::slice::<impl [i8]>::as_mut_ptr(move _134) -> bb38
  using: _134@Mir(bb37[10])
bb38:
  _139 = bzip2::__error() -> bb39
  using: 
bb39:
  _138 = (*_139)
  using: _139@Mir(bb38[0])
  _137 = bzip2::strerror(move _138) -> bb40
  using: _138@Mir(bb39[0])
bb40:
  _124 = bzip2::fprintf(move _125, move _127, move _131, move _133, move _137) -> bb41
  using: _125@Mir(bb37[1]), _127@Mir(bb37[5]), _131@Mir(bb37[7]), _133@Mir(bb37[11]), _137@Mir(bb39[1])
bb41:
  _141 = const 1_i32
  using: 
  _140 = bzip2::setExit(move _141) -> bb177
  using: _141@Mir(bb41[0])
bb42:
  _5 = const 0_i32
  using: 
  goto -> bb43
  using: 
bb43:
  _143 = _5
  using: _5@Phi(bb43)
  _144 = const 4_i32
  using: 
  _142 = Lt(move _143, move _144)
  using: _143@Mir(bb43[0]), _144@Mir(bb43[1])
  switchInt(move _142) -> [0: bb55, otherwise: bb44]
  using: _142@Mir(bb43[2])
bb44:
  _149 = const {alloc198: *mut [i8; 1034]}
  using: 
  _148 = &mut (*_149)
  using: _149@Mir(bb44[0])
  _147 = move _148 as &mut [i8] (Pointer(Unsize))
  using: _148@Mir(bb44[1])
  _146 = core::slice::<impl [i8]>::as_mut_ptr(move _147) -> bb45
  using: _147@Mir(bb44[2])
bb45:
  _151 = const {alloc391: *mut [*const i8; 4]}
  using: 
  _153 = _5
  using: _5@Phi(bb43)
  _152 = move _153 as usize (IntToInt)
  using: _153@Mir(bb45[1])
  _154 = const 4_usize
  using: 
  _155 = Lt(_152, _154)
  using: _152@Mir(bb45[2]), _154@Mir(bb45[3])
  assert(move _155, "index out of bounds: the length is {} but the index is {}", move _154, _152) -> bb46
  using: _155@Entry, _154@Entry, _152@Entry
bb46:
  _150 = (*_151)[_152]
  using: _151@Mir(bb45[0]), _152@Mir(bb45[2])
  _145 = bzip2::hasSuffix(move _146, move _150) -> bb47
  using: _146@Mir(bb44[3]), _150@Mir(bb46[0])
bb47:
  switchInt(move _145) -> [0: bb53, otherwise: bb48]
  using: _145@Mir(bb46[1])
bb48:
  _157 = const {alloc196: *mut u8}
  using: 
  _156 = (*_157)
  using: _157@Mir(bb48[0])
  switchInt(move _156) -> [0: bb52, otherwise: bb49]
  using: _156@Mir(bb48[1])
bb49:
  _160 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _159 = (*_160)
  using: _160@Mir(bb49[0])
  _164 = const b"%s: Input file %s already has %s suffix.\n\x00"
  using: 
  _163 = &raw const (*_164)
  using: _164@Mir(bb49[2])
  _162 = move _163 as *const u8 (Pointer(ArrayToPointer))
  using: _163@Mir(bb49[3])
  _161 = move _162 as *const i8 (PtrToPtr)
  using: _162@Mir(bb49[4])
  _166 = const {alloc197: *mut *mut i8}
  using: 
  _165 = (*_166)
  using: _166@Mir(bb49[6])
  _170 = const {alloc198: *mut [i8; 1034]}
  using: 
  _169 = &mut (*_170)
  using: _170@Mir(bb49[8])
  _168 = move _169 as &mut [i8] (Pointer(Unsize))
  using: _169@Mir(bb49[9])
  _167 = core::slice::<impl [i8]>::as_mut_ptr(move _168) -> bb50
  using: _168@Mir(bb49[10])
bb50:
  _172 = const {alloc391: *mut [*const i8; 4]}
  using: 
  _174 = _5
  using: _5@Phi(bb43)
  _173 = move _174 as usize (IntToInt)
  using: _174@Mir(bb50[1])
  _175 = const 4_usize
  using: 
  _176 = Lt(_173, _175)
  using: _173@Mir(bb50[2]), _175@Mir(bb50[3])
  assert(move _176, "index out of bounds: the length is {} but the index is {}", move _175, _173) -> bb51
  using: _176@Entry, _175@Entry, _173@Entry
bb51:
  _171 = (*_172)[_173]
  using: _172@Mir(bb50[0]), _173@Mir(bb50[2])
  _158 = bzip2::fprintf(move _159, move _161, move _165, move _167, move _171) -> bb52
  using: _159@Mir(bb49[1]), _161@Mir(bb49[5]), _165@Mir(bb49[7]), _167@Mir(bb49[11]), _171@Mir(bb51[0])
bb52:
  _178 = const 1_i32
  using: 
  _177 = bzip2::setExit(move _178) -> bb177
  using: _178@Mir(bb52[0])
bb53:
  _179 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb52)
  assert(!move (_179.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb54
  using: _179@Entry, _5@Entry
bb54:
  _5 = move (_179.0: i32)
  using: _179@Mir(bb53[0])
  goto -> bb43
  using: 
bb55:
  _183 = const {alloc267: *mut i32}
  using: 
  _182 = (*_183)
  using: _183@Mir(bb55[0])
  _184 = const 3_i32
  using: 
  _181 = Eq(move _182, move _184)
  using: _182@Mir(bb55[1]), _184@Mir(bb55[2])
  switchInt(move _181) -> [0: bb57, otherwise: bb56]
  using: _181@Mir(bb55[3])
bb56:
  _180 = const true
  using: 
  goto -> bb58
  using: 
bb57:
  _187 = const {alloc267: *mut i32}
  using: 
  _186 = (*_187)
  using: _187@Mir(bb57[0])
  _188 = const 2_i32
  using: 
  _185 = Eq(move _186, move _188)
  using: _186@Mir(bb57[1]), _188@Mir(bb57[2])
  _180 = move _185
  using: _185@Mir(bb57[3])
  goto -> bb58
  using: 
bb58:
  switchInt(move _180) -> [0: bb65, otherwise: bb59]
  using: _180@Phi(bb58)
bb59:
  _194 = const {alloc198: *mut [i8; 1034]}
  using: 
  _193 = &mut (*_194)
  using: _194@Mir(bb59[0])
  _192 = move _193 as &mut [i8] (Pointer(Unsize))
  using: _193@Mir(bb59[1])
  _191 = core::slice::<impl [i8]>::as_mut_ptr(move _192) -> bb60
  using: _192@Mir(bb59[2])
bb60:
  _190 = move _191 as *const i8 (Pointer(MutToConstPointer))
  using: _191@Mir(bb59[3])
  _196 = &mut _6
  using: _6@Mir(bb0[17])
  _195 = &raw mut (*_196)
  using: _196@Mir(bb60[1])
  _189 = bzip2::stat(move _190, move _195) -> bb61
  using: _190@Mir(bb60[0]), _195@Mir(bb60[2])
bb61:
  _200 = (_6.1: u16)
  using: _6@Mir(bb0[17])
  _199 = move _200 as i32 (IntToInt)
  using: _200@Mir(bb61[0])
  _201 = const 61440_i32
  using: 
  _198 = BitAnd(move _199, move _201)
  using: _199@Mir(bb61[1]), _201@Mir(bb61[2])
  _202 = const 16384_i32
  using: 
  _197 = Eq(move _198, move _202)
  using: _198@Mir(bb61[3]), _202@Mir(bb61[4])
  switchInt(move _197) -> [0: bb65, otherwise: bb62]
  using: _197@Mir(bb61[5])
bb62:
  _205 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _204 = (*_205)
  using: _205@Mir(bb62[0])
  _209 = const b"%s: Input file %s is a directory.\n\x00"
  using: 
  _208 = &raw const (*_209)
  using: _209@Mir(bb62[2])
  _207 = move _208 as *const u8 (Pointer(ArrayToPointer))
  using: _208@Mir(bb62[3])
  _206 = move _207 as *const i8 (PtrToPtr)
  using: _207@Mir(bb62[4])
  _211 = const {alloc197: *mut *mut i8}
  using: 
  _210 = (*_211)
  using: _211@Mir(bb62[6])
  _215 = const {alloc198: *mut [i8; 1034]}
  using: 
  _214 = &mut (*_215)
  using: _215@Mir(bb62[8])
  _213 = move _214 as &mut [i8] (Pointer(Unsize))
  using: _214@Mir(bb62[9])
  _212 = core::slice::<impl [i8]>::as_mut_ptr(move _213) -> bb63
  using: _213@Mir(bb62[10])
bb63:
  _203 = bzip2::fprintf(move _204, move _206, move _210, move _212) -> bb64
  using: _204@Mir(bb62[1]), _206@Mir(bb62[5]), _210@Mir(bb62[7]), _212@Mir(bb62[11])
bb64:
  _217 = const 1_i32
  using: 
  _216 = bzip2::setExit(move _217) -> bb177
  using: _217@Mir(bb64[0])
bb65:
  _222 = const {alloc267: *mut i32}
  using: 
  _221 = (*_222)
  using: _222@Mir(bb65[0])
  _223 = const 3_i32
  using: 
  _220 = Eq(move _221, move _223)
  using: _221@Mir(bb65[1]), _223@Mir(bb65[2])
  switchInt(move _220) -> [0: bb69, otherwise: bb70]
  using: _220@Mir(bb65[3])
bb66:
  _218 = const false
  using: 
  goto -> bb68
  using: 
bb67:
  _233 = const {alloc198: *mut [i8; 1034]}
  using: 
  _232 = &mut (*_233)
  using: _233@Mir(bb67[0])
  _231 = move _232 as &mut [i8] (Pointer(Unsize))
  using: _232@Mir(bb67[1])
  _230 = core::slice::<impl [i8]>::as_mut_ptr(move _231) -> bb72
  using: _231@Mir(bb67[2])
bb68:
  switchInt(move _218) -> [0: bb78, otherwise: bb74]
  using: _218@Phi(bb68)
bb69:
  _219 = const false
  using: 
  goto -> bb71
  using: 
bb70:
  _226 = const {alloc194: *mut u8}
  using: 
  _225 = (*_226)
  using: _226@Mir(bb70[0])
  _224 = Eq(move _225, const 0_u8)
  using: _225@Mir(bb70[1])
  _219 = move _224
  using: _224@Mir(bb70[2])
  goto -> bb71
  using: 
bb71:
  switchInt(move _219) -> [0: bb66, otherwise: bb67]
  using: _219@Phi(bb71)
bb72:
  _229 = bzip2::notAStandardFile(move _230) -> bb73
  using: _230@Mir(bb67[3])
bb73:
  _228 = move _229 as i32 (IntToInt)
  using: _229@Mir(bb72[0])
  _227 = Ne(move _228, const 0_i32)
  using: _228@Mir(bb73[0])
  _218 = move _227
  using: _227@Mir(bb73[1])
  goto -> bb68
  using: 
bb74:
  _235 = const {alloc196: *mut u8}
  using: 
  _234 = (*_235)
  using: _235@Mir(bb74[0])
  switchInt(move _234) -> [0: bb77, otherwise: bb75]
  using: _234@Mir(bb74[1])
bb75:
  _238 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _237 = (*_238)
  using: _238@Mir(bb75[0])
  _242 = const b"%s: Input file %s is not a normal file.\n\x00"
  using: 
  _241 = &raw const (*_242)
  using: _242@Mir(bb75[2])
  _240 = move _241 as *const u8 (Pointer(ArrayToPointer))
  using: _241@Mir(bb75[3])
  _239 = move _240 as *const i8 (PtrToPtr)
  using: _240@Mir(bb75[4])
  _244 = const {alloc197: *mut *mut i8}
  using: 
  _243 = (*_244)
  using: _244@Mir(bb75[6])
  _248 = const {alloc198: *mut [i8; 1034]}
  using: 
  _247 = &mut (*_248)
  using: _248@Mir(bb75[8])
  _246 = move _247 as &mut [i8] (Pointer(Unsize))
  using: _247@Mir(bb75[9])
  _245 = core::slice::<impl [i8]>::as_mut_ptr(move _246) -> bb76
  using: _246@Mir(bb75[10])
bb76:
  _236 = bzip2::fprintf(move _237, move _239, move _243, move _245) -> bb77
  using: _237@Mir(bb75[1]), _239@Mir(bb75[5]), _243@Mir(bb75[7]), _245@Mir(bb75[11])
bb77:
  _250 = const 1_i32
  using: 
  _249 = bzip2::setExit(move _250) -> bb177
  using: _250@Mir(bb77[0])
bb78:
  _254 = const {alloc267: *mut i32}
  using: 
  _253 = (*_254)
  using: _254@Mir(bb78[0])
  _255 = const 3_i32
  using: 
  _252 = Eq(move _253, move _255)
  using: _253@Mir(bb78[1]), _255@Mir(bb78[2])
  switchInt(move _252) -> [0: bb79, otherwise: bb80]
  using: _252@Mir(bb78[3])
bb79:
  _251 = const false
  using: 
  goto -> bb81
  using: 
bb80:
  _262 = const {alloc263: *mut [i8; 1034]}
  using: 
  _261 = &mut (*_262)
  using: _262@Mir(bb80[0])
  _260 = move _261 as &mut [i8] (Pointer(Unsize))
  using: _261@Mir(bb80[1])
  _259 = core::slice::<impl [i8]>::as_mut_ptr(move _260) -> bb82
  using: _260@Mir(bb80[2])
bb81:
  switchInt(move _251) -> [0: bb90, otherwise: bb84]
  using: _251@Phi(bb81)
bb82:
  _258 = bzip2::fileExists(move _259) -> bb83
  using: _259@Mir(bb80[3])
bb83:
  _257 = move _258 as i32 (IntToInt)
  using: _258@Mir(bb82[0])
  _256 = Ne(move _257, const 0_i32)
  using: _257@Mir(bb83[0])
  _251 = move _256
  using: _256@Mir(bb83[1])
  goto -> bb81
  using: 
bb84:
  _264 = const {alloc194: *mut u8}
  using: 
  _263 = (*_264)
  using: _264@Mir(bb84[0])
  switchInt(move _263) -> [0: bb87, otherwise: bb85]
  using: _263@Mir(bb84[1])
bb85:
  _270 = const {alloc263: *mut [i8; 1034]}
  using: 
  _269 = &mut (*_270)
  using: _270@Mir(bb85[0])
  _268 = move _269 as &mut [i8] (Pointer(Unsize))
  using: _269@Mir(bb85[1])
  _267 = core::slice::<impl [i8]>::as_mut_ptr(move _268) -> bb86
  using: _268@Mir(bb85[2])
bb86:
  _266 = move _267 as *const i8 (Pointer(MutToConstPointer))
  using: _267@Mir(bb85[3])
  _265 = bzip2::remove(move _266) -> bb90
  using: _266@Mir(bb86[0])
bb87:
  _273 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _272 = (*_273)
  using: _273@Mir(bb87[0])
  _277 = const b"%s: Output file %s already exists.\n\x00"
  using: 
  _276 = &raw const (*_277)
  using: _277@Mir(bb87[2])
  _275 = move _276 as *const u8 (Pointer(ArrayToPointer))
  using: _276@Mir(bb87[3])
  _274 = move _275 as *const i8 (PtrToPtr)
  using: _275@Mir(bb87[4])
  _279 = const {alloc197: *mut *mut i8}
  using: 
  _278 = (*_279)
  using: _279@Mir(bb87[6])
  _283 = const {alloc263: *mut [i8; 1034]}
  using: 
  _282 = &mut (*_283)
  using: _283@Mir(bb87[8])
  _281 = move _282 as &mut [i8] (Pointer(Unsize))
  using: _282@Mir(bb87[9])
  _280 = core::slice::<impl [i8]>::as_mut_ptr(move _281) -> bb88
  using: _281@Mir(bb87[10])
bb88:
  _271 = bzip2::fprintf(move _272, move _274, move _278, move _280) -> bb89
  using: _272@Mir(bb87[1]), _274@Mir(bb87[5]), _278@Mir(bb87[7]), _280@Mir(bb87[11])
bb89:
  _285 = const 1_i32
  using: 
  _284 = bzip2::setExit(move _285) -> bb177
  using: _285@Mir(bb89[0])
bb90:
  _290 = const {alloc267: *mut i32}
  using: 
  _289 = (*_290)
  using: _290@Mir(bb90[0])
  _291 = const 3_i32
  using: 
  _288 = Eq(move _289, move _291)
  using: _289@Mir(bb90[1]), _291@Mir(bb90[2])
  switchInt(move _288) -> [0: bb94, otherwise: bb95]
  using: _288@Mir(bb90[3])
bb91:
  _286 = const false
  using: 
  goto -> bb93
  using: 
bb92:
  _300 = const {alloc198: *mut [i8; 1034]}
  using: 
  _299 = &mut (*_300)
  using: _300@Mir(bb92[0])
  _298 = move _299 as &mut [i8] (Pointer(Unsize))
  using: _299@Mir(bb92[1])
  _297 = core::slice::<impl [i8]>::as_mut_ptr(move _298) -> bb97
  using: _298@Mir(bb92[2])
bb93:
  switchInt(move _286) -> [0: bb105, otherwise: bb99]
  using: _286@Phi(bb93)
bb94:
  _287 = const false
  using: 
  goto -> bb96
  using: 
bb95:
  _294 = const {alloc194: *mut u8}
  using: 
  _293 = (*_294)
  using: _294@Mir(bb95[0])
  _292 = Eq(move _293, const 0_u8)
  using: _293@Mir(bb95[1])
  _287 = move _292
  using: _292@Mir(bb95[2])
  goto -> bb96
  using: 
bb96:
  switchInt(move _287) -> [0: bb91, otherwise: bb92]
  using: _287@Phi(bb96)
bb97:
  _296 = bzip2::countHardLinks(move _297) -> bb98
  using: _297@Mir(bb92[3])
bb98:
  _4 = move _296
  using: _296@Mir(bb97[0])
  _301 = _4
  using: _4@Mir(bb98[0])
  _302 = const 0_i32
  using: 
  _295 = Gt(move _301, move _302)
  using: _301@Mir(bb98[1]), _302@Mir(bb98[2])
  _286 = move _295
  using: _295@Mir(bb98[3])
  goto -> bb93
  using: 
bb99:
  _305 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _304 = (*_305)
  using: _305@Mir(bb99[0])
  _309 = const b"%s: Input file %s has %d other link%s.\n\x00"
  using: 
  _308 = &raw const (*_309)
  using: _309@Mir(bb99[2])
  _307 = move _308 as *const u8 (Pointer(ArrayToPointer))
  using: _308@Mir(bb99[3])
  _306 = move _307 as *const i8 (PtrToPtr)
  using: _307@Mir(bb99[4])
  _311 = const {alloc197: *mut *mut i8}
  using: 
  _310 = (*_311)
  using: _311@Mir(bb99[6])
  _315 = const {alloc198: *mut [i8; 1034]}
  using: 
  _314 = &mut (*_315)
  using: _315@Mir(bb99[8])
  _313 = move _314 as &mut [i8] (Pointer(Unsize))
  using: _314@Mir(bb99[9])
  _312 = core::slice::<impl [i8]>::as_mut_ptr(move _313) -> bb100
  using: _313@Mir(bb99[10])
bb100:
  _316 = _4
  using: _4@Phi(bb93)
  _319 = _4
  using: _4@Phi(bb93)
  _320 = const 1_i32
  using: 
  _318 = Gt(move _319, move _320)
  using: _319@Mir(bb100[1]), _320@Mir(bb100[2])
  switchInt(move _318) -> [0: bb102, otherwise: bb101]
  using: _318@Mir(bb100[3])
bb101:
  _323 = const b"s\x00"
  using: 
  _322 = &raw const (*_323)
  using: _323@Mir(bb101[0])
  _321 = move _322 as *const u8 (Pointer(ArrayToPointer))
  using: _322@Mir(bb101[1])
  _317 = move _321 as *const i8 (PtrToPtr)
  using: _321@Mir(bb101[2])
  goto -> bb103
  using: 
bb102:
  _326 = const b"\x00"
  using: 
  _325 = &raw const (*_326)
  using: _326@Mir(bb102[0])
  _324 = move _325 as *const u8 (Pointer(ArrayToPointer))
  using: _325@Mir(bb102[1])
  _317 = move _324 as *const i8 (PtrToPtr)
  using: _324@Mir(bb102[2])
  goto -> bb103
  using: 
bb103:
  _303 = bzip2::fprintf(move _304, move _306, move _310, move _312, move _316, move _317) -> bb104
  using: _304@Mir(bb99[1]), _306@Mir(bb99[5]), _310@Mir(bb99[7]), _312@Mir(bb99[11]), _316@Mir(bb100[0]), _317@Phi(bb103)
bb104:
  _328 = const 1_i32
  using: 
  _327 = bzip2::setExit(move _328) -> bb177
  using: _328@Mir(bb104[0])
bb105:
  _331 = const {alloc267: *mut i32}
  using: 
  _330 = (*_331)
  using: _331@Mir(bb105[0])
  _332 = const 3_i32
  using: 
  _329 = Eq(move _330, move _332)
  using: _330@Mir(bb105[1]), _332@Mir(bb105[2])
  switchInt(move _329) -> [0: bb108, otherwise: bb106]
  using: _329@Mir(bb105[3])
bb106:
  _337 = const {alloc198: *mut [i8; 1034]}
  using: 
  _336 = &mut (*_337)
  using: _337@Mir(bb106[0])
  _335 = move _336 as &mut [i8] (Pointer(Unsize))
  using: _336@Mir(bb106[1])
  _334 = core::slice::<impl [i8]>::as_mut_ptr(move _335) -> bb107
  using: _335@Mir(bb106[2])
bb107:
  _333 = bzip2::saveInputFileMetaInfo(move _334) -> bb108
  using: _334@Mir(bb106[3])
bb108:
  _338 = const {alloc267: *mut i32}
  using: 
  switchInt((*_338)) -> [1: bb110, 2: bb116, 3: bb135, otherwise: bb109]
  using: _338@Mir(bb108[0])
bb109:
  _523 = const b"compress: bad srcMode\x00"
  using: 
  _522 = &raw const (*_523)
  using: _523@Mir(bb109[0])
  _521 = move _522 as *const u8 (Pointer(ArrayToPointer))
  using: _522@Mir(bb109[1])
  _520 = move _521 as *const i8 (PtrToPtr)
  using: _521@Mir(bb109[2])
  _519 = bzip2::panic(move _520)
  using: _520@Mir(bb109[3])
bb110:
  _340 = const {alloc195: *mut *mut blocksort::__sFILE}
  using: 
  _339 = (*_340)
  using: _340@Mir(bb110[0])
  _2 = move _339
  using: _339@Mir(bb110[1])
  _342 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _341 = (*_342)
  using: _342@Mir(bb110[3])
  _3 = move _341
  using: _341@Mir(bb110[4])
  _346 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _345 = (*_346)
  using: _346@Mir(bb110[6])
  _344 = bzip2::fileno(move _345) -> bb111
  using: _345@Mir(bb110[7])
bb111:
  _343 = bzip2::isatty(move _344) -> bb112
  using: _344@Mir(bb110[8])
bb112:
  switchInt(move _343) -> [0: bb161, otherwise: bb113]
  using: _343@Mir(bb111[0])
bb113:
  _349 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _348 = (*_349)
  using: _349@Mir(bb113[0])
  _353 = const b"%s: I won\'t write compressed data to a terminal.\n\x00"
  using: 
  _352 = &raw const (*_353)
  using: _353@Mir(bb113[2])
  _351 = move _352 as *const u8 (Pointer(ArrayToPointer))
  using: _352@Mir(bb113[3])
  _350 = move _351 as *const i8 (PtrToPtr)
  using: _351@Mir(bb113[4])
  _355 = const {alloc197: *mut *mut i8}
  using: 
  _354 = (*_355)
  using: _355@Mir(bb113[6])
  _347 = bzip2::fprintf(move _348, move _350, move _354) -> bb114
  using: _348@Mir(bb113[1]), _350@Mir(bb113[5]), _354@Mir(bb113[7])
bb114:
  _358 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _357 = (*_358)
  using: _358@Mir(bb114[0])
  _362 = const b"%s: For help, type: `%s --help\'.\n\x00"
  using: 
  _361 = &raw const (*_362)
  using: _362@Mir(bb114[2])
  _360 = move _361 as *const u8 (Pointer(ArrayToPointer))
  using: _361@Mir(bb114[3])
  _359 = move _360 as *const i8 (PtrToPtr)
  using: _360@Mir(bb114[4])
  _364 = const {alloc197: *mut *mut i8}
  using: 
  _363 = (*_364)
  using: _364@Mir(bb114[6])
  _366 = const {alloc197: *mut *mut i8}
  using: 
  _365 = (*_366)
  using: _366@Mir(bb114[8])
  _356 = bzip2::fprintf(move _357, move _359, move _363, move _365) -> bb115
  using: _357@Mir(bb114[1]), _359@Mir(bb114[5]), _363@Mir(bb114[7]), _365@Mir(bb114[9])
bb115:
  _368 = const 1_i32
  using: 
  _367 = bzip2::setExit(move _368) -> bb177
  using: _368@Mir(bb115[0])
bb116:
  _374 = const {alloc198: *mut [i8; 1034]}
  using: 
  _373 = &mut (*_374)
  using: _374@Mir(bb116[0])
  _372 = move _373 as &mut [i8] (Pointer(Unsize))
  using: _373@Mir(bb116[1])
  _371 = core::slice::<impl [i8]>::as_mut_ptr(move _372) -> bb117
  using: _372@Mir(bb116[2])
bb117:
  _370 = move _371 as *const i8 (Pointer(MutToConstPointer))
  using: _371@Mir(bb116[3])
  _378 = const b"rb\x00"
  using: 
  _377 = &raw const (*_378)
  using: _378@Mir(bb117[1])
  _376 = move _377 as *const u8 (Pointer(ArrayToPointer))
  using: _377@Mir(bb117[2])
  _375 = move _376 as *const i8 (PtrToPtr)
  using: _376@Mir(bb117[3])
  _369 = bzip2::fopen(move _370, move _375) -> bb118
  using: _370@Mir(bb117[0]), _375@Mir(bb117[4])
bb118:
  _2 = move _369
  using: _369@Mir(bb117[5])
  _380 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _379 = (*_380)
  using: _380@Mir(bb118[1])
  _3 = move _379
  using: _379@Mir(bb118[2])
  _384 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _383 = (*_384)
  using: _384@Mir(bb118[4])
  _382 = bzip2::fileno(move _383) -> bb119
  using: _383@Mir(bb118[5])
bb119:
  _381 = bzip2::isatty(move _382) -> bb120
  using: _382@Mir(bb118[6])
bb120:
  switchInt(move _381) -> [0: bb128, otherwise: bb121]
  using: _381@Mir(bb119[0])
bb121:
  _387 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _386 = (*_387)
  using: _387@Mir(bb121[0])
  _391 = const b"%s: I won\'t write compressed data to a terminal.\n\x00"
  using: 
  _390 = &raw const (*_391)
  using: _391@Mir(bb121[2])
  _389 = move _390 as *const u8 (Pointer(ArrayToPointer))
  using: _390@Mir(bb121[3])
  _388 = move _389 as *const i8 (PtrToPtr)
  using: _389@Mir(bb121[4])
  _393 = const {alloc197: *mut *mut i8}
  using: 
  _392 = (*_393)
  using: _393@Mir(bb121[6])
  _385 = bzip2::fprintf(move _386, move _388, move _392) -> bb122
  using: _386@Mir(bb121[1]), _388@Mir(bb121[5]), _392@Mir(bb121[7])
bb122:
  _396 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _395 = (*_396)
  using: _396@Mir(bb122[0])
  _400 = const b"%s: For help, type: `%s --help\'.\n\x00"
  using: 
  _399 = &raw const (*_400)
  using: _400@Mir(bb122[2])
  _398 = move _399 as *const u8 (Pointer(ArrayToPointer))
  using: _399@Mir(bb122[3])
  _397 = move _398 as *const i8 (PtrToPtr)
  using: _398@Mir(bb122[4])
  _402 = const {alloc197: *mut *mut i8}
  using: 
  _401 = (*_402)
  using: _402@Mir(bb122[6])
  _404 = const {alloc197: *mut *mut i8}
  using: 
  _403 = (*_404)
  using: _404@Mir(bb122[8])
  _394 = bzip2::fprintf(move _395, move _397, move _401, move _403) -> bb123
  using: _395@Mir(bb122[1]), _397@Mir(bb122[5]), _401@Mir(bb122[7]), _403@Mir(bb122[9])
bb123:
  _407 = _2
  using: _2@Mir(bb118[0])
  _406 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _407) -> bb124
  using: _407@Mir(bb123[0])
bb124:
  _405 = Not(move _406)
  using: _406@Mir(bb123[1])
  switchInt(move _405) -> [0: bb126, otherwise: bb125]
  using: _405@Mir(bb124[0])
bb125:
  _409 = _2
  using: _2@Mir(bb118[0])
  _408 = bzip2::fclose(move _409) -> bb127
  using: _409@Mir(bb125[0])
bb126:
  _412 = _2
  using: _2@Mir(bb118[0])
  _411 = move _412 as usize (PointerExposeAddress)
  using: _412@Mir(bb126[0])
  _410 = Eq(move _411, const 0_usize)
  using: _411@Mir(bb126[1])
  assume(move _410)
  using: _410@Mir(bb126[2])
  goto -> bb127
  using: 
bb127:
  _414 = const 1_i32
  using: 
  _413 = bzip2::setExit(move _414) -> bb177
  using: _414@Mir(bb127[0])
bb128:
  _416 = _2
  using: _2@Phi(bb127)
  _415 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _416) -> bb129
  using: _416@Mir(bb128[0])
bb129:
  switchInt(move _415) -> [0: bb161, otherwise: bb130]
  using: _415@Mir(bb128[1])
bb130:
  _419 = _2
  using: _2@Phi(bb127)
  _418 = move _419 as usize (PointerExposeAddress)
  using: _419@Mir(bb130[0])
  _417 = Eq(move _418, const 0_usize)
  using: _418@Mir(bb130[1])
  assume(move _417)
  using: _417@Mir(bb130[2])
  _422 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _421 = (*_422)
  using: _422@Mir(bb130[4])
  _426 = const b"%s: Can\'t open input file %s: %s.\n\x00"
  using: 
  _425 = &raw const (*_426)
  using: _426@Mir(bb130[6])
  _424 = move _425 as *const u8 (Pointer(ArrayToPointer))
  using: _425@Mir(bb130[7])
  _423 = move _424 as *const i8 (PtrToPtr)
  using: _424@Mir(bb130[8])
  _428 = const {alloc197: *mut *mut i8}
  using: 
  _427 = (*_428)
  using: _428@Mir(bb130[10])
  _432 = const {alloc198: *mut [i8; 1034]}
  using: 
  _431 = &mut (*_432)
  using: _432@Mir(bb130[12])
  _430 = move _431 as &mut [i8] (Pointer(Unsize))
  using: _431@Mir(bb130[13])
  _429 = core::slice::<impl [i8]>::as_mut_ptr(move _430) -> bb131
  using: _430@Mir(bb130[14])
bb131:
  _435 = bzip2::__error() -> bb132
  using: 
bb132:
  _434 = (*_435)
  using: _435@Mir(bb131[0])
  _433 = bzip2::strerror(move _434) -> bb133
  using: _434@Mir(bb132[0])
bb133:
  _420 = bzip2::fprintf(move _421, move _423, move _427, move _429, move _433) -> bb134
  using: _421@Mir(bb130[5]), _423@Mir(bb130[9]), _427@Mir(bb130[11]), _429@Mir(bb130[15]), _433@Mir(bb132[1])
bb134:
  _437 = const 1_i32
  using: 
  _436 = bzip2::setExit(move _437) -> bb177
  using: _437@Mir(bb134[0])
bb135:
  _443 = const {alloc198: *mut [i8; 1034]}
  using: 
  _442 = &mut (*_443)
  using: _443@Mir(bb135[0])
  _441 = move _442 as &mut [i8] (Pointer(Unsize))
  using: _442@Mir(bb135[1])
  _440 = core::slice::<impl [i8]>::as_mut_ptr(move _441) -> bb136
  using: _441@Mir(bb135[2])
bb136:
  _439 = move _440 as *const i8 (Pointer(MutToConstPointer))
  using: _440@Mir(bb135[3])
  _447 = const b"rb\x00"
  using: 
  _446 = &raw const (*_447)
  using: _447@Mir(bb136[1])
  _445 = move _446 as *const u8 (Pointer(ArrayToPointer))
  using: _446@Mir(bb136[2])
  _444 = move _445 as *const i8 (PtrToPtr)
  using: _445@Mir(bb136[3])
  _438 = bzip2::fopen(move _439, move _444) -> bb137
  using: _439@Mir(bb136[0]), _444@Mir(bb136[4])
bb137:
  _2 = move _438
  using: _438@Mir(bb136[5])
  _452 = const {alloc263: *mut [i8; 1034]}
  using: 
  _451 = &mut (*_452)
  using: _452@Mir(bb137[1])
  _450 = move _451 as &mut [i8] (Pointer(Unsize))
  using: _451@Mir(bb137[2])
  _449 = core::slice::<impl [i8]>::as_mut_ptr(move _450) -> bb138
  using: _450@Mir(bb137[3])
bb138:
  _456 = const b"wb\x00"
  using: 
  _455 = &raw const (*_456)
  using: _456@Mir(bb138[0])
  _454 = move _455 as *const u8 (Pointer(ArrayToPointer))
  using: _455@Mir(bb138[1])
  _453 = move _454 as *const i8 (PtrToPtr)
  using: _454@Mir(bb138[2])
  _448 = bzip2::fopen_output_safely(move _449, move _453) -> bb139
  using: _449@Mir(bb137[4]), _453@Mir(bb138[3])
bb139:
  _3 = move _448
  using: _448@Mir(bb138[4])
  _458 = _3
  using: _3@Mir(bb139[0])
  _457 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _458) -> bb140
  using: _458@Mir(bb139[1])
bb140:
  switchInt(move _457) -> [0: bb150, otherwise: bb141]
  using: _457@Mir(bb139[2])
bb141:
  _461 = _3
  using: _3@Mir(bb139[0])
  _460 = move _461 as usize (PointerExposeAddress)
  using: _461@Mir(bb141[0])
  _459 = Eq(move _460, const 0_usize)
  using: _460@Mir(bb141[1])
  assume(move _459)
  using: _459@Mir(bb141[2])
  _464 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _463 = (*_464)
  using: _464@Mir(bb141[4])
  _468 = const b"%s: Can\'t create output file %s: %s.\n\x00"
  using: 
  _467 = &raw const (*_468)
  using: _468@Mir(bb141[6])
  _466 = move _467 as *const u8 (Pointer(ArrayToPointer))
  using: _467@Mir(bb141[7])
  _465 = move _466 as *const i8 (PtrToPtr)
  using: _466@Mir(bb141[8])
  _470 = const {alloc197: *mut *mut i8}
  using: 
  _469 = (*_470)
  using: _470@Mir(bb141[10])
  _474 = const {alloc263: *mut [i8; 1034]}
  using: 
  _473 = &mut (*_474)
  using: _474@Mir(bb141[12])
  _472 = move _473 as &mut [i8] (Pointer(Unsize))
  using: _473@Mir(bb141[13])
  _471 = core::slice::<impl [i8]>::as_mut_ptr(move _472) -> bb142
  using: _472@Mir(bb141[14])
bb142:
  _477 = bzip2::__error() -> bb143
  using: 
bb143:
  _476 = (*_477)
  using: _477@Mir(bb142[0])
  _475 = bzip2::strerror(move _476) -> bb144
  using: _476@Mir(bb143[0])
bb144:
  _462 = bzip2::fprintf(move _463, move _465, move _469, move _471, move _475) -> bb145
  using: _463@Mir(bb141[5]), _465@Mir(bb141[9]), _469@Mir(bb141[11]), _471@Mir(bb141[15]), _475@Mir(bb143[1])
bb145:
  _480 = _2
  using: _2@Mir(bb137[0])
  _479 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _480) -> bb146
  using: _480@Mir(bb145[0])
bb146:
  _478 = Not(move _479)
  using: _479@Mir(bb145[1])
  switchInt(move _478) -> [0: bb148, otherwise: bb147]
  using: _478@Mir(bb146[0])
bb147:
  _482 = _2
  using: _2@Mir(bb137[0])
  _481 = bzip2::fclose(move _482) -> bb149
  using: _482@Mir(bb147[0])
bb148:
  _485 = _2
  using: _2@Mir(bb137[0])
  _484 = move _485 as usize (PointerExposeAddress)
  using: _485@Mir(bb148[0])
  _483 = Eq(move _484, const 0_usize)
  using: _484@Mir(bb148[1])
  assume(move _483)
  using: _483@Mir(bb148[2])
  goto -> bb149
  using: 
bb149:
  _487 = const 1_i32
  using: 
  _486 = bzip2::setExit(move _487) -> bb177
  using: _487@Mir(bb149[0])
bb150:
  _489 = _2
  using: _2@Phi(bb149)
  _488 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _489) -> bb151
  using: _489@Mir(bb150[0])
bb151:
  switchInt(move _488) -> [0: bb161, otherwise: bb152]
  using: _488@Mir(bb150[1])
bb152:
  _492 = _2
  using: _2@Phi(bb149)
  _491 = move _492 as usize (PointerExposeAddress)
  using: _492@Mir(bb152[0])
  _490 = Eq(move _491, const 0_usize)
  using: _491@Mir(bb152[1])
  assume(move _490)
  using: _490@Mir(bb152[2])
  _495 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _494 = (*_495)
  using: _495@Mir(bb152[4])
  _499 = const b"%s: Can\'t open input file %s: %s.\n\x00"
  using: 
  _498 = &raw const (*_499)
  using: _499@Mir(bb152[6])
  _497 = move _498 as *const u8 (Pointer(ArrayToPointer))
  using: _498@Mir(bb152[7])
  _496 = move _497 as *const i8 (PtrToPtr)
  using: _497@Mir(bb152[8])
  _501 = const {alloc197: *mut *mut i8}
  using: 
  _500 = (*_501)
  using: _501@Mir(bb152[10])
  _505 = const {alloc198: *mut [i8; 1034]}
  using: 
  _504 = &mut (*_505)
  using: _505@Mir(bb152[12])
  _503 = move _504 as &mut [i8] (Pointer(Unsize))
  using: _504@Mir(bb152[13])
  _502 = core::slice::<impl [i8]>::as_mut_ptr(move _503) -> bb153
  using: _503@Mir(bb152[14])
bb153:
  _508 = bzip2::__error() -> bb154
  using: 
bb154:
  _507 = (*_508)
  using: _508@Mir(bb153[0])
  _506 = bzip2::strerror(move _507) -> bb155
  using: _507@Mir(bb154[0])
bb155:
  _493 = bzip2::fprintf(move _494, move _496, move _500, move _502, move _506) -> bb156
  using: _494@Mir(bb152[5]), _496@Mir(bb152[9]), _500@Mir(bb152[11]), _502@Mir(bb152[15]), _506@Mir(bb154[1])
bb156:
  _511 = _3
  using: _3@Mir(bb139[0])
  _510 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _511) -> bb157
  using: _511@Mir(bb156[0])
bb157:
  _509 = Not(move _510)
  using: _510@Mir(bb156[1])
  switchInt(move _509) -> [0: bb159, otherwise: bb158]
  using: _509@Mir(bb157[0])
bb158:
  _513 = _3
  using: _3@Mir(bb139[0])
  _512 = bzip2::fclose(move _513) -> bb160
  using: _513@Mir(bb158[0])
bb159:
  _516 = _3
  using: _3@Mir(bb139[0])
  _515 = move _516 as usize (PointerExposeAddress)
  using: _516@Mir(bb159[0])
  _514 = Eq(move _515, const 0_usize)
  using: _515@Mir(bb159[1])
  assume(move _514)
  using: _514@Mir(bb159[2])
  goto -> bb160
  using: 
bb160:
  _518 = const 1_i32
  using: 
  _517 = bzip2::setExit(move _518) -> bb177
  using: _518@Mir(bb160[0])
bb161:
  _526 = const {alloc172: *mut i32}
  using: 
  _525 = (*_526)
  using: _526@Mir(bb161[0])
  _527 = const 1_i32
  using: 
  _524 = Ge(move _525, move _527)
  using: _525@Mir(bb161[1]), _527@Mir(bb161[2])
  switchInt(move _524) -> [0: bb167, otherwise: bb162]
  using: _524@Mir(bb161[3])
bb162:
  _530 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _529 = (*_530)
  using: _530@Mir(bb162[0])
  _534 = const b"  %s: \x00"
  using: 
  _533 = &raw const (*_534)
  using: _534@Mir(bb162[2])
  _532 = move _533 as *const u8 (Pointer(ArrayToPointer))
  using: _533@Mir(bb162[3])
  _531 = move _532 as *const i8 (PtrToPtr)
  using: _532@Mir(bb162[4])
  _538 = const {alloc198: *mut [i8; 1034]}
  using: 
  _537 = &mut (*_538)
  using: _538@Mir(bb162[6])
  _536 = move _537 as &mut [i8] (Pointer(Unsize))
  using: _537@Mir(bb162[7])
  _535 = core::slice::<impl [i8]>::as_mut_ptr(move _536) -> bb163
  using: _536@Mir(bb162[8])
bb163:
  _528 = bzip2::fprintf(move _529, move _531, move _535) -> bb164
  using: _529@Mir(bb162[1]), _531@Mir(bb162[5]), _535@Mir(bb162[9])
bb164:
  _543 = const {alloc198: *mut [i8; 1034]}
  using: 
  _542 = &mut (*_543)
  using: _543@Mir(bb164[0])
  _541 = move _542 as &mut [i8] (Pointer(Unsize))
  using: _542@Mir(bb164[1])
  _540 = core::slice::<impl [i8]>::as_mut_ptr(move _541) -> bb165
  using: _541@Mir(bb164[2])
bb165:
  _539 = bzip2::pad(move _540) -> bb166
  using: _540@Mir(bb164[3])
bb166:
  _546 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _545 = (*_546)
  using: _546@Mir(bb166[0])
  _544 = bzip2::fflush(move _545) -> bb167
  using: _545@Mir(bb166[1])
bb167:
  _547 = _3
  using: _3@Phi(bb161)
  _548 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_548) = move _547
  using: _548@Mir(bb167[1]), _547@Mir(bb167[0])
  _549 = const 1_i32
  using: 
  _550 = const {alloc269: *mut u8}
  using: 
  (*_550) = move _549 as u8 (IntToInt)
  using: _550@Mir(bb167[4]), _549@Mir(bb167[3])
  _552 = _2
  using: _2@Phi(bb161)
  _553 = _3
  using: _3@Phi(bb161)
  _551 = bzip2::compressStream(move _552, move _553) -> bb168
  using: _552@Mir(bb167[6]), _553@Mir(bb167[7])
bb168:
  _554 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_554) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _554@Mir(bb168[0])
  _557 = const {alloc267: *mut i32}
  using: 
  _556 = (*_557)
  using: _557@Mir(bb168[2])
  _558 = const 3_i32
  using: 
  _555 = Eq(move _556, move _558)
  using: _556@Mir(bb168[3]), _558@Mir(bb168[4])
  switchInt(move _555) -> [0: bb176, otherwise: bb169]
  using: _555@Mir(bb168[5])
bb169:
  _563 = const {alloc263: *mut [i8; 1034]}
  using: 
  _562 = &mut (*_563)
  using: _563@Mir(bb169[0])
  _561 = move _562 as &mut [i8] (Pointer(Unsize))
  using: _562@Mir(bb169[1])
  _560 = core::slice::<impl [i8]>::as_mut_ptr(move _561) -> bb170
  using: _561@Mir(bb169[2])
bb170:
  _559 = bzip2::applySavedTimeInfoToOutputFile(move _560) -> bb171
  using: _560@Mir(bb169[3])
bb171:
  _564 = const 0_i32
  using: 
  _565 = const {alloc269: *mut u8}
  using: 
  (*_565) = move _564 as u8 (IntToInt)
  using: _565@Mir(bb171[1]), _564@Mir(bb171[0])
  _567 = const {alloc392: *mut u8}
  using: 
  _566 = (*_567)
  using: _567@Mir(bb171[3])
  switchInt(move _566) -> [0: bb172, otherwise: bb176]
  using: _566@Mir(bb171[4])
bb172:
  _573 = const {alloc198: *mut [i8; 1034]}
  using: 
  _572 = &mut (*_573)
  using: _573@Mir(bb172[0])
  _571 = move _572 as &mut [i8] (Pointer(Unsize))
  using: _572@Mir(bb172[1])
  _570 = core::slice::<impl [i8]>::as_mut_ptr(move _571) -> bb173
  using: _571@Mir(bb172[2])
bb173:
  _569 = move _570 as *const i8 (Pointer(MutToConstPointer))
  using: _570@Mir(bb172[3])
  _568 = bzip2::remove(move _569) -> bb174
  using: _569@Mir(bb173[0])
bb174:
  _575 = _568
  using: _568@Mir(bb173[1])
  _576 = const 0_i32
  using: 
  _574 = Ne(move _575, move _576)
  using: _575@Mir(bb174[0]), _576@Mir(bb174[1])
  switchInt(move _574) -> [0: bb176, otherwise: bb175]
  using: _574@Mir(bb174[2])
bb175:
  _577 = bzip2::ioError()
  using: 
bb176:
  _578 = const 0_i32
  using: 
  _579 = const {alloc269: *mut u8}
  using: 
  (*_579) = move _578 as u8 (IntToInt)
  using: _579@Mir(bb176[1]), _578@Mir(bb176[0])
  goto -> bb177
  using: 
bb177:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_7) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_8) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_9) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_10) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_6) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i64; 2] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcat @ workspace/bzip2/rust/bzip2.rs:2066:13: 2067:76 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2080:13: 2083:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2092:27: 2092:36 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2092:17: 2092:37 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2089:9: 2092:38 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2100:17: 2103:66 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::stat @ workspace/bzip2/rust/bzip2.rs:2111:9: 2111:48 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2114:13: 2116:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2124:13: 2127:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::remove @ workspace/bzip2/rust/bzip2.rs:2135:13: 2135:41 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2137:13: 2140:42 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2148:9: 2153:80 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fileno @ workspace/bzip2/rust/bzip2.rs:2166:23: 2166:40 (#0) by default
rewrite call bzip2::isatty @ workspace/bzip2/rust/bzip2.rs:2166:16: 2166:41 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2167:17: 2169:83 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2170:17: 2173:34 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fopen @ workspace/bzip2/rust/bzip2.rs:2180:17: 2181:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fileno @ workspace/bzip2/rust/bzip2.rs:2183:23: 2183:40 (#0) by default
rewrite call bzip2::isatty @ workspace/bzip2/rust/bzip2.rs:2183:16: 2183:41 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2184:17: 2186:83 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2187:17: 2190:34 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:2191:39: 2191:52 (#0) by default
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2199:56: 2199:65 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2199:46: 2199:66 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2196:17: 2199:67 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fopen @ workspace/bzip2/rust/bzip2.rs:2206:17: 2207:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2216:57: 2216:66 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2216:47: 2216:67 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2213:17: 2216:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:2217:39: 2217:52 (#0) by default
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2225:56: 2225:65 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2225:46: 2225:66 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2222:17: 2225:67 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:2226:40: 2226:54 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2237:9: 2238:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fflush @ workspace/bzip2/rust/bzip2.rs:2240:9: 2240:26 (#0) by default
rewrite call bzip2::remove @ workspace/bzip2/rust/bzip2.rs:2252:41: 2252:68 (#0) by default
@DefId(0:237 ~ c2rust_lib[1043]::bzip2::uncompress)
bb0:
  _3 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _4 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_u8
  using: 
  _8 = const 0_u8
  using: 
  Deinit(_10)
  using: 
  (_10.0: i64) = const 0_i64
  using: 
  (_10.1: i64) = const 0_i64
  using: 
  Deinit(_11)
  using: 
  (_11.0: i64) = const 0_i64
  using: 
  (_11.1: i64) = const 0_i64
  using: 
  Deinit(_12)
  using: 
  (_12.0: i64) = const 0_i64
  using: 
  (_12.1: i64) = const 0_i64
  using: 
  Deinit(_13)
  using: 
  (_13.0: i64) = const 0_i64
  using: 
  (_13.1: i64) = const 0_i64
  using: 
  _14 = [const 0_i64; 2]
  using: 
  Deinit(_9)
  using: 
  (_9.0: i32) = const 0_i32
  using: 
  (_9.1: u16) = const 0_u16
  using: 
  (_9.2: u16) = const 0_u16
  using: 
  (_9.3: u64) = const 0_u64
  using: 
  (_9.4: u32) = const 0_u32
  using: 
  (_9.5: u32) = const 0_u32
  using: 
  (_9.6: i32) = const 0_i32
  using: 
  (_9.7: bzip2::timespec) = move _10
  using: _10@Mir(bb0[6])
  (_9.8: bzip2::timespec) = move _11
  using: _11@Mir(bb0[9])
  (_9.9: bzip2::timespec) = move _12
  using: _12@Mir(bb0[12])
  (_9.10: bzip2::timespec) = move _13
  using: _13@Mir(bb0[15])
  (_9.11: i64) = const 0_i64
  using: 
  (_9.12: i64) = const 0_i64
  using: 
  (_9.13: i32) = const 0_i32
  using: 
  (_9.14: u32) = const 0_u32
  using: 
  (_9.15: u32) = const 0_u32
  using: 
  (_9.16: i32) = const 0_i32
  using: 
  (_9.17: [i64; 2]) = move _14
  using: _14@Mir(bb0[18])
  _15 = const 0_i32
  using: 
  _16 = const {alloc269: *mut u8}
  using: 
  (*_16) = move _15 as u8 (IntToInt)
  using: _16@Mir(bb0[39]), _15@Mir(bb0[38])
  _19 = _1
  using: _1@Entry
  _18 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _19) -> bb4
  using: _19@Mir(bb0[41])
bb1:
  _17 = const false
  using: 
  goto -> bb3
  using: 
bb2:
  _22 = const {alloc267: *mut i32}
  using: 
  _21 = (*_22)
  using: _22@Mir(bb2[0])
  _23 = const 1_i32
  using: 
  _20 = Ne(move _21, move _23)
  using: _21@Mir(bb2[1]), _23@Mir(bb2[2])
  _17 = move _20
  using: _20@Mir(bb2[3])
  goto -> bb3
  using: 
bb3:
  switchInt(move _17) -> [0: bb6, otherwise: bb5]
  using: _17@Phi(bb3)
bb4:
  switchInt(move _18) -> [0: bb1, otherwise: bb2]
  using: _18@Mir(bb0[42])
bb5:
  _28 = const b"uncompress: bad modes\n\x00"
  using: 
  _27 = &raw const (*_28)
  using: _28@Mir(bb5[0])
  _26 = move _27 as *const u8 (Pointer(ArrayToPointer))
  using: _27@Mir(bb5[1])
  _25 = move _26 as *const i8 (PtrToPtr)
  using: _26@Mir(bb5[2])
  _24 = bzip2::panic(move _25)
  using: _25@Mir(bb5[3])
bb6:
  _8 = const 0_u8
  using: 
  _29 = const {alloc267: *mut i32}
  using: 
  switchInt((*_29)) -> [1: bb7, 3: bb11, 2: bb29, otherwise: bb33]
  using: _29@Mir(bb6[1])
bb7:
  _34 = const {alloc198: *mut [i8; 1034]}
  using: 
  _33 = &mut (*_34)
  using: _34@Mir(bb7[0])
  _32 = move _33 as &mut [i8] (Pointer(Unsize))
  using: _33@Mir(bb7[1])
  _31 = core::slice::<impl [i8]>::as_mut_ptr(move _32) -> bb8
  using: _32@Mir(bb7[2])
bb8:
  _39 = const b"(stdin)\x00"
  using: 
  _38 = &raw const (*_39)
  using: _39@Mir(bb8[0])
  _37 = move _38 as *const u8 (Pointer(ArrayToPointer))
  using: _38@Mir(bb8[1])
  _36 = move _37 as *const i8 (PtrToPtr)
  using: _37@Mir(bb8[2])
  _35 = move _36 as *mut i8 (PtrToPtr)
  using: _36@Mir(bb8[3])
  _30 = bzip2::copyFileName(move _31, move _35) -> bb9
  using: _31@Mir(bb7[3]), _35@Mir(bb8[4])
bb9:
  _44 = const {alloc263: *mut [i8; 1034]}
  using: 
  _43 = &mut (*_44)
  using: _44@Mir(bb9[0])
  _42 = move _43 as &mut [i8] (Pointer(Unsize))
  using: _43@Mir(bb9[1])
  _41 = core::slice::<impl [i8]>::as_mut_ptr(move _42) -> bb10
  using: _42@Mir(bb9[2])
bb10:
  _49 = const b"(stdout)\x00"
  using: 
  _48 = &raw const (*_49)
  using: _49@Mir(bb10[0])
  _47 = move _48 as *const u8 (Pointer(ArrayToPointer))
  using: _48@Mir(bb10[1])
  _46 = move _47 as *const i8 (PtrToPtr)
  using: _47@Mir(bb10[2])
  _45 = move _46 as *mut i8 (PtrToPtr)
  using: _46@Mir(bb10[3])
  _40 = bzip2::copyFileName(move _41, move _45) -> bb33
  using: _41@Mir(bb9[3]), _45@Mir(bb10[4])
bb11:
  _54 = const {alloc198: *mut [i8; 1034]}
  using: 
  _53 = &mut (*_54)
  using: _54@Mir(bb11[0])
  _52 = move _53 as &mut [i8] (Pointer(Unsize))
  using: _53@Mir(bb11[1])
  _51 = core::slice::<impl [i8]>::as_mut_ptr(move _52) -> bb12
  using: _52@Mir(bb11[2])
bb12:
  _55 = _1
  using: _1@Entry
  _50 = bzip2::copyFileName(move _51, move _55) -> bb13
  using: _51@Mir(bb11[3]), _55@Mir(bb12[0])
bb13:
  _60 = const {alloc263: *mut [i8; 1034]}
  using: 
  _59 = &mut (*_60)
  using: _60@Mir(bb13[0])
  _58 = move _59 as &mut [i8] (Pointer(Unsize))
  using: _59@Mir(bb13[1])
  _57 = core::slice::<impl [i8]>::as_mut_ptr(move _58) -> bb14
  using: _58@Mir(bb13[2])
bb14:
  _61 = _1
  using: _1@Entry
  _56 = bzip2::copyFileName(move _57, move _61) -> bb15
  using: _57@Mir(bb13[3]), _61@Mir(bb14[0])
bb15:
  _6 = const 0_i32
  using: 
  goto -> bb16
  using: 
bb16:
  _64 = _6
  using: _6@Phi(bb16)
  _65 = const 4_i32
  using: 
  _63 = Lt(move _64, move _65)
  using: _64@Mir(bb16[0]), _65@Mir(bb16[1])
  _62 = Not(move _63)
  using: _63@Mir(bb16[2])
  switchInt(move _62) -> [0: bb18, otherwise: bb17]
  using: _62@Mir(bb16[3])
bb17:
  _2 = const 17860125682698302841_u64
  using: 
  goto -> bb26
  using: 
bb18:
  _70 = const {alloc263: *mut [i8; 1034]}
  using: 
  _69 = &mut (*_70)
  using: _70@Mir(bb18[0])
  _68 = move _69 as &mut [i8] (Pointer(Unsize))
  using: _69@Mir(bb18[1])
  _67 = core::slice::<impl [i8]>::as_mut_ptr(move _68) -> bb19
  using: _68@Mir(bb18[2])
bb19:
  _72 = const {alloc391: *mut [*const i8; 4]}
  using: 
  _74 = _6
  using: _6@Phi(bb16)
  _73 = move _74 as usize (IntToInt)
  using: _74@Mir(bb19[1])
  _75 = const 4_usize
  using: 
  _76 = Lt(_73, _75)
  using: _73@Mir(bb19[2]), _75@Mir(bb19[3])
  assert(move _76, "index out of bounds: the length is {} but the index is {}", move _75, _73) -> bb20
  using: _76@Entry, _75@Entry, _73@Entry
bb20:
  _71 = (*_72)[_73]
  using: _72@Mir(bb19[0]), _73@Mir(bb19[2])
  _78 = const {alloc432: *mut [*const i8; 4]}
  using: 
  _80 = _6
  using: _6@Phi(bb16)
  _79 = move _80 as usize (IntToInt)
  using: _80@Mir(bb20[2])
  _81 = const 4_usize
  using: 
  _82 = Lt(_79, _81)
  using: _79@Mir(bb20[3]), _81@Mir(bb20[4])
  assert(move _82, "index out of bounds: the length is {} but the index is {}", move _81, _79) -> bb21
  using: _82@Entry, _81@Entry, _79@Entry
bb21:
  _77 = (*_78)[_79]
  using: _78@Mir(bb20[1]), _79@Mir(bb20[3])
  _66 = bzip2::mapSuffix(move _67, move _71, move _77) -> bb22
  using: _67@Mir(bb18[3]), _71@Mir(bb20[0]), _77@Mir(bb21[0])
bb22:
  switchInt(move _66) -> [0: bb24, otherwise: bb23]
  using: _66@Mir(bb21[1])
bb23:
  _2 = const 15314513098708193206_u64
  using: 
  goto -> bb26
  using: 
bb24:
  _83 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb16)
  assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb25
  using: _83@Entry, _6@Entry
bb25:
  _6 = move (_83.0: i32)
  using: _83@Mir(bb24[0])
  goto -> bb16
  using: 
bb26:
  switchInt(_2) -> [15314513098708193206: bb33, otherwise: bb27]
  using: _2@Phi(bb26)
bb27:
  _8 = const 1_u8
  using: 
  _88 = const {alloc263: *mut [i8; 1034]}
  using: 
  _87 = &mut (*_88)
  using: _88@Mir(bb27[1])
  _86 = move _87 as &mut [i8] (Pointer(Unsize))
  using: _87@Mir(bb27[2])
  _85 = core::slice::<impl [i8]>::as_mut_ptr(move _86) -> bb28
  using: _86@Mir(bb27[3])
bb28:
  _92 = const b".out\x00"
  using: 
  _91 = &raw const (*_92)
  using: _92@Mir(bb28[0])
  _90 = move _91 as *const u8 (Pointer(ArrayToPointer))
  using: _91@Mir(bb28[1])
  _89 = move _90 as *const i8 (PtrToPtr)
  using: _90@Mir(bb28[2])
  _84 = bzip2::strcat(move _85, move _89) -> bb33
  using: _85@Mir(bb27[4]), _89@Mir(bb28[3])
bb29:
  _97 = const {alloc198: *mut [i8; 1034]}
  using: 
  _96 = &mut (*_97)
  using: _97@Mir(bb29[0])
  _95 = move _96 as &mut [i8] (Pointer(Unsize))
  using: _96@Mir(bb29[1])
  _94 = core::slice::<impl [i8]>::as_mut_ptr(move _95) -> bb30
  using: _95@Mir(bb29[2])
bb30:
  _98 = _1
  using: _1@Entry
  _93 = bzip2::copyFileName(move _94, move _98) -> bb31
  using: _94@Mir(bb29[3]), _98@Mir(bb30[0])
bb31:
  _103 = const {alloc263: *mut [i8; 1034]}
  using: 
  _102 = &mut (*_103)
  using: _103@Mir(bb31[0])
  _101 = move _102 as &mut [i8] (Pointer(Unsize))
  using: _102@Mir(bb31[1])
  _100 = core::slice::<impl [i8]>::as_mut_ptr(move _101) -> bb32
  using: _101@Mir(bb31[2])
bb32:
  _108 = const b"(stdout)\x00"
  using: 
  _107 = &raw const (*_108)
  using: _108@Mir(bb32[0])
  _106 = move _107 as *const u8 (Pointer(ArrayToPointer))
  using: _107@Mir(bb32[1])
  _105 = move _106 as *const i8 (PtrToPtr)
  using: _106@Mir(bb32[2])
  _104 = move _105 as *mut i8 (PtrToPtr)
  using: _105@Mir(bb32[3])
  _99 = bzip2::copyFileName(move _100, move _104) -> bb33
  using: _100@Mir(bb31[3]), _104@Mir(bb32[4])
bb33:
  _112 = const {alloc267: *mut i32}
  using: 
  _111 = (*_112)
  using: _112@Mir(bb33[0])
  _113 = const 1_i32
  using: 
  _110 = Ne(move _111, move _113)
  using: _111@Mir(bb33[1]), _113@Mir(bb33[2])
  switchInt(move _110) -> [0: bb34, otherwise: bb35]
  using: _110@Mir(bb33[3])
bb34:
  _109 = const false
  using: 
  goto -> bb36
  using: 
bb35:
  _120 = const {alloc198: *mut [i8; 1034]}
  using: 
  _119 = &mut (*_120)
  using: _120@Mir(bb35[0])
  _118 = move _119 as &mut [i8] (Pointer(Unsize))
  using: _119@Mir(bb35[1])
  _117 = core::slice::<impl [i8]>::as_mut_ptr(move _118) -> bb37
  using: _118@Mir(bb35[2])
bb36:
  switchInt(move _109) -> [0: bb43, otherwise: bb39]
  using: _109@Phi(bb36)
bb37:
  _116 = bzip2::containsDubiousChars(move _117) -> bb38
  using: _117@Mir(bb35[3])
bb38:
  _115 = move _116 as i32 (IntToInt)
  using: _116@Mir(bb37[0])
  _114 = Ne(move _115, const 0_i32)
  using: _115@Mir(bb38[0])
  _109 = move _114
  using: _114@Mir(bb38[1])
  goto -> bb36
  using: 
bb39:
  _122 = const {alloc196: *mut u8}
  using: 
  _121 = (*_122)
  using: _122@Mir(bb39[0])
  switchInt(move _121) -> [0: bb42, otherwise: bb40]
  using: _121@Mir(bb39[1])
bb40:
  _125 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _124 = (*_125)
  using: _125@Mir(bb40[0])
  _129 = const b"%s: There are no files matching `%s\'.\n\x00"
  using: 
  _128 = &raw const (*_129)
  using: _129@Mir(bb40[2])
  _127 = move _128 as *const u8 (Pointer(ArrayToPointer))
  using: _128@Mir(bb40[3])
  _126 = move _127 as *const i8 (PtrToPtr)
  using: _127@Mir(bb40[4])
  _131 = const {alloc197: *mut *mut i8}
  using: 
  _130 = (*_131)
  using: _131@Mir(bb40[6])
  _135 = const {alloc198: *mut [i8; 1034]}
  using: 
  _134 = &mut (*_135)
  using: _135@Mir(bb40[8])
  _133 = move _134 as &mut [i8] (Pointer(Unsize))
  using: _134@Mir(bb40[9])
  _132 = core::slice::<impl [i8]>::as_mut_ptr(move _133) -> bb41
  using: _133@Mir(bb40[10])
bb41:
  _123 = bzip2::fprintf(move _124, move _126, move _130, move _132) -> bb42
  using: _124@Mir(bb40[1]), _126@Mir(bb40[5]), _130@Mir(bb40[7]), _132@Mir(bb40[11])
bb42:
  _137 = const 1_i32
  using: 
  _136 = bzip2::setExit(move _137) -> bb188
  using: _137@Mir(bb42[0])
bb43:
  _141 = const {alloc267: *mut i32}
  using: 
  _140 = (*_141)
  using: _141@Mir(bb43[0])
  _142 = const 1_i32
  using: 
  _139 = Ne(move _140, move _142)
  using: _140@Mir(bb43[1]), _142@Mir(bb43[2])
  switchInt(move _139) -> [0: bb44, otherwise: bb45]
  using: _139@Mir(bb43[3])
bb44:
  _138 = const false
  using: 
  goto -> bb46
  using: 
bb45:
  _148 = const {alloc198: *mut [i8; 1034]}
  using: 
  _147 = &mut (*_148)
  using: _148@Mir(bb45[0])
  _146 = move _147 as &mut [i8] (Pointer(Unsize))
  using: _147@Mir(bb45[1])
  _145 = core::slice::<impl [i8]>::as_mut_ptr(move _146) -> bb47
  using: _146@Mir(bb45[2])
bb46:
  switchInt(move _138) -> [0: bb54, otherwise: bb49]
  using: _138@Phi(bb46)
bb47:
  _144 = bzip2::fileExists(move _145) -> bb48
  using: _145@Mir(bb45[3])
bb48:
  _143 = Eq(move _144, const 0_u8)
  using: _144@Mir(bb47[0])
  _138 = move _143
  using: _143@Mir(bb48[0])
  goto -> bb46
  using: 
bb49:
  _151 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _150 = (*_151)
  using: _151@Mir(bb49[0])
  _155 = const b"%s: Can\'t open input file %s: %s.\n\x00"
  using: 
  _154 = &raw const (*_155)
  using: _155@Mir(bb49[2])
  _153 = move _154 as *const u8 (Pointer(ArrayToPointer))
  using: _154@Mir(bb49[3])
  _152 = move _153 as *const i8 (PtrToPtr)
  using: _153@Mir(bb49[4])
  _157 = const {alloc197: *mut *mut i8}
  using: 
  _156 = (*_157)
  using: _157@Mir(bb49[6])
  _161 = const {alloc198: *mut [i8; 1034]}
  using: 
  _160 = &mut (*_161)
  using: _161@Mir(bb49[8])
  _159 = move _160 as &mut [i8] (Pointer(Unsize))
  using: _160@Mir(bb49[9])
  _158 = core::slice::<impl [i8]>::as_mut_ptr(move _159) -> bb50
  using: _159@Mir(bb49[10])
bb50:
  _164 = bzip2::__error() -> bb51
  using: 
bb51:
  _163 = (*_164)
  using: _164@Mir(bb50[0])
  _162 = bzip2::strerror(move _163) -> bb52
  using: _163@Mir(bb51[0])
bb52:
  _149 = bzip2::fprintf(move _150, move _152, move _156, move _158, move _162) -> bb53
  using: _150@Mir(bb49[1]), _152@Mir(bb49[5]), _156@Mir(bb49[7]), _158@Mir(bb49[11]), _162@Mir(bb51[1])
bb53:
  _166 = const 1_i32
  using: 
  _165 = bzip2::setExit(move _166) -> bb188
  using: _166@Mir(bb53[0])
bb54:
  _170 = const {alloc267: *mut i32}
  using: 
  _169 = (*_170)
  using: _170@Mir(bb54[0])
  _171 = const 3_i32
  using: 
  _168 = Eq(move _169, move _171)
  using: _169@Mir(bb54[1]), _171@Mir(bb54[2])
  switchInt(move _168) -> [0: bb56, otherwise: bb55]
  using: _168@Mir(bb54[3])
bb55:
  _167 = const true
  using: 
  goto -> bb57
  using: 
bb56:
  _174 = const {alloc267: *mut i32}
  using: 
  _173 = (*_174)
  using: _174@Mir(bb56[0])
  _175 = const 2_i32
  using: 
  _172 = Eq(move _173, move _175)
  using: _173@Mir(bb56[1]), _175@Mir(bb56[2])
  _167 = move _172
  using: _172@Mir(bb56[3])
  goto -> bb57
  using: 
bb57:
  switchInt(move _167) -> [0: bb64, otherwise: bb58]
  using: _167@Phi(bb57)
bb58:
  _181 = const {alloc198: *mut [i8; 1034]}
  using: 
  _180 = &mut (*_181)
  using: _181@Mir(bb58[0])
  _179 = move _180 as &mut [i8] (Pointer(Unsize))
  using: _180@Mir(bb58[1])
  _178 = core::slice::<impl [i8]>::as_mut_ptr(move _179) -> bb59
  using: _179@Mir(bb58[2])
bb59:
  _177 = move _178 as *const i8 (Pointer(MutToConstPointer))
  using: _178@Mir(bb58[3])
  _183 = &mut _9
  using: _9@Mir(bb0[19])
  _182 = &raw mut (*_183)
  using: _183@Mir(bb59[1])
  _176 = bzip2::stat(move _177, move _182) -> bb60
  using: _177@Mir(bb59[0]), _182@Mir(bb59[2])
bb60:
  _187 = (_9.1: u16)
  using: _9@Mir(bb0[19])
  _186 = move _187 as i32 (IntToInt)
  using: _187@Mir(bb60[0])
  _188 = const 61440_i32
  using: 
  _185 = BitAnd(move _186, move _188)
  using: _186@Mir(bb60[1]), _188@Mir(bb60[2])
  _189 = const 16384_i32
  using: 
  _184 = Eq(move _185, move _189)
  using: _185@Mir(bb60[3]), _189@Mir(bb60[4])
  switchInt(move _184) -> [0: bb64, otherwise: bb61]
  using: _184@Mir(bb60[5])
bb61:
  _192 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _191 = (*_192)
  using: _192@Mir(bb61[0])
  _196 = const b"%s: Input file %s is a directory.\n\x00"
  using: 
  _195 = &raw const (*_196)
  using: _196@Mir(bb61[2])
  _194 = move _195 as *const u8 (Pointer(ArrayToPointer))
  using: _195@Mir(bb61[3])
  _193 = move _194 as *const i8 (PtrToPtr)
  using: _194@Mir(bb61[4])
  _198 = const {alloc197: *mut *mut i8}
  using: 
  _197 = (*_198)
  using: _198@Mir(bb61[6])
  _202 = const {alloc198: *mut [i8; 1034]}
  using: 
  _201 = &mut (*_202)
  using: _202@Mir(bb61[8])
  _200 = move _201 as &mut [i8] (Pointer(Unsize))
  using: _201@Mir(bb61[9])
  _199 = core::slice::<impl [i8]>::as_mut_ptr(move _200) -> bb62
  using: _200@Mir(bb61[10])
bb62:
  _190 = bzip2::fprintf(move _191, move _193, move _197, move _199) -> bb63
  using: _191@Mir(bb61[1]), _193@Mir(bb61[5]), _197@Mir(bb61[7]), _199@Mir(bb61[11])
bb63:
  _204 = const 1_i32
  using: 
  _203 = bzip2::setExit(move _204) -> bb188
  using: _204@Mir(bb63[0])
bb64:
  _209 = const {alloc267: *mut i32}
  using: 
  _208 = (*_209)
  using: _209@Mir(bb64[0])
  _210 = const 3_i32
  using: 
  _207 = Eq(move _208, move _210)
  using: _208@Mir(bb64[1]), _210@Mir(bb64[2])
  switchInt(move _207) -> [0: bb68, otherwise: bb69]
  using: _207@Mir(bb64[3])
bb65:
  _205 = const false
  using: 
  goto -> bb67
  using: 
bb66:
  _220 = const {alloc198: *mut [i8; 1034]}
  using: 
  _219 = &mut (*_220)
  using: _220@Mir(bb66[0])
  _218 = move _219 as &mut [i8] (Pointer(Unsize))
  using: _219@Mir(bb66[1])
  _217 = core::slice::<impl [i8]>::as_mut_ptr(move _218) -> bb71
  using: _218@Mir(bb66[2])
bb67:
  switchInt(move _205) -> [0: bb77, otherwise: bb73]
  using: _205@Phi(bb67)
bb68:
  _206 = const false
  using: 
  goto -> bb70
  using: 
bb69:
  _213 = const {alloc194: *mut u8}
  using: 
  _212 = (*_213)
  using: _213@Mir(bb69[0])
  _211 = Eq(move _212, const 0_u8)
  using: _212@Mir(bb69[1])
  _206 = move _211
  using: _211@Mir(bb69[2])
  goto -> bb70
  using: 
bb70:
  switchInt(move _206) -> [0: bb65, otherwise: bb66]
  using: _206@Phi(bb70)
bb71:
  _216 = bzip2::notAStandardFile(move _217) -> bb72
  using: _217@Mir(bb66[3])
bb72:
  _215 = move _216 as i32 (IntToInt)
  using: _216@Mir(bb71[0])
  _214 = Ne(move _215, const 0_i32)
  using: _215@Mir(bb72[0])
  _205 = move _214
  using: _214@Mir(bb72[1])
  goto -> bb67
  using: 
bb73:
  _222 = const {alloc196: *mut u8}
  using: 
  _221 = (*_222)
  using: _222@Mir(bb73[0])
  switchInt(move _221) -> [0: bb76, otherwise: bb74]
  using: _221@Mir(bb73[1])
bb74:
  _225 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _224 = (*_225)
  using: _225@Mir(bb74[0])
  _229 = const b"%s: Input file %s is not a normal file.\n\x00"
  using: 
  _228 = &raw const (*_229)
  using: _229@Mir(bb74[2])
  _227 = move _228 as *const u8 (Pointer(ArrayToPointer))
  using: _228@Mir(bb74[3])
  _226 = move _227 as *const i8 (PtrToPtr)
  using: _227@Mir(bb74[4])
  _231 = const {alloc197: *mut *mut i8}
  using: 
  _230 = (*_231)
  using: _231@Mir(bb74[6])
  _235 = const {alloc198: *mut [i8; 1034]}
  using: 
  _234 = &mut (*_235)
  using: _235@Mir(bb74[8])
  _233 = move _234 as &mut [i8] (Pointer(Unsize))
  using: _234@Mir(bb74[9])
  _232 = core::slice::<impl [i8]>::as_mut_ptr(move _233) -> bb75
  using: _233@Mir(bb74[10])
bb75:
  _223 = bzip2::fprintf(move _224, move _226, move _230, move _232) -> bb76
  using: _224@Mir(bb74[1]), _226@Mir(bb74[5]), _230@Mir(bb74[7]), _232@Mir(bb74[11])
bb76:
  _237 = const 1_i32
  using: 
  _236 = bzip2::setExit(move _237) -> bb188
  using: _237@Mir(bb76[0])
bb77:
  _238 = _8
  using: _8@Phi(bb33)
  switchInt(move _238) -> [0: bb82, otherwise: bb78]
  using: _238@Mir(bb77[0])
bb78:
  _240 = const {alloc196: *mut u8}
  using: 
  _239 = (*_240)
  using: _240@Mir(bb78[0])
  switchInt(move _239) -> [0: bb82, otherwise: bb79]
  using: _239@Mir(bb78[1])
bb79:
  _243 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _242 = (*_243)
  using: _243@Mir(bb79[0])
  _247 = const b"%s: Can\'t guess original name for %s -- using %s\n\x00"
  using: 
  _246 = &raw const (*_247)
  using: _247@Mir(bb79[2])
  _245 = move _246 as *const u8 (Pointer(ArrayToPointer))
  using: _246@Mir(bb79[3])
  _244 = move _245 as *const i8 (PtrToPtr)
  using: _245@Mir(bb79[4])
  _249 = const {alloc197: *mut *mut i8}
  using: 
  _248 = (*_249)
  using: _249@Mir(bb79[6])
  _253 = const {alloc198: *mut [i8; 1034]}
  using: 
  _252 = &mut (*_253)
  using: _253@Mir(bb79[8])
  _251 = move _252 as &mut [i8] (Pointer(Unsize))
  using: _252@Mir(bb79[9])
  _250 = core::slice::<impl [i8]>::as_mut_ptr(move _251) -> bb80
  using: _251@Mir(bb79[10])
bb80:
  _257 = const {alloc263: *mut [i8; 1034]}
  using: 
  _256 = &mut (*_257)
  using: _257@Mir(bb80[0])
  _255 = move _256 as &mut [i8] (Pointer(Unsize))
  using: _256@Mir(bb80[1])
  _254 = core::slice::<impl [i8]>::as_mut_ptr(move _255) -> bb81
  using: _255@Mir(bb80[2])
bb81:
  _241 = bzip2::fprintf(move _242, move _244, move _248, move _250, move _254) -> bb82
  using: _242@Mir(bb79[1]), _244@Mir(bb79[5]), _248@Mir(bb79[7]), _250@Mir(bb79[11]), _254@Mir(bb80[3])
bb82:
  _261 = const {alloc267: *mut i32}
  using: 
  _260 = (*_261)
  using: _261@Mir(bb82[0])
  _262 = const 3_i32
  using: 
  _259 = Eq(move _260, move _262)
  using: _260@Mir(bb82[1]), _262@Mir(bb82[2])
  switchInt(move _259) -> [0: bb83, otherwise: bb84]
  using: _259@Mir(bb82[3])
bb83:
  _258 = const false
  using: 
  goto -> bb85
  using: 
bb84:
  _269 = const {alloc263: *mut [i8; 1034]}
  using: 
  _268 = &mut (*_269)
  using: _269@Mir(bb84[0])
  _267 = move _268 as &mut [i8] (Pointer(Unsize))
  using: _268@Mir(bb84[1])
  _266 = core::slice::<impl [i8]>::as_mut_ptr(move _267) -> bb86
  using: _267@Mir(bb84[2])
bb85:
  switchInt(move _258) -> [0: bb94, otherwise: bb88]
  using: _258@Phi(bb85)
bb86:
  _265 = bzip2::fileExists(move _266) -> bb87
  using: _266@Mir(bb84[3])
bb87:
  _264 = move _265 as i32 (IntToInt)
  using: _265@Mir(bb86[0])
  _263 = Ne(move _264, const 0_i32)
  using: _264@Mir(bb87[0])
  _258 = move _263
  using: _263@Mir(bb87[1])
  goto -> bb85
  using: 
bb88:
  _271 = const {alloc194: *mut u8}
  using: 
  _270 = (*_271)
  using: _271@Mir(bb88[0])
  switchInt(move _270) -> [0: bb91, otherwise: bb89]
  using: _270@Mir(bb88[1])
bb89:
  _277 = const {alloc263: *mut [i8; 1034]}
  using: 
  _276 = &mut (*_277)
  using: _277@Mir(bb89[0])
  _275 = move _276 as &mut [i8] (Pointer(Unsize))
  using: _276@Mir(bb89[1])
  _274 = core::slice::<impl [i8]>::as_mut_ptr(move _275) -> bb90
  using: _275@Mir(bb89[2])
bb90:
  _273 = move _274 as *const i8 (Pointer(MutToConstPointer))
  using: _274@Mir(bb89[3])
  _272 = bzip2::remove(move _273) -> bb94
  using: _273@Mir(bb90[0])
bb91:
  _280 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _279 = (*_280)
  using: _280@Mir(bb91[0])
  _284 = const b"%s: Output file %s already exists.\n\x00"
  using: 
  _283 = &raw const (*_284)
  using: _284@Mir(bb91[2])
  _282 = move _283 as *const u8 (Pointer(ArrayToPointer))
  using: _283@Mir(bb91[3])
  _281 = move _282 as *const i8 (PtrToPtr)
  using: _282@Mir(bb91[4])
  _286 = const {alloc197: *mut *mut i8}
  using: 
  _285 = (*_286)
  using: _286@Mir(bb91[6])
  _290 = const {alloc263: *mut [i8; 1034]}
  using: 
  _289 = &mut (*_290)
  using: _290@Mir(bb91[8])
  _288 = move _289 as &mut [i8] (Pointer(Unsize))
  using: _289@Mir(bb91[9])
  _287 = core::slice::<impl [i8]>::as_mut_ptr(move _288) -> bb92
  using: _288@Mir(bb91[10])
bb92:
  _278 = bzip2::fprintf(move _279, move _281, move _285, move _287) -> bb93
  using: _279@Mir(bb91[1]), _281@Mir(bb91[5]), _285@Mir(bb91[7]), _287@Mir(bb91[11])
bb93:
  _292 = const 1_i32
  using: 
  _291 = bzip2::setExit(move _292) -> bb188
  using: _292@Mir(bb93[0])
bb94:
  _297 = const {alloc267: *mut i32}
  using: 
  _296 = (*_297)
  using: _297@Mir(bb94[0])
  _298 = const 3_i32
  using: 
  _295 = Eq(move _296, move _298)
  using: _296@Mir(bb94[1]), _298@Mir(bb94[2])
  switchInt(move _295) -> [0: bb98, otherwise: bb99]
  using: _295@Mir(bb94[3])
bb95:
  _293 = const false
  using: 
  goto -> bb97
  using: 
bb96:
  _307 = const {alloc198: *mut [i8; 1034]}
  using: 
  _306 = &mut (*_307)
  using: _307@Mir(bb96[0])
  _305 = move _306 as &mut [i8] (Pointer(Unsize))
  using: _306@Mir(bb96[1])
  _304 = core::slice::<impl [i8]>::as_mut_ptr(move _305) -> bb101
  using: _305@Mir(bb96[2])
bb97:
  switchInt(move _293) -> [0: bb109, otherwise: bb103]
  using: _293@Phi(bb97)
bb98:
  _294 = const false
  using: 
  goto -> bb100
  using: 
bb99:
  _301 = const {alloc194: *mut u8}
  using: 
  _300 = (*_301)
  using: _301@Mir(bb99[0])
  _299 = Eq(move _300, const 0_u8)
  using: _300@Mir(bb99[1])
  _294 = move _299
  using: _299@Mir(bb99[2])
  goto -> bb100
  using: 
bb100:
  switchInt(move _294) -> [0: bb95, otherwise: bb96]
  using: _294@Phi(bb100)
bb101:
  _303 = bzip2::countHardLinks(move _304) -> bb102
  using: _304@Mir(bb96[3])
bb102:
  _5 = move _303
  using: _303@Mir(bb101[0])
  _308 = _5
  using: _5@Mir(bb102[0])
  _309 = const 0_i32
  using: 
  _302 = Gt(move _308, move _309)
  using: _308@Mir(bb102[1]), _309@Mir(bb102[2])
  _293 = move _302
  using: _302@Mir(bb102[3])
  goto -> bb97
  using: 
bb103:
  _312 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _311 = (*_312)
  using: _312@Mir(bb103[0])
  _316 = const b"%s: Input file %s has %d other link%s.\n\x00"
  using: 
  _315 = &raw const (*_316)
  using: _316@Mir(bb103[2])
  _314 = move _315 as *const u8 (Pointer(ArrayToPointer))
  using: _315@Mir(bb103[3])
  _313 = move _314 as *const i8 (PtrToPtr)
  using: _314@Mir(bb103[4])
  _318 = const {alloc197: *mut *mut i8}
  using: 
  _317 = (*_318)
  using: _318@Mir(bb103[6])
  _322 = const {alloc198: *mut [i8; 1034]}
  using: 
  _321 = &mut (*_322)
  using: _322@Mir(bb103[8])
  _320 = move _321 as &mut [i8] (Pointer(Unsize))
  using: _321@Mir(bb103[9])
  _319 = core::slice::<impl [i8]>::as_mut_ptr(move _320) -> bb104
  using: _320@Mir(bb103[10])
bb104:
  _323 = _5
  using: _5@Phi(bb97)
  _326 = _5
  using: _5@Phi(bb97)
  _327 = const 1_i32
  using: 
  _325 = Gt(move _326, move _327)
  using: _326@Mir(bb104[1]), _327@Mir(bb104[2])
  switchInt(move _325) -> [0: bb106, otherwise: bb105]
  using: _325@Mir(bb104[3])
bb105:
  _330 = const b"s\x00"
  using: 
  _329 = &raw const (*_330)
  using: _330@Mir(bb105[0])
  _328 = move _329 as *const u8 (Pointer(ArrayToPointer))
  using: _329@Mir(bb105[1])
  _324 = move _328 as *const i8 (PtrToPtr)
  using: _328@Mir(bb105[2])
  goto -> bb107
  using: 
bb106:
  _333 = const b"\x00"
  using: 
  _332 = &raw const (*_333)
  using: _333@Mir(bb106[0])
  _331 = move _332 as *const u8 (Pointer(ArrayToPointer))
  using: _332@Mir(bb106[1])
  _324 = move _331 as *const i8 (PtrToPtr)
  using: _331@Mir(bb106[2])
  goto -> bb107
  using: 
bb107:
  _310 = bzip2::fprintf(move _311, move _313, move _317, move _319, move _323, move _324) -> bb108
  using: _311@Mir(bb103[1]), _313@Mir(bb103[5]), _317@Mir(bb103[7]), _319@Mir(bb103[11]), _323@Mir(bb104[0]), _324@Phi(bb107)
bb108:
  _335 = const 1_i32
  using: 
  _334 = bzip2::setExit(move _335) -> bb188
  using: _335@Mir(bb108[0])
bb109:
  _338 = const {alloc267: *mut i32}
  using: 
  _337 = (*_338)
  using: _338@Mir(bb109[0])
  _339 = const 3_i32
  using: 
  _336 = Eq(move _337, move _339)
  using: _337@Mir(bb109[1]), _339@Mir(bb109[2])
  switchInt(move _336) -> [0: bb112, otherwise: bb110]
  using: _336@Mir(bb109[3])
bb110:
  _344 = const {alloc198: *mut [i8; 1034]}
  using: 
  _343 = &mut (*_344)
  using: _344@Mir(bb110[0])
  _342 = move _343 as &mut [i8] (Pointer(Unsize))
  using: _343@Mir(bb110[1])
  _341 = core::slice::<impl [i8]>::as_mut_ptr(move _342) -> bb111
  using: _342@Mir(bb110[2])
bb111:
  _340 = bzip2::saveInputFileMetaInfo(move _341) -> bb112
  using: _341@Mir(bb110[3])
bb112:
  _345 = const {alloc267: *mut i32}
  using: 
  switchInt((*_345)) -> [1: bb114, 2: bb120, 3: bb133, otherwise: bb113]
  using: _345@Mir(bb112[0])
bb113:
  _504 = const b"uncompress: bad srcMode\x00"
  using: 
  _503 = &raw const (*_504)
  using: _504@Mir(bb113[0])
  _502 = move _503 as *const u8 (Pointer(ArrayToPointer))
  using: _503@Mir(bb113[1])
  _501 = move _502 as *const i8 (PtrToPtr)
  using: _502@Mir(bb113[2])
  _500 = bzip2::panic(move _501)
  using: _501@Mir(bb113[3])
bb114:
  _347 = const {alloc195: *mut *mut blocksort::__sFILE}
  using: 
  _346 = (*_347)
  using: _347@Mir(bb114[0])
  _3 = move _346
  using: _346@Mir(bb114[1])
  _349 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _348 = (*_349)
  using: _349@Mir(bb114[3])
  _4 = move _348
  using: _348@Mir(bb114[4])
  _353 = const {alloc195: *mut *mut blocksort::__sFILE}
  using: 
  _352 = (*_353)
  using: _353@Mir(bb114[6])
  _351 = bzip2::fileno(move _352) -> bb115
  using: _352@Mir(bb114[7])
bb115:
  _350 = bzip2::isatty(move _351) -> bb116
  using: _351@Mir(bb114[8])
bb116:
  switchInt(move _350) -> [0: bb159, otherwise: bb117]
  using: _350@Mir(bb115[0])
bb117:
  _356 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _355 = (*_356)
  using: _356@Mir(bb117[0])
  _360 = const b"%s: I won\'t read compressed data from a terminal.\n\x00"
  using: 
  _359 = &raw const (*_360)
  using: _360@Mir(bb117[2])
  _358 = move _359 as *const u8 (Pointer(ArrayToPointer))
  using: _359@Mir(bb117[3])
  _357 = move _358 as *const i8 (PtrToPtr)
  using: _358@Mir(bb117[4])
  _362 = const {alloc197: *mut *mut i8}
  using: 
  _361 = (*_362)
  using: _362@Mir(bb117[6])
  _354 = bzip2::fprintf(move _355, move _357, move _361) -> bb118
  using: _355@Mir(bb117[1]), _357@Mir(bb117[5]), _361@Mir(bb117[7])
bb118:
  _365 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _364 = (*_365)
  using: _365@Mir(bb118[0])
  _369 = const b"%s: For help, type: `%s --help\'.\n\x00"
  using: 
  _368 = &raw const (*_369)
  using: _369@Mir(bb118[2])
  _367 = move _368 as *const u8 (Pointer(ArrayToPointer))
  using: _368@Mir(bb118[3])
  _366 = move _367 as *const i8 (PtrToPtr)
  using: _367@Mir(bb118[4])
  _371 = const {alloc197: *mut *mut i8}
  using: 
  _370 = (*_371)
  using: _371@Mir(bb118[6])
  _373 = const {alloc197: *mut *mut i8}
  using: 
  _372 = (*_373)
  using: _373@Mir(bb118[8])
  _363 = bzip2::fprintf(move _364, move _366, move _370, move _372) -> bb119
  using: _364@Mir(bb118[1]), _366@Mir(bb118[5]), _370@Mir(bb118[7]), _372@Mir(bb118[9])
bb119:
  _375 = const 1_i32
  using: 
  _374 = bzip2::setExit(move _375) -> bb188
  using: _375@Mir(bb119[0])
bb120:
  _381 = const {alloc198: *mut [i8; 1034]}
  using: 
  _380 = &mut (*_381)
  using: _381@Mir(bb120[0])
  _379 = move _380 as &mut [i8] (Pointer(Unsize))
  using: _380@Mir(bb120[1])
  _378 = core::slice::<impl [i8]>::as_mut_ptr(move _379) -> bb121
  using: _379@Mir(bb120[2])
bb121:
  _377 = move _378 as *const i8 (Pointer(MutToConstPointer))
  using: _378@Mir(bb120[3])
  _385 = const b"rb\x00"
  using: 
  _384 = &raw const (*_385)
  using: _385@Mir(bb121[1])
  _383 = move _384 as *const u8 (Pointer(ArrayToPointer))
  using: _384@Mir(bb121[2])
  _382 = move _383 as *const i8 (PtrToPtr)
  using: _383@Mir(bb121[3])
  _376 = bzip2::fopen(move _377, move _382) -> bb122
  using: _377@Mir(bb121[0]), _382@Mir(bb121[4])
bb122:
  _3 = move _376
  using: _376@Mir(bb121[5])
  _387 = const {alloc175: *mut *mut blocksort::__sFILE}
  using: 
  _386 = (*_387)
  using: _387@Mir(bb122[1])
  _4 = move _386
  using: _386@Mir(bb122[2])
  _389 = _3
  using: _3@Mir(bb122[0])
  _388 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _389) -> bb123
  using: _389@Mir(bb122[4])
bb123:
  switchInt(move _388) -> [0: bb159, otherwise: bb124]
  using: _388@Mir(bb122[5])
bb124:
  _392 = _3
  using: _3@Mir(bb122[0])
  _391 = move _392 as usize (PointerExposeAddress)
  using: _392@Mir(bb124[0])
  _390 = Eq(move _391, const 0_usize)
  using: _391@Mir(bb124[1])
  assume(move _390)
  using: _390@Mir(bb124[2])
  _395 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _394 = (*_395)
  using: _395@Mir(bb124[4])
  _399 = const b"%s: Can\'t open input file %s:%s.\n\x00"
  using: 
  _398 = &raw const (*_399)
  using: _399@Mir(bb124[6])
  _397 = move _398 as *const u8 (Pointer(ArrayToPointer))
  using: _398@Mir(bb124[7])
  _396 = move _397 as *const i8 (PtrToPtr)
  using: _397@Mir(bb124[8])
  _401 = const {alloc197: *mut *mut i8}
  using: 
  _400 = (*_401)
  using: _401@Mir(bb124[10])
  _405 = const {alloc198: *mut [i8; 1034]}
  using: 
  _404 = &mut (*_405)
  using: _405@Mir(bb124[12])
  _403 = move _404 as &mut [i8] (Pointer(Unsize))
  using: _404@Mir(bb124[13])
  _402 = core::slice::<impl [i8]>::as_mut_ptr(move _403) -> bb125
  using: _403@Mir(bb124[14])
bb125:
  _408 = bzip2::__error() -> bb126
  using: 
bb126:
  _407 = (*_408)
  using: _408@Mir(bb125[0])
  _406 = bzip2::strerror(move _407) -> bb127
  using: _407@Mir(bb126[0])
bb127:
  _393 = bzip2::fprintf(move _394, move _396, move _400, move _402, move _406) -> bb128
  using: _394@Mir(bb124[5]), _396@Mir(bb124[9]), _400@Mir(bb124[11]), _402@Mir(bb124[15]), _406@Mir(bb126[1])
bb128:
  _411 = _3
  using: _3@Mir(bb122[0])
  _410 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _411) -> bb129
  using: _411@Mir(bb128[0])
bb129:
  _409 = Not(move _410)
  using: _410@Mir(bb128[1])
  switchInt(move _409) -> [0: bb131, otherwise: bb130]
  using: _409@Mir(bb129[0])
bb130:
  _413 = _3
  using: _3@Mir(bb122[0])
  _412 = bzip2::fclose(move _413) -> bb132
  using: _413@Mir(bb130[0])
bb131:
  _416 = _3
  using: _3@Mir(bb122[0])
  _415 = move _416 as usize (PointerExposeAddress)
  using: _416@Mir(bb131[0])
  _414 = Eq(move _415, const 0_usize)
  using: _415@Mir(bb131[1])
  assume(move _414)
  using: _414@Mir(bb131[2])
  goto -> bb132
  using: 
bb132:
  _418 = const 1_i32
  using: 
  _417 = bzip2::setExit(move _418) -> bb188
  using: _418@Mir(bb132[0])
bb133:
  _424 = const {alloc198: *mut [i8; 1034]}
  using: 
  _423 = &mut (*_424)
  using: _424@Mir(bb133[0])
  _422 = move _423 as &mut [i8] (Pointer(Unsize))
  using: _423@Mir(bb133[1])
  _421 = core::slice::<impl [i8]>::as_mut_ptr(move _422) -> bb134
  using: _422@Mir(bb133[2])
bb134:
  _420 = move _421 as *const i8 (Pointer(MutToConstPointer))
  using: _421@Mir(bb133[3])
  _428 = const b"rb\x00"
  using: 
  _427 = &raw const (*_428)
  using: _428@Mir(bb134[1])
  _426 = move _427 as *const u8 (Pointer(ArrayToPointer))
  using: _427@Mir(bb134[2])
  _425 = move _426 as *const i8 (PtrToPtr)
  using: _426@Mir(bb134[3])
  _419 = bzip2::fopen(move _420, move _425) -> bb135
  using: _420@Mir(bb134[0]), _425@Mir(bb134[4])
bb135:
  _3 = move _419
  using: _419@Mir(bb134[5])
  _433 = const {alloc263: *mut [i8; 1034]}
  using: 
  _432 = &mut (*_433)
  using: _433@Mir(bb135[1])
  _431 = move _432 as &mut [i8] (Pointer(Unsize))
  using: _432@Mir(bb135[2])
  _430 = core::slice::<impl [i8]>::as_mut_ptr(move _431) -> bb136
  using: _431@Mir(bb135[3])
bb136:
  _437 = const b"wb\x00"
  using: 
  _436 = &raw const (*_437)
  using: _437@Mir(bb136[0])
  _435 = move _436 as *const u8 (Pointer(ArrayToPointer))
  using: _436@Mir(bb136[1])
  _434 = move _435 as *const i8 (PtrToPtr)
  using: _435@Mir(bb136[2])
  _429 = bzip2::fopen_output_safely(move _430, move _434) -> bb137
  using: _430@Mir(bb135[4]), _434@Mir(bb136[3])
bb137:
  _4 = move _429
  using: _429@Mir(bb136[4])
  _439 = _4
  using: _4@Mir(bb137[0])
  _438 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _439) -> bb138
  using: _439@Mir(bb137[1])
bb138:
  switchInt(move _438) -> [0: bb148, otherwise: bb139]
  using: _438@Mir(bb137[2])
bb139:
  _442 = _4
  using: _4@Mir(bb137[0])
  _441 = move _442 as usize (PointerExposeAddress)
  using: _442@Mir(bb139[0])
  _440 = Eq(move _441, const 0_usize)
  using: _441@Mir(bb139[1])
  assume(move _440)
  using: _440@Mir(bb139[2])
  _445 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _444 = (*_445)
  using: _445@Mir(bb139[4])
  _449 = const b"%s: Can\'t create output file %s: %s.\n\x00"
  using: 
  _448 = &raw const (*_449)
  using: _449@Mir(bb139[6])
  _447 = move _448 as *const u8 (Pointer(ArrayToPointer))
  using: _448@Mir(bb139[7])
  _446 = move _447 as *const i8 (PtrToPtr)
  using: _447@Mir(bb139[8])
  _451 = const {alloc197: *mut *mut i8}
  using: 
  _450 = (*_451)
  using: _451@Mir(bb139[10])
  _455 = const {alloc263: *mut [i8; 1034]}
  using: 
  _454 = &mut (*_455)
  using: _455@Mir(bb139[12])
  _453 = move _454 as &mut [i8] (Pointer(Unsize))
  using: _454@Mir(bb139[13])
  _452 = core::slice::<impl [i8]>::as_mut_ptr(move _453) -> bb140
  using: _453@Mir(bb139[14])
bb140:
  _458 = bzip2::__error() -> bb141
  using: 
bb141:
  _457 = (*_458)
  using: _458@Mir(bb140[0])
  _456 = bzip2::strerror(move _457) -> bb142
  using: _457@Mir(bb141[0])
bb142:
  _443 = bzip2::fprintf(move _444, move _446, move _450, move _452, move _456) -> bb143
  using: _444@Mir(bb139[5]), _446@Mir(bb139[9]), _450@Mir(bb139[11]), _452@Mir(bb139[15]), _456@Mir(bb141[1])
bb143:
  _461 = _3
  using: _3@Mir(bb135[0])
  _460 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _461) -> bb144
  using: _461@Mir(bb143[0])
bb144:
  _459 = Not(move _460)
  using: _460@Mir(bb143[1])
  switchInt(move _459) -> [0: bb146, otherwise: bb145]
  using: _459@Mir(bb144[0])
bb145:
  _463 = _3
  using: _3@Mir(bb135[0])
  _462 = bzip2::fclose(move _463) -> bb147
  using: _463@Mir(bb145[0])
bb146:
  _466 = _3
  using: _3@Mir(bb135[0])
  _465 = move _466 as usize (PointerExposeAddress)
  using: _466@Mir(bb146[0])
  _464 = Eq(move _465, const 0_usize)
  using: _465@Mir(bb146[1])
  assume(move _464)
  using: _464@Mir(bb146[2])
  goto -> bb147
  using: 
bb147:
  _468 = const 1_i32
  using: 
  _467 = bzip2::setExit(move _468) -> bb188
  using: _468@Mir(bb147[0])
bb148:
  _470 = _3
  using: _3@Phi(bb147)
  _469 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _470) -> bb149
  using: _470@Mir(bb148[0])
bb149:
  switchInt(move _469) -> [0: bb159, otherwise: bb150]
  using: _469@Mir(bb148[1])
bb150:
  _473 = _3
  using: _3@Phi(bb147)
  _472 = move _473 as usize (PointerExposeAddress)
  using: _473@Mir(bb150[0])
  _471 = Eq(move _472, const 0_usize)
  using: _472@Mir(bb150[1])
  assume(move _471)
  using: _471@Mir(bb150[2])
  _476 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _475 = (*_476)
  using: _476@Mir(bb150[4])
  _480 = const b"%s: Can\'t open input file %s: %s.\n\x00"
  using: 
  _479 = &raw const (*_480)
  using: _480@Mir(bb150[6])
  _478 = move _479 as *const u8 (Pointer(ArrayToPointer))
  using: _479@Mir(bb150[7])
  _477 = move _478 as *const i8 (PtrToPtr)
  using: _478@Mir(bb150[8])
  _482 = const {alloc197: *mut *mut i8}
  using: 
  _481 = (*_482)
  using: _482@Mir(bb150[10])
  _486 = const {alloc198: *mut [i8; 1034]}
  using: 
  _485 = &mut (*_486)
  using: _486@Mir(bb150[12])
  _484 = move _485 as &mut [i8] (Pointer(Unsize))
  using: _485@Mir(bb150[13])
  _483 = core::slice::<impl [i8]>::as_mut_ptr(move _484) -> bb151
  using: _484@Mir(bb150[14])
bb151:
  _489 = bzip2::__error() -> bb152
  using: 
bb152:
  _488 = (*_489)
  using: _489@Mir(bb151[0])
  _487 = bzip2::strerror(move _488) -> bb153
  using: _488@Mir(bb152[0])
bb153:
  _474 = bzip2::fprintf(move _475, move _477, move _481, move _483, move _487) -> bb154
  using: _475@Mir(bb150[5]), _477@Mir(bb150[9]), _481@Mir(bb150[11]), _483@Mir(bb150[15]), _487@Mir(bb152[1])
bb154:
  _492 = _4
  using: _4@Mir(bb137[0])
  _491 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _492) -> bb155
  using: _492@Mir(bb154[0])
bb155:
  _490 = Not(move _491)
  using: _491@Mir(bb154[1])
  switchInt(move _490) -> [0: bb157, otherwise: bb156]
  using: _490@Mir(bb155[0])
bb156:
  _494 = _4
  using: _4@Mir(bb137[0])
  _493 = bzip2::fclose(move _494) -> bb158
  using: _494@Mir(bb156[0])
bb157:
  _497 = _4
  using: _4@Mir(bb137[0])
  _496 = move _497 as usize (PointerExposeAddress)
  using: _497@Mir(bb157[0])
  _495 = Eq(move _496, const 0_usize)
  using: _496@Mir(bb157[1])
  assume(move _495)
  using: _495@Mir(bb157[2])
  goto -> bb158
  using: 
bb158:
  _499 = const 1_i32
  using: 
  _498 = bzip2::setExit(move _499) -> bb188
  using: _499@Mir(bb158[0])
bb159:
  _507 = const {alloc172: *mut i32}
  using: 
  _506 = (*_507)
  using: _507@Mir(bb159[0])
  _508 = const 1_i32
  using: 
  _505 = Ge(move _506, move _508)
  using: _506@Mir(bb159[1]), _508@Mir(bb159[2])
  switchInt(move _505) -> [0: bb165, otherwise: bb160]
  using: _505@Mir(bb159[3])
bb160:
  _511 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _510 = (*_511)
  using: _511@Mir(bb160[0])
  _515 = const b"  %s: \x00"
  using: 
  _514 = &raw const (*_515)
  using: _515@Mir(bb160[2])
  _513 = move _514 as *const u8 (Pointer(ArrayToPointer))
  using: _514@Mir(bb160[3])
  _512 = move _513 as *const i8 (PtrToPtr)
  using: _513@Mir(bb160[4])
  _519 = const {alloc198: *mut [i8; 1034]}
  using: 
  _518 = &mut (*_519)
  using: _519@Mir(bb160[6])
  _517 = move _518 as &mut [i8] (Pointer(Unsize))
  using: _518@Mir(bb160[7])
  _516 = core::slice::<impl [i8]>::as_mut_ptr(move _517) -> bb161
  using: _517@Mir(bb160[8])
bb161:
  _509 = bzip2::fprintf(move _510, move _512, move _516) -> bb162
  using: _510@Mir(bb160[1]), _512@Mir(bb160[5]), _516@Mir(bb160[9])
bb162:
  _524 = const {alloc198: *mut [i8; 1034]}
  using: 
  _523 = &mut (*_524)
  using: _524@Mir(bb162[0])
  _522 = move _523 as &mut [i8] (Pointer(Unsize))
  using: _523@Mir(bb162[1])
  _521 = core::slice::<impl [i8]>::as_mut_ptr(move _522) -> bb163
  using: _522@Mir(bb162[2])
bb163:
  _520 = bzip2::pad(move _521) -> bb164
  using: _521@Mir(bb162[3])
bb164:
  _527 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _526 = (*_527)
  using: _527@Mir(bb164[0])
  _525 = bzip2::fflush(move _526) -> bb165
  using: _526@Mir(bb164[1])
bb165:
  _528 = _4
  using: _4@Phi(bb159)
  _529 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_529) = move _528
  using: _529@Mir(bb165[1]), _528@Mir(bb165[0])
  _530 = const 1_i32
  using: 
  _531 = const {alloc269: *mut u8}
  using: 
  (*_531) = move _530 as u8 (IntToInt)
  using: _531@Mir(bb165[4]), _530@Mir(bb165[3])
  _533 = _3
  using: _3@Phi(bb159)
  _534 = _4
  using: _4@Phi(bb159)
  _532 = bzip2::uncompressStream(move _533, move _534) -> bb166
  using: _533@Mir(bb165[6]), _534@Mir(bb165[7])
bb166:
  _7 = move _532
  using: _532@Mir(bb165[8])
  _535 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_535) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _535@Mir(bb166[1])
  _536 = _7
  using: _7@Mir(bb166[0])
  switchInt(move _536) -> [0: bb175, otherwise: bb167]
  using: _536@Mir(bb166[3])
bb167:
  _539 = const {alloc267: *mut i32}
  using: 
  _538 = (*_539)
  using: _539@Mir(bb167[0])
  _540 = const 3_i32
  using: 
  _537 = Eq(move _538, move _540)
  using: _538@Mir(bb167[1]), _540@Mir(bb167[2])
  switchInt(move _537) -> [0: bb180, otherwise: bb168]
  using: _537@Mir(bb167[3])
bb168:
  _545 = const {alloc263: *mut [i8; 1034]}
  using: 
  _544 = &mut (*_545)
  using: _545@Mir(bb168[0])
  _543 = move _544 as &mut [i8] (Pointer(Unsize))
  using: _544@Mir(bb168[1])
  _542 = core::slice::<impl [i8]>::as_mut_ptr(move _543) -> bb169
  using: _543@Mir(bb168[2])
bb169:
  _541 = bzip2::applySavedTimeInfoToOutputFile(move _542) -> bb170
  using: _542@Mir(bb168[3])
bb170:
  _546 = const 0_i32
  using: 
  _547 = const {alloc269: *mut u8}
  using: 
  (*_547) = move _546 as u8 (IntToInt)
  using: _547@Mir(bb170[1]), _546@Mir(bb170[0])
  _549 = const {alloc392: *mut u8}
  using: 
  _548 = (*_549)
  using: _549@Mir(bb170[3])
  switchInt(move _548) -> [0: bb171, otherwise: bb180]
  using: _548@Mir(bb170[4])
bb171:
  _555 = const {alloc198: *mut [i8; 1034]}
  using: 
  _554 = &mut (*_555)
  using: _555@Mir(bb171[0])
  _553 = move _554 as &mut [i8] (Pointer(Unsize))
  using: _554@Mir(bb171[1])
  _552 = core::slice::<impl [i8]>::as_mut_ptr(move _553) -> bb172
  using: _553@Mir(bb171[2])
bb172:
  _551 = move _552 as *const i8 (Pointer(MutToConstPointer))
  using: _552@Mir(bb171[3])
  _550 = bzip2::remove(move _551) -> bb173
  using: _551@Mir(bb172[0])
bb173:
  _557 = _550
  using: _550@Mir(bb172[1])
  _558 = const 0_i32
  using: 
  _556 = Ne(move _557, move _558)
  using: _557@Mir(bb173[0]), _558@Mir(bb173[1])
  switchInt(move _556) -> [0: bb180, otherwise: bb174]
  using: _556@Mir(bb173[2])
bb174:
  _559 = bzip2::ioError()
  using: 
bb175:
  _560 = const 1_i32
  using: 
  _561 = const {alloc433: *mut u8}
  using: 
  (*_561) = move _560 as u8 (IntToInt)
  using: _561@Mir(bb175[1]), _560@Mir(bb175[0])
  _562 = const 0_i32
  using: 
  _563 = const {alloc269: *mut u8}
  using: 
  (*_563) = move _562 as u8 (IntToInt)
  using: _563@Mir(bb175[4]), _562@Mir(bb175[3])
  _566 = const {alloc267: *mut i32}
  using: 
  _565 = (*_566)
  using: _566@Mir(bb175[6])
  _567 = const 3_i32
  using: 
  _564 = Eq(move _565, move _567)
  using: _565@Mir(bb175[7]), _567@Mir(bb175[8])
  switchInt(move _564) -> [0: bb180, otherwise: bb176]
  using: _564@Mir(bb175[9])
bb176:
  _573 = const {alloc263: *mut [i8; 1034]}
  using: 
  _572 = &mut (*_573)
  using: _573@Mir(bb176[0])
  _571 = move _572 as &mut [i8] (Pointer(Unsize))
  using: _572@Mir(bb176[1])
  _570 = core::slice::<impl [i8]>::as_mut_ptr(move _571) -> bb177
  using: _571@Mir(bb176[2])
bb177:
  _569 = move _570 as *const i8 (Pointer(MutToConstPointer))
  using: _570@Mir(bb176[3])
  _568 = bzip2::remove(move _569) -> bb178
  using: _569@Mir(bb177[0])
bb178:
  _575 = _568
  using: _568@Mir(bb177[1])
  _576 = const 0_i32
  using: 
  _574 = Ne(move _575, move _576)
  using: _575@Mir(bb178[0]), _576@Mir(bb178[1])
  switchInt(move _574) -> [0: bb180, otherwise: bb179]
  using: _574@Mir(bb178[2])
bb179:
  _577 = bzip2::ioError()
  using: 
bb180:
  _578 = const 0_i32
  using: 
  _579 = const {alloc269: *mut u8}
  using: 
  (*_579) = move _578 as u8 (IntToInt)
  using: _579@Mir(bb180[1]), _578@Mir(bb180[0])
  _580 = _7
  using: _7@Mir(bb166[0])
  switchInt(move _580) -> [0: bb183, otherwise: bb181]
  using: _580@Mir(bb180[3])
bb181:
  _583 = const {alloc172: *mut i32}
  using: 
  _582 = (*_583)
  using: _583@Mir(bb181[0])
  _584 = const 1_i32
  using: 
  _581 = Ge(move _582, move _584)
  using: _582@Mir(bb181[1]), _584@Mir(bb181[2])
  switchInt(move _581) -> [0: bb188, otherwise: bb182]
  using: _581@Mir(bb181[3])
bb182:
  _587 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _586 = (*_587)
  using: _587@Mir(bb182[0])
  _591 = const b"done\n\x00"
  using: 
  _590 = &raw const (*_591)
  using: _591@Mir(bb182[2])
  _589 = move _590 as *const u8 (Pointer(ArrayToPointer))
  using: _590@Mir(bb182[3])
  _588 = move _589 as *const i8 (PtrToPtr)
  using: _589@Mir(bb182[4])
  _585 = bzip2::fprintf(move _586, move _588) -> bb188
  using: _586@Mir(bb182[1]), _588@Mir(bb182[5])
bb183:
  _593 = const 2_i32
  using: 
  _592 = bzip2::setExit(move _593) -> bb184
  using: _593@Mir(bb183[0])
bb184:
  _596 = const {alloc172: *mut i32}
  using: 
  _595 = (*_596)
  using: _596@Mir(bb184[0])
  _597 = const 1_i32
  using: 
  _594 = Ge(move _595, move _597)
  using: _595@Mir(bb184[1]), _597@Mir(bb184[2])
  switchInt(move _594) -> [0: bb186, otherwise: bb185]
  using: _594@Mir(bb184[3])
bb185:
  _600 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _599 = (*_600)
  using: _600@Mir(bb185[0])
  _604 = const b"not a bzip2 file.\n\x00"
  using: 
  _603 = &raw const (*_604)
  using: _604@Mir(bb185[2])
  _602 = move _603 as *const u8 (Pointer(ArrayToPointer))
  using: _603@Mir(bb185[3])
  _601 = move _602 as *const i8 (PtrToPtr)
  using: _602@Mir(bb185[4])
  _598 = bzip2::fprintf(move _599, move _601) -> bb188
  using: _599@Mir(bb185[1]), _601@Mir(bb185[5])
bb186:
  _607 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _606 = (*_607)
  using: _607@Mir(bb186[0])
  _611 = const b"%s: %s is not a bzip2 file.\n\x00"
  using: 
  _610 = &raw const (*_611)
  using: _611@Mir(bb186[2])
  _609 = move _610 as *const u8 (Pointer(ArrayToPointer))
  using: _610@Mir(bb186[3])
  _608 = move _609 as *const i8 (PtrToPtr)
  using: _609@Mir(bb186[4])
  _613 = const {alloc197: *mut *mut i8}
  using: 
  _612 = (*_613)
  using: _613@Mir(bb186[6])
  _617 = const {alloc198: *mut [i8; 1034]}
  using: 
  _616 = &mut (*_617)
  using: _617@Mir(bb186[8])
  _615 = move _616 as &mut [i8] (Pointer(Unsize))
  using: _616@Mir(bb186[9])
  _614 = core::slice::<impl [i8]>::as_mut_ptr(move _615) -> bb187
  using: _615@Mir(bb186[10])
bb187:
  _605 = bzip2::fprintf(move _606, move _608, move _612, move _614) -> bb188
  using: _606@Mir(bb186[1]), _608@Mir(bb186[5]), _612@Mir(bb186[7]), _614@Mir(bb186[11])
bb188:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_10) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_11) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_12) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_13) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_9) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i64; 2] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcat @ workspace/bzip2/rust/bzip2.rs:2321:21: 2322:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2337:13: 2340:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2349:27: 2349:36 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2349:17: 2349:37 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2346:9: 2349:38 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::stat @ workspace/bzip2/rust/bzip2.rs:2354:9: 2354:48 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2357:13: 2359:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2367:13: 2370:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2377:13: 2380:63 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::remove @ workspace/bzip2/rust/bzip2.rs:2387:13: 2387:41 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2389:13: 2392:42 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2400:9: 2405:80 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fileno @ workspace/bzip2/rust/bzip2.rs:2418:23: 2418:39 (#0) by default
rewrite call bzip2::isatty @ workspace/bzip2/rust/bzip2.rs:2418:16: 2418:40 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2419:17: 2421:83 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2422:17: 2425:34 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fopen @ workspace/bzip2/rust/bzip2.rs:2432:17: 2433:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2439:56: 2439:65 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2439:46: 2439:66 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2436:17: 2439:67 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:2440:39: 2440:52 (#0) by default
rewrite call bzip2::fopen @ workspace/bzip2/rust/bzip2.rs:2447:17: 2448:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2457:57: 2457:66 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2457:47: 2457:67 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2454:17: 2457:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:2458:39: 2458:52 (#0) by default
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2466:56: 2466:65 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2466:46: 2466:66 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2463:17: 2466:67 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fclose @ workspace/bzip2/rust/bzip2.rs:2467:40: 2467:54 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2478:9: 2479:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fflush @ workspace/bzip2/rust/bzip2.rs:2481:9: 2481:26 (#0) by default
rewrite call bzip2::remove @ workspace/bzip2/rust/bzip2.rs:2494:45: 2494:72 (#0) by default
rewrite call bzip2::remove @ workspace/bzip2/rust/bzip2.rs:2502:43: 2502:71 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2509:13: 2510:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2515:13: 2517:53 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2519:13: 2521:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:239 ~ c2rust_lib[1043]::bzip2::testf)
bb0:
  _2 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _3 = const 0_u8
  using: 
  Deinit(_5)
  using: 
  (_5.0: i64) = const 0_i64
  using: 
  (_5.1: i64) = const 0_i64
  using: 
  Deinit(_6)
  using: 
  (_6.0: i64) = const 0_i64
  using: 
  (_6.1: i64) = const 0_i64
  using: 
  Deinit(_7)
  using: 
  (_7.0: i64) = const 0_i64
  using: 
  (_7.1: i64) = const 0_i64
  using: 
  Deinit(_8)
  using: 
  (_8.0: i64) = const 0_i64
  using: 
  (_8.1: i64) = const 0_i64
  using: 
  _9 = [const 0_i64; 2]
  using: 
  Deinit(_4)
  using: 
  (_4.0: i32) = const 0_i32
  using: 
  (_4.1: u16) = const 0_u16
  using: 
  (_4.2: u16) = const 0_u16
  using: 
  (_4.3: u64) = const 0_u64
  using: 
  (_4.4: u32) = const 0_u32
  using: 
  (_4.5: u32) = const 0_u32
  using: 
  (_4.6: i32) = const 0_i32
  using: 
  (_4.7: bzip2::timespec) = move _5
  using: _5@Mir(bb0[2])
  (_4.8: bzip2::timespec) = move _6
  using: _6@Mir(bb0[5])
  (_4.9: bzip2::timespec) = move _7
  using: _7@Mir(bb0[8])
  (_4.10: bzip2::timespec) = move _8
  using: _8@Mir(bb0[11])
  (_4.11: i64) = const 0_i64
  using: 
  (_4.12: i64) = const 0_i64
  using: 
  (_4.13: i32) = const 0_i32
  using: 
  (_4.14: u32) = const 0_u32
  using: 
  (_4.15: u32) = const 0_u32
  using: 
  (_4.16: i32) = const 0_i32
  using: 
  (_4.17: [i64; 2]) = move _9
  using: _9@Mir(bb0[14])
  _10 = const 0_i32
  using: 
  _11 = const {alloc269: *mut u8}
  using: 
  (*_11) = move _10 as u8 (IntToInt)
  using: _11@Mir(bb0[35]), _10@Mir(bb0[34])
  _14 = _1
  using: _1@Entry
  _13 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _14) -> bb4
  using: _14@Mir(bb0[37])
bb1:
  _12 = const false
  using: 
  goto -> bb3
  using: 
bb2:
  _17 = const {alloc267: *mut i32}
  using: 
  _16 = (*_17)
  using: _17@Mir(bb2[0])
  _18 = const 1_i32
  using: 
  _15 = Ne(move _16, move _18)
  using: _16@Mir(bb2[1]), _18@Mir(bb2[2])
  _12 = move _15
  using: _15@Mir(bb2[3])
  goto -> bb3
  using: 
bb3:
  switchInt(move _12) -> [0: bb6, otherwise: bb5]
  using: _12@Phi(bb3)
bb4:
  switchInt(move _13) -> [0: bb1, otherwise: bb2]
  using: _13@Mir(bb0[38])
bb5:
  _23 = const b"testf: bad modes\n\x00"
  using: 
  _22 = &raw const (*_23)
  using: _23@Mir(bb5[0])
  _21 = move _22 as *const u8 (Pointer(ArrayToPointer))
  using: _22@Mir(bb5[1])
  _20 = move _21 as *const i8 (PtrToPtr)
  using: _21@Mir(bb5[2])
  _19 = bzip2::panic(move _20)
  using: _20@Mir(bb5[3])
bb6:
  _28 = const {alloc263: *mut [i8; 1034]}
  using: 
  _27 = &mut (*_28)
  using: _28@Mir(bb6[0])
  _26 = move _27 as &mut [i8] (Pointer(Unsize))
  using: _27@Mir(bb6[1])
  _25 = core::slice::<impl [i8]>::as_mut_ptr(move _26) -> bb7
  using: _26@Mir(bb6[2])
bb7:
  _33 = const b"(none)\x00"
  using: 
  _32 = &raw const (*_33)
  using: _33@Mir(bb7[0])
  _31 = move _32 as *const u8 (Pointer(ArrayToPointer))
  using: _32@Mir(bb7[1])
  _30 = move _31 as *const i8 (PtrToPtr)
  using: _31@Mir(bb7[2])
  _29 = move _30 as *mut i8 (PtrToPtr)
  using: _30@Mir(bb7[3])
  _24 = bzip2::copyFileName(move _25, move _29) -> bb8
  using: _25@Mir(bb6[3]), _29@Mir(bb7[4])
bb8:
  _34 = const {alloc267: *mut i32}
  using: 
  switchInt((*_34)) -> [1: bb9, 3: bb11, 2: bb13, otherwise: bb15]
  using: _34@Mir(bb8[0])
bb9:
  _39 = const {alloc198: *mut [i8; 1034]}
  using: 
  _38 = &mut (*_39)
  using: _39@Mir(bb9[0])
  _37 = move _38 as &mut [i8] (Pointer(Unsize))
  using: _38@Mir(bb9[1])
  _36 = core::slice::<impl [i8]>::as_mut_ptr(move _37) -> bb10
  using: _37@Mir(bb9[2])
bb10:
  _44 = const b"(stdin)\x00"
  using: 
  _43 = &raw const (*_44)
  using: _44@Mir(bb10[0])
  _42 = move _43 as *const u8 (Pointer(ArrayToPointer))
  using: _43@Mir(bb10[1])
  _41 = move _42 as *const i8 (PtrToPtr)
  using: _42@Mir(bb10[2])
  _40 = move _41 as *mut i8 (PtrToPtr)
  using: _41@Mir(bb10[3])
  _35 = bzip2::copyFileName(move _36, move _40) -> bb15
  using: _36@Mir(bb9[3]), _40@Mir(bb10[4])
bb11:
  _49 = const {alloc198: *mut [i8; 1034]}
  using: 
  _48 = &mut (*_49)
  using: _49@Mir(bb11[0])
  _47 = move _48 as &mut [i8] (Pointer(Unsize))
  using: _48@Mir(bb11[1])
  _46 = core::slice::<impl [i8]>::as_mut_ptr(move _47) -> bb12
  using: _47@Mir(bb11[2])
bb12:
  _50 = _1
  using: _1@Entry
  _45 = bzip2::copyFileName(move _46, move _50) -> bb15
  using: _46@Mir(bb11[3]), _50@Mir(bb12[0])
bb13:
  _55 = const {alloc198: *mut [i8; 1034]}
  using: 
  _54 = &mut (*_55)
  using: _55@Mir(bb13[0])
  _53 = move _54 as &mut [i8] (Pointer(Unsize))
  using: _54@Mir(bb13[1])
  _52 = core::slice::<impl [i8]>::as_mut_ptr(move _53) -> bb14
  using: _53@Mir(bb13[2])
bb14:
  _56 = _1
  using: _1@Entry
  _51 = bzip2::copyFileName(move _52, move _56) -> bb15
  using: _52@Mir(bb13[3]), _56@Mir(bb14[0])
bb15:
  _60 = const {alloc267: *mut i32}
  using: 
  _59 = (*_60)
  using: _60@Mir(bb15[0])
  _61 = const 1_i32
  using: 
  _58 = Ne(move _59, move _61)
  using: _59@Mir(bb15[1]), _61@Mir(bb15[2])
  switchInt(move _58) -> [0: bb16, otherwise: bb17]
  using: _58@Mir(bb15[3])
bb16:
  _57 = const false
  using: 
  goto -> bb18
  using: 
bb17:
  _68 = const {alloc198: *mut [i8; 1034]}
  using: 
  _67 = &mut (*_68)
  using: _68@Mir(bb17[0])
  _66 = move _67 as &mut [i8] (Pointer(Unsize))
  using: _67@Mir(bb17[1])
  _65 = core::slice::<impl [i8]>::as_mut_ptr(move _66) -> bb19
  using: _66@Mir(bb17[2])
bb18:
  switchInt(move _57) -> [0: bb25, otherwise: bb21]
  using: _57@Phi(bb18)
bb19:
  _64 = bzip2::containsDubiousChars(move _65) -> bb20
  using: _65@Mir(bb17[3])
bb20:
  _63 = move _64 as i32 (IntToInt)
  using: _64@Mir(bb19[0])
  _62 = Ne(move _63, const 0_i32)
  using: _63@Mir(bb20[0])
  _57 = move _62
  using: _62@Mir(bb20[1])
  goto -> bb18
  using: 
bb21:
  _70 = const {alloc196: *mut u8}
  using: 
  _69 = (*_70)
  using: _70@Mir(bb21[0])
  switchInt(move _69) -> [0: bb24, otherwise: bb22]
  using: _69@Mir(bb21[1])
bb22:
  _73 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _72 = (*_73)
  using: _73@Mir(bb22[0])
  _77 = const b"%s: There are no files matching `%s\'.\n\x00"
  using: 
  _76 = &raw const (*_77)
  using: _77@Mir(bb22[2])
  _75 = move _76 as *const u8 (Pointer(ArrayToPointer))
  using: _76@Mir(bb22[3])
  _74 = move _75 as *const i8 (PtrToPtr)
  using: _75@Mir(bb22[4])
  _79 = const {alloc197: *mut *mut i8}
  using: 
  _78 = (*_79)
  using: _79@Mir(bb22[6])
  _83 = const {alloc198: *mut [i8; 1034]}
  using: 
  _82 = &mut (*_83)
  using: _83@Mir(bb22[8])
  _81 = move _82 as &mut [i8] (Pointer(Unsize))
  using: _82@Mir(bb22[9])
  _80 = core::slice::<impl [i8]>::as_mut_ptr(move _81) -> bb23
  using: _81@Mir(bb22[10])
bb23:
  _71 = bzip2::fprintf(move _72, move _74, move _78, move _80) -> bb24
  using: _72@Mir(bb22[1]), _74@Mir(bb22[5]), _78@Mir(bb22[7]), _80@Mir(bb22[11])
bb24:
  _85 = const 1_i32
  using: 
  _84 = bzip2::setExit(move _85) -> bb75
  using: _85@Mir(bb24[0])
bb25:
  _89 = const {alloc267: *mut i32}
  using: 
  _88 = (*_89)
  using: _89@Mir(bb25[0])
  _90 = const 1_i32
  using: 
  _87 = Ne(move _88, move _90)
  using: _88@Mir(bb25[1]), _90@Mir(bb25[2])
  switchInt(move _87) -> [0: bb26, otherwise: bb27]
  using: _87@Mir(bb25[3])
bb26:
  _86 = const false
  using: 
  goto -> bb28
  using: 
bb27:
  _96 = const {alloc198: *mut [i8; 1034]}
  using: 
  _95 = &mut (*_96)
  using: _96@Mir(bb27[0])
  _94 = move _95 as &mut [i8] (Pointer(Unsize))
  using: _95@Mir(bb27[1])
  _93 = core::slice::<impl [i8]>::as_mut_ptr(move _94) -> bb29
  using: _94@Mir(bb27[2])
bb28:
  switchInt(move _86) -> [0: bb36, otherwise: bb31]
  using: _86@Phi(bb28)
bb29:
  _92 = bzip2::fileExists(move _93) -> bb30
  using: _93@Mir(bb27[3])
bb30:
  _91 = Eq(move _92, const 0_u8)
  using: _92@Mir(bb29[0])
  _86 = move _91
  using: _91@Mir(bb30[0])
  goto -> bb28
  using: 
bb31:
  _99 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _98 = (*_99)
  using: _99@Mir(bb31[0])
  _103 = const b"%s: Can\'t open input %s: %s.\n\x00"
  using: 
  _102 = &raw const (*_103)
  using: _103@Mir(bb31[2])
  _101 = move _102 as *const u8 (Pointer(ArrayToPointer))
  using: _102@Mir(bb31[3])
  _100 = move _101 as *const i8 (PtrToPtr)
  using: _101@Mir(bb31[4])
  _105 = const {alloc197: *mut *mut i8}
  using: 
  _104 = (*_105)
  using: _105@Mir(bb31[6])
  _109 = const {alloc198: *mut [i8; 1034]}
  using: 
  _108 = &mut (*_109)
  using: _109@Mir(bb31[8])
  _107 = move _108 as &mut [i8] (Pointer(Unsize))
  using: _108@Mir(bb31[9])
  _106 = core::slice::<impl [i8]>::as_mut_ptr(move _107) -> bb32
  using: _107@Mir(bb31[10])
bb32:
  _112 = bzip2::__error() -> bb33
  using: 
bb33:
  _111 = (*_112)
  using: _112@Mir(bb32[0])
  _110 = bzip2::strerror(move _111) -> bb34
  using: _111@Mir(bb33[0])
bb34:
  _97 = bzip2::fprintf(move _98, move _100, move _104, move _106, move _110) -> bb35
  using: _98@Mir(bb31[1]), _100@Mir(bb31[5]), _104@Mir(bb31[7]), _106@Mir(bb31[11]), _110@Mir(bb33[1])
bb35:
  _114 = const 1_i32
  using: 
  _113 = bzip2::setExit(move _114) -> bb75
  using: _114@Mir(bb35[0])
bb36:
  _117 = const {alloc267: *mut i32}
  using: 
  _116 = (*_117)
  using: _117@Mir(bb36[0])
  _118 = const 1_i32
  using: 
  _115 = Ne(move _116, move _118)
  using: _116@Mir(bb36[1]), _118@Mir(bb36[2])
  switchInt(move _115) -> [0: bb43, otherwise: bb37]
  using: _115@Mir(bb36[3])
bb37:
  _124 = const {alloc198: *mut [i8; 1034]}
  using: 
  _123 = &mut (*_124)
  using: _124@Mir(bb37[0])
  _122 = move _123 as &mut [i8] (Pointer(Unsize))
  using: _123@Mir(bb37[1])
  _121 = core::slice::<impl [i8]>::as_mut_ptr(move _122) -> bb38
  using: _122@Mir(bb37[2])
bb38:
  _120 = move _121 as *const i8 (Pointer(MutToConstPointer))
  using: _121@Mir(bb37[3])
  _126 = &mut _4
  using: _4@Mir(bb0[15])
  _125 = &raw mut (*_126)
  using: _126@Mir(bb38[1])
  _119 = bzip2::stat(move _120, move _125) -> bb39
  using: _120@Mir(bb38[0]), _125@Mir(bb38[2])
bb39:
  _130 = (_4.1: u16)
  using: _4@Mir(bb0[15])
  _129 = move _130 as i32 (IntToInt)
  using: _130@Mir(bb39[0])
  _131 = const 61440_i32
  using: 
  _128 = BitAnd(move _129, move _131)
  using: _129@Mir(bb39[1]), _131@Mir(bb39[2])
  _132 = const 16384_i32
  using: 
  _127 = Eq(move _128, move _132)
  using: _128@Mir(bb39[3]), _132@Mir(bb39[4])
  switchInt(move _127) -> [0: bb43, otherwise: bb40]
  using: _127@Mir(bb39[5])
bb40:
  _135 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _134 = (*_135)
  using: _135@Mir(bb40[0])
  _139 = const b"%s: Input file %s is a directory.\n\x00"
  using: 
  _138 = &raw const (*_139)
  using: _139@Mir(bb40[2])
  _137 = move _138 as *const u8 (Pointer(ArrayToPointer))
  using: _138@Mir(bb40[3])
  _136 = move _137 as *const i8 (PtrToPtr)
  using: _137@Mir(bb40[4])
  _141 = const {alloc197: *mut *mut i8}
  using: 
  _140 = (*_141)
  using: _141@Mir(bb40[6])
  _145 = const {alloc198: *mut [i8; 1034]}
  using: 
  _144 = &mut (*_145)
  using: _145@Mir(bb40[8])
  _143 = move _144 as &mut [i8] (Pointer(Unsize))
  using: _144@Mir(bb40[9])
  _142 = core::slice::<impl [i8]>::as_mut_ptr(move _143) -> bb41
  using: _143@Mir(bb40[10])
bb41:
  _133 = bzip2::fprintf(move _134, move _136, move _140, move _142) -> bb42
  using: _134@Mir(bb40[1]), _136@Mir(bb40[5]), _140@Mir(bb40[7]), _142@Mir(bb40[11])
bb42:
  _147 = const 1_i32
  using: 
  _146 = bzip2::setExit(move _147) -> bb75
  using: _147@Mir(bb42[0])
bb43:
  _148 = const {alloc267: *mut i32}
  using: 
  switchInt((*_148)) -> [1: bb45, 2: bb52, 3: bb52, otherwise: bb44]
  using: _148@Mir(bb43[0])
bb44:
  _214 = const b"testf: bad srcMode\x00"
  using: 
  _213 = &raw const (*_214)
  using: _214@Mir(bb44[0])
  _212 = move _213 as *const u8 (Pointer(ArrayToPointer))
  using: _213@Mir(bb44[1])
  _211 = move _212 as *const i8 (PtrToPtr)
  using: _212@Mir(bb44[2])
  _210 = bzip2::panic(move _211)
  using: _211@Mir(bb44[3])
bb45:
  _152 = const {alloc195: *mut *mut blocksort::__sFILE}
  using: 
  _151 = (*_152)
  using: _152@Mir(bb45[0])
  _150 = bzip2::fileno(move _151) -> bb46
  using: _151@Mir(bb45[1])
bb46:
  _149 = bzip2::isatty(move _150) -> bb47
  using: _150@Mir(bb45[2])
bb47:
  switchInt(move _149) -> [0: bb51, otherwise: bb48]
  using: _149@Mir(bb46[0])
bb48:
  _155 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _154 = (*_155)
  using: _155@Mir(bb48[0])
  _159 = const b"%s: I won\'t read compressed data from a terminal.\n\x00"
  using: 
  _158 = &raw const (*_159)
  using: _159@Mir(bb48[2])
  _157 = move _158 as *const u8 (Pointer(ArrayToPointer))
  using: _158@Mir(bb48[3])
  _156 = move _157 as *const i8 (PtrToPtr)
  using: _157@Mir(bb48[4])
  _161 = const {alloc197: *mut *mut i8}
  using: 
  _160 = (*_161)
  using: _161@Mir(bb48[6])
  _153 = bzip2::fprintf(move _154, move _156, move _160) -> bb49
  using: _154@Mir(bb48[1]), _156@Mir(bb48[5]), _160@Mir(bb48[7])
bb49:
  _164 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _163 = (*_164)
  using: _164@Mir(bb49[0])
  _168 = const b"%s: For help, type: `%s --help\'.\n\x00"
  using: 
  _167 = &raw const (*_168)
  using: _168@Mir(bb49[2])
  _166 = move _167 as *const u8 (Pointer(ArrayToPointer))
  using: _167@Mir(bb49[3])
  _165 = move _166 as *const i8 (PtrToPtr)
  using: _166@Mir(bb49[4])
  _170 = const {alloc197: *mut *mut i8}
  using: 
  _169 = (*_170)
  using: _170@Mir(bb49[6])
  _172 = const {alloc197: *mut *mut i8}
  using: 
  _171 = (*_172)
  using: _172@Mir(bb49[8])
  _162 = bzip2::fprintf(move _163, move _165, move _169, move _171) -> bb50
  using: _163@Mir(bb49[1]), _165@Mir(bb49[5]), _169@Mir(bb49[7]), _171@Mir(bb49[9])
bb50:
  _174 = const 1_i32
  using: 
  _173 = bzip2::setExit(move _174) -> bb75
  using: _174@Mir(bb50[0])
bb51:
  _176 = const {alloc195: *mut *mut blocksort::__sFILE}
  using: 
  _175 = (*_176)
  using: _176@Mir(bb51[0])
  _2 = move _175
  using: _175@Mir(bb51[1])
  goto -> bb61
  using: 
bb52:
  _182 = const {alloc198: *mut [i8; 1034]}
  using: 
  _181 = &mut (*_182)
  using: _182@Mir(bb52[0])
  _180 = move _181 as &mut [i8] (Pointer(Unsize))
  using: _181@Mir(bb52[1])
  _179 = core::slice::<impl [i8]>::as_mut_ptr(move _180) -> bb53
  using: _180@Mir(bb52[2])
bb53:
  _178 = move _179 as *const i8 (Pointer(MutToConstPointer))
  using: _179@Mir(bb52[3])
  _186 = const b"rb\x00"
  using: 
  _185 = &raw const (*_186)
  using: _186@Mir(bb53[1])
  _184 = move _185 as *const u8 (Pointer(ArrayToPointer))
  using: _185@Mir(bb53[2])
  _183 = move _184 as *const i8 (PtrToPtr)
  using: _184@Mir(bb53[3])
  _177 = bzip2::fopen(move _178, move _183) -> bb54
  using: _178@Mir(bb53[0]), _183@Mir(bb53[4])
bb54:
  _2 = move _177
  using: _177@Mir(bb53[5])
  _188 = _2
  using: _2@Mir(bb54[0])
  _187 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _188) -> bb55
  using: _188@Mir(bb54[1])
bb55:
  switchInt(move _187) -> [0: bb61, otherwise: bb56]
  using: _187@Mir(bb54[2])
bb56:
  _191 = _2
  using: _2@Mir(bb54[0])
  _190 = move _191 as usize (PointerExposeAddress)
  using: _191@Mir(bb56[0])
  _189 = Eq(move _190, const 0_usize)
  using: _190@Mir(bb56[1])
  assume(move _189)
  using: _189@Mir(bb56[2])
  _194 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _193 = (*_194)
  using: _194@Mir(bb56[4])
  _198 = const b"%s: Can\'t open input file %s:%s.\n\x00"
  using: 
  _197 = &raw const (*_198)
  using: _198@Mir(bb56[6])
  _196 = move _197 as *const u8 (Pointer(ArrayToPointer))
  using: _197@Mir(bb56[7])
  _195 = move _196 as *const i8 (PtrToPtr)
  using: _196@Mir(bb56[8])
  _200 = const {alloc197: *mut *mut i8}
  using: 
  _199 = (*_200)
  using: _200@Mir(bb56[10])
  _204 = const {alloc198: *mut [i8; 1034]}
  using: 
  _203 = &mut (*_204)
  using: _204@Mir(bb56[12])
  _202 = move _203 as &mut [i8] (Pointer(Unsize))
  using: _203@Mir(bb56[13])
  _201 = core::slice::<impl [i8]>::as_mut_ptr(move _202) -> bb57
  using: _202@Mir(bb56[14])
bb57:
  _207 = bzip2::__error() -> bb58
  using: 
bb58:
  _206 = (*_207)
  using: _207@Mir(bb57[0])
  _205 = bzip2::strerror(move _206) -> bb59
  using: _206@Mir(bb58[0])
bb59:
  _192 = bzip2::fprintf(move _193, move _195, move _199, move _201, move _205) -> bb60
  using: _193@Mir(bb56[5]), _195@Mir(bb56[9]), _199@Mir(bb56[11]), _201@Mir(bb56[15]), _205@Mir(bb58[1])
bb60:
  _209 = const 1_i32
  using: 
  _208 = bzip2::setExit(move _209) -> bb75
  using: _209@Mir(bb60[0])
bb61:
  _217 = const {alloc172: *mut i32}
  using: 
  _216 = (*_217)
  using: _217@Mir(bb61[0])
  _218 = const 1_i32
  using: 
  _215 = Ge(move _216, move _218)
  using: _216@Mir(bb61[1]), _218@Mir(bb61[2])
  switchInt(move _215) -> [0: bb67, otherwise: bb62]
  using: _215@Mir(bb61[3])
bb62:
  _221 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _220 = (*_221)
  using: _221@Mir(bb62[0])
  _225 = const b"  %s: \x00"
  using: 
  _224 = &raw const (*_225)
  using: _225@Mir(bb62[2])
  _223 = move _224 as *const u8 (Pointer(ArrayToPointer))
  using: _224@Mir(bb62[3])
  _222 = move _223 as *const i8 (PtrToPtr)
  using: _223@Mir(bb62[4])
  _229 = const {alloc198: *mut [i8; 1034]}
  using: 
  _228 = &mut (*_229)
  using: _229@Mir(bb62[6])
  _227 = move _228 as &mut [i8] (Pointer(Unsize))
  using: _228@Mir(bb62[7])
  _226 = core::slice::<impl [i8]>::as_mut_ptr(move _227) -> bb63
  using: _227@Mir(bb62[8])
bb63:
  _219 = bzip2::fprintf(move _220, move _222, move _226) -> bb64
  using: _220@Mir(bb62[1]), _222@Mir(bb62[5]), _226@Mir(bb62[9])
bb64:
  _234 = const {alloc198: *mut [i8; 1034]}
  using: 
  _233 = &mut (*_234)
  using: _234@Mir(bb64[0])
  _232 = move _233 as &mut [i8] (Pointer(Unsize))
  using: _233@Mir(bb64[1])
  _231 = core::slice::<impl [i8]>::as_mut_ptr(move _232) -> bb65
  using: _232@Mir(bb64[2])
bb65:
  _230 = bzip2::pad(move _231) -> bb66
  using: _231@Mir(bb64[3])
bb66:
  _237 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _236 = (*_237)
  using: _237@Mir(bb66[0])
  _235 = bzip2::fflush(move _236) -> bb67
  using: _236@Mir(bb66[1])
bb67:
  _238 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_238) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _238@Mir(bb67[0])
  _240 = _2
  using: _2@Phi(bb61)
  _239 = bzip2::testStream(move _240) -> bb68
  using: _240@Mir(bb67[2])
bb68:
  _3 = move _239
  using: _239@Mir(bb67[3])
  _243 = _3
  using: _3@Mir(bb68[0])
  _242 = move _243 as i32 (IntToInt)
  using: _243@Mir(bb68[1])
  switchInt(move _242) -> [0: bb69, otherwise: bb70]
  using: _242@Mir(bb68[2])
bb69:
  _241 = const false
  using: 
  goto -> bb71
  using: 
bb70:
  _246 = const {alloc172: *mut i32}
  using: 
  _245 = (*_246)
  using: _246@Mir(bb70[0])
  _247 = const 1_i32
  using: 
  _244 = Ge(move _245, move _247)
  using: _245@Mir(bb70[1]), _247@Mir(bb70[2])
  _241 = move _244
  using: _244@Mir(bb70[3])
  goto -> bb71
  using: 
bb71:
  switchInt(move _241) -> [0: bb73, otherwise: bb72]
  using: _241@Phi(bb71)
bb72:
  _250 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _249 = (*_250)
  using: _250@Mir(bb72[0])
  _254 = const b"ok\n\x00"
  using: 
  _253 = &raw const (*_254)
  using: _254@Mir(bb72[2])
  _252 = move _253 as *const u8 (Pointer(ArrayToPointer))
  using: _253@Mir(bb72[3])
  _251 = move _252 as *const i8 (PtrToPtr)
  using: _252@Mir(bb72[4])
  _248 = bzip2::fprintf(move _249, move _251) -> bb73
  using: _249@Mir(bb72[1]), _251@Mir(bb72[5])
bb73:
  _255 = _3
  using: _3@Mir(bb68[0])
  switchInt(move _255) -> [0: bb74, otherwise: bb75]
  using: _255@Mir(bb73[0])
bb74:
  _256 = const 1_i32
  using: 
  _257 = const {alloc474: *mut u8}
  using: 
  (*_257) = move _256 as u8 (IntToInt)
  using: _257@Mir(bb74[1]), _256@Mir(bb74[0])
  goto -> bb75
  using: 
bb75:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_5) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_6) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_7) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_8) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_4) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i64; 2] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2568:13: 2571:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2580:27: 2580:36 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2580:17: 2580:37 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2577:9: 2580:38 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::stat @ workspace/bzip2/rust/bzip2.rs:2585:9: 2585:48 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2588:13: 2590:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fileno @ workspace/bzip2/rust/bzip2.rs:2597:23: 2597:39 (#0) by default
rewrite call bzip2::isatty @ workspace/bzip2/rust/bzip2.rs:2597:16: 2597:40 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2598:17: 2600:83 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2601:17: 2604:34 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fopen @ workspace/bzip2/rust/bzip2.rs:2612:17: 2613:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::__error @ workspace/bzip2/rust/bzip2.rs:2618:56: 2618:65 (#0) by default
rewrite call bzip2::strerror @ workspace/bzip2/rust/bzip2.rs:2618:46: 2618:66 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2615:17: 2618:67 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2629:9: 2630:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fflush @ workspace/bzip2/rust/bzip2.rs:2632:9: 2632:26 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2638:9: 2638:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:241 ~ c2rust_lib[1043]::bzip2::license)
bb0:
  _3 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _2 = (*_3)
  using: _3@Mir(bb0[0])
  _7 = const b"bzip2, a block-sorting file compressor.  Version %s.\n   \n   Copyright (C) 1996-2019 by Julian Seward.\n   \n   This program is free software; you can redistribute it and/or modify\n   it under the terms set out in the LICENSE file, which is included\n   in the bzip2 source distribution.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   LICENSE file for more details.\n   \n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[3])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[4])
  _8 = bzlib::BZ2_bzlibVersion() -> bb1
  using: 
bb1:
  _1 = bzip2::fprintf(move _2, move _4, move _8) -> bb2
  using: _2@Mir(bb0[1]), _4@Mir(bb0[5]), _8@Mir(bb0[6])
bb2:
  return
  using: _0@Entry
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2644:5: 2646:95 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:242 ~ c2rust_lib[1043]::bzip2::usage)
bb0:
  _4 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _3 = (*_4)
  using: _4@Mir(bb0[0])
  _8 = const b"bzip2, a block-sorting file compressor.  Version %s.\n\n   usage: %s [flags and input files in any order]\n\n   -h --help           print this message\n   -d --decompress     force decompression\n   -z --compress       force compression\n   -k --keep           keep (don\'t delete) input files\n   -f --force          overwrite existing output files\n   -t --test           test compressed file integrity\n   -c --stdout         output to standard out\n   -q --quiet          suppress noncritical error messages\n   -v --verbose        be verbose (a 2nd -v gives more)\n   -L --license        display software version & license\n   -V --version        display software version & license\n   -s --small          use less memory (at most 2500k)\n   -1 .. -9            set block size to 100k .. 900k\n   --fast              alias for -1\n   --best              alias for -9\n\n   If invoked as `bzip2\', default action is to compress.\n              as `bunzip2\',  default action is to decompress.\n              as `bzcat\', default action is to decompress to stdout.\n\n   If no file names are given, bzip2 compresses or decompresses\n   from standard input to standard output.  You can combine\n   short flags, so `-v -4\' means the same as -v4 or -4v, &c.\n\n\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _9 = bzlib::BZ2_bzlibVersion() -> bb1
  using: 
bb1:
  _10 = _1
  using: _1@Entry
  _2 = bzip2::fprintf(move _3, move _5, move _9, move _10) -> bb2
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5]), _9@Mir(bb0[6]), _10@Mir(bb1[0])
bb2:
  return
  using: _0@Entry
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2650:5: 2653:26 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:243 ~ c2rust_lib[1043]::bzip2::redundant)
bb0:
  _4 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _3 = (*_4)
  using: _4@Mir(bb0[0])
  _8 = const b"%s: %s is redundant in versions 0.9.5 and above\n\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _10 = const {alloc197: *mut *mut i8}
  using: 
  _9 = (*_10)
  using: _10@Mir(bb0[6])
  _11 = _1
  using: _1@Entry
  _2 = bzip2::fprintf(move _3, move _5, move _9, move _11) -> bb1
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5]), _9@Mir(bb0[7]), _11@Mir(bb0[8])
bb1:
  return
  using: _0@Entry
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2657:5: 2659:74 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:244 ~ c2rust_lib[1043]::bzip2::myMalloc)
bb0:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  _4 = _1
  using: _1@Entry
  _3 = move _4 as u64 (IntToInt)
  using: _4@Mir(bb0[1])
  _2 = bzip2::malloc(move _3) -> bb1
  using: _3@Mir(bb0[2])
bb1:
  _0 = move _2
  using: _2@Mir(bb0[3])
  _6 = _0
  using: _0@Mir(bb1[0])
  _5 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _6) -> bb2
  using: _6@Mir(bb1[1])
bb2:
  switchInt(move _5) -> [0: bb4, otherwise: bb3]
  using: _5@Mir(bb1[2])
bb3:
  _9 = _0
  using: _0@Mir(bb1[0])
  _8 = move _9 as usize (PointerExposeAddress)
  using: _9@Mir(bb3[0])
  _7 = Eq(move _8, const 0_usize)
  using: _8@Mir(bb3[1])
  assume(move _7)
  using: _7@Mir(bb3[2])
  _10 = bzip2::outOfMemory()
  using: 
bb4:
  return
  using: _0@Mir(bb1[0])
@DefId(0:245 ~ c2rust_lib[1043]::bzip2::mkCell)
bb0:
  _0 = const {0x0 as *mut bzip2::zzzz}
  using: 
  _4 = std::mem::size_of::<bzip2::zzzz>() -> bb1
  using: 
bb1:
  _3 = move _4 as u64 (IntToInt)
  using: _4@Mir(bb0[1])
  _2 = move _3 as i32 (IntToInt)
  using: _3@Mir(bb1[0])
  _1 = bzip2::myMalloc(move _2) -> bb2
  using: _2@Mir(bb1[1])
bb2:
  _0 = move _1 as *mut bzip2::zzzz (PtrToPtr)
  using: _1@Mir(bb1[2])
  ((*_0).0: *mut i8) = const 0_usize as *mut i8 (PointerFromExposedAddress)
  using: _0@Mir(bb2[0])
  ((*_0).1: *mut bzip2::zzzz) = const 0_usize as *mut bzip2::zzzz (PointerFromExposedAddress)
  using: _0@Mir(bb2[0])
  return
  using: _0@Mir(bb2[0])
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:2672:18: 2672:47 (#0) by default
@DefId(0:246 ~ c2rust_lib[1043]::bzip2::snocString)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[0])
bb1:
  switchInt(move _3) -> [0: bb8, otherwise: bb2]
  using: _3@Mir(bb0[1])
bb2:
  _7 = _1
  using: _1@Entry
  _6 = move _7 as usize (PointerExposeAddress)
  using: _7@Mir(bb2[0])
  _5 = Eq(move _6, const 0_usize)
  using: _6@Mir(bb2[1])
  assume(move _5)
  using: _5@Mir(bb2[2])
  _8 = bzip2::mkCell() -> bb3
  using: 
bb3:
  _12 = const 5_u64
  using: 
  _15 = _2
  using: _2@Entry
  _14 = move _15 as *const i8 (Pointer(MutToConstPointer))
  using: _15@Mir(bb3[1])
  _13 = bzip2::strlen(move _14) -> bb4
  using: _14@Mir(bb3[2])
bb4:
  _11 = core::num::<impl u64>::wrapping_add(move _12, move _13) -> bb5
  using: _12@Mir(bb3[0]), _13@Mir(bb3[3])
bb5:
  _10 = move _11 as i32 (IntToInt)
  using: _11@Mir(bb4[0])
  _9 = bzip2::myMalloc(move _10) -> bb6
  using: _10@Mir(bb5[0])
bb6:
  ((*_8).0: *mut i8) = move _9 as *mut i8 (PtrToPtr)
  using: _8@Mir(bb2[4]), _9@Mir(bb5[1])
  _17 = ((*_8).0: *mut i8)
  using: _8@Mir(bb2[4])
  _19 = _2
  using: _2@Entry
  _18 = move _19 as *const i8 (Pointer(MutToConstPointer))
  using: _19@Mir(bb6[2])
  _16 = bzip2::strcpy(move _17, move _18) -> bb7
  using: _17@Mir(bb6[1]), _18@Mir(bb6[3])
bb7:
  _0 = _8
  using: _8@Mir(bb2[4])
  goto -> bb14
  using: 
bb8:
  _20 = _1
  using: _1@Entry
  goto -> bb9
  using: 
bb9:
  _23 = ((*_20).1: *mut bzip2::zzzz)
  using: _20@Phi(bb9)
  _22 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _23) -> bb10
  using: _23@Mir(bb9[0])
bb10:
  _21 = Not(move _22)
  using: _22@Mir(bb9[1])
  switchInt(move _21) -> [0: bb12, otherwise: bb11]
  using: _21@Mir(bb10[0])
bb11:
  _24 = ((*_20).1: *mut bzip2::zzzz)
  using: _20@Phi(bb9)
  _20 = move _24
  using: _24@Mir(bb11[0])
  goto -> bb9
  using: 
bb12:
  _27 = ((*_20).1: *mut bzip2::zzzz)
  using: _20@Phi(bb9)
  _26 = move _27 as usize (PointerExposeAddress)
  using: _27@Mir(bb12[0])
  _25 = Eq(move _26, const 0_usize)
  using: _26@Mir(bb12[1])
  assume(move _25)
  using: _25@Mir(bb12[2])
  _29 = ((*_20).1: *mut bzip2::zzzz)
  using: _20@Phi(bb9)
  _30 = _2
  using: _2@Entry
  _28 = bzip2::snocString(move _29, move _30) -> bb13
  using: _29@Mir(bb12[4]), _30@Mir(bb12[5])
bb13:
  ((*_20).1: *mut bzip2::zzzz) = move _28
  using: _20@Phi(bb9), _28@Mir(bb12[6])
  _0 = _1
  using: _1@Entry
  goto -> bb14
  using: 
bb14:
  return
  using: _0@Phi(bb14)
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:2685:63: 2685:75 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/bzip2/rust/bzip2.rs:2685:50: 2685:76 (#0) by default
rewrite call bzip2::strcpy @ workspace/bzip2/rust/bzip2.rs:2687:9: 2687:34 (#0) by default
@DefId(0:247 ~ c2rust_lib[1043]::bzip2::addFlagsFromEnvVar)
bb0:
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _6 = const {0x0 as *mut i8}
  using: 
  _7 = const {0x0 as *mut i8}
  using: 
  _10 = _2
  using: _2@Entry
  _9 = move _10 as *const i8 (Pointer(MutToConstPointer))
  using: _10@Mir(bb0[5])
  _8 = bzip2::getenv(move _9) -> bb1
  using: _9@Mir(bb0[6])
bb1:
  _6 = move _8
  using: _8@Mir(bb0[7])
  _13 = _6
  using: _6@Mir(bb1[0])
  _12 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _13) -> bb2
  using: _13@Mir(bb1[1])
bb2:
  _11 = Not(move _12)
  using: _12@Mir(bb1[2])
  switchInt(move _11) -> [0: bb35, otherwise: bb3]
  using: _11@Mir(bb2[0])
bb3:
  _14 = _6
  using: _6@Mir(bb1[0])
  _7 = move _14
  using: _14@Mir(bb3[0])
  _3 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _19 = _7
  using: _7@Phi(bb4)
  _21 = _3
  using: _3@Phi(bb4)
  _20 = move _21 as isize (IntToInt)
  using: _21@Mir(bb4[1])
  _18 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _19, move _20) -> bb5
  using: _19@Mir(bb4[0]), _20@Mir(bb4[2])
bb5:
  _17 = (*_18)
  using: _18@Mir(bb4[3])
  _16 = move _17 as i32 (IntToInt)
  using: _17@Mir(bb5[0])
  _22 = const 0_i32
  using: 
  _15 = Eq(move _16, move _22)
  using: _16@Mir(bb5[1]), _22@Mir(bb5[2])
  switchInt(move _15) -> [0: bb6, otherwise: bb36]
  using: _15@Mir(bb5[3])
bb6:
  _24 = _7
  using: _7@Phi(bb4)
  _26 = _3
  using: _3@Phi(bb4)
  _25 = move _26 as isize (IntToInt)
  using: _26@Mir(bb6[1])
  _23 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _24, move _25) -> bb7
  using: _24@Mir(bb6[0]), _25@Mir(bb6[2])
bb7:
  _7 = move _23
  using: _23@Mir(bb6[3])
  _3 = const 0_i32
  using: 
  goto -> bb8
  using: 
bb8:
  _31 = _7
  using: _7@Phi(bb8)
  _32 = const 0_isize
  using: 
  _30 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _31, move _32) -> bb9
  using: _31@Mir(bb8[0]), _32@Mir(bb8[1])
bb9:
  _29 = (*_30)
  using: _30@Mir(bb8[2])
  _28 = move _29 as i32 (IntToInt)
  using: _29@Mir(bb9[0])
  _27 = bzip2::isspace(move _28) -> bb10
  using: _28@Mir(bb9[1])
bb10:
  switchInt(move _27) -> [0: bb13, otherwise: bb11]
  using: _27@Mir(bb9[2])
bb11:
  _34 = _7
  using: _7@Phi(bb8)
  _33 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _34, const 1_isize) -> bb12
  using: _34@Mir(bb11[0])
bb12:
  _7 = move _33
  using: _33@Mir(bb11[1])
  goto -> bb8
  using: 
bb13:
  _40 = _7
  using: _7@Phi(bb13)
  _42 = _3
  using: _3@Phi(bb13)
  _41 = move _42 as isize (IntToInt)
  using: _42@Mir(bb13[1])
  _39 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _40, move _41) -> bb17
  using: _40@Mir(bb13[0]), _41@Mir(bb13[2])
bb14:
  _35 = const false
  using: 
  goto -> bb16
  using: 
bb15:
  _49 = _7
  using: _7@Phi(bb13)
  _51 = _3
  using: _3@Phi(bb13)
  _50 = move _51 as isize (IntToInt)
  using: _51@Mir(bb15[1])
  _48 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _49, move _50) -> bb18
  using: _49@Mir(bb15[0]), _50@Mir(bb15[2])
bb16:
  switchInt(move _35) -> [0: bb22, otherwise: bb20]
  using: _35@Phi(bb16)
bb17:
  _38 = (*_39)
  using: _39@Mir(bb13[3])
  _37 = move _38 as i32 (IntToInt)
  using: _38@Mir(bb17[0])
  _43 = const 0_i32
  using: 
  _36 = Ne(move _37, move _43)
  using: _37@Mir(bb17[1]), _43@Mir(bb17[2])
  switchInt(move _36) -> [0: bb14, otherwise: bb15]
  using: _36@Mir(bb17[3])
bb18:
  _47 = (*_48)
  using: _48@Mir(bb15[3])
  _46 = move _47 as i32 (IntToInt)
  using: _47@Mir(bb18[0])
  _45 = bzip2::isspace(move _46) -> bb19
  using: _46@Mir(bb18[1])
bb19:
  _44 = Eq(move _45, const 0_i32)
  using: _45@Mir(bb18[2])
  _35 = move _44
  using: _44@Mir(bb19[0])
  goto -> bb16
  using: 
bb20:
  _52 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb16)
  assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb21
  using: _52@Entry, _3@Entry
bb21:
  _3 = move (_52.0: i32)
  using: _52@Mir(bb20[0])
  goto -> bb13
  using: 
bb22:
  _54 = _3
  using: _3@Phi(bb16)
  _55 = const 0_i32
  using: 
  _53 = Gt(move _54, move _55)
  using: _54@Mir(bb22[0]), _55@Mir(bb22[1])
  switchInt(move _53) -> [0: bb4, otherwise: bb23]
  using: _53@Mir(bb22[2])
bb23:
  _56 = _3
  using: _3@Phi(bb16)
  _5 = move _56
  using: _56@Mir(bb23[0])
  _58 = _5
  using: _5@Mir(bb23[1])
  _59 = const 1024_i32
  using: 
  _57 = Gt(move _58, move _59)
  using: _58@Mir(bb23[2]), _59@Mir(bb23[3])
  switchInt(move _57) -> [0: bb25, otherwise: bb24]
  using: _57@Mir(bb23[4])
bb24:
  _5 = const 1024_i32
  using: 
  goto -> bb25
  using: 
bb25:
  _4 = const 0_i32
  using: 
  goto -> bb26
  using: 
bb26:
  _61 = _4
  using: _4@Phi(bb26)
  _62 = _5
  using: _5@Phi(bb25)
  _60 = Lt(move _61, move _62)
  using: _61@Mir(bb26[0]), _62@Mir(bb26[1])
  switchInt(move _60) -> [0: bb31, otherwise: bb27]
  using: _60@Mir(bb26[2])
bb27:
  _65 = _7
  using: _7@Phi(bb26)
  _67 = _4
  using: _4@Phi(bb26)
  _66 = move _67 as isize (IntToInt)
  using: _67@Mir(bb27[1])
  _64 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _65, move _66) -> bb28
  using: _65@Mir(bb27[0]), _66@Mir(bb27[2])
bb28:
  _63 = (*_64)
  using: _64@Mir(bb27[3])
  _68 = const {alloc516: *mut [i8; 1034]}
  using: 
  _70 = _4
  using: _4@Phi(bb26)
  _69 = move _70 as usize (IntToInt)
  using: _70@Mir(bb28[2])
  _71 = const 1034_usize
  using: 
  _72 = Lt(_69, _71)
  using: _69@Mir(bb28[3]), _71@Mir(bb28[4])
  assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _69) -> bb29
  using: _72@Entry, _71@Entry, _69@Entry
bb29:
  (*_68)[_69] = move _63
  using: _68@Mir(bb28[1]), _69@Mir(bb28[3]), _63@Mir(bb28[0])
  _73 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb26)
  assert(!move (_73.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb30
  using: _73@Entry, _4@Entry
bb30:
  _4 = move (_73.0: i32)
  using: _73@Mir(bb29[1])
  goto -> bb26
  using: 
bb31:
  _74 = const 0_i32
  using: 
  _75 = const {alloc516: *mut [i8; 1034]}
  using: 
  _77 = _5
  using: _5@Phi(bb25)
  _76 = move _77 as usize (IntToInt)
  using: _77@Mir(bb31[2])
  _78 = const 1034_usize
  using: 
  _79 = Lt(_76, _78)
  using: _76@Mir(bb31[3]), _78@Mir(bb31[4])
  assert(move _79, "index out of bounds: the length is {} but the index is {}", move _78, _76) -> bb32
  using: _79@Entry, _78@Entry, _76@Entry
bb32:
  (*_75)[_76] = move _74 as i8 (IntToInt)
  using: _75@Mir(bb31[1]), _76@Mir(bb31[3]), _74@Mir(bb31[0])
  _81 = (*_1)
  using: _1@Phi(bb4)
  _85 = const {alloc516: *mut [i8; 1034]}
  using: 
  _84 = &mut (*_85)
  using: _85@Mir(bb32[2])
  _83 = move _84 as &mut [i8] (Pointer(Unsize))
  using: _84@Mir(bb32[3])
  _82 = core::slice::<impl [i8]>::as_mut_ptr(move _83) -> bb33
  using: _83@Mir(bb32[4])
bb33:
  _80 = bzip2::snocString(move _81, move _82) -> bb34
  using: _81@Mir(bb32[1]), _82@Mir(bb32[5])
bb34:
  (*_1) = move _80
  using: _1@Phi(bb4), _80@Mir(bb33[0])
  goto -> bb4
  using: 
bb35:
  _88 = _6
  using: _6@Mir(bb1[0])
  _87 = move _88 as usize (PointerExposeAddress)
  using: _88@Mir(bb35[0])
  _86 = Eq(move _87, const 0_usize)
  using: _87@Mir(bb35[1])
  assume(move _86)
  using: _86@Mir(bb35[2])
  goto -> bb36
  using: 
bb36:
  return
  using: _0@Entry
rewrite call bzip2::getenv @ workspace/bzip2/rust/bzip2.rs:2704:15: 2704:30 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2709:19: 2709:37 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2712:19: 2712:37 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2714:30: 2714:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2716:23: 2716:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2718:22: 2718:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2719:34: 2719:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2729:46: 2729:64 (#0) by default
@DefId(0:248 ~ c2rust_lib[1043]::bzip2::main_0)
bb0:
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = const {0x0 as *mut i8}
  using: 
  _6 = const 0_usize as *mut bzip2::zzzz (PointerFromExposedAddress)
  using: 
  _7 = const {0x0 as *mut bzip2::zzzz}
  using: 
  _8 = const 0_u8
  using: 
  _16 = std::mem::size_of::<i32>() -> bb16
  using: 
bb1:
  _9 = const true
  using: 
  goto -> bb3
  using: 
bb2:
  _36 = std::mem::size_of::<u8>() -> bb21
  using: 
bb3:
  switchInt(move _9) -> [0: bb23, otherwise: bb22]
  using: _9@Phi(bb3)
bb4:
  _10 = const true
  using: 
  goto -> bb6
  using: 
bb5:
  _32 = std::mem::size_of::<i8>() -> bb20
  using: 
bb6:
  switchInt(move _10) -> [0: bb2, otherwise: bb1]
  using: _10@Phi(bb6)
bb7:
  _11 = const true
  using: 
  goto -> bb9
  using: 
bb8:
  _28 = std::mem::size_of::<u16>() -> bb19
  using: 
bb9:
  switchInt(move _11) -> [0: bb5, otherwise: bb4]
  using: _11@Phi(bb9)
bb10:
  _12 = const true
  using: 
  goto -> bb12
  using: 
bb11:
  _24 = std::mem::size_of::<i16>() -> bb18
  using: 
bb12:
  switchInt(move _12) -> [0: bb8, otherwise: bb7]
  using: _12@Phi(bb12)
bb13:
  _13 = const true
  using: 
  goto -> bb15
  using: 
bb14:
  _20 = std::mem::size_of::<u32>() -> bb17
  using: 
bb15:
  switchInt(move _13) -> [0: bb11, otherwise: bb10]
  using: _13@Phi(bb15)
bb16:
  _15 = move _16 as u64 (IntToInt)
  using: _16@Mir(bb0[6])
  _17 = const 4_u64
  using: 
  _14 = Ne(move _15, move _17)
  using: _15@Mir(bb16[0]), _17@Mir(bb16[1])
  switchInt(move _14) -> [0: bb14, otherwise: bb13]
  using: _14@Mir(bb16[2])
bb17:
  _19 = move _20 as u64 (IntToInt)
  using: _20@Mir(bb14[0])
  _21 = const 4_u64
  using: 
  _18 = Ne(move _19, move _21)
  using: _19@Mir(bb17[0]), _21@Mir(bb17[1])
  _13 = move _18
  using: _18@Mir(bb17[2])
  goto -> bb15
  using: 
bb18:
  _23 = move _24 as u64 (IntToInt)
  using: _24@Mir(bb11[0])
  _25 = const 2_u64
  using: 
  _22 = Ne(move _23, move _25)
  using: _23@Mir(bb18[0]), _25@Mir(bb18[1])
  _12 = move _22
  using: _22@Mir(bb18[2])
  goto -> bb12
  using: 
bb19:
  _27 = move _28 as u64 (IntToInt)
  using: _28@Mir(bb8[0])
  _29 = const 2_u64
  using: 
  _26 = Ne(move _27, move _29)
  using: _27@Mir(bb19[0]), _29@Mir(bb19[1])
  _11 = move _26
  using: _26@Mir(bb19[2])
  goto -> bb9
  using: 
bb20:
  _31 = move _32 as u64 (IntToInt)
  using: _32@Mir(bb5[0])
  _33 = const 1_u64
  using: 
  _30 = Ne(move _31, move _33)
  using: _31@Mir(bb20[0]), _33@Mir(bb20[1])
  _10 = move _30
  using: _30@Mir(bb20[2])
  goto -> bb6
  using: 
bb21:
  _35 = move _36 as u64 (IntToInt)
  using: _36@Mir(bb2[0])
  _37 = const 1_u64
  using: 
  _34 = Ne(move _35, move _37)
  using: _35@Mir(bb21[0]), _37@Mir(bb21[1])
  _9 = move _34
  using: _34@Mir(bb21[2])
  goto -> bb3
  using: 
bb22:
  _38 = bzip2::configError()
  using: 
bb23:
  _39 = const {alloc176: *mut *mut blocksort::__sFILE}
  using: 
  (*_39) = const 0_usize as *mut blocksort::__sFILE (PointerFromExposedAddress)
  using: _39@Mir(bb23[0])
  _40 = const 0_i32
  using: 
  _41 = const {alloc193: *mut u8}
  using: 
  (*_41) = move _40 as u8 (IntToInt)
  using: _41@Mir(bb23[3]), _40@Mir(bb23[2])
  _42 = const 0_i32
  using: 
  _43 = const {alloc392: *mut u8}
  using: 
  (*_43) = move _42 as u8 (IntToInt)
  using: _43@Mir(bb23[6]), _42@Mir(bb23[5])
  _44 = const 0_i32
  using: 
  _45 = const {alloc194: *mut u8}
  using: 
  (*_45) = move _44 as u8 (IntToInt)
  using: _45@Mir(bb23[9]), _44@Mir(bb23[8])
  _46 = const 1_i32
  using: 
  _47 = const {alloc196: *mut u8}
  using: 
  (*_47) = move _46 as u8 (IntToInt)
  using: _47@Mir(bb23[12]), _46@Mir(bb23[11])
  _48 = const 0_i32
  using: 
  _49 = const {alloc172: *mut i32}
  using: 
  (*_49) = move _48
  using: _49@Mir(bb23[15]), _48@Mir(bb23[14])
  _50 = const 9_i32
  using: 
  _51 = const {alloc171: *mut i32}
  using: 
  (*_51) = move _50
  using: _51@Mir(bb23[18]), _50@Mir(bb23[17])
  _52 = const 0_i32
  using: 
  _53 = const {alloc474: *mut u8}
  using: 
  (*_53) = move _52 as u8 (IntToInt)
  using: _53@Mir(bb23[21]), _52@Mir(bb23[20])
  _54 = const 0_i32
  using: 
  _55 = const {alloc433: *mut u8}
  using: 
  (*_55) = move _54 as u8 (IntToInt)
  using: _55@Mir(bb23[24]), _54@Mir(bb23[23])
  _56 = const 0_i32
  using: 
  _57 = const {alloc270: *mut i32}
  using: 
  (*_57) = move _56
  using: _57@Mir(bb23[27]), _56@Mir(bb23[26])
  _58 = const 0_i32
  using: 
  _59 = const {alloc271: *mut i32}
  using: 
  (*_59) = move _58
  using: _59@Mir(bb23[30]), _58@Mir(bb23[29])
  _60 = const 30_i32
  using: 
  _61 = const {alloc173: *mut i32}
  using: 
  (*_61) = move _60
  using: _61@Mir(bb23[33]), _60@Mir(bb23[32])
  _62 = const 0_i32
  using: 
  _63 = const {alloc269: *mut u8}
  using: 
  (*_63) = move _62 as u8 (IntToInt)
  using: _63@Mir(bb23[36]), _62@Mir(bb23[35])
  _64 = const 0_i32
  using: 
  _65 = const {alloc256: *mut i32}
  using: 
  (*_65) = move _64
  using: _65@Mir(bb23[39]), _64@Mir(bb23[38])
  _4 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  _67 = const 11_i32
  using: 
  _69 = bzip2::mySIGSEGVorSIGBUScatcher as unsafe extern "C" fn(i32) (Pointer(ReifyFnPointer))
  using: 
  Deinit(_68)
  using: 
  ((_68 as Some).0: unsafe extern "C" fn(i32)) = move _69
  using: _69@Mir(bb23[44])
  discriminant(_68) = 1
  using: 
  _66 = bzip2::signal(move _67, move _68) -> bb24
  using: _67@Mir(bb23[43]), _68@Mir(bb23[45])
bb24:
  _71 = const 10_i32
  using: 
  _73 = bzip2::mySIGSEGVorSIGBUScatcher as unsafe extern "C" fn(i32) (Pointer(ReifyFnPointer))
  using: 
  Deinit(_72)
  using: 
  ((_72 as Some).0: unsafe extern "C" fn(i32)) = move _73
  using: _73@Mir(bb24[1])
  discriminant(_72) = 1
  using: 
  _70 = bzip2::signal(move _71, move _72) -> bb25
  using: _71@Mir(bb24[0]), _72@Mir(bb24[2])
bb25:
  _78 = const {alloc198: *mut [i8; 1034]}
  using: 
  _77 = &mut (*_78)
  using: _78@Mir(bb25[0])
  _76 = move _77 as &mut [i8] (Pointer(Unsize))
  using: _77@Mir(bb25[1])
  _75 = core::slice::<impl [i8]>::as_mut_ptr(move _76) -> bb26
  using: _76@Mir(bb25[2])
bb26:
  _83 = const b"(none)\x00"
  using: 
  _82 = &raw const (*_83)
  using: _83@Mir(bb26[0])
  _81 = move _82 as *const u8 (Pointer(ArrayToPointer))
  using: _82@Mir(bb26[1])
  _80 = move _81 as *const i8 (PtrToPtr)
  using: _81@Mir(bb26[2])
  _79 = move _80 as *mut i8 (PtrToPtr)
  using: _80@Mir(bb26[3])
  _74 = bzip2::copyFileName(move _75, move _79) -> bb27
  using: _75@Mir(bb25[3]), _79@Mir(bb26[4])
bb27:
  _88 = const {alloc263: *mut [i8; 1034]}
  using: 
  _87 = &mut (*_88)
  using: _88@Mir(bb27[0])
  _86 = move _87 as &mut [i8] (Pointer(Unsize))
  using: _87@Mir(bb27[1])
  _85 = core::slice::<impl [i8]>::as_mut_ptr(move _86) -> bb28
  using: _86@Mir(bb27[2])
bb28:
  _93 = const b"(none)\x00"
  using: 
  _92 = &raw const (*_93)
  using: _93@Mir(bb28[0])
  _91 = move _92 as *const u8 (Pointer(ArrayToPointer))
  using: _92@Mir(bb28[1])
  _90 = move _91 as *const i8 (PtrToPtr)
  using: _91@Mir(bb28[2])
  _89 = move _90 as *mut i8 (PtrToPtr)
  using: _90@Mir(bb28[3])
  _84 = bzip2::copyFileName(move _85, move _89) -> bb29
  using: _85@Mir(bb27[3]), _89@Mir(bb28[4])
bb29:
  _98 = const {alloc523: *mut [i8; 1034]}
  using: 
  _97 = &mut (*_98)
  using: _98@Mir(bb29[0])
  _96 = move _97 as &mut [i8] (Pointer(Unsize))
  using: _97@Mir(bb29[1])
  _95 = core::slice::<impl [i8]>::as_mut_ptr(move _96) -> bb30
  using: _96@Mir(bb29[2])
bb30:
  _101 = _2
  using: _2@Entry
  _102 = const 0_isize
  using: 
  _100 = std::ptr::mut_ptr::<impl *mut *mut i8>::offset(move _101, move _102) -> bb31
  using: _101@Mir(bb30[0]), _102@Mir(bb30[1])
bb31:
  _99 = (*_100)
  using: _100@Mir(bb30[2])
  _94 = bzip2::copyFileName(move _95, move _99) -> bb32
  using: _95@Mir(bb29[3]), _99@Mir(bb31[0])
bb32:
  _109 = const {alloc523: *mut [i8; 1034]}
  using: 
  _108 = &mut (*_109)
  using: _109@Mir(bb32[0])
  _107 = move _108 as &mut [i8] (Pointer(Unsize))
  using: _108@Mir(bb32[1])
  _106 = core::slice::<impl [i8]>::as_mut_ptr(move _107) -> bb33
  using: _107@Mir(bb32[2])
bb33:
  _110 = const 0_isize
  using: 
  _105 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _106, move _110) -> bb34
  using: _106@Mir(bb32[3]), _110@Mir(bb33[0])
bb34:
  _104 = &mut (*_105)
  using: _105@Mir(bb33[1])
  _103 = &raw mut (*_104)
  using: _104@Mir(bb34[0])
  _111 = const {alloc197: *mut *mut i8}
  using: 
  (*_111) = move _103
  using: _111@Mir(bb34[2]), _103@Mir(bb34[1])
  _118 = const {alloc523: *mut [i8; 1034]}
  using: 
  _117 = &mut (*_118)
  using: _118@Mir(bb34[4])
  _116 = move _117 as &mut [i8] (Pointer(Unsize))
  using: _117@Mir(bb34[5])
  _115 = core::slice::<impl [i8]>::as_mut_ptr(move _116) -> bb35
  using: _116@Mir(bb34[6])
bb35:
  _119 = const 0_isize
  using: 
  _114 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _115, move _119) -> bb36
  using: _115@Mir(bb34[7]), _119@Mir(bb35[0])
bb36:
  _113 = &mut (*_114)
  using: _114@Mir(bb35[1])
  _112 = &raw mut (*_113)
  using: _113@Mir(bb36[0])
  _5 = move _112
  using: _112@Mir(bb36[1])
  goto -> bb37
  using: 
bb37:
  _122 = (*_5)
  using: _5@Phi(bb37)
  _121 = move _122 as i32 (IntToInt)
  using: _122@Mir(bb37[0])
  _123 = const 0_i32
  using: 
  _120 = Ne(move _121, move _123)
  using: _121@Mir(bb37[1]), _123@Mir(bb37[2])
  switchInt(move _120) -> [0: bb43, otherwise: bb38]
  using: _120@Mir(bb37[3])
bb38:
  _126 = (*_5)
  using: _5@Phi(bb37)
  _125 = move _126 as i32 (IntToInt)
  using: _126@Mir(bb38[0])
  _127 = const 47_i32
  using: 
  _124 = Eq(move _125, move _127)
  using: _125@Mir(bb38[1]), _127@Mir(bb38[2])
  switchInt(move _124) -> [0: bb41, otherwise: bb39]
  using: _124@Mir(bb38[3])
bb39:
  _129 = _5
  using: _5@Phi(bb37)
  _130 = const 1_isize
  using: 
  _128 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _129, move _130) -> bb40
  using: _129@Mir(bb39[0]), _130@Mir(bb39[1])
bb40:
  _131 = const {alloc197: *mut *mut i8}
  using: 
  (*_131) = move _128
  using: _131@Mir(bb40[0]), _128@Mir(bb39[2])
  goto -> bb41
  using: 
bb41:
  _133 = _5
  using: _5@Phi(bb41)
  _132 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _133, const 1_isize) -> bb42
  using: _133@Mir(bb41[0])
bb42:
  _5 = move _132
  using: _132@Mir(bb41[1])
  goto -> bb37
  using: 
bb43:
  _6 = const 0_usize as *mut bzip2::zzzz (PointerFromExposedAddress)
  using: 
  _136 = &mut _6
  using: _6@Mir(bb43[0])
  _135 = &raw mut (*_136)
  using: _136@Mir(bb43[1])
  _141 = const b"BZIP2\x00"
  using: 
  _140 = &raw const (*_141)
  using: _141@Mir(bb43[3])
  _139 = move _140 as *const u8 (Pointer(ArrayToPointer))
  using: _140@Mir(bb43[4])
  _138 = move _139 as *const i8 (PtrToPtr)
  using: _139@Mir(bb43[5])
  _137 = move _138 as *mut i8 (PtrToPtr)
  using: _138@Mir(bb43[6])
  _134 = bzip2::addFlagsFromEnvVar(move _135, move _137) -> bb44
  using: _135@Mir(bb43[2]), _137@Mir(bb43[7])
bb44:
  _144 = &mut _6
  using: _6@Mir(bb43[0])
  _143 = &raw mut (*_144)
  using: _144@Mir(bb44[0])
  _149 = const b"BZIP\x00"
  using: 
  _148 = &raw const (*_149)
  using: _149@Mir(bb44[2])
  _147 = move _148 as *const u8 (Pointer(ArrayToPointer))
  using: _148@Mir(bb44[3])
  _146 = move _147 as *const i8 (PtrToPtr)
  using: _147@Mir(bb44[4])
  _145 = move _146 as *mut i8 (PtrToPtr)
  using: _146@Mir(bb44[5])
  _142 = bzip2::addFlagsFromEnvVar(move _143, move _145) -> bb45
  using: _143@Mir(bb44[1]), _145@Mir(bb44[6])
bb45:
  _3 = const 1_i32
  using: 
  goto -> bb46
  using: 
bb46:
  _151 = _3
  using: _3@Phi(bb46)
  _153 = _1
  using: _1@Entry
  _154 = const 1_i32
  using: 
  _155 = CheckedSub(_153, _154)
  using: _153@Mir(bb46[1]), _154@Mir(bb46[2])
  assert(!move (_155.1: bool), "attempt to compute `{} - {}`, which would overflow", move _153, move _154) -> bb47
  using: _155@Entry, _153@Entry, _154@Entry
bb47:
  _152 = move (_155.0: i32)
  using: _155@Mir(bb46[3])
  _150 = Le(move _151, move _152)
  using: _151@Mir(bb46[0]), _152@Mir(bb47[0])
  switchInt(move _150) -> [0: bb52, otherwise: bb48]
  using: _150@Mir(bb47[1])
bb48:
  _157 = _6
  using: _6@Phi(bb46)
  _160 = _2
  using: _2@Phi(bb46)
  _162 = _3
  using: _3@Phi(bb46)
  _161 = move _162 as isize (IntToInt)
  using: _162@Mir(bb48[2])
  _159 = std::ptr::mut_ptr::<impl *mut *mut i8>::offset(move _160, move _161) -> bb49
  using: _160@Mir(bb48[1]), _161@Mir(bb48[3])
bb49:
  _158 = (*_159)
  using: _159@Mir(bb48[4])
  _156 = bzip2::snocString(move _157, move _158) -> bb50
  using: _157@Mir(bb48[0]), _158@Mir(bb49[0])
bb50:
  _6 = move _156
  using: _156@Mir(bb49[1])
  _163 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb46)
  assert(!move (_163.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb51
  using: _163@Entry, _3@Entry
bb51:
  _3 = move (_163.0: i32)
  using: _163@Mir(bb50[1])
  goto -> bb46
  using: 
bb52:
  _164 = const 7_i32
  using: 
  _165 = const {alloc326: *mut i32}
  using: 
  (*_165) = move _164
  using: _165@Mir(bb52[1]), _164@Mir(bb52[0])
  _166 = const 0_i32
  using: 
  _167 = const {alloc270: *mut i32}
  using: 
  (*_167) = move _166
  using: _167@Mir(bb52[4]), _166@Mir(bb52[3])
  _8 = const 1_u8
  using: 
  _168 = _6
  using: _6@Phi(bb46)
  _7 = move _168
  using: _168@Mir(bb52[7])
  goto -> bb53
  using: 
bb53:
  _171 = _7
  using: _7@Phi(bb53)
  _170 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _171) -> bb54
  using: _171@Mir(bb53[0])
bb54:
  _169 = Not(move _170)
  using: _170@Mir(bb53[1])
  switchInt(move _169) -> [0: bb69, otherwise: bb55]
  using: _169@Mir(bb54[0])
bb55:
  _175 = ((*_7).0: *mut i8)
  using: _7@Phi(bb53)
  _174 = move _175 as *const i8 (Pointer(MutToConstPointer))
  using: _175@Mir(bb55[0])
  _179 = const b"--\x00"
  using: 
  _178 = &raw const (*_179)
  using: _179@Mir(bb55[2])
  _177 = move _178 as *const u8 (Pointer(ArrayToPointer))
  using: _178@Mir(bb55[3])
  _176 = move _177 as *const i8 (PtrToPtr)
  using: _177@Mir(bb55[4])
  _173 = bzip2::strcmp(move _174, move _176) -> bb56
  using: _174@Mir(bb55[1]), _176@Mir(bb55[5])
bb56:
  _180 = const 0_i32
  using: 
  _172 = Eq(move _173, move _180)
  using: _173@Mir(bb55[6]), _180@Mir(bb56[0])
  switchInt(move _172) -> [0: bb58, otherwise: bb57]
  using: _172@Mir(bb56[1])
bb57:
  _8 = const 0_u8
  using: 
  goto -> bb68
  using: 
bb58:
  _187 = ((*_7).0: *mut i8)
  using: _7@Phi(bb53)
  _188 = const 0_isize
  using: 
  _186 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _187, move _188) -> bb62
  using: _187@Mir(bb58[0]), _188@Mir(bb58[1])
bb59:
  _182 = const false
  using: 
  goto -> bb61
  using: 
bb60:
  _192 = _8
  using: _8@Phi(bb53)
  _191 = move _192 as i32 (IntToInt)
  using: _192@Mir(bb60[0])
  _190 = Ne(move _191, const 0_i32)
  using: _191@Mir(bb60[1])
  _182 = move _190
  using: _190@Mir(bb60[2])
  goto -> bb61
  using: 
bb61:
  _181 = Not(move _182)
  using: _182@Phi(bb61)
  switchInt(move _181) -> [0: bb68, otherwise: bb63]
  using: _181@Mir(bb61[0])
bb62:
  _185 = (*_186)
  using: _186@Mir(bb58[2])
  _184 = move _185 as i32 (IntToInt)
  using: _185@Mir(bb62[0])
  _189 = const 45_i32
  using: 
  _183 = Eq(move _184, move _189)
  using: _184@Mir(bb62[1]), _189@Mir(bb62[2])
  switchInt(move _183) -> [0: bb59, otherwise: bb60]
  using: _183@Mir(bb62[3])
bb63:
  _193 = const {alloc270: *mut i32}
  using: 
  _194 = CheckedAdd((*_193), const 1_i32)
  using: _193@Mir(bb63[0])
  assert(!move (_194.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_193), const 1_i32) -> bb64
  using: _194@Entry, _193@Entry
bb64:
  (*_193) = move (_194.0: i32)
  using: _193@Mir(bb63[0]), _194@Mir(bb63[1])
  _197 = const {alloc326: *mut i32}
  using: 
  _196 = (*_197)
  using: _197@Mir(bb64[1])
  _201 = ((*_7).0: *mut i8)
  using: _7@Phi(bb53)
  _200 = move _201 as *const i8 (Pointer(MutToConstPointer))
  using: _201@Mir(bb64[3])
  _199 = bzip2::strlen(move _200) -> bb65
  using: _200@Mir(bb64[4])
bb65:
  _198 = move _199 as i32 (IntToInt)
  using: _199@Mir(bb64[5])
  _195 = Lt(move _196, move _198)
  using: _196@Mir(bb64[2]), _198@Mir(bb65[0])
  switchInt(move _195) -> [0: bb68, otherwise: bb66]
  using: _195@Mir(bb65[1])
bb66:
  _204 = ((*_7).0: *mut i8)
  using: _7@Phi(bb53)
  _203 = move _204 as *const i8 (Pointer(MutToConstPointer))
  using: _204@Mir(bb66[0])
  _202 = bzip2::strlen(move _203) -> bb67
  using: _203@Mir(bb66[1])
bb67:
  _205 = const {alloc326: *mut i32}
  using: 
  (*_205) = move _202 as i32 (IntToInt)
  using: _205@Mir(bb67[0]), _202@Mir(bb66[2])
  goto -> bb68
  using: 
bb68:
  _206 = ((*_7).1: *mut bzip2::zzzz)
  using: _7@Phi(bb68)
  _7 = move _206
  using: _206@Mir(bb68[0])
  goto -> bb53
  using: 
bb69:
  _209 = _7
  using: _7@Phi(bb68)
  _208 = move _209 as usize (PointerExposeAddress)
  using: _209@Mir(bb69[0])
  _207 = Eq(move _208, const 0_usize)
  using: _208@Mir(bb69[1])
  assume(move _207)
  using: _207@Mir(bb69[2])
  _212 = const {alloc270: *mut i32}
  using: 
  _211 = (*_212)
  using: _212@Mir(bb69[4])
  _213 = const 0_i32
  using: 
  _210 = Eq(move _211, move _213)
  using: _211@Mir(bb69[5]), _213@Mir(bb69[6])
  switchInt(move _210) -> [0: bb71, otherwise: bb70]
  using: _210@Mir(bb69[7])
bb70:
  _214 = const 1_i32
  using: 
  _215 = const {alloc267: *mut i32}
  using: 
  (*_215) = move _214
  using: _215@Mir(bb70[1]), _214@Mir(bb70[0])
  goto -> bb72
  using: 
bb71:
  _216 = const 3_i32
  using: 
  _217 = const {alloc267: *mut i32}
  using: 
  (*_217) = move _216
  using: _217@Mir(bb71[1]), _216@Mir(bb71[0])
  goto -> bb72
  using: 
bb72:
  _218 = const 1_i32
  using: 
  _219 = const {alloc268: *mut i32}
  using: 
  (*_219) = move _218
  using: _219@Mir(bb72[1]), _218@Mir(bb72[0])
  _226 = const {alloc197: *mut *mut i8}
  using: 
  _225 = (*_226)
  using: _226@Mir(bb72[3])
  _224 = move _225 as *const i8 (Pointer(MutToConstPointer))
  using: _225@Mir(bb72[4])
  _230 = const b"unzip\x00"
  using: 
  _229 = &raw const (*_230)
  using: _230@Mir(bb72[6])
  _228 = move _229 as *const u8 (Pointer(ArrayToPointer))
  using: _229@Mir(bb72[7])
  _227 = move _228 as *const i8 (PtrToPtr)
  using: _228@Mir(bb72[8])
  _223 = bzip2::strstr(move _224, move _227) -> bb76
  using: _224@Mir(bb72[5]), _227@Mir(bb72[9])
bb73:
  _220 = const true
  using: 
  goto -> bb75
  using: 
bb74:
  _236 = const {alloc197: *mut *mut i8}
  using: 
  _235 = (*_236)
  using: _236@Mir(bb74[0])
  _234 = move _235 as *const i8 (Pointer(MutToConstPointer))
  using: _235@Mir(bb74[1])
  _240 = const b"UNZIP\x00"
  using: 
  _239 = &raw const (*_240)
  using: _240@Mir(bb74[3])
  _238 = move _239 as *const u8 (Pointer(ArrayToPointer))
  using: _239@Mir(bb74[4])
  _237 = move _238 as *const i8 (PtrToPtr)
  using: _238@Mir(bb74[5])
  _233 = bzip2::strstr(move _234, move _237) -> bb78
  using: _234@Mir(bb74[2]), _237@Mir(bb74[6])
bb75:
  switchInt(move _220) -> [0: bb81, otherwise: bb80]
  using: _220@Phi(bb75)
bb76:
  _222 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _223) -> bb77
  using: _223@Mir(bb72[10])
bb77:
  _221 = Not(move _222)
  using: _222@Mir(bb76[0])
  switchInt(move _221) -> [0: bb74, otherwise: bb73]
  using: _221@Mir(bb77[0])
bb78:
  _232 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _233) -> bb79
  using: _233@Mir(bb74[7])
bb79:
  _231 = Not(move _232)
  using: _232@Mir(bb78[0])
  _220 = move _231
  using: _231@Mir(bb79[0])
  goto -> bb75
  using: 
bb80:
  _241 = const 2_i32
  using: 
  _242 = const {alloc268: *mut i32}
  using: 
  (*_242) = move _241
  using: _242@Mir(bb80[1]), _241@Mir(bb80[0])
  goto -> bb81
  using: 
bb81:
  _251 = const {alloc197: *mut *mut i8}
  using: 
  _250 = (*_251)
  using: _251@Mir(bb81[0])
  _249 = move _250 as *const i8 (Pointer(MutToConstPointer))
  using: _250@Mir(bb81[1])
  _255 = const b"z2cat\x00"
  using: 
  _254 = &raw const (*_255)
  using: _255@Mir(bb81[3])
  _253 = move _254 as *const u8 (Pointer(ArrayToPointer))
  using: _254@Mir(bb81[4])
  _252 = move _253 as *const i8 (PtrToPtr)
  using: _253@Mir(bb81[5])
  _248 = bzip2::strstr(move _249, move _252) -> bb91
  using: _249@Mir(bb81[2]), _252@Mir(bb81[6])
bb82:
  _243 = const true
  using: 
  goto -> bb84
  using: 
bb83:
  _281 = const {alloc197: *mut *mut i8}
  using: 
  _280 = (*_281)
  using: _281@Mir(bb83[0])
  _279 = move _280 as *const i8 (Pointer(MutToConstPointer))
  using: _280@Mir(bb83[1])
  _285 = const b"ZCAT\x00"
  using: 
  _284 = &raw const (*_285)
  using: _285@Mir(bb83[3])
  _283 = move _284 as *const u8 (Pointer(ArrayToPointer))
  using: _284@Mir(bb83[4])
  _282 = move _283 as *const i8 (PtrToPtr)
  using: _283@Mir(bb83[5])
  _278 = bzip2::strstr(move _279, move _282) -> bb97
  using: _279@Mir(bb83[2]), _282@Mir(bb83[6])
bb84:
  switchInt(move _243) -> [0: bb103, otherwise: bb99]
  using: _243@Phi(bb84)
bb85:
  _244 = const true
  using: 
  goto -> bb87
  using: 
bb86:
  _271 = const {alloc197: *mut *mut i8}
  using: 
  _270 = (*_271)
  using: _271@Mir(bb86[0])
  _269 = move _270 as *const i8 (Pointer(MutToConstPointer))
  using: _270@Mir(bb86[1])
  _275 = const b"zcat\x00"
  using: 
  _274 = &raw const (*_275)
  using: _275@Mir(bb86[3])
  _273 = move _274 as *const u8 (Pointer(ArrayToPointer))
  using: _274@Mir(bb86[4])
  _272 = move _273 as *const i8 (PtrToPtr)
  using: _273@Mir(bb86[5])
  _268 = bzip2::strstr(move _269, move _272) -> bb95
  using: _269@Mir(bb86[2]), _272@Mir(bb86[6])
bb87:
  switchInt(move _244) -> [0: bb83, otherwise: bb82]
  using: _244@Phi(bb87)
bb88:
  _245 = const true
  using: 
  goto -> bb90
  using: 
bb89:
  _261 = const {alloc197: *mut *mut i8}
  using: 
  _260 = (*_261)
  using: _261@Mir(bb89[0])
  _259 = move _260 as *const i8 (Pointer(MutToConstPointer))
  using: _260@Mir(bb89[1])
  _265 = const b"Z2CAT\x00"
  using: 
  _264 = &raw const (*_265)
  using: _265@Mir(bb89[3])
  _263 = move _264 as *const u8 (Pointer(ArrayToPointer))
  using: _264@Mir(bb89[4])
  _262 = move _263 as *const i8 (PtrToPtr)
  using: _263@Mir(bb89[5])
  _258 = bzip2::strstr(move _259, move _262) -> bb93
  using: _259@Mir(bb89[2]), _262@Mir(bb89[6])
bb90:
  switchInt(move _245) -> [0: bb86, otherwise: bb85]
  using: _245@Phi(bb90)
bb91:
  _247 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _248) -> bb92
  using: _248@Mir(bb81[7])
bb92:
  _246 = Not(move _247)
  using: _247@Mir(bb91[0])
  switchInt(move _246) -> [0: bb89, otherwise: bb88]
  using: _246@Mir(bb92[0])
bb93:
  _257 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _258) -> bb94
  using: _258@Mir(bb89[7])
bb94:
  _256 = Not(move _257)
  using: _257@Mir(bb93[0])
  _245 = move _256
  using: _256@Mir(bb94[0])
  goto -> bb90
  using: 
bb95:
  _267 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _268) -> bb96
  using: _268@Mir(bb86[7])
bb96:
  _266 = Not(move _267)
  using: _267@Mir(bb95[0])
  _244 = move _266
  using: _266@Mir(bb96[0])
  goto -> bb87
  using: 
bb97:
  _277 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _278) -> bb98
  using: _278@Mir(bb83[7])
bb98:
  _276 = Not(move _277)
  using: _277@Mir(bb97[0])
  _243 = move _276
  using: _276@Mir(bb98[0])
  goto -> bb84
  using: 
bb99:
  _286 = const 2_i32
  using: 
  _287 = const {alloc268: *mut i32}
  using: 
  (*_287) = move _286
  using: _287@Mir(bb99[1]), _286@Mir(bb99[0])
  _291 = const {alloc270: *mut i32}
  using: 
  _290 = (*_291)
  using: _291@Mir(bb99[3])
  _292 = const 0_i32
  using: 
  _289 = Eq(move _290, move _292)
  using: _290@Mir(bb99[4]), _292@Mir(bb99[5])
  switchInt(move _289) -> [0: bb101, otherwise: bb100]
  using: _289@Mir(bb99[6])
bb100:
  _288 = const 1_i32
  using: 
  goto -> bb102
  using: 
bb101:
  _288 = const 2_i32
  using: 
  goto -> bb102
  using: 
bb102:
  _293 = const {alloc267: *mut i32}
  using: 
  (*_293) = move _288
  using: _293@Mir(bb102[0]), _288@Phi(bb102)
  goto -> bb103
  using: 
bb103:
  _294 = _6
  using: _6@Phi(bb46)
  _7 = move _294
  using: _294@Mir(bb103[0])
  goto -> bb104
  using: 
bb104:
  _297 = _7
  using: _7@Phi(bb104)
  _296 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _297) -> bb105
  using: _297@Mir(bb104[0])
bb105:
  _295 = Not(move _296)
  using: _296@Mir(bb104[1])
  switchInt(move _295) -> [0: bb147, otherwise: bb106]
  using: _295@Mir(bb105[0])
bb106:
  _301 = ((*_7).0: *mut i8)
  using: _7@Phi(bb104)
  _300 = move _301 as *const i8 (Pointer(MutToConstPointer))
  using: _301@Mir(bb106[0])
  _305 = const b"--\x00"
  using: 
  _304 = &raw const (*_305)
  using: _305@Mir(bb106[2])
  _303 = move _304 as *const u8 (Pointer(ArrayToPointer))
  using: _304@Mir(bb106[3])
  _302 = move _303 as *const i8 (PtrToPtr)
  using: _303@Mir(bb106[4])
  _299 = bzip2::strcmp(move _300, move _302) -> bb107
  using: _300@Mir(bb106[1]), _302@Mir(bb106[5])
bb107:
  _306 = const 0_i32
  using: 
  _298 = Eq(move _299, move _306)
  using: _299@Mir(bb106[6]), _306@Mir(bb107[0])
  switchInt(move _298) -> [0: bb108, otherwise: bb147]
  using: _298@Mir(bb107[1])
bb108:
  _312 = ((*_7).0: *mut i8)
  using: _7@Phi(bb104)
  _313 = const 0_isize
  using: 
  _311 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _312, move _313) -> bb112
  using: _312@Mir(bb108[0]), _313@Mir(bb108[1])
bb109:
  _307 = const false
  using: 
  goto -> bb111
  using: 
bb110:
  _319 = ((*_7).0: *mut i8)
  using: _7@Phi(bb104)
  _320 = const 1_isize
  using: 
  _318 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _319, move _320) -> bb113
  using: _319@Mir(bb110[0]), _320@Mir(bb110[1])
bb111:
  switchInt(move _307) -> [0: bb146, otherwise: bb114]
  using: _307@Phi(bb111)
bb112:
  _310 = (*_311)
  using: _311@Mir(bb108[2])
  _309 = move _310 as i32 (IntToInt)
  using: _310@Mir(bb112[0])
  _314 = const 45_i32
  using: 
  _308 = Eq(move _309, move _314)
  using: _309@Mir(bb112[1]), _314@Mir(bb112[2])
  switchInt(move _308) -> [0: bb109, otherwise: bb110]
  using: _308@Mir(bb112[3])
bb113:
  _317 = (*_318)
  using: _318@Mir(bb110[2])
  _316 = move _317 as i32 (IntToInt)
  using: _317@Mir(bb113[0])
  _321 = const 45_i32
  using: 
  _315 = Ne(move _316, move _321)
  using: _316@Mir(bb113[1]), _321@Mir(bb113[2])
  _307 = move _315
  using: _315@Mir(bb113[3])
  goto -> bb111
  using: 
bb114:
  _4 = const 1_i32
  using: 
  goto -> bb115
  using: 
bb115:
  _326 = ((*_7).0: *mut i8)
  using: _7@Phi(bb115)
  _328 = _4
  using: _4@Phi(bb115)
  _327 = move _328 as isize (IntToInt)
  using: _328@Mir(bb115[1])
  _325 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _326, move _327) -> bb116
  using: _326@Mir(bb115[0]), _327@Mir(bb115[2])
bb116:
  _324 = (*_325)
  using: _325@Mir(bb115[3])
  _323 = move _324 as i32 (IntToInt)
  using: _324@Mir(bb116[0])
  _329 = const 0_i32
  using: 
  _322 = Ne(move _323, move _329)
  using: _323@Mir(bb116[1]), _329@Mir(bb116[2])
  switchInt(move _322) -> [0: bb146, otherwise: bb117]
  using: _322@Mir(bb116[3])
bb117:
  _333 = ((*_7).0: *mut i8)
  using: _7@Phi(bb115)
  _335 = _4
  using: _4@Phi(bb115)
  _334 = move _335 as isize (IntToInt)
  using: _335@Mir(bb117[1])
  _332 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _333, move _334) -> bb118
  using: _333@Mir(bb117[0]), _334@Mir(bb117[2])
bb118:
  _331 = (*_332)
  using: _332@Mir(bb117[3])
  _330 = move _331 as i32 (IntToInt)
  using: _331@Mir(bb118[0])
  switchInt(_330) -> [99: bb120, 100: bb121, 122: bb122, 102: bb123, 116: bb124, 107: bb125, 115: bb126, 113: bb127, 49: bb128, 50: bb129, 51: bb130, 52: bb131, 53: bb132, 54: bb133, 55: bb134, 56: bb135, 57: bb136, 86: bb137, 76: bb137, 118: bb138, 104: bb140, otherwise: bb119]
  using: _330@Mir(bb118[1])
bb119:
  _380 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _379 = (*_380)
  using: _380@Mir(bb119[0])
  _384 = const b"%s: Bad flag `%s\'\n\x00"
  using: 
  _383 = &raw const (*_384)
  using: _384@Mir(bb119[2])
  _382 = move _383 as *const u8 (Pointer(ArrayToPointer))
  using: _383@Mir(bb119[3])
  _381 = move _382 as *const i8 (PtrToPtr)
  using: _382@Mir(bb119[4])
  _386 = const {alloc197: *mut *mut i8}
  using: 
  _385 = (*_386)
  using: _386@Mir(bb119[6])
  _387 = ((*_7).0: *mut i8)
  using: _7@Phi(bb115)
  _378 = bzip2::fprintf(move _379, move _381, move _385, move _387) -> bb142
  using: _379@Mir(bb119[1]), _381@Mir(bb119[5]), _385@Mir(bb119[7]), _387@Mir(bb119[8])
bb120:
  _336 = const 2_i32
  using: 
  _337 = const {alloc267: *mut i32}
  using: 
  (*_337) = move _336
  using: _337@Mir(bb120[1]), _336@Mir(bb120[0])
  goto -> bb144
  using: 
bb121:
  _338 = const 2_i32
  using: 
  _339 = const {alloc268: *mut i32}
  using: 
  (*_339) = move _338
  using: _339@Mir(bb121[1]), _338@Mir(bb121[0])
  goto -> bb144
  using: 
bb122:
  _340 = const 1_i32
  using: 
  _341 = const {alloc268: *mut i32}
  using: 
  (*_341) = move _340
  using: _341@Mir(bb122[1]), _340@Mir(bb122[0])
  goto -> bb144
  using: 
bb123:
  _342 = const 1_i32
  using: 
  _343 = const {alloc194: *mut u8}
  using: 
  (*_343) = move _342 as u8 (IntToInt)
  using: _343@Mir(bb123[1]), _342@Mir(bb123[0])
  goto -> bb144
  using: 
bb124:
  _344 = const 3_i32
  using: 
  _345 = const {alloc268: *mut i32}
  using: 
  (*_345) = move _344
  using: _345@Mir(bb124[1]), _344@Mir(bb124[0])
  goto -> bb144
  using: 
bb125:
  _346 = const 1_i32
  using: 
  _347 = const {alloc392: *mut u8}
  using: 
  (*_347) = move _346 as u8 (IntToInt)
  using: _347@Mir(bb125[1]), _346@Mir(bb125[0])
  goto -> bb144
  using: 
bb126:
  _348 = const 1_i32
  using: 
  _349 = const {alloc193: *mut u8}
  using: 
  (*_349) = move _348 as u8 (IntToInt)
  using: _349@Mir(bb126[1]), _348@Mir(bb126[0])
  goto -> bb144
  using: 
bb127:
  _350 = const 0_i32
  using: 
  _351 = const {alloc196: *mut u8}
  using: 
  (*_351) = move _350 as u8 (IntToInt)
  using: _351@Mir(bb127[1]), _350@Mir(bb127[0])
  goto -> bb144
  using: 
bb128:
  _352 = const 1_i32
  using: 
  _353 = const {alloc171: *mut i32}
  using: 
  (*_353) = move _352
  using: _353@Mir(bb128[1]), _352@Mir(bb128[0])
  goto -> bb144
  using: 
bb129:
  _354 = const 2_i32
  using: 
  _355 = const {alloc171: *mut i32}
  using: 
  (*_355) = move _354
  using: _355@Mir(bb129[1]), _354@Mir(bb129[0])
  goto -> bb144
  using: 
bb130:
  _356 = const 3_i32
  using: 
  _357 = const {alloc171: *mut i32}
  using: 
  (*_357) = move _356
  using: _357@Mir(bb130[1]), _356@Mir(bb130[0])
  goto -> bb144
  using: 
bb131:
  _358 = const 4_i32
  using: 
  _359 = const {alloc171: *mut i32}
  using: 
  (*_359) = move _358
  using: _359@Mir(bb131[1]), _358@Mir(bb131[0])
  goto -> bb144
  using: 
bb132:
  _360 = const 5_i32
  using: 
  _361 = const {alloc171: *mut i32}
  using: 
  (*_361) = move _360
  using: _361@Mir(bb132[1]), _360@Mir(bb132[0])
  goto -> bb144
  using: 
bb133:
  _362 = const 6_i32
  using: 
  _363 = const {alloc171: *mut i32}
  using: 
  (*_363) = move _362
  using: _363@Mir(bb133[1]), _362@Mir(bb133[0])
  goto -> bb144
  using: 
bb134:
  _364 = const 7_i32
  using: 
  _365 = const {alloc171: *mut i32}
  using: 
  (*_365) = move _364
  using: _365@Mir(bb134[1]), _364@Mir(bb134[0])
  goto -> bb144
  using: 
bb135:
  _366 = const 8_i32
  using: 
  _367 = const {alloc171: *mut i32}
  using: 
  (*_367) = move _366
  using: _367@Mir(bb135[1]), _366@Mir(bb135[0])
  goto -> bb144
  using: 
bb136:
  _368 = const 9_i32
  using: 
  _369 = const {alloc171: *mut i32}
  using: 
  (*_369) = move _368
  using: _369@Mir(bb136[1]), _368@Mir(bb136[0])
  goto -> bb144
  using: 
bb137:
  _370 = bzip2::license() -> bb144
  using: 
bb138:
  _371 = const {alloc172: *mut i32}
  using: 
  _372 = CheckedAdd((*_371), const 1_i32)
  using: _371@Mir(bb138[0])
  assert(!move (_372.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_371), const 1_i32) -> bb139
  using: _372@Entry, _371@Entry
bb139:
  (*_371) = move (_372.0: i32)
  using: _371@Mir(bb138[0]), _372@Mir(bb138[1])
  goto -> bb144
  using: 
bb140:
  _375 = const {alloc197: *mut *mut i8}
  using: 
  _374 = (*_375)
  using: _375@Mir(bb140[0])
  _373 = bzip2::usage(move _374) -> bb141
  using: _374@Mir(bb140[1])
bb141:
  _377 = const 0_i32
  using: 
  _376 = bzip2::exit(move _377)
  using: _377@Mir(bb141[0])
bb142:
  _390 = const {alloc197: *mut *mut i8}
  using: 
  _389 = (*_390)
  using: _390@Mir(bb142[0])
  _388 = bzip2::usage(move _389) -> bb143
  using: _389@Mir(bb142[1])
bb143:
  _392 = const 1_i32
  using: 
  _391 = bzip2::exit(move _392)
  using: _392@Mir(bb143[0])
bb144:
  _393 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb115)
  assert(!move (_393.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb145
  using: _393@Entry, _4@Entry
bb145:
  _4 = move (_393.0: i32)
  using: _393@Mir(bb144[0])
  goto -> bb115
  using: 
bb146:
  _394 = ((*_7).1: *mut bzip2::zzzz)
  using: _7@Phi(bb146)
  _7 = move _394
  using: _394@Mir(bb146[0])
  goto -> bb104
  using: 
bb147:
  _397 = _7
  using: _7@Phi(bb147)
  _396 = move _397 as usize (PointerExposeAddress)
  using: _397@Mir(bb147[0])
  _395 = Eq(move _396, const 0_usize)
  using: _396@Mir(bb147[1])
  assume(move _395)
  using: _395@Mir(bb147[2])
  _398 = _6
  using: _6@Phi(bb46)
  _7 = move _398
  using: _398@Mir(bb147[4])
  goto -> bb148
  using: 
bb148:
  _401 = _7
  using: _7@Phi(bb148)
  _400 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _401) -> bb149
  using: _401@Mir(bb148[0])
bb149:
  _399 = Not(move _400)
  using: _400@Mir(bb148[1])
  switchInt(move _399) -> [0: bb211, otherwise: bb150]
  using: _399@Mir(bb149[0])
bb150:
  _405 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _404 = move _405 as *const i8 (Pointer(MutToConstPointer))
  using: _405@Mir(bb150[0])
  _409 = const b"--\x00"
  using: 
  _408 = &raw const (*_409)
  using: _409@Mir(bb150[2])
  _407 = move _408 as *const u8 (Pointer(ArrayToPointer))
  using: _408@Mir(bb150[3])
  _406 = move _407 as *const i8 (PtrToPtr)
  using: _407@Mir(bb150[4])
  _403 = bzip2::strcmp(move _404, move _406) -> bb151
  using: _404@Mir(bb150[1]), _406@Mir(bb150[5])
bb151:
  _410 = const 0_i32
  using: 
  _402 = Eq(move _403, move _410)
  using: _403@Mir(bb150[6]), _410@Mir(bb151[0])
  switchInt(move _402) -> [0: bb152, otherwise: bb211]
  using: _402@Mir(bb151[1])
bb152:
  _414 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _413 = move _414 as *const i8 (Pointer(MutToConstPointer))
  using: _414@Mir(bb152[0])
  _418 = const b"--stdout\x00"
  using: 
  _417 = &raw const (*_418)
  using: _418@Mir(bb152[2])
  _416 = move _417 as *const u8 (Pointer(ArrayToPointer))
  using: _417@Mir(bb152[3])
  _415 = move _416 as *const i8 (PtrToPtr)
  using: _416@Mir(bb152[4])
  _412 = bzip2::strcmp(move _413, move _415) -> bb153
  using: _413@Mir(bb152[1]), _415@Mir(bb152[5])
bb153:
  _419 = const 0_i32
  using: 
  _411 = Eq(move _412, move _419)
  using: _412@Mir(bb152[6]), _419@Mir(bb153[0])
  switchInt(move _411) -> [0: bb155, otherwise: bb154]
  using: _411@Mir(bb153[1])
bb154:
  _420 = const 2_i32
  using: 
  _421 = const {alloc267: *mut i32}
  using: 
  (*_421) = move _420
  using: _421@Mir(bb154[1]), _420@Mir(bb154[0])
  goto -> bb210
  using: 
bb155:
  _425 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _424 = move _425 as *const i8 (Pointer(MutToConstPointer))
  using: _425@Mir(bb155[0])
  _429 = const b"--decompress\x00"
  using: 
  _428 = &raw const (*_429)
  using: _429@Mir(bb155[2])
  _427 = move _428 as *const u8 (Pointer(ArrayToPointer))
  using: _428@Mir(bb155[3])
  _426 = move _427 as *const i8 (PtrToPtr)
  using: _427@Mir(bb155[4])
  _423 = bzip2::strcmp(move _424, move _426) -> bb156
  using: _424@Mir(bb155[1]), _426@Mir(bb155[5])
bb156:
  _430 = const 0_i32
  using: 
  _422 = Eq(move _423, move _430)
  using: _423@Mir(bb155[6]), _430@Mir(bb156[0])
  switchInt(move _422) -> [0: bb158, otherwise: bb157]
  using: _422@Mir(bb156[1])
bb157:
  _431 = const 2_i32
  using: 
  _432 = const {alloc268: *mut i32}
  using: 
  (*_432) = move _431
  using: _432@Mir(bb157[1]), _431@Mir(bb157[0])
  goto -> bb210
  using: 
bb158:
  _436 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _435 = move _436 as *const i8 (Pointer(MutToConstPointer))
  using: _436@Mir(bb158[0])
  _440 = const b"--compress\x00"
  using: 
  _439 = &raw const (*_440)
  using: _440@Mir(bb158[2])
  _438 = move _439 as *const u8 (Pointer(ArrayToPointer))
  using: _439@Mir(bb158[3])
  _437 = move _438 as *const i8 (PtrToPtr)
  using: _438@Mir(bb158[4])
  _434 = bzip2::strcmp(move _435, move _437) -> bb159
  using: _435@Mir(bb158[1]), _437@Mir(bb158[5])
bb159:
  _441 = const 0_i32
  using: 
  _433 = Eq(move _434, move _441)
  using: _434@Mir(bb158[6]), _441@Mir(bb159[0])
  switchInt(move _433) -> [0: bb161, otherwise: bb160]
  using: _433@Mir(bb159[1])
bb160:
  _442 = const 1_i32
  using: 
  _443 = const {alloc268: *mut i32}
  using: 
  (*_443) = move _442
  using: _443@Mir(bb160[1]), _442@Mir(bb160[0])
  goto -> bb210
  using: 
bb161:
  _447 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _446 = move _447 as *const i8 (Pointer(MutToConstPointer))
  using: _447@Mir(bb161[0])
  _451 = const b"--force\x00"
  using: 
  _450 = &raw const (*_451)
  using: _451@Mir(bb161[2])
  _449 = move _450 as *const u8 (Pointer(ArrayToPointer))
  using: _450@Mir(bb161[3])
  _448 = move _449 as *const i8 (PtrToPtr)
  using: _449@Mir(bb161[4])
  _445 = bzip2::strcmp(move _446, move _448) -> bb162
  using: _446@Mir(bb161[1]), _448@Mir(bb161[5])
bb162:
  _452 = const 0_i32
  using: 
  _444 = Eq(move _445, move _452)
  using: _445@Mir(bb161[6]), _452@Mir(bb162[0])
  switchInt(move _444) -> [0: bb164, otherwise: bb163]
  using: _444@Mir(bb162[1])
bb163:
  _453 = const 1_i32
  using: 
  _454 = const {alloc194: *mut u8}
  using: 
  (*_454) = move _453 as u8 (IntToInt)
  using: _454@Mir(bb163[1]), _453@Mir(bb163[0])
  goto -> bb210
  using: 
bb164:
  _458 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _457 = move _458 as *const i8 (Pointer(MutToConstPointer))
  using: _458@Mir(bb164[0])
  _462 = const b"--test\x00"
  using: 
  _461 = &raw const (*_462)
  using: _462@Mir(bb164[2])
  _460 = move _461 as *const u8 (Pointer(ArrayToPointer))
  using: _461@Mir(bb164[3])
  _459 = move _460 as *const i8 (PtrToPtr)
  using: _460@Mir(bb164[4])
  _456 = bzip2::strcmp(move _457, move _459) -> bb165
  using: _457@Mir(bb164[1]), _459@Mir(bb164[5])
bb165:
  _463 = const 0_i32
  using: 
  _455 = Eq(move _456, move _463)
  using: _456@Mir(bb164[6]), _463@Mir(bb165[0])
  switchInt(move _455) -> [0: bb167, otherwise: bb166]
  using: _455@Mir(bb165[1])
bb166:
  _464 = const 3_i32
  using: 
  _465 = const {alloc268: *mut i32}
  using: 
  (*_465) = move _464
  using: _465@Mir(bb166[1]), _464@Mir(bb166[0])
  goto -> bb210
  using: 
bb167:
  _469 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _468 = move _469 as *const i8 (Pointer(MutToConstPointer))
  using: _469@Mir(bb167[0])
  _473 = const b"--keep\x00"
  using: 
  _472 = &raw const (*_473)
  using: _473@Mir(bb167[2])
  _471 = move _472 as *const u8 (Pointer(ArrayToPointer))
  using: _472@Mir(bb167[3])
  _470 = move _471 as *const i8 (PtrToPtr)
  using: _471@Mir(bb167[4])
  _467 = bzip2::strcmp(move _468, move _470) -> bb168
  using: _468@Mir(bb167[1]), _470@Mir(bb167[5])
bb168:
  _474 = const 0_i32
  using: 
  _466 = Eq(move _467, move _474)
  using: _467@Mir(bb167[6]), _474@Mir(bb168[0])
  switchInt(move _466) -> [0: bb170, otherwise: bb169]
  using: _466@Mir(bb168[1])
bb169:
  _475 = const 1_i32
  using: 
  _476 = const {alloc392: *mut u8}
  using: 
  (*_476) = move _475 as u8 (IntToInt)
  using: _476@Mir(bb169[1]), _475@Mir(bb169[0])
  goto -> bb210
  using: 
bb170:
  _480 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _479 = move _480 as *const i8 (Pointer(MutToConstPointer))
  using: _480@Mir(bb170[0])
  _484 = const b"--small\x00"
  using: 
  _483 = &raw const (*_484)
  using: _484@Mir(bb170[2])
  _482 = move _483 as *const u8 (Pointer(ArrayToPointer))
  using: _483@Mir(bb170[3])
  _481 = move _482 as *const i8 (PtrToPtr)
  using: _482@Mir(bb170[4])
  _478 = bzip2::strcmp(move _479, move _481) -> bb171
  using: _479@Mir(bb170[1]), _481@Mir(bb170[5])
bb171:
  _485 = const 0_i32
  using: 
  _477 = Eq(move _478, move _485)
  using: _478@Mir(bb170[6]), _485@Mir(bb171[0])
  switchInt(move _477) -> [0: bb173, otherwise: bb172]
  using: _477@Mir(bb171[1])
bb172:
  _486 = const 1_i32
  using: 
  _487 = const {alloc193: *mut u8}
  using: 
  (*_487) = move _486 as u8 (IntToInt)
  using: _487@Mir(bb172[1]), _486@Mir(bb172[0])
  goto -> bb210
  using: 
bb173:
  _491 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _490 = move _491 as *const i8 (Pointer(MutToConstPointer))
  using: _491@Mir(bb173[0])
  _495 = const b"--quiet\x00"
  using: 
  _494 = &raw const (*_495)
  using: _495@Mir(bb173[2])
  _493 = move _494 as *const u8 (Pointer(ArrayToPointer))
  using: _494@Mir(bb173[3])
  _492 = move _493 as *const i8 (PtrToPtr)
  using: _493@Mir(bb173[4])
  _489 = bzip2::strcmp(move _490, move _492) -> bb174
  using: _490@Mir(bb173[1]), _492@Mir(bb173[5])
bb174:
  _496 = const 0_i32
  using: 
  _488 = Eq(move _489, move _496)
  using: _489@Mir(bb173[6]), _496@Mir(bb174[0])
  switchInt(move _488) -> [0: bb176, otherwise: bb175]
  using: _488@Mir(bb174[1])
bb175:
  _497 = const 0_i32
  using: 
  _498 = const {alloc196: *mut u8}
  using: 
  (*_498) = move _497 as u8 (IntToInt)
  using: _498@Mir(bb175[1]), _497@Mir(bb175[0])
  goto -> bb210
  using: 
bb176:
  _502 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _501 = move _502 as *const i8 (Pointer(MutToConstPointer))
  using: _502@Mir(bb176[0])
  _506 = const b"--version\x00"
  using: 
  _505 = &raw const (*_506)
  using: _506@Mir(bb176[2])
  _504 = move _505 as *const u8 (Pointer(ArrayToPointer))
  using: _505@Mir(bb176[3])
  _503 = move _504 as *const i8 (PtrToPtr)
  using: _504@Mir(bb176[4])
  _500 = bzip2::strcmp(move _501, move _503) -> bb177
  using: _501@Mir(bb176[1]), _503@Mir(bb176[5])
bb177:
  _507 = const 0_i32
  using: 
  _499 = Eq(move _500, move _507)
  using: _500@Mir(bb176[6]), _507@Mir(bb177[0])
  switchInt(move _499) -> [0: bb179, otherwise: bb178]
  using: _499@Mir(bb177[1])
bb178:
  _508 = bzip2::license() -> bb210
  using: 
bb179:
  _512 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _511 = move _512 as *const i8 (Pointer(MutToConstPointer))
  using: _512@Mir(bb179[0])
  _516 = const b"--license\x00"
  using: 
  _515 = &raw const (*_516)
  using: _516@Mir(bb179[2])
  _514 = move _515 as *const u8 (Pointer(ArrayToPointer))
  using: _515@Mir(bb179[3])
  _513 = move _514 as *const i8 (PtrToPtr)
  using: _514@Mir(bb179[4])
  _510 = bzip2::strcmp(move _511, move _513) -> bb180
  using: _511@Mir(bb179[1]), _513@Mir(bb179[5])
bb180:
  _517 = const 0_i32
  using: 
  _509 = Eq(move _510, move _517)
  using: _510@Mir(bb179[6]), _517@Mir(bb180[0])
  switchInt(move _509) -> [0: bb182, otherwise: bb181]
  using: _509@Mir(bb180[1])
bb181:
  _518 = bzip2::license() -> bb210
  using: 
bb182:
  _522 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _521 = move _522 as *const i8 (Pointer(MutToConstPointer))
  using: _522@Mir(bb182[0])
  _526 = const b"--exponential\x00"
  using: 
  _525 = &raw const (*_526)
  using: _526@Mir(bb182[2])
  _524 = move _525 as *const u8 (Pointer(ArrayToPointer))
  using: _525@Mir(bb182[3])
  _523 = move _524 as *const i8 (PtrToPtr)
  using: _524@Mir(bb182[4])
  _520 = bzip2::strcmp(move _521, move _523) -> bb183
  using: _521@Mir(bb182[1]), _523@Mir(bb182[5])
bb183:
  _527 = const 0_i32
  using: 
  _519 = Eq(move _520, move _527)
  using: _520@Mir(bb182[6]), _527@Mir(bb183[0])
  switchInt(move _519) -> [0: bb185, otherwise: bb184]
  using: _519@Mir(bb183[1])
bb184:
  _528 = const 1_i32
  using: 
  _529 = const {alloc173: *mut i32}
  using: 
  (*_529) = move _528
  using: _529@Mir(bb184[1]), _528@Mir(bb184[0])
  goto -> bb210
  using: 
bb185:
  _533 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _532 = move _533 as *const i8 (Pointer(MutToConstPointer))
  using: _533@Mir(bb185[0])
  _537 = const b"--repetitive-best\x00"
  using: 
  _536 = &raw const (*_537)
  using: _537@Mir(bb185[2])
  _535 = move _536 as *const u8 (Pointer(ArrayToPointer))
  using: _536@Mir(bb185[3])
  _534 = move _535 as *const i8 (PtrToPtr)
  using: _535@Mir(bb185[4])
  _531 = bzip2::strcmp(move _532, move _534) -> bb186
  using: _532@Mir(bb185[1]), _534@Mir(bb185[5])
bb186:
  _538 = const 0_i32
  using: 
  _530 = Eq(move _531, move _538)
  using: _531@Mir(bb185[6]), _538@Mir(bb186[0])
  switchInt(move _530) -> [0: bb188, otherwise: bb187]
  using: _530@Mir(bb186[1])
bb187:
  _540 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _539 = bzip2::redundant(move _540) -> bb210
  using: _540@Mir(bb187[0])
bb188:
  _544 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _543 = move _544 as *const i8 (Pointer(MutToConstPointer))
  using: _544@Mir(bb188[0])
  _548 = const b"--repetitive-fast\x00"
  using: 
  _547 = &raw const (*_548)
  using: _548@Mir(bb188[2])
  _546 = move _547 as *const u8 (Pointer(ArrayToPointer))
  using: _547@Mir(bb188[3])
  _545 = move _546 as *const i8 (PtrToPtr)
  using: _546@Mir(bb188[4])
  _542 = bzip2::strcmp(move _543, move _545) -> bb189
  using: _543@Mir(bb188[1]), _545@Mir(bb188[5])
bb189:
  _549 = const 0_i32
  using: 
  _541 = Eq(move _542, move _549)
  using: _542@Mir(bb188[6]), _549@Mir(bb189[0])
  switchInt(move _541) -> [0: bb191, otherwise: bb190]
  using: _541@Mir(bb189[1])
bb190:
  _551 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _550 = bzip2::redundant(move _551) -> bb210
  using: _551@Mir(bb190[0])
bb191:
  _555 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _554 = move _555 as *const i8 (Pointer(MutToConstPointer))
  using: _555@Mir(bb191[0])
  _559 = const b"--fast\x00"
  using: 
  _558 = &raw const (*_559)
  using: _559@Mir(bb191[2])
  _557 = move _558 as *const u8 (Pointer(ArrayToPointer))
  using: _558@Mir(bb191[3])
  _556 = move _557 as *const i8 (PtrToPtr)
  using: _557@Mir(bb191[4])
  _553 = bzip2::strcmp(move _554, move _556) -> bb192
  using: _554@Mir(bb191[1]), _556@Mir(bb191[5])
bb192:
  _560 = const 0_i32
  using: 
  _552 = Eq(move _553, move _560)
  using: _553@Mir(bb191[6]), _560@Mir(bb192[0])
  switchInt(move _552) -> [0: bb194, otherwise: bb193]
  using: _552@Mir(bb192[1])
bb193:
  _561 = const 1_i32
  using: 
  _562 = const {alloc171: *mut i32}
  using: 
  (*_562) = move _561
  using: _562@Mir(bb193[1]), _561@Mir(bb193[0])
  goto -> bb210
  using: 
bb194:
  _566 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _565 = move _566 as *const i8 (Pointer(MutToConstPointer))
  using: _566@Mir(bb194[0])
  _570 = const b"--best\x00"
  using: 
  _569 = &raw const (*_570)
  using: _570@Mir(bb194[2])
  _568 = move _569 as *const u8 (Pointer(ArrayToPointer))
  using: _569@Mir(bb194[3])
  _567 = move _568 as *const i8 (PtrToPtr)
  using: _568@Mir(bb194[4])
  _564 = bzip2::strcmp(move _565, move _567) -> bb195
  using: _565@Mir(bb194[1]), _567@Mir(bb194[5])
bb195:
  _571 = const 0_i32
  using: 
  _563 = Eq(move _564, move _571)
  using: _564@Mir(bb194[6]), _571@Mir(bb195[0])
  switchInt(move _563) -> [0: bb197, otherwise: bb196]
  using: _563@Mir(bb195[1])
bb196:
  _572 = const 9_i32
  using: 
  _573 = const {alloc171: *mut i32}
  using: 
  (*_573) = move _572
  using: _573@Mir(bb196[1]), _572@Mir(bb196[0])
  goto -> bb210
  using: 
bb197:
  _577 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _576 = move _577 as *const i8 (Pointer(MutToConstPointer))
  using: _577@Mir(bb197[0])
  _581 = const b"--verbose\x00"
  using: 
  _580 = &raw const (*_581)
  using: _581@Mir(bb197[2])
  _579 = move _580 as *const u8 (Pointer(ArrayToPointer))
  using: _580@Mir(bb197[3])
  _578 = move _579 as *const i8 (PtrToPtr)
  using: _579@Mir(bb197[4])
  _575 = bzip2::strcmp(move _576, move _578) -> bb198
  using: _576@Mir(bb197[1]), _578@Mir(bb197[5])
bb198:
  _582 = const 0_i32
  using: 
  _574 = Eq(move _575, move _582)
  using: _575@Mir(bb197[6]), _582@Mir(bb198[0])
  switchInt(move _574) -> [0: bb201, otherwise: bb199]
  using: _574@Mir(bb198[1])
bb199:
  _583 = const {alloc172: *mut i32}
  using: 
  _584 = CheckedAdd((*_583), const 1_i32)
  using: _583@Mir(bb199[0])
  assert(!move (_584.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_583), const 1_i32) -> bb200
  using: _584@Entry, _583@Entry
bb200:
  (*_583) = move (_584.0: i32)
  using: _583@Mir(bb199[0]), _584@Mir(bb199[1])
  goto -> bb210
  using: 
bb201:
  _588 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _587 = move _588 as *const i8 (Pointer(MutToConstPointer))
  using: _588@Mir(bb201[0])
  _592 = const b"--help\x00"
  using: 
  _591 = &raw const (*_592)
  using: _592@Mir(bb201[2])
  _590 = move _591 as *const u8 (Pointer(ArrayToPointer))
  using: _591@Mir(bb201[3])
  _589 = move _590 as *const i8 (PtrToPtr)
  using: _590@Mir(bb201[4])
  _586 = bzip2::strcmp(move _587, move _589) -> bb202
  using: _587@Mir(bb201[1]), _589@Mir(bb201[5])
bb202:
  _593 = const 0_i32
  using: 
  _585 = Eq(move _586, move _593)
  using: _586@Mir(bb201[6]), _593@Mir(bb202[0])
  switchInt(move _585) -> [0: bb205, otherwise: bb203]
  using: _585@Mir(bb202[1])
bb203:
  _596 = const {alloc197: *mut *mut i8}
  using: 
  _595 = (*_596)
  using: _596@Mir(bb203[0])
  _594 = bzip2::usage(move _595) -> bb204
  using: _595@Mir(bb203[1])
bb204:
  _598 = const 0_i32
  using: 
  _597 = bzip2::exit(move _598)
  using: _598@Mir(bb204[0])
bb205:
  _602 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _601 = move _602 as *const i8 (Pointer(MutToConstPointer))
  using: _602@Mir(bb205[0])
  _606 = const b"--\x00"
  using: 
  _605 = &raw const (*_606)
  using: _606@Mir(bb205[2])
  _604 = move _605 as *const u8 (Pointer(ArrayToPointer))
  using: _605@Mir(bb205[3])
  _603 = move _604 as *const i8 (PtrToPtr)
  using: _604@Mir(bb205[4])
  _607 = const 2_u64
  using: 
  _600 = bzip2::strncmp(move _601, move _603, move _607) -> bb206
  using: _601@Mir(bb205[1]), _603@Mir(bb205[5]), _607@Mir(bb205[6])
bb206:
  _608 = const 0_i32
  using: 
  _599 = Eq(move _600, move _608)
  using: _600@Mir(bb205[7]), _608@Mir(bb206[0])
  switchInt(move _599) -> [0: bb210, otherwise: bb207]
  using: _599@Mir(bb206[1])
bb207:
  _611 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _610 = (*_611)
  using: _611@Mir(bb207[0])
  _615 = const b"%s: Bad flag `%s\'\n\x00"
  using: 
  _614 = &raw const (*_615)
  using: _615@Mir(bb207[2])
  _613 = move _614 as *const u8 (Pointer(ArrayToPointer))
  using: _614@Mir(bb207[3])
  _612 = move _613 as *const i8 (PtrToPtr)
  using: _613@Mir(bb207[4])
  _617 = const {alloc197: *mut *mut i8}
  using: 
  _616 = (*_617)
  using: _617@Mir(bb207[6])
  _618 = ((*_7).0: *mut i8)
  using: _7@Phi(bb148)
  _609 = bzip2::fprintf(move _610, move _612, move _616, move _618) -> bb208
  using: _610@Mir(bb207[1]), _612@Mir(bb207[5]), _616@Mir(bb207[7]), _618@Mir(bb207[8])
bb208:
  _621 = const {alloc197: *mut *mut i8}
  using: 
  _620 = (*_621)
  using: _621@Mir(bb208[0])
  _619 = bzip2::usage(move _620) -> bb209
  using: _620@Mir(bb208[1])
bb209:
  _623 = const 1_i32
  using: 
  _622 = bzip2::exit(move _623)
  using: _623@Mir(bb209[0])
bb210:
  _624 = ((*_7).1: *mut bzip2::zzzz)
  using: _7@Phi(bb210)
  _7 = move _624
  using: _624@Mir(bb210[0])
  goto -> bb148
  using: 
bb211:
  _627 = _7
  using: _7@Phi(bb211)
  _626 = move _627 as usize (PointerExposeAddress)
  using: _627@Mir(bb211[0])
  _625 = Eq(move _626, const 0_usize)
  using: _626@Mir(bb211[1])
  assume(move _625)
  using: _625@Mir(bb211[2])
  _630 = const {alloc172: *mut i32}
  using: 
  _629 = (*_630)
  using: _630@Mir(bb211[4])
  _631 = const 4_i32
  using: 
  _628 = Gt(move _629, move _631)
  using: _629@Mir(bb211[5]), _631@Mir(bb211[6])
  switchInt(move _628) -> [0: bb213, otherwise: bb212]
  using: _628@Mir(bb211[7])
bb212:
  _632 = const 4_i32
  using: 
  _633 = const {alloc172: *mut i32}
  using: 
  (*_633) = move _632
  using: _633@Mir(bb212[1]), _632@Mir(bb212[0])
  goto -> bb213
  using: 
bb213:
  _638 = const {alloc268: *mut i32}
  using: 
  _637 = (*_638)
  using: _638@Mir(bb213[0])
  _639 = const 1_i32
  using: 
  _636 = Eq(move _637, move _639)
  using: _637@Mir(bb213[1]), _639@Mir(bb213[2])
  switchInt(move _636) -> [0: bb217, otherwise: bb218]
  using: _636@Mir(bb213[3])
bb214:
  _634 = const false
  using: 
  goto -> bb216
  using: 
bb215:
  _646 = const {alloc171: *mut i32}
  using: 
  _645 = (*_646)
  using: _646@Mir(bb215[0])
  _647 = const 2_i32
  using: 
  _644 = Gt(move _645, move _647)
  using: _645@Mir(bb215[1]), _647@Mir(bb215[2])
  _634 = move _644
  using: _644@Mir(bb215[3])
  goto -> bb216
  using: 
bb216:
  switchInt(move _634) -> [0: bb221, otherwise: bb220]
  using: _634@Phi(bb216)
bb217:
  _635 = const false
  using: 
  goto -> bb219
  using: 
bb218:
  _643 = const {alloc193: *mut u8}
  using: 
  _642 = (*_643)
  using: _643@Mir(bb218[0])
  _641 = move _642 as i32 (IntToInt)
  using: _642@Mir(bb218[1])
  _640 = Ne(move _641, const 0_i32)
  using: _641@Mir(bb218[2])
  _635 = move _640
  using: _640@Mir(bb218[3])
  goto -> bb219
  using: 
bb219:
  switchInt(move _635) -> [0: bb214, otherwise: bb215]
  using: _635@Phi(bb219)
bb220:
  _648 = const 2_i32
  using: 
  _649 = const {alloc171: *mut i32}
  using: 
  (*_649) = move _648
  using: _649@Mir(bb220[1]), _648@Mir(bb220[0])
  goto -> bb221
  using: 
bb221:
  _653 = const {alloc268: *mut i32}
  using: 
  _652 = (*_653)
  using: _653@Mir(bb221[0])
  _654 = const 3_i32
  using: 
  _651 = Eq(move _652, move _654)
  using: _652@Mir(bb221[1]), _654@Mir(bb221[2])
  switchInt(move _651) -> [0: bb222, otherwise: bb223]
  using: _651@Mir(bb221[3])
bb222:
  _650 = const false
  using: 
  goto -> bb224
  using: 
bb223:
  _657 = const {alloc267: *mut i32}
  using: 
  _656 = (*_657)
  using: _657@Mir(bb223[0])
  _658 = const 2_i32
  using: 
  _655 = Eq(move _656, move _658)
  using: _656@Mir(bb223[1]), _658@Mir(bb223[2])
  _650 = move _655
  using: _655@Mir(bb223[3])
  goto -> bb224
  using: 
bb224:
  switchInt(move _650) -> [0: bb227, otherwise: bb225]
  using: _650@Phi(bb224)
bb225:
  _661 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _660 = (*_661)
  using: _661@Mir(bb225[0])
  _665 = const b"%s: -c and -t cannot be used together.\n\x00"
  using: 
  _664 = &raw const (*_665)
  using: _665@Mir(bb225[2])
  _663 = move _664 as *const u8 (Pointer(ArrayToPointer))
  using: _664@Mir(bb225[3])
  _662 = move _663 as *const i8 (PtrToPtr)
  using: _663@Mir(bb225[4])
  _667 = const {alloc197: *mut *mut i8}
  using: 
  _666 = (*_667)
  using: _667@Mir(bb225[6])
  _659 = bzip2::fprintf(move _660, move _662, move _666) -> bb226
  using: _660@Mir(bb225[1]), _662@Mir(bb225[5]), _666@Mir(bb225[7])
bb226:
  _669 = const 1_i32
  using: 
  _668 = bzip2::exit(move _669)
  using: _669@Mir(bb226[0])
bb227:
  _673 = const {alloc267: *mut i32}
  using: 
  _672 = (*_673)
  using: _673@Mir(bb227[0])
  _674 = const 2_i32
  using: 
  _671 = Eq(move _672, move _674)
  using: _672@Mir(bb227[1]), _674@Mir(bb227[2])
  switchInt(move _671) -> [0: bb228, otherwise: bb229]
  using: _671@Mir(bb227[3])
bb228:
  _670 = const false
  using: 
  goto -> bb230
  using: 
bb229:
  _677 = const {alloc270: *mut i32}
  using: 
  _676 = (*_677)
  using: _677@Mir(bb229[0])
  _678 = const 0_i32
  using: 
  _675 = Eq(move _676, move _678)
  using: _676@Mir(bb229[1]), _678@Mir(bb229[2])
  _670 = move _675
  using: _675@Mir(bb229[3])
  goto -> bb230
  using: 
bb230:
  switchInt(move _670) -> [0: bb232, otherwise: bb231]
  using: _670@Phi(bb230)
bb231:
  _679 = const 1_i32
  using: 
  _680 = const {alloc267: *mut i32}
  using: 
  (*_680) = move _679
  using: _680@Mir(bb231[1]), _679@Mir(bb231[0])
  goto -> bb232
  using: 
bb232:
  _683 = const {alloc268: *mut i32}
  using: 
  _682 = (*_683)
  using: _683@Mir(bb232[0])
  _684 = const 1_i32
  using: 
  _681 = Ne(move _682, move _684)
  using: _682@Mir(bb232[1]), _684@Mir(bb232[2])
  switchInt(move _681) -> [0: bb234, otherwise: bb233]
  using: _681@Mir(bb232[3])
bb233:
  _685 = const 0_i32
  using: 
  _686 = const {alloc171: *mut i32}
  using: 
  (*_686) = move _685
  using: _686@Mir(bb233[1]), _685@Mir(bb233[0])
  goto -> bb234
  using: 
bb234:
  _689 = const {alloc267: *mut i32}
  using: 
  _688 = (*_689)
  using: _689@Mir(bb234[0])
  _690 = const 3_i32
  using: 
  _687 = Eq(move _688, move _690)
  using: _688@Mir(bb234[1]), _690@Mir(bb234[2])
  switchInt(move _687) -> [0: bb238, otherwise: bb235]
  using: _687@Mir(bb234[3])
bb235:
  _692 = const 2_i32
  using: 
  _694 = bzip2::mySignalCatcher as unsafe extern "C" fn(i32) (Pointer(ReifyFnPointer))
  using: 
  Deinit(_693)
  using: 
  ((_693 as Some).0: unsafe extern "C" fn(i32)) = move _694
  using: _694@Mir(bb235[1])
  discriminant(_693) = 1
  using: 
  _691 = bzip2::signal(move _692, move _693) -> bb236
  using: _692@Mir(bb235[0]), _693@Mir(bb235[2])
bb236:
  _696 = const 15_i32
  using: 
  _698 = bzip2::mySignalCatcher as unsafe extern "C" fn(i32) (Pointer(ReifyFnPointer))
  using: 
  Deinit(_697)
  using: 
  ((_697 as Some).0: unsafe extern "C" fn(i32)) = move _698
  using: _698@Mir(bb236[1])
  discriminant(_697) = 1
  using: 
  _695 = bzip2::signal(move _696, move _697) -> bb237
  using: _696@Mir(bb236[0]), _697@Mir(bb236[2])
bb237:
  _700 = const 1_i32
  using: 
  _702 = bzip2::mySignalCatcher as unsafe extern "C" fn(i32) (Pointer(ReifyFnPointer))
  using: 
  Deinit(_701)
  using: 
  ((_701 as Some).0: unsafe extern "C" fn(i32)) = move _702
  using: _702@Mir(bb237[1])
  discriminant(_701) = 1
  using: 
  _699 = bzip2::signal(move _700, move _701) -> bb238
  using: _700@Mir(bb237[0]), _701@Mir(bb237[2])
bb238:
  _705 = const {alloc268: *mut i32}
  using: 
  _704 = (*_705)
  using: _705@Mir(bb238[0])
  _706 = const 1_i32
  using: 
  _703 = Eq(move _704, move _706)
  using: _704@Mir(bb238[1]), _706@Mir(bb238[2])
  switchInt(move _703) -> [0: bb256, otherwise: bb239]
  using: _703@Mir(bb238[3])
bb239:
  _709 = const {alloc267: *mut i32}
  using: 
  _708 = (*_709)
  using: _709@Mir(bb239[0])
  _710 = const 1_i32
  using: 
  _707 = Eq(move _708, move _710)
  using: _708@Mir(bb239[1]), _710@Mir(bb239[2])
  switchInt(move _707) -> [0: bb241, otherwise: bb240]
  using: _707@Mir(bb239[3])
bb240:
  _712 = const {0x0 as *mut i8}
  using: 
  _711 = bzip2::compress(move _712) -> bb299
  using: _712@Mir(bb240[0])
bb241:
  _8 = const 1_u8
  using: 
  _713 = _6
  using: _6@Phi(bb46)
  _7 = move _713
  using: _713@Mir(bb241[1])
  goto -> bb242
  using: 
bb242:
  _716 = _7
  using: _7@Phi(bb242)
  _715 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _716) -> bb243
  using: _716@Mir(bb242[0])
bb243:
  _714 = Not(move _715)
  using: _715@Mir(bb242[1])
  switchInt(move _714) -> [0: bb255, otherwise: bb244]
  using: _714@Mir(bb243[0])
bb244:
  _720 = ((*_7).0: *mut i8)
  using: _7@Phi(bb242)
  _719 = move _720 as *const i8 (Pointer(MutToConstPointer))
  using: _720@Mir(bb244[0])
  _724 = const b"--\x00"
  using: 
  _723 = &raw const (*_724)
  using: _724@Mir(bb244[2])
  _722 = move _723 as *const u8 (Pointer(ArrayToPointer))
  using: _723@Mir(bb244[3])
  _721 = move _722 as *const i8 (PtrToPtr)
  using: _722@Mir(bb244[4])
  _718 = bzip2::strcmp(move _719, move _721) -> bb245
  using: _719@Mir(bb244[1]), _721@Mir(bb244[5])
bb245:
  _725 = const 0_i32
  using: 
  _717 = Eq(move _718, move _725)
  using: _718@Mir(bb244[6]), _725@Mir(bb245[0])
  switchInt(move _717) -> [0: bb247, otherwise: bb246]
  using: _717@Mir(bb245[1])
bb246:
  _8 = const 0_u8
  using: 
  goto -> bb254
  using: 
bb247:
  _732 = ((*_7).0: *mut i8)
  using: _7@Phi(bb242)
  _733 = const 0_isize
  using: 
  _731 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _732, move _733) -> bb251
  using: _732@Mir(bb247[0]), _733@Mir(bb247[1])
bb248:
  _727 = const false
  using: 
  goto -> bb250
  using: 
bb249:
  _737 = _8
  using: _8@Phi(bb242)
  _736 = move _737 as i32 (IntToInt)
  using: _737@Mir(bb249[0])
  _735 = Ne(move _736, const 0_i32)
  using: _736@Mir(bb249[1])
  _727 = move _735
  using: _735@Mir(bb249[2])
  goto -> bb250
  using: 
bb250:
  _726 = Not(move _727)
  using: _727@Phi(bb250)
  switchInt(move _726) -> [0: bb254, otherwise: bb252]
  using: _726@Mir(bb250[0])
bb251:
  _730 = (*_731)
  using: _731@Mir(bb247[2])
  _729 = move _730 as i32 (IntToInt)
  using: _730@Mir(bb251[0])
  _734 = const 45_i32
  using: 
  _728 = Eq(move _729, move _734)
  using: _729@Mir(bb251[1]), _734@Mir(bb251[2])
  switchInt(move _728) -> [0: bb248, otherwise: bb249]
  using: _728@Mir(bb251[3])
bb252:
  _738 = const {alloc271: *mut i32}
  using: 
  _739 = CheckedAdd((*_738), const 1_i32)
  using: _738@Mir(bb252[0])
  assert(!move (_739.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_738), const 1_i32) -> bb253
  using: _739@Entry, _738@Entry
bb253:
  (*_738) = move (_739.0: i32)
  using: _738@Mir(bb252[0]), _739@Mir(bb252[1])
  _741 = ((*_7).0: *mut i8)
  using: _7@Phi(bb242)
  _740 = bzip2::compress(move _741) -> bb254
  using: _741@Mir(bb253[1])
bb254:
  _742 = ((*_7).1: *mut bzip2::zzzz)
  using: _7@Phi(bb254)
  _7 = move _742
  using: _742@Mir(bb254[0])
  goto -> bb242
  using: 
bb255:
  _745 = _7
  using: _7@Phi(bb254)
  _744 = move _745 as usize (PointerExposeAddress)
  using: _745@Mir(bb255[0])
  _743 = Eq(move _744, const 0_usize)
  using: _744@Mir(bb255[1])
  assume(move _743)
  using: _743@Mir(bb255[2])
  goto -> bb299
  using: 
bb256:
  _748 = const {alloc268: *mut i32}
  using: 
  _747 = (*_748)
  using: _748@Mir(bb256[0])
  _749 = const 2_i32
  using: 
  _746 = Eq(move _747, move _749)
  using: _747@Mir(bb256[1]), _749@Mir(bb256[2])
  switchInt(move _746) -> [0: bb277, otherwise: bb257]
  using: _746@Mir(bb256[3])
bb257:
  _750 = const 0_i32
  using: 
  _751 = const {alloc433: *mut u8}
  using: 
  (*_751) = move _750 as u8 (IntToInt)
  using: _751@Mir(bb257[1]), _750@Mir(bb257[0])
  _754 = const {alloc267: *mut i32}
  using: 
  _753 = (*_754)
  using: _754@Mir(bb257[3])
  _755 = const 1_i32
  using: 
  _752 = Eq(move _753, move _755)
  using: _753@Mir(bb257[4]), _755@Mir(bb257[5])
  switchInt(move _752) -> [0: bb259, otherwise: bb258]
  using: _752@Mir(bb257[6])
bb258:
  _757 = const {0x0 as *mut i8}
  using: 
  _756 = bzip2::uncompress(move _757) -> bb274
  using: _757@Mir(bb258[0])
bb259:
  _8 = const 1_u8
  using: 
  _758 = _6
  using: _6@Phi(bb46)
  _7 = move _758
  using: _758@Mir(bb259[1])
  goto -> bb260
  using: 
bb260:
  _761 = _7
  using: _7@Phi(bb260)
  _760 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _761) -> bb261
  using: _761@Mir(bb260[0])
bb261:
  _759 = Not(move _760)
  using: _760@Mir(bb260[1])
  switchInt(move _759) -> [0: bb273, otherwise: bb262]
  using: _759@Mir(bb261[0])
bb262:
  _765 = ((*_7).0: *mut i8)
  using: _7@Phi(bb260)
  _764 = move _765 as *const i8 (Pointer(MutToConstPointer))
  using: _765@Mir(bb262[0])
  _769 = const b"--\x00"
  using: 
  _768 = &raw const (*_769)
  using: _769@Mir(bb262[2])
  _767 = move _768 as *const u8 (Pointer(ArrayToPointer))
  using: _768@Mir(bb262[3])
  _766 = move _767 as *const i8 (PtrToPtr)
  using: _767@Mir(bb262[4])
  _763 = bzip2::strcmp(move _764, move _766) -> bb263
  using: _764@Mir(bb262[1]), _766@Mir(bb262[5])
bb263:
  _770 = const 0_i32
  using: 
  _762 = Eq(move _763, move _770)
  using: _763@Mir(bb262[6]), _770@Mir(bb263[0])
  switchInt(move _762) -> [0: bb265, otherwise: bb264]
  using: _762@Mir(bb263[1])
bb264:
  _8 = const 0_u8
  using: 
  goto -> bb272
  using: 
bb265:
  _777 = ((*_7).0: *mut i8)
  using: _7@Phi(bb260)
  _778 = const 0_isize
  using: 
  _776 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _777, move _778) -> bb269
  using: _777@Mir(bb265[0]), _778@Mir(bb265[1])
bb266:
  _772 = const false
  using: 
  goto -> bb268
  using: 
bb267:
  _782 = _8
  using: _8@Phi(bb260)
  _781 = move _782 as i32 (IntToInt)
  using: _782@Mir(bb267[0])
  _780 = Ne(move _781, const 0_i32)
  using: _781@Mir(bb267[1])
  _772 = move _780
  using: _780@Mir(bb267[2])
  goto -> bb268
  using: 
bb268:
  _771 = Not(move _772)
  using: _772@Phi(bb268)
  switchInt(move _771) -> [0: bb272, otherwise: bb270]
  using: _771@Mir(bb268[0])
bb269:
  _775 = (*_776)
  using: _776@Mir(bb265[2])
  _774 = move _775 as i32 (IntToInt)
  using: _775@Mir(bb269[0])
  _779 = const 45_i32
  using: 
  _773 = Eq(move _774, move _779)
  using: _774@Mir(bb269[1]), _779@Mir(bb269[2])
  switchInt(move _773) -> [0: bb266, otherwise: bb267]
  using: _773@Mir(bb269[3])
bb270:
  _783 = const {alloc271: *mut i32}
  using: 
  _784 = CheckedAdd((*_783), const 1_i32)
  using: _783@Mir(bb270[0])
  assert(!move (_784.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_783), const 1_i32) -> bb271
  using: _784@Entry, _783@Entry
bb271:
  (*_783) = move (_784.0: i32)
  using: _783@Mir(bb270[0]), _784@Mir(bb270[1])
  _786 = ((*_7).0: *mut i8)
  using: _7@Phi(bb260)
  _785 = bzip2::uncompress(move _786) -> bb272
  using: _786@Mir(bb271[1])
bb272:
  _787 = ((*_7).1: *mut bzip2::zzzz)
  using: _7@Phi(bb272)
  _7 = move _787
  using: _787@Mir(bb272[0])
  goto -> bb260
  using: 
bb273:
  _790 = _7
  using: _7@Phi(bb272)
  _789 = move _790 as usize (PointerExposeAddress)
  using: _790@Mir(bb273[0])
  _788 = Eq(move _789, const 0_usize)
  using: _789@Mir(bb273[1])
  assume(move _788)
  using: _788@Mir(bb273[2])
  goto -> bb274
  using: 
bb274:
  _792 = const {alloc433: *mut u8}
  using: 
  _791 = (*_792)
  using: _792@Mir(bb274[0])
  switchInt(move _791) -> [0: bb299, otherwise: bb275]
  using: _791@Mir(bb274[1])
bb275:
  _794 = const 2_i32
  using: 
  _793 = bzip2::setExit(move _794) -> bb276
  using: _794@Mir(bb275[0])
bb276:
  _797 = const {alloc256: *mut i32}
  using: 
  _796 = (*_797)
  using: _797@Mir(bb276[0])
  _795 = bzip2::exit(move _796)
  using: _796@Mir(bb276[1])
bb277:
  _798 = const 0_i32
  using: 
  _799 = const {alloc474: *mut u8}
  using: 
  (*_799) = move _798 as u8 (IntToInt)
  using: _799@Mir(bb277[1]), _798@Mir(bb277[0])
  _802 = const {alloc267: *mut i32}
  using: 
  _801 = (*_802)
  using: _802@Mir(bb277[3])
  _803 = const 1_i32
  using: 
  _800 = Eq(move _801, move _803)
  using: _801@Mir(bb277[4]), _803@Mir(bb277[5])
  switchInt(move _800) -> [0: bb279, otherwise: bb278]
  using: _800@Mir(bb277[6])
bb278:
  _805 = const {0x0 as *mut i8}
  using: 
  _804 = bzip2::testf(move _805) -> bb294
  using: _805@Mir(bb278[0])
bb279:
  _8 = const 1_u8
  using: 
  _806 = _6
  using: _6@Phi(bb274)
  _7 = move _806
  using: _806@Mir(bb279[1])
  goto -> bb280
  using: 
bb280:
  _809 = _7
  using: _7@Phi(bb280)
  _808 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _809) -> bb281
  using: _809@Mir(bb280[0])
bb281:
  _807 = Not(move _808)
  using: _808@Mir(bb280[1])
  switchInt(move _807) -> [0: bb293, otherwise: bb282]
  using: _807@Mir(bb281[0])
bb282:
  _813 = ((*_7).0: *mut i8)
  using: _7@Phi(bb280)
  _812 = move _813 as *const i8 (Pointer(MutToConstPointer))
  using: _813@Mir(bb282[0])
  _817 = const b"--\x00"
  using: 
  _816 = &raw const (*_817)
  using: _817@Mir(bb282[2])
  _815 = move _816 as *const u8 (Pointer(ArrayToPointer))
  using: _816@Mir(bb282[3])
  _814 = move _815 as *const i8 (PtrToPtr)
  using: _815@Mir(bb282[4])
  _811 = bzip2::strcmp(move _812, move _814) -> bb283
  using: _812@Mir(bb282[1]), _814@Mir(bb282[5])
bb283:
  _818 = const 0_i32
  using: 
  _810 = Eq(move _811, move _818)
  using: _811@Mir(bb282[6]), _818@Mir(bb283[0])
  switchInt(move _810) -> [0: bb285, otherwise: bb284]
  using: _810@Mir(bb283[1])
bb284:
  _8 = const 0_u8
  using: 
  goto -> bb292
  using: 
bb285:
  _825 = ((*_7).0: *mut i8)
  using: _7@Phi(bb280)
  _826 = const 0_isize
  using: 
  _824 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _825, move _826) -> bb289
  using: _825@Mir(bb285[0]), _826@Mir(bb285[1])
bb286:
  _820 = const false
  using: 
  goto -> bb288
  using: 
bb287:
  _830 = _8
  using: _8@Phi(bb280)
  _829 = move _830 as i32 (IntToInt)
  using: _830@Mir(bb287[0])
  _828 = Ne(move _829, const 0_i32)
  using: _829@Mir(bb287[1])
  _820 = move _828
  using: _828@Mir(bb287[2])
  goto -> bb288
  using: 
bb288:
  _819 = Not(move _820)
  using: _820@Phi(bb288)
  switchInt(move _819) -> [0: bb292, otherwise: bb290]
  using: _819@Mir(bb288[0])
bb289:
  _823 = (*_824)
  using: _824@Mir(bb285[2])
  _822 = move _823 as i32 (IntToInt)
  using: _823@Mir(bb289[0])
  _827 = const 45_i32
  using: 
  _821 = Eq(move _822, move _827)
  using: _822@Mir(bb289[1]), _827@Mir(bb289[2])
  switchInt(move _821) -> [0: bb286, otherwise: bb287]
  using: _821@Mir(bb289[3])
bb290:
  _831 = const {alloc271: *mut i32}
  using: 
  _832 = CheckedAdd((*_831), const 1_i32)
  using: _831@Mir(bb290[0])
  assert(!move (_832.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_831), const 1_i32) -> bb291
  using: _832@Entry, _831@Entry
bb291:
  (*_831) = move (_832.0: i32)
  using: _831@Mir(bb290[0]), _832@Mir(bb290[1])
  _834 = ((*_7).0: *mut i8)
  using: _7@Phi(bb280)
  _833 = bzip2::testf(move _834) -> bb292
  using: _834@Mir(bb291[1])
bb292:
  _835 = ((*_7).1: *mut bzip2::zzzz)
  using: _7@Phi(bb292)
  _7 = move _835
  using: _835@Mir(bb292[0])
  goto -> bb280
  using: 
bb293:
  _838 = _7
  using: _7@Phi(bb292)
  _837 = move _838 as usize (PointerExposeAddress)
  using: _838@Mir(bb293[0])
  _836 = Eq(move _837, const 0_usize)
  using: _837@Mir(bb293[1])
  assume(move _836)
  using: _836@Mir(bb293[2])
  goto -> bb294
  using: 
bb294:
  _840 = const {alloc474: *mut u8}
  using: 
  _839 = (*_840)
  using: _840@Mir(bb294[0])
  switchInt(move _839) -> [0: bb299, otherwise: bb295]
  using: _839@Mir(bb294[1])
bb295:
  _842 = const {alloc196: *mut u8}
  using: 
  _841 = (*_842)
  using: _842@Mir(bb295[0])
  switchInt(move _841) -> [0: bb297, otherwise: bb296]
  using: _841@Mir(bb295[1])
bb296:
  _845 = const {alloc174: *mut *mut blocksort::__sFILE}
  using: 
  _844 = (*_845)
  using: _845@Mir(bb296[0])
  _849 = const b"\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n\x00"
  using: 
  _848 = &raw const (*_849)
  using: _849@Mir(bb296[2])
  _847 = move _848 as *const u8 (Pointer(ArrayToPointer))
  using: _848@Mir(bb296[3])
  _846 = move _847 as *const i8 (PtrToPtr)
  using: _847@Mir(bb296[4])
  _843 = bzip2::fprintf(move _844, move _846) -> bb297
  using: _844@Mir(bb296[1]), _846@Mir(bb296[5])
bb297:
  _851 = const 2_i32
  using: 
  _850 = bzip2::setExit(move _851) -> bb298
  using: _851@Mir(bb297[0])
bb298:
  _854 = const {alloc256: *mut i32}
  using: 
  _853 = (*_854)
  using: _854@Mir(bb298[0])
  _852 = bzip2::exit(move _853)
  using: _853@Mir(bb298[1])
bb299:
  _855 = _6
  using: _6@Phi(bb299)
  _7 = move _855
  using: _855@Mir(bb299[0])
  goto -> bb300
  using: 
bb300:
  _858 = _7
  using: _7@Phi(bb300)
  _857 = std::ptr::mut_ptr::<impl *mut bzip2::zzzz>::is_null(move _858) -> bb301
  using: _858@Mir(bb300[0])
bb301:
  _856 = Not(move _857)
  using: _857@Mir(bb300[1])
  switchInt(move _856) -> [0: bb308, otherwise: bb302]
  using: _856@Mir(bb301[0])
bb302:
  _859 = ((*_7).1: *mut bzip2::zzzz)
  using: _7@Phi(bb300)
  _862 = ((*_7).0: *mut i8)
  using: _7@Phi(bb300)
  _861 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _862) -> bb303
  using: _862@Mir(bb302[1])
bb303:
  _860 = Not(move _861)
  using: _861@Mir(bb302[2])
  switchInt(move _860) -> [0: bb305, otherwise: bb304]
  using: _860@Mir(bb303[0])
bb304:
  _865 = ((*_7).0: *mut i8)
  using: _7@Phi(bb300)
  _864 = move _865 as *mut std::ffi::c_void (PtrToPtr)
  using: _865@Mir(bb304[0])
  _863 = bzip2::free(move _864) -> bb306
  using: _864@Mir(bb304[1])
bb305:
  _868 = ((*_7).0: *mut i8)
  using: _7@Phi(bb300)
  _867 = move _868 as usize (PointerExposeAddress)
  using: _868@Mir(bb305[0])
  _866 = Eq(move _867, const 0_usize)
  using: _867@Mir(bb305[1])
  assume(move _866)
  using: _866@Mir(bb305[2])
  goto -> bb306
  using: 
bb306:
  _871 = _7
  using: _7@Phi(bb306)
  _870 = move _871 as *mut std::ffi::c_void (PtrToPtr)
  using: _871@Mir(bb306[0])
  _869 = bzip2::free(move _870) -> bb307
  using: _870@Mir(bb306[1])
bb307:
  _872 = _859
  using: _859@Mir(bb302[0])
  _7 = move _872
  using: _872@Mir(bb307[0])
  goto -> bb300
  using: 
bb308:
  _875 = _7
  using: _7@Phi(bb306)
  _874 = move _875 as usize (PointerExposeAddress)
  using: _875@Mir(bb308[0])
  _873 = Eq(move _874, const 0_usize)
  using: _874@Mir(bb308[1])
  assume(move _873)
  using: _873@Mir(bb308[2])
  _876 = const {alloc256: *mut i32}
  using: 
  _0 = (*_876)
  using: _876@Mir(bb308[4])
  return
  using: _0@Mir(bb308[5])
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:2746:8: 2746:38 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:2756:12: 2756:42 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:2754:12: 2754:41 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:2752:12: 2752:43 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:2750:12: 2750:42 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2.rs:2748:12: 2748:43 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_68) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_68) = 1 is ignored
rewrite call bzip2::signal @ workspace/bzip2/rust/bzip2.rs:2779:5: 2781:63 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_72) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_72) = 1 is ignored
rewrite call bzip2::signal @ workspace/bzip2/rust/bzip2.rs:2782:5: 2784:63 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2792:24: 2792:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2794:43: 2794:84 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2797:43: 2797:84 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2801:28: 2801:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2803:19: 2803:28 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2817:45: 2817:63 (#0) by default
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2826:12: 2826:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2829:33: 2829:74 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:2833:34: 2833:52 (#0) by default
rewrite call bzip2::strlen @ workspace/bzip2/rust/bzip2.rs:2834:35: 2834:53 (#0) by default
rewrite call bzip2::strstr @ workspace/bzip2/rust/bzip2.rs:2846:9: 2847:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strstr @ workspace/bzip2/rust/bzip2.rs:2848:13: 2849:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strstr @ workspace/bzip2/rust/bzip2.rs:2853:9: 2854:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strstr @ workspace/bzip2/rust/bzip2.rs:2861:13: 2862:76 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strstr @ workspace/bzip2/rust/bzip2.rs:2858:13: 2859:76 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strstr @ workspace/bzip2/rust/bzip2.rs:2855:13: 2856:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2873:12: 2873:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2877:24: 2877:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2879:28: 2879:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2882:31: 2882:49 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:2884:35: 2884:53 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:2906:25: 2909:44 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:2904:47: 2904:77 (#0) by default
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:2911:25: 2911:55 (#0) by default
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2922:12: 2922:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2926:12: 2927:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2930:19: 2932:58 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2934:19: 2936:58 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2938:19: 2939:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2942:19: 2943:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2946:19: 2947:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2950:19: 2951:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2954:19: 2955:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2958:19: 2959:87 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2962:19: 2963:87 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2966:19: 2968:58 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2970:19: 2972:58 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2974:19: 2976:58 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2978:19: 2979:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2982:19: 2983:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2986:19: 2987:87 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:2990:19: 2991:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:2994:13: 2994:43 (#0) by default
rewrite call bzip2::strncmp @ workspace/bzip2/rust/bzip2.rs:2996:16: 2998:74 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:3000:17: 3002:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:3004:17: 3004:47 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:3015:9: 3017:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:3018:9: 3018:39 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_693) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_693) = 1 is ignored
rewrite call bzip2::signal @ workspace/bzip2/rust/bzip2.rs:3025:9: 3027:67 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_697) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_697) = 1 is ignored
rewrite call bzip2::signal @ workspace/bzip2/rust/bzip2.rs:3028:9: 3030:67 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_701) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_701) = 1 is ignored
rewrite call bzip2::signal @ workspace/bzip2/rust/bzip2.rs:3031:9: 3033:67 (#0) by default
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:3042:20: 3043:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:3046:41: 3046:82 (#0) by default
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:3063:20: 3064:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:3067:41: 3067:82 (#0) by default
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:3076:68: 3076:83 (#0) by default
rewrite call bzip2::strcmp @ workspace/bzip2/rust/bzip2.rs:3085:20: 3086:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2.rs:3089:41: 3089:82 (#0) by default
rewrite call bzip2::fprintf @ workspace/bzip2/rust/bzip2.rs:3100:17: 3102:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2::exit @ workspace/bzip2/rust/bzip2.rs:3105:13: 3105:28 (#0) by default
@DefId(0:290 ~ c2rust_lib[1043]::bzip2recover::readError)
bb0:
  _3 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _2 = (*_3)
  using: _3@Mir(bb0[0])
  _7 = const b"%s: I/O error reading `%s\', possible reason follows.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[3])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[4])
  _11 = const {alloc577: *mut [i8; 2000]}
  using: 
  _10 = &mut (*_11)
  using: _11@Mir(bb0[6])
  _9 = move _10 as &mut [i8] (Pointer(Unsize))
  using: _10@Mir(bb0[7])
  _8 = core::slice::<impl [i8]>::as_mut_ptr(move _9) -> bb1
  using: _9@Mir(bb0[8])
bb1:
  _15 = const {alloc578: *mut [i8; 2000]}
  using: 
  _14 = &mut (*_15)
  using: _15@Mir(bb1[0])
  _13 = move _14 as &mut [i8] (Pointer(Unsize))
  using: _14@Mir(bb1[1])
  _12 = core::slice::<impl [i8]>::as_mut_ptr(move _13) -> bb2
  using: _13@Mir(bb1[2])
bb2:
  _1 = bzip2recover::fprintf(move _2, move _4, move _8, move _12) -> bb3
  using: _2@Mir(bb0[1]), _4@Mir(bb0[5]), _8@Mir(bb0[9]), _12@Mir(bb1[3])
bb3:
  _21 = const {alloc577: *mut [i8; 2000]}
  using: 
  _20 = &mut (*_21)
  using: _21@Mir(bb3[0])
  _19 = move _20 as &mut [i8] (Pointer(Unsize))
  using: _20@Mir(bb3[1])
  _18 = core::slice::<impl [i8]>::as_mut_ptr(move _19) -> bb4
  using: _19@Mir(bb3[2])
bb4:
  _17 = move _18 as *const i8 (Pointer(MutToConstPointer))
  using: _18@Mir(bb3[3])
  _16 = bzip2recover::perror(move _17) -> bb5
  using: _17@Mir(bb4[0])
bb5:
  _24 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _23 = (*_24)
  using: _24@Mir(bb5[0])
  _28 = const b"%s: warning: output file(s) may be incomplete.\n\x00"
  using: 
  _27 = &raw const (*_28)
  using: _28@Mir(bb5[2])
  _26 = move _27 as *const u8 (Pointer(ArrayToPointer))
  using: _27@Mir(bb5[3])
  _25 = move _26 as *const i8 (PtrToPtr)
  using: _26@Mir(bb5[4])
  _32 = const {alloc577: *mut [i8; 2000]}
  using: 
  _31 = &mut (*_32)
  using: _32@Mir(bb5[6])
  _30 = move _31 as &mut [i8] (Pointer(Unsize))
  using: _31@Mir(bb5[7])
  _29 = core::slice::<impl [i8]>::as_mut_ptr(move _30) -> bb6
  using: _30@Mir(bb5[8])
bb6:
  _22 = bzip2recover::fprintf(move _23, move _25, move _29) -> bb7
  using: _23@Mir(bb5[1]), _25@Mir(bb5[5]), _29@Mir(bb5[9])
bb7:
  _34 = const 1_i32
  using: 
  _33 = bzip2recover::exit(move _34)
  using: _34@Mir(bb7[0])
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:112:5: 115:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::perror @ workspace/bzip2/rust/bzip2recover.rs:116:5: 116:34 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:117:5: 119:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:120:5: 120:35 (#0) by default
@DefId(0:291 ~ c2rust_lib[1043]::bzip2recover::writeError)
bb0:
  _3 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _2 = (*_3)
  using: _3@Mir(bb0[0])
  _7 = const b"%s: I/O error reading `%s\', possible reason follows.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[3])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[4])
  _11 = const {alloc577: *mut [i8; 2000]}
  using: 
  _10 = &mut (*_11)
  using: _11@Mir(bb0[6])
  _9 = move _10 as &mut [i8] (Pointer(Unsize))
  using: _10@Mir(bb0[7])
  _8 = core::slice::<impl [i8]>::as_mut_ptr(move _9) -> bb1
  using: _9@Mir(bb0[8])
bb1:
  _15 = const {alloc578: *mut [i8; 2000]}
  using: 
  _14 = &mut (*_15)
  using: _15@Mir(bb1[0])
  _13 = move _14 as &mut [i8] (Pointer(Unsize))
  using: _14@Mir(bb1[1])
  _12 = core::slice::<impl [i8]>::as_mut_ptr(move _13) -> bb2
  using: _13@Mir(bb1[2])
bb2:
  _1 = bzip2recover::fprintf(move _2, move _4, move _8, move _12) -> bb3
  using: _2@Mir(bb0[1]), _4@Mir(bb0[5]), _8@Mir(bb0[9]), _12@Mir(bb1[3])
bb3:
  _21 = const {alloc577: *mut [i8; 2000]}
  using: 
  _20 = &mut (*_21)
  using: _21@Mir(bb3[0])
  _19 = move _20 as &mut [i8] (Pointer(Unsize))
  using: _20@Mir(bb3[1])
  _18 = core::slice::<impl [i8]>::as_mut_ptr(move _19) -> bb4
  using: _19@Mir(bb3[2])
bb4:
  _17 = move _18 as *const i8 (Pointer(MutToConstPointer))
  using: _18@Mir(bb3[3])
  _16 = bzip2recover::perror(move _17) -> bb5
  using: _17@Mir(bb4[0])
bb5:
  _24 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _23 = (*_24)
  using: _24@Mir(bb5[0])
  _28 = const b"%s: warning: output file(s) may be incomplete.\n\x00"
  using: 
  _27 = &raw const (*_28)
  using: _28@Mir(bb5[2])
  _26 = move _27 as *const u8 (Pointer(ArrayToPointer))
  using: _27@Mir(bb5[3])
  _25 = move _26 as *const i8 (PtrToPtr)
  using: _26@Mir(bb5[4])
  _32 = const {alloc577: *mut [i8; 2000]}
  using: 
  _31 = &mut (*_32)
  using: _32@Mir(bb5[6])
  _30 = move _31 as &mut [i8] (Pointer(Unsize))
  using: _31@Mir(bb5[7])
  _29 = core::slice::<impl [i8]>::as_mut_ptr(move _30) -> bb6
  using: _30@Mir(bb5[8])
bb6:
  _22 = bzip2recover::fprintf(move _23, move _25, move _29) -> bb7
  using: _23@Mir(bb5[1]), _25@Mir(bb5[5]), _29@Mir(bb5[9])
bb7:
  _34 = const 1_i32
  using: 
  _33 = bzip2recover::exit(move _34)
  using: _34@Mir(bb7[0])
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:124:5: 127:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::perror @ workspace/bzip2/rust/bzip2recover.rs:128:5: 128:34 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:129:5: 131:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:132:5: 132:35 (#0) by default
@DefId(0:292 ~ c2rust_lib[1043]::bzip2recover::mallocFail)
bb0:
  _4 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _3 = (*_4)
  using: _4@Mir(bb0[0])
  _8 = const b"%s: malloc failed on request for %d bytes.\n\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _12 = const {alloc577: *mut [i8; 2000]}
  using: 
  _11 = &mut (*_12)
  using: _12@Mir(bb0[6])
  _10 = move _11 as &mut [i8] (Pointer(Unsize))
  using: _11@Mir(bb0[7])
  _9 = core::slice::<impl [i8]>::as_mut_ptr(move _10) -> bb1
  using: _10@Mir(bb0[8])
bb1:
  _13 = _1
  using: _1@Entry
  _2 = bzip2recover::fprintf(move _3, move _5, move _9, move _13) -> bb2
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5]), _9@Mir(bb0[9]), _13@Mir(bb1[0])
bb2:
  _16 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _15 = (*_16)
  using: _16@Mir(bb2[0])
  _20 = const b"%s: warning: output file(s) may be incomplete.\n\x00"
  using: 
  _19 = &raw const (*_20)
  using: _20@Mir(bb2[2])
  _18 = move _19 as *const u8 (Pointer(ArrayToPointer))
  using: _19@Mir(bb2[3])
  _17 = move _18 as *const i8 (PtrToPtr)
  using: _18@Mir(bb2[4])
  _24 = const {alloc577: *mut [i8; 2000]}
  using: 
  _23 = &mut (*_24)
  using: _24@Mir(bb2[6])
  _22 = move _23 as &mut [i8] (Pointer(Unsize))
  using: _23@Mir(bb2[7])
  _21 = core::slice::<impl [i8]>::as_mut_ptr(move _22) -> bb3
  using: _22@Mir(bb2[8])
bb3:
  _14 = bzip2recover::fprintf(move _15, move _17, move _21) -> bb4
  using: _15@Mir(bb2[1]), _17@Mir(bb2[5]), _21@Mir(bb2[9])
bb4:
  _26 = const 1_i32
  using: 
  _25 = bzip2recover::exit(move _26)
  using: _26@Mir(bb4[0])
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:136:5: 138:74 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:139:5: 141:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:142:5: 142:35 (#0) by default
@DefId(0:293 ~ c2rust_lib[1043]::bzip2recover::tooManyBlocks)
bb0:
  _4 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _3 = (*_4)
  using: _4@Mir(bb0[0])
  _8 = const b"%s: `%s\' appears to contain more than %d blocks\n\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _12 = const {alloc577: *mut [i8; 2000]}
  using: 
  _11 = &mut (*_12)
  using: _12@Mir(bb0[6])
  _10 = move _11 as &mut [i8] (Pointer(Unsize))
  using: _11@Mir(bb0[7])
  _9 = core::slice::<impl [i8]>::as_mut_ptr(move _10) -> bb1
  using: _10@Mir(bb0[8])
bb1:
  _16 = const {alloc578: *mut [i8; 2000]}
  using: 
  _15 = &mut (*_16)
  using: _16@Mir(bb1[0])
  _14 = move _15 as &mut [i8] (Pointer(Unsize))
  using: _15@Mir(bb1[1])
  _13 = core::slice::<impl [i8]>::as_mut_ptr(move _14) -> bb2
  using: _14@Mir(bb1[2])
bb2:
  _17 = _1
  using: _1@Entry
  _2 = bzip2recover::fprintf(move _3, move _5, move _9, move _13, move _17) -> bb3
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5]), _9@Mir(bb0[9]), _13@Mir(bb1[3]), _17@Mir(bb2[0])
bb3:
  _20 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _19 = (*_20)
  using: _20@Mir(bb3[0])
  _24 = const b"%s: and cannot be handled.  To fix, increase\n\x00"
  using: 
  _23 = &raw const (*_24)
  using: _24@Mir(bb3[2])
  _22 = move _23 as *const u8 (Pointer(ArrayToPointer))
  using: _23@Mir(bb3[3])
  _21 = move _22 as *const i8 (PtrToPtr)
  using: _22@Mir(bb3[4])
  _28 = const {alloc577: *mut [i8; 2000]}
  using: 
  _27 = &mut (*_28)
  using: _28@Mir(bb3[6])
  _26 = move _27 as &mut [i8] (Pointer(Unsize))
  using: _27@Mir(bb3[7])
  _25 = core::slice::<impl [i8]>::as_mut_ptr(move _26) -> bb4
  using: _26@Mir(bb3[8])
bb4:
  _18 = bzip2recover::fprintf(move _19, move _21, move _25) -> bb5
  using: _19@Mir(bb3[1]), _21@Mir(bb3[5]), _25@Mir(bb3[9])
bb5:
  _31 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _30 = (*_31)
  using: _31@Mir(bb5[0])
  _35 = const b"%s: BZ_MAX_HANDLED_BLOCKS in bzip2recover.c, and recompile.\n\x00"
  using: 
  _34 = &raw const (*_35)
  using: _35@Mir(bb5[2])
  _33 = move _34 as *const u8 (Pointer(ArrayToPointer))
  using: _34@Mir(bb5[3])
  _32 = move _33 as *const i8 (PtrToPtr)
  using: _33@Mir(bb5[4])
  _39 = const {alloc577: *mut [i8; 2000]}
  using: 
  _38 = &mut (*_39)
  using: _39@Mir(bb5[6])
  _37 = move _38 as &mut [i8] (Pointer(Unsize))
  using: _38@Mir(bb5[7])
  _36 = core::slice::<impl [i8]>::as_mut_ptr(move _37) -> bb6
  using: _37@Mir(bb5[8])
bb6:
  _29 = bzip2recover::fprintf(move _30, move _32, move _36) -> bb7
  using: _30@Mir(bb5[1]), _32@Mir(bb5[5]), _36@Mir(bb5[9])
bb7:
  _41 = const 1_i32
  using: 
  _40 = bzip2recover::exit(move _41)
  using: _41@Mir(bb7[0])
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:146:5: 149:57 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:150:5: 152:71 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:153:5: 155:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:156:5: 156:35 (#0) by default
@DefId(0:294 ~ c2rust_lib[1043]::bzip2recover::bsOpenReadStream)
bb0:
  _4 = std::mem::size_of::<bzip2recover::BitStream>() -> bb1
  using: 
bb1:
  _3 = move _4 as u64 (IntToInt)
  using: _4@Mir(bb0[0])
  _2 = bzip2recover::malloc(move _3) -> bb2
  using: _3@Mir(bb1[0])
bb2:
  _0 = move _2 as *mut bzip2recover::BitStream (PtrToPtr)
  using: _2@Mir(bb1[1])
  _6 = _0
  using: _0@Mir(bb2[0])
  _5 = std::ptr::mut_ptr::<impl *mut bzip2recover::BitStream>::is_null(move _6) -> bb3
  using: _6@Mir(bb2[1])
bb3:
  switchInt(move _5) -> [0: bb6, otherwise: bb4]
  using: _5@Mir(bb2[2])
bb4:
  _9 = _0
  using: _0@Mir(bb2[0])
  _8 = move _9 as usize (PointerExposeAddress)
  using: _9@Mir(bb4[0])
  _7 = Eq(move _8, const 0_usize)
  using: _8@Mir(bb4[1])
  assume(move _7)
  using: _7@Mir(bb4[2])
  _13 = std::mem::size_of::<bzip2recover::BitStream>() -> bb5
  using: 
bb5:
  _12 = move _13 as u64 (IntToInt)
  using: _13@Mir(bb4[4])
  _11 = move _12 as i32 (IntToInt)
  using: _12@Mir(bb5[0])
  _10 = bzip2recover::mallocFail(move _11) -> bb6
  using: _11@Mir(bb5[1])
bb6:
  _14 = _1
  using: _1@Entry
  ((*_0).0: *mut blocksort::__sFILE) = move _14
  using: _0@Phi(bb6), _14@Mir(bb6[0])
  _15 = const 0_i32
  using: 
  ((*_0).1: i32) = move _15
  using: _0@Phi(bb6), _15@Mir(bb6[2])
  _16 = const 0_i32
  using: 
  ((*_0).2: i32) = move _16
  using: _0@Phi(bb6), _16@Mir(bb6[4])
  _17 = const 114_i32
  using: 
  ((*_0).3: i8) = move _17 as i8 (IntToInt)
  using: _0@Phi(bb6), _17@Mir(bb6[6])
  return
  using: _0@Phi(bb6)
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2recover.rs:162:16: 162:50 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2recover.rs:165:20: 165:54 (#0) by default
@DefId(0:295 ~ c2rust_lib[1043]::bzip2recover::bsOpenWriteStream)
bb0:
  _4 = std::mem::size_of::<bzip2recover::BitStream>() -> bb1
  using: 
bb1:
  _3 = move _4 as u64 (IntToInt)
  using: _4@Mir(bb0[0])
  _2 = bzip2recover::malloc(move _3) -> bb2
  using: _3@Mir(bb1[0])
bb2:
  _0 = move _2 as *mut bzip2recover::BitStream (PtrToPtr)
  using: _2@Mir(bb1[1])
  _6 = _0
  using: _0@Mir(bb2[0])
  _5 = std::ptr::mut_ptr::<impl *mut bzip2recover::BitStream>::is_null(move _6) -> bb3
  using: _6@Mir(bb2[1])
bb3:
  switchInt(move _5) -> [0: bb6, otherwise: bb4]
  using: _5@Mir(bb2[2])
bb4:
  _9 = _0
  using: _0@Mir(bb2[0])
  _8 = move _9 as usize (PointerExposeAddress)
  using: _9@Mir(bb4[0])
  _7 = Eq(move _8, const 0_usize)
  using: _8@Mir(bb4[1])
  assume(move _7)
  using: _7@Mir(bb4[2])
  _13 = std::mem::size_of::<bzip2recover::BitStream>() -> bb5
  using: 
bb5:
  _12 = move _13 as u64 (IntToInt)
  using: _13@Mir(bb4[4])
  _11 = move _12 as i32 (IntToInt)
  using: _12@Mir(bb5[0])
  _10 = bzip2recover::mallocFail(move _11) -> bb6
  using: _11@Mir(bb5[1])
bb6:
  _14 = _1
  using: _1@Entry
  ((*_0).0: *mut blocksort::__sFILE) = move _14
  using: _0@Phi(bb6), _14@Mir(bb6[0])
  _15 = const 0_i32
  using: 
  ((*_0).1: i32) = move _15
  using: _0@Phi(bb6), _15@Mir(bb6[2])
  _16 = const 0_i32
  using: 
  ((*_0).2: i32) = move _16
  using: _0@Phi(bb6), _16@Mir(bb6[4])
  _17 = const 119_i32
  using: 
  ((*_0).3: i8) = move _17 as i8 (IntToInt)
  using: _0@Phi(bb6), _17@Mir(bb6[6])
  return
  using: _0@Phi(bb6)
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2recover.rs:178:16: 178:50 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2recover.rs:181:20: 181:54 (#0) by default
@DefId(0:296 ~ c2rust_lib[1043]::bzip2recover::bsPutBit)
bb0:
  _4 = ((*_1).2: i32)
  using: _1@Entry
  _5 = const 8_i32
  using: 
  _3 = Eq(move _4, move _5)
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1])
  switchInt(move _3) -> [0: bb6, otherwise: bb1]
  using: _3@Mir(bb0[2])
bb1:
  _9 = ((*_1).1: i32)
  using: _1@Entry
  _8 = move _9 as u8 (IntToInt)
  using: _9@Mir(bb1[0])
  _7 = move _8 as i32 (IntToInt)
  using: _8@Mir(bb1[1])
  _10 = ((*_1).0: *mut blocksort::__sFILE)
  using: _1@Entry
  _6 = bzip2recover::putc(move _7, move _10) -> bb2
  using: _7@Mir(bb1[2]), _10@Mir(bb1[3])
bb2:
  _12 = _6
  using: _6@Mir(bb1[4])
  _13 = const -1_i32
  using: 
  _11 = Eq(move _12, move _13)
  using: _12@Mir(bb2[0]), _13@Mir(bb2[1])
  switchInt(move _11) -> [0: bb4, otherwise: bb3]
  using: _11@Mir(bb2[2])
bb3:
  _14 = bzip2recover::writeError() -> bb4
  using: 
bb4:
  _17 = const {alloc600: *mut u64}
  using: 
  _16 = (*_17)
  using: _17@Mir(bb4[0])
  _15 = core::num::<impl u64>::wrapping_add(move _16, const 1_u64) -> bb5
  using: _16@Mir(bb4[1])
bb5:
  _18 = const {alloc600: *mut u64}
  using: 
  (*_18) = move _15
  using: _18@Mir(bb5[0]), _15@Mir(bb4[2])
  _19 = const 1_i32
  using: 
  ((*_1).2: i32) = move _19
  using: _1@Entry, _19@Mir(bb5[2])
  _20 = _2
  using: _2@Entry
  _21 = const 1_i32
  using: 
  ((*_1).1: i32) = BitAnd(move _20, move _21)
  using: _1@Entry, _20@Mir(bb5[4]), _21@Mir(bb5[5])
  goto -> bb9
  using: 
bb6:
  _23 = ((*_1).1: i32)
  using: _1@Entry
  _24 = const 1_i32
  using: 
  _25 = CheckedShl(_23, _24)
  using: _23@Mir(bb6[0]), _24@Mir(bb6[1])
  assert(!move (_25.1: bool), "attempt to shift left by `{}`, which would overflow", move _24) -> bb7
  using: _25@Entry, _23@Entry, _24@Entry
bb7:
  _22 = move (_25.0: i32)
  using: _25@Mir(bb6[2])
  _27 = _2
  using: _2@Entry
  _28 = const 1_i32
  using: 
  _26 = BitAnd(move _27, move _28)
  using: _27@Mir(bb7[1]), _28@Mir(bb7[2])
  ((*_1).1: i32) = BitOr(move _22, move _26)
  using: _1@Entry, _22@Mir(bb7[0]), _26@Mir(bb7[3])
  _29 = CheckedAdd(((*_1).2: i32), const 1_i32)
  using: _1@Entry
  assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).2: i32), const 1_i32) -> bb8
  using: _29@Entry, _1@Entry
bb8:
  ((*_1).2: i32) = move (_29.0: i32)
  using: _1@Entry, _29@Mir(bb7[5])
  goto -> bb9
  using: 
bb9:
  return
  using: _0@Entry
rewrite call bzip2recover::putc @ workspace/bzip2/rust/bzip2recover.rs:194:13: 194:77 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/bzip2/rust/bzip2recover.rs:196:29: 196:44 (#0) by default
@DefId(0:297 ~ c2rust_lib[1043]::bzip2recover::bsGetBit)
bb0:
  _3 = ((*_1).2: i32)
  using: _1@Entry
  _4 = const 0_i32
  using: 
  _2 = Gt(move _3, move _4)
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1])
  switchInt(move _2) -> [0: bb4, otherwise: bb1]
  using: _2@Mir(bb0[2])
bb1:
  _5 = CheckedSub(((*_1).2: i32), const 1_i32)
  using: _1@Entry
  assert(!move (_5.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).2: i32), const 1_i32) -> bb2
  using: _5@Entry, _1@Entry
bb2:
  ((*_1).2: i32) = move (_5.0: i32)
  using: _1@Entry, _5@Mir(bb1[0])
  _7 = ((*_1).1: i32)
  using: _1@Entry
  _8 = ((*_1).2: i32)
  using: _1@Entry
  _9 = CheckedShr(_7, _8)
  using: _7@Mir(bb2[1]), _8@Mir(bb2[2])
  assert(!move (_9.1: bool), "attempt to shift right by `{}`, which would overflow", move _8) -> bb3
  using: _9@Entry, _7@Entry, _8@Entry
bb3:
  _6 = move (_9.0: i32)
  using: _9@Mir(bb2[3])
  _10 = const 1_i32
  using: 
  _0 = BitAnd(move _6, move _10)
  using: _6@Mir(bb3[0]), _10@Mir(bb3[1])
  goto -> bb12
  using: 
bb4:
  _12 = ((*_1).0: *mut blocksort::__sFILE)
  using: _1@Entry
  _11 = bzip2recover::getc(move _12) -> bb5
  using: _12@Mir(bb4[0])
bb5:
  _14 = _11
  using: _11@Mir(bb4[1])
  _15 = const -1_i32
  using: 
  _13 = Eq(move _14, move _15)
  using: _14@Mir(bb5[0]), _15@Mir(bb5[1])
  switchInt(move _13) -> [0: bb10, otherwise: bb6]
  using: _13@Mir(bb5[2])
bb6:
  _18 = bzip2recover::__error() -> bb7
  using: 
bb7:
  _17 = (*_18)
  using: _18@Mir(bb6[0])
  _19 = const 0_i32
  using: 
  _16 = Ne(move _17, move _19)
  using: _17@Mir(bb7[0]), _19@Mir(bb7[1])
  switchInt(move _16) -> [0: bb9, otherwise: bb8]
  using: _16@Mir(bb7[2])
bb8:
  _20 = bzip2recover::readError() -> bb9
  using: 
bb9:
  _0 = const 2_i32
  using: 
  goto -> bb12
  using: 
bb10:
  _21 = const 7_i32
  using: 
  ((*_1).2: i32) = move _21
  using: _1@Entry, _21@Mir(bb10[0])
  _22 = _11
  using: _11@Mir(bb4[1])
  ((*_1).1: i32) = move _22
  using: _1@Entry, _22@Mir(bb10[2])
  _24 = ((*_1).1: i32)
  using: _1@Entry
  _25 = const 7_i32
  using: 
  _26 = CheckedShr(_24, _25)
  using: _24@Mir(bb10[4]), _25@Mir(bb10[5])
  assert(!move (_26.1: bool), "attempt to shift right by `{}`, which would overflow", move _25) -> bb11
  using: _26@Entry, _24@Entry, _25@Entry
bb11:
  _23 = move (_26.0: i32)
  using: _26@Mir(bb10[6])
  _27 = const 1_i32
  using: 
  _0 = BitAnd(move _23, move _27)
  using: _23@Mir(bb11[0]), _27@Mir(bb11[1])
  goto -> bb12
  using: 
bb12:
  return
  using: _0@Phi(bb12)
rewrite call bzip2recover::getc @ workspace/bzip2/rust/bzip2recover.rs:214:33: 214:51 (#0) by default
rewrite call bzip2recover::__error @ workspace/bzip2/rust/bzip2recover.rs:216:17: 216:26 (#0) by default
@DefId(0:298 ~ c2rust_lib[1043]::bzip2recover::bsClose)
bb0:
  _2 = const 0_i32
  using: 
  _5 = ((*_1).3: i8)
  using: _1@Entry
  _4 = move _5 as i32 (IntToInt)
  using: _5@Mir(bb0[1])
  _6 = const 119_i32
  using: 
  _3 = Eq(move _4, move _6)
  using: _4@Mir(bb0[2]), _6@Mir(bb0[3])
  switchInt(move _3) -> [0: bb12, otherwise: bb1]
  using: _3@Mir(bb0[4])
bb1:
  _8 = ((*_1).2: i32)
  using: _1@Phi(bb1)
  _9 = const 8_i32
  using: 
  _7 = Lt(move _8, move _9)
  using: _8@Mir(bb1[0]), _9@Mir(bb1[1])
  switchInt(move _7) -> [0: bb5, otherwise: bb2]
  using: _7@Mir(bb1[2])
bb2:
  _10 = CheckedAdd(((*_1).2: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).2: i32), const 1_i32) -> bb3
  using: _10@Entry, _1@Entry
bb3:
  ((*_1).2: i32) = move (_10.0: i32)
  using: _1@Phi(bb1), _10@Mir(bb2[0])
  _11 = const 1_i32
  using: 
  _12 = CheckedShl(((*_1).1: i32), _11)
  using: _1@Phi(bb1), _11@Mir(bb3[1])
  assert(!move (_12.1: bool), "attempt to shift left by `{}`, which would overflow", move _11) -> bb4
  using: _12@Entry, _1@Entry, _11@Entry
bb4:
  ((*_1).1: i32) = move (_12.0: i32)
  using: _1@Phi(bb1), _12@Mir(bb3[2])
  goto -> bb1
  using: 
bb5:
  _16 = ((*_1).1: i32)
  using: _1@Phi(bb1)
  _15 = move _16 as u8 (IntToInt)
  using: _16@Mir(bb5[0])
  _14 = move _15 as i32 (IntToInt)
  using: _15@Mir(bb5[1])
  _17 = ((*_1).0: *mut blocksort::__sFILE)
  using: _1@Phi(bb1)
  _13 = bzip2recover::putc(move _14, move _17) -> bb6
  using: _14@Mir(bb5[2]), _17@Mir(bb5[3])
bb6:
  _2 = move _13
  using: _13@Mir(bb5[4])
  _19 = _2
  using: _2@Mir(bb6[0])
  _20 = const -1_i32
  using: 
  _18 = Eq(move _19, move _20)
  using: _19@Mir(bb6[1]), _20@Mir(bb6[2])
  switchInt(move _18) -> [0: bb8, otherwise: bb7]
  using: _18@Mir(bb6[3])
bb7:
  _21 = bzip2recover::writeError() -> bb8
  using: 
bb8:
  _24 = const {alloc600: *mut u64}
  using: 
  _23 = (*_24)
  using: _24@Mir(bb8[0])
  _22 = core::num::<impl u64>::wrapping_add(move _23, const 1_u64) -> bb9
  using: _23@Mir(bb8[1])
bb9:
  _25 = const {alloc600: *mut u64}
  using: 
  (*_25) = move _22
  using: _25@Mir(bb9[0]), _22@Mir(bb8[2])
  _27 = ((*_1).0: *mut blocksort::__sFILE)
  using: _1@Phi(bb1)
  _26 = bzip2recover::fflush(move _27) -> bb10
  using: _27@Mir(bb9[2])
bb10:
  _2 = move _26
  using: _26@Mir(bb9[3])
  _29 = _2
  using: _2@Mir(bb10[0])
  _30 = const -1_i32
  using: 
  _28 = Eq(move _29, move _30)
  using: _29@Mir(bb10[1]), _30@Mir(bb10[2])
  switchInt(move _28) -> [0: bb12, otherwise: bb11]
  using: _28@Mir(bb10[3])
bb11:
  _31 = bzip2recover::writeError() -> bb12
  using: 
bb12:
  _33 = ((*_1).0: *mut blocksort::__sFILE)
  using: _1@Phi(bb12)
  _32 = bzip2recover::fclose(move _33) -> bb13
  using: _33@Mir(bb12[0])
bb13:
  _2 = move _32
  using: _32@Mir(bb12[1])
  _35 = _2
  using: _2@Mir(bb13[0])
  _36 = const -1_i32
  using: 
  _34 = Eq(move _35, move _36)
  using: _35@Mir(bb13[1]), _36@Mir(bb13[2])
  switchInt(move _34) -> [0: bb17, otherwise: bb14]
  using: _34@Mir(bb13[3])
bb14:
  _39 = ((*_1).3: i8)
  using: _1@Phi(bb12)
  _38 = move _39 as i32 (IntToInt)
  using: _39@Mir(bb14[0])
  _40 = const 119_i32
  using: 
  _37 = Eq(move _38, move _40)
  using: _38@Mir(bb14[1]), _40@Mir(bb14[2])
  switchInt(move _37) -> [0: bb16, otherwise: bb15]
  using: _37@Mir(bb14[3])
bb15:
  _41 = bzip2recover::writeError() -> bb17
  using: 
bb16:
  _42 = bzip2recover::readError() -> bb17
  using: 
bb17:
  _45 = _1
  using: _1@Phi(bb17)
  _44 = move _45 as *mut std::ffi::c_void (PtrToPtr)
  using: _45@Mir(bb17[0])
  _43 = bzip2recover::free(move _44) -> bb18
  using: _44@Mir(bb17[1])
bb18:
  return
  using: _0@Entry
rewrite call bzip2recover::putc @ workspace/bzip2/rust/bzip2recover.rs:232:18: 232:82 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/bzip2/rust/bzip2recover.rs:234:29: 234:44 (#0) by default
rewrite call bzip2recover::fflush @ workspace/bzip2/rust/bzip2recover.rs:235:18: 235:38 (#0) by default
rewrite call bzip2recover::fclose @ workspace/bzip2/rust/bzip2recover.rs:238:14: 238:34 (#0) by default
@DefId(0:299 ~ c2rust_lib[1043]::bzip2recover::bsPutUChar)
bb0:
  _3 = const 0_i32
  using: 
  _3 = const 7_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _3
  using: _3@Phi(bb1)
  _6 = const 0_i32
  using: 
  _4 = Ge(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb6, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _8 = _1
  using: _1@Phi(bb1)
  _13 = _2
  using: _2@Phi(bb1)
  _12 = move _13 as u32 (IntToInt)
  using: _13@Mir(bb2[1])
  _14 = _3
  using: _3@Phi(bb1)
  _15 = CheckedShr(_12, _14)
  using: _12@Mir(bb2[2]), _14@Mir(bb2[3])
  assert(!move (_15.1: bool), "attempt to shift right by `{}`, which would overflow", move _14) -> bb3
  using: _15@Entry, _12@Entry, _14@Entry
bb3:
  _11 = move (_15.0: u32)
  using: _15@Mir(bb2[4])
  _16 = const 1_u32
  using: 
  _10 = BitAnd(move _11, move _16)
  using: _11@Mir(bb3[0]), _16@Mir(bb3[1])
  _9 = move _10 as i32 (IntToInt)
  using: _10@Mir(bb3[2])
  _7 = bzip2recover::bsPutBit(move _8, move _9) -> bb4
  using: _8@Mir(bb2[0]), _9@Mir(bb3[3])
bb4:
  _17 = CheckedSub(_3, const 1_i32)
  using: _3@Phi(bb1)
  assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1_i32) -> bb5
  using: _17@Entry, _3@Entry
bb5:
  _3 = move (_17.0: i32)
  using: _17@Mir(bb4[0])
  goto -> bb1
  using: 
bb6:
  return
  using: _0@Entry
@DefId(0:300 ~ c2rust_lib[1043]::bzip2recover::bsPutUInt32)
bb0:
  _3 = const 0_i32
  using: 
  _3 = const 31_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _3
  using: _3@Phi(bb1)
  _6 = const 0_i32
  using: 
  _4 = Ge(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb6, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _8 = _1
  using: _1@Phi(bb1)
  _12 = _2
  using: _2@Phi(bb1)
  _13 = _3
  using: _3@Phi(bb1)
  _14 = CheckedShr(_12, _13)
  using: _12@Mir(bb2[1]), _13@Mir(bb2[2])
  assert(!move (_14.1: bool), "attempt to shift right by `{}`, which would overflow", move _13) -> bb3
  using: _14@Entry, _12@Entry, _13@Entry
bb3:
  _11 = move (_14.0: u32)
  using: _14@Mir(bb2[3])
  _15 = const 1_u32
  using: 
  _10 = BitAnd(move _11, move _15)
  using: _11@Mir(bb3[0]), _15@Mir(bb3[1])
  _9 = move _10 as i32 (IntToInt)
  using: _10@Mir(bb3[2])
  _7 = bzip2recover::bsPutBit(move _8, move _9) -> bb4
  using: _8@Mir(bb2[0]), _9@Mir(bb3[3])
bb4:
  _16 = CheckedSub(_3, const 1_i32)
  using: _3@Phi(bb1)
  assert(!move (_16.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1_i32) -> bb5
  using: _16@Entry, _3@Entry
bb5:
  _3 = move (_16.0: i32)
  using: _16@Mir(bb4[0])
  goto -> bb1
  using: 
bb6:
  return
  using: _0@Entry
@DefId(0:301 ~ c2rust_lib[1043]::bzip2recover::endsInBz2)
bb0:
  _5 = _1
  using: _1@Entry
  _4 = move _5 as *const i8 (Pointer(MutToConstPointer))
  using: _5@Mir(bb0[0])
  _3 = bzip2recover::strlen(move _4) -> bb1
  using: _4@Mir(bb0[1])
bb1:
  _2 = move _3 as i32 (IntToInt)
  using: _3@Mir(bb0[2])
  _7 = _2
  using: _2@Mir(bb1[0])
  _8 = const 4_i32
  using: 
  _6 = Le(move _7, move _8)
  using: _7@Mir(bb1[1]), _8@Mir(bb1[2])
  switchInt(move _6) -> [0: bb3, otherwise: bb2]
  using: _6@Mir(bb1[3])
bb2:
  _0 = const 0_u8
  using: 
  goto -> bb21
  using: 
bb3:
  _17 = _1
  using: _1@Entry
  _20 = _2
  using: _2@Mir(bb1[0])
  _21 = const 4_i32
  using: 
  _22 = CheckedSub(_20, _21)
  using: _20@Mir(bb3[1]), _21@Mir(bb3[2])
  assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", move _20, move _21) -> bb13
  using: _22@Entry, _20@Entry, _21@Entry
bb4:
  _10 = const false
  using: 
  goto -> bb6
  using: 
bb5:
  _50 = _1
  using: _1@Phi(bb9)
  _53 = _2
  using: _2@Phi(bb9)
  _54 = const 1_i32
  using: 
  _55 = CheckedSub(_53, _54)
  using: _53@Mir(bb5[1]), _54@Mir(bb5[2])
  assert(!move (_55.1: bool), "attempt to compute `{} - {}`, which would overflow", move _53, move _54) -> bb19
  using: _55@Entry, _53@Entry, _54@Entry
bb6:
  _9 = move _10 as i32 (IntToInt)
  using: _10@Phi(bb6)
  _0 = move _9 as u8 (IntToInt)
  using: _9@Mir(bb6[0])
  goto -> bb21
  using: 
bb7:
  _11 = const false
  using: 
  goto -> bb9
  using: 
bb8:
  _39 = _1
  using: _1@Phi(bb12)
  _42 = _2
  using: _2@Phi(bb12)
  _43 = const 2_i32
  using: 
  _44 = CheckedSub(_42, _43)
  using: _42@Mir(bb8[1]), _43@Mir(bb8[2])
  assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", move _42, move _43) -> bb17
  using: _44@Entry, _42@Entry, _43@Entry
bb9:
  switchInt(move _11) -> [0: bb4, otherwise: bb5]
  using: _11@Phi(bb9)
bb10:
  _12 = const false
  using: 
  goto -> bb12
  using: 
bb11:
  _28 = _1
  using: _1@Entry
  _31 = _2
  using: _2@Mir(bb1[0])
  _32 = const 3_i32
  using: 
  _33 = CheckedSub(_31, _32)
  using: _31@Mir(bb11[1]), _32@Mir(bb11[2])
  assert(!move (_33.1: bool), "attempt to compute `{} - {}`, which would overflow", move _31, move _32) -> bb15
  using: _33@Entry, _31@Entry, _32@Entry
bb12:
  switchInt(move _12) -> [0: bb7, otherwise: bb8]
  using: _12@Phi(bb12)
bb13:
  _19 = move (_22.0: i32)
  using: _22@Mir(bb3[3])
  _18 = move _19 as isize (IntToInt)
  using: _19@Mir(bb13[0])
  _16 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _17, move _18) -> bb14
  using: _17@Mir(bb3[0]), _18@Mir(bb13[1])
bb14:
  _15 = (*_16)
  using: _16@Mir(bb13[2])
  _14 = move _15 as i32 (IntToInt)
  using: _15@Mir(bb14[0])
  _23 = const 46_i32
  using: 
  _13 = Eq(move _14, move _23)
  using: _14@Mir(bb14[1]), _23@Mir(bb14[2])
  switchInt(move _13) -> [0: bb10, otherwise: bb11]
  using: _13@Mir(bb14[3])
bb15:
  _30 = move (_33.0: i32)
  using: _33@Mir(bb11[3])
  _29 = move _30 as isize (IntToInt)
  using: _30@Mir(bb15[0])
  _27 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _28, move _29) -> bb16
  using: _28@Mir(bb11[0]), _29@Mir(bb15[1])
bb16:
  _26 = (*_27)
  using: _27@Mir(bb15[2])
  _25 = move _26 as i32 (IntToInt)
  using: _26@Mir(bb16[0])
  _34 = const 98_i32
  using: 
  _24 = Eq(move _25, move _34)
  using: _25@Mir(bb16[1]), _34@Mir(bb16[2])
  _12 = move _24
  using: _24@Mir(bb16[3])
  goto -> bb12
  using: 
bb17:
  _41 = move (_44.0: i32)
  using: _44@Mir(bb8[3])
  _40 = move _41 as isize (IntToInt)
  using: _41@Mir(bb17[0])
  _38 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _39, move _40) -> bb18
  using: _39@Mir(bb8[0]), _40@Mir(bb17[1])
bb18:
  _37 = (*_38)
  using: _38@Mir(bb17[2])
  _36 = move _37 as i32 (IntToInt)
  using: _37@Mir(bb18[0])
  _45 = const 122_i32
  using: 
  _35 = Eq(move _36, move _45)
  using: _36@Mir(bb18[1]), _45@Mir(bb18[2])
  _11 = move _35
  using: _35@Mir(bb18[3])
  goto -> bb9
  using: 
bb19:
  _52 = move (_55.0: i32)
  using: _55@Mir(bb5[3])
  _51 = move _52 as isize (IntToInt)
  using: _52@Mir(bb19[0])
  _49 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _50, move _51) -> bb20
  using: _50@Mir(bb5[0]), _51@Mir(bb19[1])
bb20:
  _48 = (*_49)
  using: _49@Mir(bb19[2])
  _47 = move _48 as i32 (IntToInt)
  using: _48@Mir(bb20[0])
  _56 = const 50_i32
  using: 
  _46 = Eq(move _47, move _56)
  using: _47@Mir(bb20[1]), _56@Mir(bb20[2])
  _10 = move _46
  using: _46@Mir(bb20[3])
  goto -> bb6
  using: 
bb21:
  return
  using: _0@Phi(bb21)
rewrite call bzip2recover::strlen @ workspace/bzip2/rust/bzip2recover.rs:268:24: 268:36 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:270:19: 270:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:272:23: 272:70 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:274:23: 274:70 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:276:23: 276:70 (#0) by default
@DefId(0:314 ~ c2rust_lib[1043]::bzip2recover::main_0)
bb0:
  _3 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _4 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _5 = const {0x0 as *mut bzip2recover::BitStream}
  using: 
  _6 = const {0x0 as *mut bzip2recover::BitStream}
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_u64
  using: 
  _12 = const 0_u32
  using: 
  _13 = const 0_u32
  using: 
  _14 = const 0_u32
  using: 
  _15 = const {0x0 as *mut i8}
  using: 
  _20 = const {alloc577: *mut [i8; 2000]}
  using: 
  _19 = &mut (*_20)
  using: _20@Mir(bb0[13])
  _18 = move _19 as &mut [i8] (Pointer(Unsize))
  using: _19@Mir(bb0[14])
  _17 = core::slice::<impl [i8]>::as_mut_ptr(move _18) -> bb1
  using: _18@Mir(bb0[15])
bb1:
  _24 = _2
  using: _2@Entry
  _25 = const 0_isize
  using: 
  _23 = std::ptr::mut_ptr::<impl *mut *mut i8>::offset(move _24, move _25) -> bb2
  using: _24@Mir(bb1[0]), _25@Mir(bb1[1])
bb2:
  _22 = (*_23)
  using: _23@Mir(bb1[2])
  _21 = move _22 as *const i8 (Pointer(MutToConstPointer))
  using: _22@Mir(bb2[0])
  _26 = const 1999_u64
  using: 
  _16 = bzip2recover::strncpy(move _17, move _21, move _26) -> bb3
  using: _17@Mir(bb0[16]), _21@Mir(bb2[1]), _26@Mir(bb2[2])
bb3:
  _27 = const 0_i32
  using: 
  _28 = const {alloc577: *mut [i8; 2000]}
  using: 
  _29 = const 1999_usize
  using: 
  (*_28)[_29] = move _27 as i8 (IntToInt)
  using: _28@Mir(bb3[1]), _29@Mir(bb3[2]), _27@Mir(bb3[0])
  _30 = const 0_i32
  using: 
  _31 = const {alloc614: *mut [i8; 2000]}
  using: 
  _32 = const 0_usize
  using: 
  (*_31)[_32] = move _30 as i8 (IntToInt)
  using: _31@Mir(bb3[5]), _32@Mir(bb3[6]), _30@Mir(bb3[4])
  _34 = const {alloc614: *mut [i8; 2000]}
  using: 
  _35 = const 0_usize
  using: 
  _33 = (*_34)[_35]
  using: _34@Mir(bb3[8]), _35@Mir(bb3[9])
  _36 = const {alloc578: *mut [i8; 2000]}
  using: 
  _37 = const 0_usize
  using: 
  (*_36)[_37] = move _33
  using: _36@Mir(bb3[11]), _37@Mir(bb3[12]), _33@Mir(bb3[10])
  _40 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _39 = (*_40)
  using: _40@Mir(bb3[14])
  _44 = const b"bzip2recover 1.0.8: extracts blocks from damaged .bz2 files.\n\x00"
  using: 
  _43 = &raw const (*_44)
  using: _44@Mir(bb3[16])
  _42 = move _43 as *const u8 (Pointer(ArrayToPointer))
  using: _43@Mir(bb3[17])
  _41 = move _42 as *const i8 (PtrToPtr)
  using: _42@Mir(bb3[18])
  _38 = bzip2recover::fprintf(move _39, move _41) -> bb4
  using: _39@Mir(bb3[15]), _41@Mir(bb3[19])
bb4:
  _46 = _1
  using: _1@Entry
  _47 = const 2_i32
  using: 
  _45 = Ne(move _46, move _47)
  using: _46@Mir(bb4[0]), _47@Mir(bb4[1])
  switchInt(move _45) -> [0: bb15, otherwise: bb5]
  using: _45@Mir(bb4[2])
bb5:
  _50 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _49 = (*_50)
  using: _50@Mir(bb5[0])
  _54 = const b"%s: usage is `%s damaged_file_name\'.\n\x00"
  using: 
  _53 = &raw const (*_54)
  using: _54@Mir(bb5[2])
  _52 = move _53 as *const u8 (Pointer(ArrayToPointer))
  using: _53@Mir(bb5[3])
  _51 = move _52 as *const i8 (PtrToPtr)
  using: _52@Mir(bb5[4])
  _58 = const {alloc577: *mut [i8; 2000]}
  using: 
  _57 = &mut (*_58)
  using: _58@Mir(bb5[6])
  _56 = move _57 as &mut [i8] (Pointer(Unsize))
  using: _57@Mir(bb5[7])
  _55 = core::slice::<impl [i8]>::as_mut_ptr(move _56) -> bb6
  using: _56@Mir(bb5[8])
bb6:
  _62 = const {alloc577: *mut [i8; 2000]}
  using: 
  _61 = &mut (*_62)
  using: _62@Mir(bb6[0])
  _60 = move _61 as &mut [i8] (Pointer(Unsize))
  using: _61@Mir(bb6[1])
  _59 = core::slice::<impl [i8]>::as_mut_ptr(move _60) -> bb7
  using: _60@Mir(bb6[2])
bb7:
  _48 = bzip2recover::fprintf(move _49, move _51, move _55, move _59) -> bb8
  using: _49@Mir(bb5[1]), _51@Mir(bb5[5]), _55@Mir(bb5[9]), _59@Mir(bb6[3])
bb8:
  _64 = std::mem::size_of::<u64>() -> bb9
  using: 
bb9:
  _63 = move _64 as u64 (IntToInt)
  using: _64@Mir(bb8[0])
  switchInt(_63) -> [8: bb11, 4: bb12, otherwise: bb10]
  using: _63@Mir(bb9[0])
bb10:
  _88 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _87 = (*_88)
  using: _88@Mir(bb10[0])
  _92 = const b"\tsizeof(MaybeUInt64) is not 4 or 8 -- configuration error.\n\x00"
  using: 
  _91 = &raw const (*_92)
  using: _92@Mir(bb10[2])
  _90 = move _91 as *const u8 (Pointer(ArrayToPointer))
  using: _91@Mir(bb10[3])
  _89 = move _90 as *const i8 (PtrToPtr)
  using: _90@Mir(bb10[4])
  _86 = bzip2recover::fprintf(move _87, move _89) -> bb14
  using: _87@Mir(bb10[1]), _89@Mir(bb10[5])
bb11:
  _67 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _66 = (*_67)
  using: _67@Mir(bb11[0])
  _71 = const b"\trestrictions on size of recovered file: None\n\x00"
  using: 
  _70 = &raw const (*_71)
  using: _71@Mir(bb11[2])
  _69 = move _70 as *const u8 (Pointer(ArrayToPointer))
  using: _70@Mir(bb11[3])
  _68 = move _69 as *const i8 (PtrToPtr)
  using: _69@Mir(bb11[4])
  _65 = bzip2recover::fprintf(move _66, move _68) -> bb14
  using: _66@Mir(bb11[1]), _68@Mir(bb11[5])
bb12:
  _74 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _73 = (*_74)
  using: _74@Mir(bb12[0])
  _78 = const b"\trestrictions on size of recovered file: 512 MB\n\x00"
  using: 
  _77 = &raw const (*_78)
  using: _78@Mir(bb12[2])
  _76 = move _77 as *const u8 (Pointer(ArrayToPointer))
  using: _77@Mir(bb12[3])
  _75 = move _76 as *const i8 (PtrToPtr)
  using: _76@Mir(bb12[4])
  _72 = bzip2recover::fprintf(move _73, move _75) -> bb13
  using: _73@Mir(bb12[1]), _75@Mir(bb12[5])
bb13:
  _81 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _80 = (*_81)
  using: _81@Mir(bb13[0])
  _85 = const b"\tto circumvent, recompile with MaybeUInt64 as an\n\tunsigned 64-bit int.\n\x00"
  using: 
  _84 = &raw const (*_85)
  using: _85@Mir(bb13[2])
  _83 = move _84 as *const u8 (Pointer(ArrayToPointer))
  using: _84@Mir(bb13[3])
  _82 = move _83 as *const i8 (PtrToPtr)
  using: _83@Mir(bb13[4])
  _79 = bzip2recover::fprintf(move _80, move _82) -> bb14
  using: _80@Mir(bb13[1]), _82@Mir(bb13[5])
bb14:
  _94 = const 1_i32
  using: 
  _93 = bzip2recover::exit(move _94)
  using: _94@Mir(bb14[0])
bb15:
  _100 = _2
  using: _2@Entry
  _101 = const 1_isize
  using: 
  _99 = std::ptr::mut_ptr::<impl *mut *mut i8>::offset(move _100, move _101) -> bb16
  using: _100@Mir(bb15[0]), _101@Mir(bb15[1])
bb16:
  _98 = (*_99)
  using: _99@Mir(bb15[2])
  _97 = move _98 as *const i8 (Pointer(MutToConstPointer))
  using: _98@Mir(bb16[0])
  _96 = bzip2recover::strlen(move _97) -> bb17
  using: _97@Mir(bb16[1])
bb17:
  _102 = const 1980_u64
  using: 
  _95 = Ge(move _96, move _102)
  using: _96@Mir(bb16[2]), _102@Mir(bb17[0])
  switchInt(move _95) -> [0: bb23, otherwise: bb18]
  using: _95@Mir(bb17[1])
bb18:
  _105 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _104 = (*_105)
  using: _105@Mir(bb18[0])
  _109 = const b"%s: supplied filename is suspiciously (>= %d chars) long.  Bye!\n\x00"
  using: 
  _108 = &raw const (*_109)
  using: _109@Mir(bb18[2])
  _107 = move _108 as *const u8 (Pointer(ArrayToPointer))
  using: _108@Mir(bb18[3])
  _106 = move _107 as *const i8 (PtrToPtr)
  using: _107@Mir(bb18[4])
  _113 = const {alloc577: *mut [i8; 2000]}
  using: 
  _112 = &mut (*_113)
  using: _113@Mir(bb18[6])
  _111 = move _112 as &mut [i8] (Pointer(Unsize))
  using: _112@Mir(bb18[7])
  _110 = core::slice::<impl [i8]>::as_mut_ptr(move _111) -> bb19
  using: _111@Mir(bb18[8])
bb19:
  _119 = _2
  using: _2@Entry
  _120 = const 1_isize
  using: 
  _118 = std::ptr::mut_ptr::<impl *mut *mut i8>::offset(move _119, move _120) -> bb20
  using: _119@Mir(bb19[0]), _120@Mir(bb19[1])
bb20:
  _117 = (*_118)
  using: _118@Mir(bb19[2])
  _116 = move _117 as *const i8 (Pointer(MutToConstPointer))
  using: _117@Mir(bb20[0])
  _115 = bzip2recover::strlen(move _116) -> bb21
  using: _116@Mir(bb20[1])
bb21:
  _114 = move _115 as i32 (IntToInt)
  using: _115@Mir(bb20[2])
  _103 = bzip2recover::fprintf(move _104, move _106, move _110, move _114) -> bb22
  using: _104@Mir(bb18[1]), _106@Mir(bb18[5]), _110@Mir(bb18[9]), _114@Mir(bb21[0])
bb22:
  _122 = const 1_i32
  using: 
  _121 = bzip2recover::exit(move _122)
  using: _122@Mir(bb22[0])
bb23:
  _127 = const {alloc578: *mut [i8; 2000]}
  using: 
  _126 = &mut (*_127)
  using: _127@Mir(bb23[0])
  _125 = move _126 as &mut [i8] (Pointer(Unsize))
  using: _126@Mir(bb23[1])
  _124 = core::slice::<impl [i8]>::as_mut_ptr(move _125) -> bb24
  using: _125@Mir(bb23[2])
bb24:
  _131 = _2
  using: _2@Entry
  _132 = const 1_isize
  using: 
  _130 = std::ptr::mut_ptr::<impl *mut *mut i8>::offset(move _131, move _132) -> bb25
  using: _131@Mir(bb24[0]), _132@Mir(bb24[1])
bb25:
  _129 = (*_130)
  using: _130@Mir(bb24[2])
  _128 = move _129 as *const i8 (Pointer(MutToConstPointer))
  using: _129@Mir(bb25[0])
  _123 = bzip2recover::strcpy(move _124, move _128) -> bb26
  using: _124@Mir(bb23[3]), _128@Mir(bb25[1])
bb26:
  _138 = const {alloc578: *mut [i8; 2000]}
  using: 
  _137 = &mut (*_138)
  using: _138@Mir(bb26[0])
  _136 = move _137 as &mut [i8] (Pointer(Unsize))
  using: _137@Mir(bb26[1])
  _135 = core::slice::<impl [i8]>::as_mut_ptr(move _136) -> bb27
  using: _136@Mir(bb26[2])
bb27:
  _134 = move _135 as *const i8 (Pointer(MutToConstPointer))
  using: _135@Mir(bb26[3])
  _142 = const b"rb\x00"
  using: 
  _141 = &raw const (*_142)
  using: _142@Mir(bb27[1])
  _140 = move _141 as *const u8 (Pointer(ArrayToPointer))
  using: _141@Mir(bb27[2])
  _139 = move _140 as *const i8 (PtrToPtr)
  using: _140@Mir(bb27[3])
  _133 = bzip2recover::fopen(move _134, move _139) -> bb28
  using: _134@Mir(bb27[0]), _139@Mir(bb27[4])
bb28:
  _3 = move _133
  using: _133@Mir(bb27[5])
  _144 = _3
  using: _3@Mir(bb28[0])
  _143 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _144) -> bb29
  using: _144@Mir(bb28[1])
bb29:
  switchInt(move _143) -> [0: bb34, otherwise: bb30]
  using: _143@Mir(bb28[2])
bb30:
  _147 = _3
  using: _3@Mir(bb28[0])
  _146 = move _147 as usize (PointerExposeAddress)
  using: _147@Mir(bb30[0])
  _145 = Eq(move _146, const 0_usize)
  using: _146@Mir(bb30[1])
  assume(move _145)
  using: _145@Mir(bb30[2])
  _150 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _149 = (*_150)
  using: _150@Mir(bb30[4])
  _154 = const b"%s: can\'t read `%s\'\n\x00"
  using: 
  _153 = &raw const (*_154)
  using: _154@Mir(bb30[6])
  _152 = move _153 as *const u8 (Pointer(ArrayToPointer))
  using: _153@Mir(bb30[7])
  _151 = move _152 as *const i8 (PtrToPtr)
  using: _152@Mir(bb30[8])
  _158 = const {alloc577: *mut [i8; 2000]}
  using: 
  _157 = &mut (*_158)
  using: _158@Mir(bb30[10])
  _156 = move _157 as &mut [i8] (Pointer(Unsize))
  using: _157@Mir(bb30[11])
  _155 = core::slice::<impl [i8]>::as_mut_ptr(move _156) -> bb31
  using: _156@Mir(bb30[12])
bb31:
  _162 = const {alloc578: *mut [i8; 2000]}
  using: 
  _161 = &mut (*_162)
  using: _162@Mir(bb31[0])
  _160 = move _161 as &mut [i8] (Pointer(Unsize))
  using: _161@Mir(bb31[1])
  _159 = core::slice::<impl [i8]>::as_mut_ptr(move _160) -> bb32
  using: _160@Mir(bb31[2])
bb32:
  _148 = bzip2recover::fprintf(move _149, move _151, move _155, move _159) -> bb33
  using: _149@Mir(bb30[5]), _151@Mir(bb30[9]), _155@Mir(bb30[13]), _159@Mir(bb31[3])
bb33:
  _164 = const 1_i32
  using: 
  _163 = bzip2recover::exit(move _164)
  using: _164@Mir(bb33[0])
bb34:
  _166 = _3
  using: _3@Mir(bb28[0])
  _165 = bzip2recover::bsOpenReadStream(move _166) -> bb35
  using: _166@Mir(bb34[0])
bb35:
  _5 = move _165
  using: _165@Mir(bb34[1])
  _169 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _168 = (*_169)
  using: _169@Mir(bb35[1])
  _173 = const b"%s: searching for block boundaries ...\n\x00"
  using: 
  _172 = &raw const (*_173)
  using: _173@Mir(bb35[3])
  _171 = move _172 as *const u8 (Pointer(ArrayToPointer))
  using: _172@Mir(bb35[4])
  _170 = move _171 as *const i8 (PtrToPtr)
  using: _171@Mir(bb35[5])
  _177 = const {alloc577: *mut [i8; 2000]}
  using: 
  _176 = &mut (*_177)
  using: _177@Mir(bb35[7])
  _175 = move _176 as &mut [i8] (Pointer(Unsize))
  using: _176@Mir(bb35[8])
  _174 = core::slice::<impl [i8]>::as_mut_ptr(move _175) -> bb36
  using: _175@Mir(bb35[9])
bb36:
  _167 = bzip2recover::fprintf(move _168, move _170, move _174) -> bb37
  using: _168@Mir(bb35[2]), _170@Mir(bb35[6]), _174@Mir(bb35[10])
bb37:
  _11 = const 0_u64
  using: 
  _13 = const 0_u32
  using: 
  _12 = const 0_u32
  using: 
  _9 = const 0_i32
  using: 
  _178 = const 0_i32
  using: 
  _179 = const {alloc615: *mut [u64; 50000]}
  using: 
  _180 = const 0_usize
  using: 
  (*_179)[_180] = move _178 as u64 (IntToInt)
  using: _179@Mir(bb37[5]), _180@Mir(bb37[6]), _178@Mir(bb37[4])
  _10 = const 0_i32
  using: 
  goto -> bb38
  using: 
bb38:
  _182 = _5
  using: _5@Mir(bb35[0])
  _181 = bzip2recover::bsGetBit(move _182) -> bb39
  using: _182@Mir(bb38[0])
bb39:
  _7 = move _181
  using: _181@Mir(bb38[1])
  _184 = _11
  using: _11@Phi(bb38)
  _183 = core::num::<impl u64>::wrapping_add(move _184, const 1_u64) -> bb40
  using: _184@Mir(bb39[1])
bb40:
  _11 = move _183
  using: _183@Mir(bb39[2])
  _186 = _7
  using: _7@Mir(bb39[0])
  _187 = const 2_i32
  using: 
  _185 = Eq(move _186, move _187)
  using: _186@Mir(bb40[1]), _187@Mir(bb40[2])
  switchInt(move _185) -> [0: bb56, otherwise: bb41]
  using: _185@Mir(bb40[3])
bb41:
  _190 = _11
  using: _11@Mir(bb40[0])
  _192 = const {alloc615: *mut [u64; 50000]}
  using: 
  _194 = _9
  using: _9@Phi(bb38)
  _193 = move _194 as usize (IntToInt)
  using: _194@Mir(bb41[2])
  _195 = const 50000_usize
  using: 
  _196 = Lt(_193, _195)
  using: _193@Mir(bb41[3]), _195@Mir(bb41[4])
  assert(move _196, "index out of bounds: the length is {} but the index is {}", move _195, _193) -> bb45
  using: _196@Entry, _195@Entry, _193@Entry
bb42:
  _188 = const false
  using: 
  goto -> bb44
  using: 
bb43:
  _199 = _11
  using: _11@Mir(bb40[0])
  _201 = const {alloc615: *mut [u64; 50000]}
  using: 
  _203 = _9
  using: _9@Phi(bb38)
  _202 = move _203 as usize (IntToInt)
  using: _203@Mir(bb43[2])
  _204 = const 50000_usize
  using: 
  _205 = Lt(_202, _204)
  using: _202@Mir(bb43[3]), _204@Mir(bb43[4])
  assert(move _205, "index out of bounds: the length is {} but the index is {}", move _204, _202) -> bb46
  using: _205@Entry, _204@Entry, _202@Entry
bb44:
  switchInt(move _188) -> [0: bb54, otherwise: bb48]
  using: _188@Phi(bb44)
bb45:
  _191 = (*_192)[_193]
  using: _192@Mir(bb41[1]), _193@Mir(bb41[3])
  _189 = Ge(move _190, move _191)
  using: _190@Mir(bb41[0]), _191@Mir(bb45[0])
  switchInt(move _189) -> [0: bb42, otherwise: bb43]
  using: _189@Mir(bb45[1])
bb46:
  _200 = (*_201)[_202]
  using: _201@Mir(bb43[1]), _202@Mir(bb43[3])
  _198 = core::num::<impl u64>::wrapping_sub(move _199, move _200) -> bb47
  using: _199@Mir(bb43[0]), _200@Mir(bb46[0])
bb47:
  _206 = const 40_u64
  using: 
  _197 = Ge(move _198, move _206)
  using: _198@Mir(bb46[1]), _206@Mir(bb47[0])
  _188 = move _197
  using: _197@Mir(bb47[1])
  goto -> bb44
  using: 
bb48:
  _208 = _11
  using: _11@Phi(bb44)
  _209 = const 1_u64
  using: 
  _207 = core::num::<impl u64>::wrapping_sub(move _208, move _209) -> bb49
  using: _208@Mir(bb48[0]), _209@Mir(bb48[1])
bb49:
  _210 = const {alloc616: *mut [u64; 50000]}
  using: 
  _212 = _9
  using: _9@Phi(bb44)
  _211 = move _212 as usize (IntToInt)
  using: _212@Mir(bb49[1])
  _213 = const 50000_usize
  using: 
  _214 = Lt(_211, _213)
  using: _211@Mir(bb49[2]), _213@Mir(bb49[3])
  assert(move _214, "index out of bounds: the length is {} but the index is {}", move _213, _211) -> bb50
  using: _214@Entry, _213@Entry, _211@Entry
bb50:
  (*_210)[_211] = move _207
  using: _210@Mir(bb49[0]), _211@Mir(bb49[2]), _207@Mir(bb48[2])
  _216 = _9
  using: _9@Phi(bb44)
  _217 = const 0_i32
  using: 
  _215 = Gt(move _216, move _217)
  using: _216@Mir(bb50[1]), _217@Mir(bb50[2])
  switchInt(move _215) -> [0: bb97, otherwise: bb51]
  using: _215@Mir(bb50[3])
bb51:
  _220 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _219 = (*_220)
  using: _220@Mir(bb51[0])
  _224 = const b"   block %d runs from %Lu to %Lu (incomplete)\n\x00"
  using: 
  _223 = &raw const (*_224)
  using: _224@Mir(bb51[2])
  _222 = move _223 as *const u8 (Pointer(ArrayToPointer))
  using: _223@Mir(bb51[3])
  _221 = move _222 as *const i8 (PtrToPtr)
  using: _222@Mir(bb51[4])
  _225 = _9
  using: _9@Phi(bb44)
  _227 = const {alloc615: *mut [u64; 50000]}
  using: 
  _229 = _9
  using: _9@Phi(bb44)
  _228 = move _229 as usize (IntToInt)
  using: _229@Mir(bb51[8])
  _230 = const 50000_usize
  using: 
  _231 = Lt(_228, _230)
  using: _228@Mir(bb51[9]), _230@Mir(bb51[10])
  assert(move _231, "index out of bounds: the length is {} but the index is {}", move _230, _228) -> bb52
  using: _231@Entry, _230@Entry, _228@Entry
bb52:
  _226 = (*_227)[_228]
  using: _227@Mir(bb51[7]), _228@Mir(bb51[9])
  _233 = const {alloc616: *mut [u64; 50000]}
  using: 
  _235 = _9
  using: _9@Phi(bb44)
  _234 = move _235 as usize (IntToInt)
  using: _235@Mir(bb52[2])
  _236 = const 50000_usize
  using: 
  _237 = Lt(_234, _236)
  using: _234@Mir(bb52[3]), _236@Mir(bb52[4])
  assert(move _237, "index out of bounds: the length is {} but the index is {}", move _236, _234) -> bb53
  using: _237@Entry, _236@Entry, _234@Entry
bb53:
  _232 = (*_233)[_234]
  using: _233@Mir(bb52[1]), _234@Mir(bb52[3])
  _218 = bzip2recover::fprintf(move _219, move _221, move _225, move _226, move _232) -> bb97
  using: _219@Mir(bb51[1]), _221@Mir(bb51[5]), _225@Mir(bb51[6]), _226@Mir(bb52[0]), _232@Mir(bb53[0])
bb54:
  _238 = CheckedSub(_9, const 1_i32)
  using: _9@Phi(bb44)
  assert(!move (_238.1: bool), "attempt to compute `{} - {}`, which would overflow", _9, const 1_i32) -> bb55
  using: _238@Entry, _9@Entry
bb55:
  _9 = move (_238.0: i32)
  using: _238@Mir(bb54[0])
  goto -> bb97
  using: 
bb56:
  _240 = _12
  using: _12@Phi(bb214)
  _241 = const 1_i32
  using: 
  _242 = CheckedShl(_240, _241)
  using: _240@Mir(bb56[0]), _241@Mir(bb56[1])
  assert(!move (_242.1: bool), "attempt to shift left by `{}`, which would overflow", move _241) -> bb57
  using: _242@Entry, _240@Entry, _241@Entry
bb57:
  _239 = move (_242.0: u32)
  using: _242@Mir(bb56[2])
  _244 = _13
  using: _13@Phi(bb214)
  _245 = const 31_i32
  using: 
  _246 = CheckedShr(_244, _245)
  using: _244@Mir(bb57[1]), _245@Mir(bb57[2])
  assert(!move (_246.1: bool), "attempt to shift right by `{}`, which would overflow", move _245) -> bb58
  using: _246@Entry, _244@Entry, _245@Entry
bb58:
  _243 = move (_246.0: u32)
  using: _246@Mir(bb57[3])
  _12 = BitOr(move _239, move _243)
  using: _239@Mir(bb57[0]), _243@Mir(bb58[0])
  _248 = _13
  using: _13@Phi(bb214)
  _249 = const 1_i32
  using: 
  _250 = CheckedShl(_248, _249)
  using: _248@Mir(bb58[2]), _249@Mir(bb58[3])
  assert(!move (_250.1: bool), "attempt to shift left by `{}`, which would overflow", move _249) -> bb59
  using: _250@Entry, _248@Entry, _249@Entry
bb59:
  _247 = move (_250.0: u32)
  using: _250@Mir(bb58[4])
  _253 = _7
  using: _7@Phi(bb136)
  _254 = const 1_i32
  using: 
  _252 = BitAnd(move _253, move _254)
  using: _253@Mir(bb59[1]), _254@Mir(bb59[2])
  _251 = move _252 as u32 (IntToInt)
  using: _252@Mir(bb59[3])
  _13 = BitOr(move _247, move _251)
  using: _247@Mir(bb59[0]), _251@Mir(bb59[4])
  _260 = _12
  using: _12@Mir(bb58[1])
  _261 = const 65535_u32
  using: 
  _259 = BitAnd(move _260, move _261)
  using: _260@Mir(bb59[6]), _261@Mir(bb59[7])
  _258 = move _259 as u64 (IntToInt)
  using: _259@Mir(bb59[8])
  _262 = const 12609_u64
  using: 
  _257 = Eq(move _258, move _262)
  using: _258@Mir(bb59[9]), _262@Mir(bb59[10])
  switchInt(move _257) -> [0: bb63, otherwise: bb64]
  using: _257@Mir(bb59[11])
bb60:
  _255 = const true
  using: 
  goto -> bb62
  using: 
bb61:
  _271 = _12
  using: _12@Mir(bb58[1])
  _272 = const 65535_u32
  using: 
  _270 = BitAnd(move _271, move _272)
  using: _271@Mir(bb61[0]), _272@Mir(bb61[1])
  _269 = move _270 as u64 (IntToInt)
  using: _270@Mir(bb61[2])
  _273 = const 6002_u64
  using: 
  _268 = Eq(move _269, move _273)
  using: _269@Mir(bb61[3]), _273@Mir(bb61[4])
  switchInt(move _268) -> [0: bb66, otherwise: bb67]
  using: _268@Mir(bb61[5])
bb62:
  switchInt(move _255) -> [0: bb38, otherwise: bb69]
  using: _255@Phi(bb62)
bb63:
  _256 = const false
  using: 
  goto -> bb65
  using: 
bb64:
  _265 = _13
  using: _13@Mir(bb59[5])
  _264 = move _265 as u64 (IntToInt)
  using: _265@Mir(bb64[0])
  _266 = const 1495683929_u64
  using: 
  _263 = Eq(move _264, move _266)
  using: _264@Mir(bb64[1]), _266@Mir(bb64[2])
  _256 = move _263
  using: _263@Mir(bb64[3])
  goto -> bb65
  using: 
bb65:
  switchInt(move _256) -> [0: bb61, otherwise: bb60]
  using: _256@Phi(bb65)
bb66:
  _267 = const false
  using: 
  goto -> bb68
  using: 
bb67:
  _276 = _13
  using: _13@Phi(bb65)
  _275 = move _276 as u64 (IntToInt)
  using: _276@Mir(bb67[0])
  _277 = const 1161318544_u64
  using: 
  _274 = Eq(move _275, move _277)
  using: _275@Mir(bb67[1]), _277@Mir(bb67[2])
  _267 = move _274
  using: _274@Mir(bb67[3])
  goto -> bb68
  using: 
bb68:
  _255 = move _267
  using: _267@Phi(bb68)
  goto -> bb62
  using: 
bb69:
  _279 = _11
  using: _11@Phi(bb128)
  _280 = const 49_u64
  using: 
  _278 = Gt(move _279, move _280)
  using: _279@Mir(bb69[0]), _280@Mir(bb69[1])
  switchInt(move _278) -> [0: bb73, otherwise: bb70]
  using: _278@Mir(bb69[2])
bb70:
  _282 = _11
  using: _11@Phi(bb128)
  _283 = const 49_u64
  using: 
  _281 = core::num::<impl u64>::wrapping_sub(move _282, move _283) -> bb71
  using: _282@Mir(bb70[0]), _283@Mir(bb70[1])
bb71:
  _284 = const {alloc616: *mut [u64; 50000]}
  using: 
  _286 = _9
  using: _9@Phi(bb97)
  _285 = move _286 as usize (IntToInt)
  using: _286@Mir(bb71[1])
  _287 = const 50000_usize
  using: 
  _288 = Lt(_285, _287)
  using: _285@Mir(bb71[2]), _287@Mir(bb71[3])
  assert(move _288, "index out of bounds: the length is {} but the index is {}", move _287, _285) -> bb72
  using: _288@Entry, _287@Entry, _285@Entry
bb72:
  (*_284)[_285] = move _281
  using: _284@Mir(bb71[0]), _285@Mir(bb71[2]), _281@Mir(bb70[2])
  goto -> bb75
  using: 
bb73:
  _289 = const 0_i32
  using: 
  _290 = const {alloc616: *mut [u64; 50000]}
  using: 
  _292 = _9
  using: _9@Phi(bb97)
  _291 = move _292 as usize (IntToInt)
  using: _292@Mir(bb73[2])
  _293 = const 50000_usize
  using: 
  _294 = Lt(_291, _293)
  using: _291@Mir(bb73[3]), _293@Mir(bb73[4])
  assert(move _294, "index out of bounds: the length is {} but the index is {}", move _293, _291) -> bb74
  using: _294@Entry, _293@Entry, _291@Entry
bb74:
  (*_290)[_291] = move _289 as u64 (IntToInt)
  using: _290@Mir(bb73[1]), _291@Mir(bb73[3]), _289@Mir(bb73[0])
  goto -> bb75
  using: 
bb75:
  _297 = _9
  using: _9@Phi(bb75)
  _298 = const 0_i32
  using: 
  _296 = Gt(move _297, move _298)
  using: _297@Mir(bb75[0]), _298@Mir(bb75[1])
  switchInt(move _296) -> [0: bb76, otherwise: bb77]
  using: _296@Mir(bb75[2])
bb76:
  _295 = const false
  using: 
  goto -> bb78
  using: 
bb77:
  _302 = const {alloc616: *mut [u64; 50000]}
  using: 
  _304 = _9
  using: _9@Phi(bb75)
  _303 = move _304 as usize (IntToInt)
  using: _304@Mir(bb77[1])
  _305 = const 50000_usize
  using: 
  _306 = Lt(_303, _305)
  using: _303@Mir(bb77[2]), _305@Mir(bb77[3])
  assert(move _306, "index out of bounds: the length is {} but the index is {}", move _305, _303) -> bb79
  using: _306@Entry, _305@Entry, _303@Entry
bb78:
  switchInt(move _295) -> [0: bb92, otherwise: bb82]
  using: _295@Phi(bb78)
bb79:
  _301 = (*_302)[_303]
  using: _302@Mir(bb77[0]), _303@Mir(bb77[2])
  _308 = const {alloc615: *mut [u64; 50000]}
  using: 
  _310 = _9
  using: _9@Phi(bb75)
  _309 = move _310 as usize (IntToInt)
  using: _310@Mir(bb79[2])
  _311 = const 50000_usize
  using: 
  _312 = Lt(_309, _311)
  using: _309@Mir(bb79[3]), _311@Mir(bb79[4])
  assert(move _312, "index out of bounds: the length is {} but the index is {}", move _311, _309) -> bb80
  using: _312@Entry, _311@Entry, _309@Entry
bb80:
  _307 = (*_308)[_309]
  using: _308@Mir(bb79[1]), _309@Mir(bb79[3])
  _300 = core::num::<impl u64>::wrapping_sub(move _301, move _307) -> bb81
  using: _301@Mir(bb79[0]), _307@Mir(bb80[0])
bb81:
  _313 = const 130_u64
  using: 
  _299 = Ge(move _300, move _313)
  using: _300@Mir(bb80[1]), _313@Mir(bb81[0])
  _295 = move _299
  using: _299@Mir(bb81[1])
  goto -> bb78
  using: 
bb82:
  _316 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _315 = (*_316)
  using: _316@Mir(bb82[0])
  _320 = const b"   block %d runs from %Lu to %Lu\n\x00"
  using: 
  _319 = &raw const (*_320)
  using: _320@Mir(bb82[2])
  _318 = move _319 as *const u8 (Pointer(ArrayToPointer))
  using: _319@Mir(bb82[3])
  _317 = move _318 as *const i8 (PtrToPtr)
  using: _318@Mir(bb82[4])
  _322 = _10
  using: _10@Phi(bb214)
  _323 = const 1_i32
  using: 
  _324 = CheckedAdd(_322, _323)
  using: _322@Mir(bb82[6]), _323@Mir(bb82[7])
  assert(!move (_324.1: bool), "attempt to compute `{} + {}`, which would overflow", move _322, move _323) -> bb83
  using: _324@Entry, _322@Entry, _323@Entry
bb83:
  _321 = move (_324.0: i32)
  using: _324@Mir(bb82[8])
  _326 = const {alloc615: *mut [u64; 50000]}
  using: 
  _328 = _9
  using: _9@Phi(bb78)
  _327 = move _328 as usize (IntToInt)
  using: _328@Mir(bb83[2])
  _329 = const 50000_usize
  using: 
  _330 = Lt(_327, _329)
  using: _327@Mir(bb83[3]), _329@Mir(bb83[4])
  assert(move _330, "index out of bounds: the length is {} but the index is {}", move _329, _327) -> bb84
  using: _330@Entry, _329@Entry, _327@Entry
bb84:
  _325 = (*_326)[_327]
  using: _326@Mir(bb83[1]), _327@Mir(bb83[3])
  _332 = const {alloc616: *mut [u64; 50000]}
  using: 
  _334 = _9
  using: _9@Phi(bb78)
  _333 = move _334 as usize (IntToInt)
  using: _334@Mir(bb84[2])
  _335 = const 50000_usize
  using: 
  _336 = Lt(_333, _335)
  using: _333@Mir(bb84[3]), _335@Mir(bb84[4])
  assert(move _336, "index out of bounds: the length is {} but the index is {}", move _335, _333) -> bb85
  using: _336@Entry, _335@Entry, _333@Entry
bb85:
  _331 = (*_332)[_333]
  using: _332@Mir(bb84[1]), _333@Mir(bb84[3])
  _314 = bzip2recover::fprintf(move _315, move _317, move _321, move _325, move _331) -> bb86
  using: _315@Mir(bb82[1]), _317@Mir(bb82[5]), _321@Mir(bb83[0]), _325@Mir(bb84[0]), _331@Mir(bb85[0])
bb86:
  _338 = const {alloc615: *mut [u64; 50000]}
  using: 
  _340 = _9
  using: _9@Phi(bb78)
  _339 = move _340 as usize (IntToInt)
  using: _340@Mir(bb86[1])
  _341 = const 50000_usize
  using: 
  _342 = Lt(_339, _341)
  using: _339@Mir(bb86[2]), _341@Mir(bb86[3])
  assert(move _342, "index out of bounds: the length is {} but the index is {}", move _341, _339) -> bb87
  using: _342@Entry, _341@Entry, _339@Entry
bb87:
  _337 = (*_338)[_339]
  using: _338@Mir(bb86[0]), _339@Mir(bb86[2])
  _343 = const {alloc617: *mut [u64; 50000]}
  using: 
  _345 = _10
  using: _10@Phi(bb214)
  _344 = move _345 as usize (IntToInt)
  using: _345@Mir(bb87[2])
  _346 = const 50000_usize
  using: 
  _347 = Lt(_344, _346)
  using: _344@Mir(bb87[3]), _346@Mir(bb87[4])
  assert(move _347, "index out of bounds: the length is {} but the index is {}", move _346, _344) -> bb88
  using: _347@Entry, _346@Entry, _344@Entry
bb88:
  (*_343)[_344] = move _337
  using: _343@Mir(bb87[1]), _344@Mir(bb87[3]), _337@Mir(bb87[0])
  _349 = const {alloc616: *mut [u64; 50000]}
  using: 
  _351 = _9
  using: _9@Phi(bb78)
  _350 = move _351 as usize (IntToInt)
  using: _351@Mir(bb88[2])
  _352 = const 50000_usize
  using: 
  _353 = Lt(_350, _352)
  using: _350@Mir(bb88[3]), _352@Mir(bb88[4])
  assert(move _353, "index out of bounds: the length is {} but the index is {}", move _352, _350) -> bb89
  using: _353@Entry, _352@Entry, _350@Entry
bb89:
  _348 = (*_349)[_350]
  using: _349@Mir(bb88[1]), _350@Mir(bb88[3])
  _354 = const {alloc618: *mut [u64; 50000]}
  using: 
  _356 = _10
  using: _10@Phi(bb214)
  _355 = move _356 as usize (IntToInt)
  using: _356@Mir(bb89[2])
  _357 = const 50000_usize
  using: 
  _358 = Lt(_355, _357)
  using: _355@Mir(bb89[3]), _357@Mir(bb89[4])
  assert(move _358, "index out of bounds: the length is {} but the index is {}", move _357, _355) -> bb90
  using: _358@Entry, _357@Entry, _355@Entry
bb90:
  (*_354)[_355] = move _348
  using: _354@Mir(bb89[1]), _355@Mir(bb89[3]), _348@Mir(bb89[0])
  _359 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb214)
  assert(!move (_359.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb91
  using: _359@Entry, _10@Entry
bb91:
  _10 = move (_359.0: i32)
  using: _359@Mir(bb90[1])
  goto -> bb92
  using: 
bb92:
  _361 = _9
  using: _9@Phi(bb92)
  _362 = const 50000_i32
  using: 
  _360 = Ge(move _361, move _362)
  using: _361@Mir(bb92[0]), _362@Mir(bb92[1])
  switchInt(move _360) -> [0: bb94, otherwise: bb93]
  using: _360@Mir(bb92[2])
bb93:
  _364 = const 50000_i32
  using: 
  _363 = bzip2recover::tooManyBlocks(move _364) -> bb94
  using: _364@Mir(bb93[0])
bb94:
  _365 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb92)
  assert(!move (_365.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb95
  using: _365@Entry, _9@Entry
bb95:
  _9 = move (_365.0: i32)
  using: _365@Mir(bb94[0])
  _366 = _11
  using: _11@Phi(bb75)
  _367 = const {alloc615: *mut [u64; 50000]}
  using: 
  _369 = _9
  using: _9@Mir(bb95[0])
  _368 = move _369 as usize (IntToInt)
  using: _369@Mir(bb95[3])
  _370 = const 50000_usize
  using: 
  _371 = Lt(_368, _370)
  using: _368@Mir(bb95[4]), _370@Mir(bb95[5])
  assert(move _371, "index out of bounds: the length is {} but the index is {}", move _370, _368) -> bb96
  using: _371@Entry, _370@Entry, _368@Entry
bb96:
  (*_367)[_368] = move _366
  using: _367@Mir(bb95[2]), _368@Mir(bb95[4]), _366@Mir(bb95[1])
  goto -> bb38
  using: 
bb97:
  _373 = _5
  using: _5@Mir(bb35[0])
  _372 = bzip2recover::bsClose(move _373) -> bb98
  using: _373@Mir(bb97[0])
bb98:
  _375 = _10
  using: _10@Phi(bb38)
  _376 = const 1_i32
  using: 
  _374 = Lt(move _375, move _376)
  using: _375@Mir(bb98[0]), _376@Mir(bb98[1])
  switchInt(move _374) -> [0: bb102, otherwise: bb99]
  using: _374@Mir(bb98[2])
bb99:
  _379 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _378 = (*_379)
  using: _379@Mir(bb99[0])
  _383 = const b"%s: sorry, I couldn\'t find any block boundaries.\n\x00"
  using: 
  _382 = &raw const (*_383)
  using: _383@Mir(bb99[2])
  _381 = move _382 as *const u8 (Pointer(ArrayToPointer))
  using: _382@Mir(bb99[3])
  _380 = move _381 as *const i8 (PtrToPtr)
  using: _381@Mir(bb99[4])
  _387 = const {alloc577: *mut [i8; 2000]}
  using: 
  _386 = &mut (*_387)
  using: _387@Mir(bb99[6])
  _385 = move _386 as &mut [i8] (Pointer(Unsize))
  using: _386@Mir(bb99[7])
  _384 = core::slice::<impl [i8]>::as_mut_ptr(move _385) -> bb100
  using: _385@Mir(bb99[8])
bb100:
  _377 = bzip2recover::fprintf(move _378, move _380, move _384) -> bb101
  using: _378@Mir(bb99[1]), _380@Mir(bb99[5]), _384@Mir(bb99[9])
bb101:
  _389 = const 1_i32
  using: 
  _388 = bzip2recover::exit(move _389)
  using: _389@Mir(bb101[0])
bb102:
  _392 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _391 = (*_392)
  using: _392@Mir(bb102[0])
  _396 = const b"%s: splitting into blocks\n\x00"
  using: 
  _395 = &raw const (*_396)
  using: _396@Mir(bb102[2])
  _394 = move _395 as *const u8 (Pointer(ArrayToPointer))
  using: _395@Mir(bb102[3])
  _393 = move _394 as *const i8 (PtrToPtr)
  using: _394@Mir(bb102[4])
  _400 = const {alloc577: *mut [i8; 2000]}
  using: 
  _399 = &mut (*_400)
  using: _400@Mir(bb102[6])
  _398 = move _399 as &mut [i8] (Pointer(Unsize))
  using: _399@Mir(bb102[7])
  _397 = core::slice::<impl [i8]>::as_mut_ptr(move _398) -> bb103
  using: _398@Mir(bb102[8])
bb103:
  _390 = bzip2recover::fprintf(move _391, move _393, move _397) -> bb104
  using: _391@Mir(bb102[1]), _393@Mir(bb102[5]), _397@Mir(bb102[9])
bb104:
  _406 = const {alloc578: *mut [i8; 2000]}
  using: 
  _405 = &mut (*_406)
  using: _406@Mir(bb104[0])
  _404 = move _405 as &mut [i8] (Pointer(Unsize))
  using: _405@Mir(bb104[1])
  _403 = core::slice::<impl [i8]>::as_mut_ptr(move _404) -> bb105
  using: _404@Mir(bb104[2])
bb105:
  _402 = move _403 as *const i8 (Pointer(MutToConstPointer))
  using: _403@Mir(bb104[3])
  _410 = const b"rb\x00"
  using: 
  _409 = &raw const (*_410)
  using: _410@Mir(bb105[1])
  _408 = move _409 as *const u8 (Pointer(ArrayToPointer))
  using: _409@Mir(bb105[2])
  _407 = move _408 as *const i8 (PtrToPtr)
  using: _408@Mir(bb105[3])
  _401 = bzip2recover::fopen(move _402, move _407) -> bb106
  using: _402@Mir(bb105[0]), _407@Mir(bb105[4])
bb106:
  _3 = move _401
  using: _401@Mir(bb105[5])
  _412 = _3
  using: _3@Mir(bb106[0])
  _411 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _412) -> bb107
  using: _412@Mir(bb106[1])
bb107:
  switchInt(move _411) -> [0: bb112, otherwise: bb108]
  using: _411@Mir(bb106[2])
bb108:
  _415 = _3
  using: _3@Mir(bb106[0])
  _414 = move _415 as usize (PointerExposeAddress)
  using: _415@Mir(bb108[0])
  _413 = Eq(move _414, const 0_usize)
  using: _414@Mir(bb108[1])
  assume(move _413)
  using: _413@Mir(bb108[2])
  _418 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _417 = (*_418)
  using: _418@Mir(bb108[4])
  _422 = const b"%s: can\'t open `%s\'\n\x00"
  using: 
  _421 = &raw const (*_422)
  using: _422@Mir(bb108[6])
  _420 = move _421 as *const u8 (Pointer(ArrayToPointer))
  using: _421@Mir(bb108[7])
  _419 = move _420 as *const i8 (PtrToPtr)
  using: _420@Mir(bb108[8])
  _426 = const {alloc577: *mut [i8; 2000]}
  using: 
  _425 = &mut (*_426)
  using: _426@Mir(bb108[10])
  _424 = move _425 as &mut [i8] (Pointer(Unsize))
  using: _425@Mir(bb108[11])
  _423 = core::slice::<impl [i8]>::as_mut_ptr(move _424) -> bb109
  using: _424@Mir(bb108[12])
bb109:
  _430 = const {alloc578: *mut [i8; 2000]}
  using: 
  _429 = &mut (*_430)
  using: _430@Mir(bb109[0])
  _428 = move _429 as &mut [i8] (Pointer(Unsize))
  using: _429@Mir(bb109[1])
  _427 = core::slice::<impl [i8]>::as_mut_ptr(move _428) -> bb110
  using: _428@Mir(bb109[2])
bb110:
  _416 = bzip2recover::fprintf(move _417, move _419, move _423, move _427) -> bb111
  using: _417@Mir(bb108[5]), _419@Mir(bb108[9]), _423@Mir(bb108[13]), _427@Mir(bb109[3])
bb111:
  _432 = const 1_i32
  using: 
  _431 = bzip2recover::exit(move _432)
  using: _432@Mir(bb111[0])
bb112:
  _434 = _3
  using: _3@Mir(bb106[0])
  _433 = bzip2recover::bsOpenReadStream(move _434) -> bb113
  using: _434@Mir(bb112[0])
bb113:
  _5 = move _433
  using: _433@Mir(bb112[1])
  _14 = const 0_u32
  using: 
  _6 = const {0x0 as *mut bzip2recover::BitStream}
  using: 
  _11 = const 0_u64
  using: 
  _4 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _8 = const 0_i32
  using: 
  goto -> bb114
  using: 
bb114:
  _436 = _5
  using: _5@Mir(bb113[0])
  _435 = bzip2recover::bsGetBit(move _436) -> bb115
  using: _436@Mir(bb114[0])
bb115:
  _7 = move _435
  using: _435@Mir(bb114[1])
  _438 = _7
  using: _7@Mir(bb115[0])
  _439 = const 2_i32
  using: 
  _437 = Eq(move _438, move _439)
  using: _438@Mir(bb115[1]), _439@Mir(bb115[2])
  switchInt(move _437) -> [0: bb116, otherwise: bb214]
  using: _437@Mir(bb115[3])
bb116:
  _441 = _12
  using: _12@Phi(bb114)
  _442 = const 1_i32
  using: 
  _443 = CheckedShl(_441, _442)
  using: _441@Mir(bb116[0]), _442@Mir(bb116[1])
  assert(!move (_443.1: bool), "attempt to shift left by `{}`, which would overflow", move _442) -> bb117
  using: _443@Entry, _441@Entry, _442@Entry
bb117:
  _440 = move (_443.0: u32)
  using: _443@Mir(bb116[2])
  _445 = _13
  using: _13@Phi(bb114)
  _446 = const 31_i32
  using: 
  _447 = CheckedShr(_445, _446)
  using: _445@Mir(bb117[1]), _446@Mir(bb117[2])
  assert(!move (_447.1: bool), "attempt to shift right by `{}`, which would overflow", move _446) -> bb118
  using: _447@Entry, _445@Entry, _446@Entry
bb118:
  _444 = move (_447.0: u32)
  using: _447@Mir(bb117[3])
  _12 = BitOr(move _440, move _444)
  using: _440@Mir(bb117[0]), _444@Mir(bb118[0])
  _449 = _13
  using: _13@Phi(bb114)
  _450 = const 1_i32
  using: 
  _451 = CheckedShl(_449, _450)
  using: _449@Mir(bb118[2]), _450@Mir(bb118[3])
  assert(!move (_451.1: bool), "attempt to shift left by `{}`, which would overflow", move _450) -> bb119
  using: _451@Entry, _449@Entry, _450@Entry
bb119:
  _448 = move (_451.0: u32)
  using: _451@Mir(bb118[4])
  _454 = _7
  using: _7@Mir(bb115[0])
  _455 = const 1_i32
  using: 
  _453 = BitAnd(move _454, move _455)
  using: _454@Mir(bb119[1]), _455@Mir(bb119[2])
  _452 = move _453 as u32 (IntToInt)
  using: _453@Mir(bb119[3])
  _13 = BitOr(move _448, move _452)
  using: _448@Mir(bb119[0]), _452@Mir(bb119[4])
  _457 = _11
  using: _11@Phi(bb114)
  _459 = const 47_u64
  using: 
  _461 = const {alloc617: *mut [u64; 50000]}
  using: 
  _463 = _8
  using: _8@Phi(bb114)
  _462 = move _463 as usize (IntToInt)
  using: _463@Mir(bb119[9])
  _464 = const 50000_usize
  using: 
  _465 = Lt(_462, _464)
  using: _462@Mir(bb119[10]), _464@Mir(bb119[11])
  assert(move _465, "index out of bounds: the length is {} but the index is {}", move _464, _462) -> bb120
  using: _465@Entry, _464@Entry, _462@Entry
bb120:
  _460 = (*_461)[_462]
  using: _461@Mir(bb119[8]), _462@Mir(bb119[10])
  _458 = core::num::<impl u64>::wrapping_add(move _459, move _460) -> bb121
  using: _459@Mir(bb119[7]), _460@Mir(bb120[0])
bb121:
  _456 = Eq(move _457, move _458)
  using: _457@Mir(bb119[6]), _458@Mir(bb120[1])
  switchInt(move _456) -> [0: bb125, otherwise: bb122]
  using: _456@Mir(bb121[0])
bb122:
  _467 = _12
  using: _12@Mir(bb118[1])
  _468 = const 16_i32
  using: 
  _469 = CheckedShl(_467, _468)
  using: _467@Mir(bb122[0]), _468@Mir(bb122[1])
  assert(!move (_469.1: bool), "attempt to shift left by `{}`, which would overflow", move _468) -> bb123
  using: _469@Entry, _467@Entry, _468@Entry
bb123:
  _466 = move (_469.0: u32)
  using: _469@Mir(bb122[2])
  _471 = _13
  using: _13@Mir(bb119[5])
  _472 = const 16_i32
  using: 
  _473 = CheckedShr(_471, _472)
  using: _471@Mir(bb123[1]), _472@Mir(bb123[2])
  assert(!move (_473.1: bool), "attempt to shift right by `{}`, which would overflow", move _472) -> bb124
  using: _473@Entry, _471@Entry, _472@Entry
bb124:
  _470 = move (_473.0: u32)
  using: _473@Mir(bb123[3])
  _14 = BitOr(move _466, move _470)
  using: _466@Mir(bb123[0]), _470@Mir(bb124[0])
  goto -> bb125
  using: 
bb125:
  _478 = _4
  using: _4@Phi(bb114)
  _477 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _478) -> bb132
  using: _478@Mir(bb125[0])
bb126:
  _474 = const false
  using: 
  goto -> bb128
  using: 
bb127:
  _488 = _11
  using: _11@Phi(bb131)
  _490 = const {alloc618: *mut [u64; 50000]}
  using: 
  _492 = _8
  using: _8@Phi(bb131)
  _491 = move _492 as usize (IntToInt)
  using: _492@Mir(bb127[2])
  _493 = const 50000_usize
  using: 
  _494 = Lt(_491, _493)
  using: _491@Mir(bb127[3]), _493@Mir(bb127[4])
  assert(move _494, "index out of bounds: the length is {} but the index is {}", move _493, _491) -> bb134
  using: _494@Entry, _493@Entry, _491@Entry
bb128:
  switchInt(move _474) -> [0: bb136, otherwise: bb135]
  using: _474@Phi(bb128)
bb129:
  _475 = const false
  using: 
  goto -> bb131
  using: 
bb130:
  _480 = _11
  using: _11@Phi(bb114)
  _482 = const {alloc617: *mut [u64; 50000]}
  using: 
  _484 = _8
  using: _8@Phi(bb114)
  _483 = move _484 as usize (IntToInt)
  using: _484@Mir(bb130[2])
  _485 = const 50000_usize
  using: 
  _486 = Lt(_483, _485)
  using: _483@Mir(bb130[3]), _485@Mir(bb130[4])
  assert(move _486, "index out of bounds: the length is {} but the index is {}", move _485, _483) -> bb133
  using: _486@Entry, _485@Entry, _483@Entry
bb131:
  switchInt(move _475) -> [0: bb126, otherwise: bb127]
  using: _475@Phi(bb131)
bb132:
  _476 = Not(move _477)
  using: _477@Mir(bb125[1])
  switchInt(move _476) -> [0: bb129, otherwise: bb130]
  using: _476@Mir(bb132[0])
bb133:
  _481 = (*_482)[_483]
  using: _482@Mir(bb130[1]), _483@Mir(bb130[3])
  _479 = Ge(move _480, move _481)
  using: _480@Mir(bb130[0]), _481@Mir(bb133[0])
  _475 = move _479
  using: _479@Mir(bb133[1])
  goto -> bb131
  using: 
bb134:
  _489 = (*_490)[_491]
  using: _490@Mir(bb127[1]), _491@Mir(bb127[3])
  _487 = Le(move _488, move _489)
  using: _488@Mir(bb127[0]), _489@Mir(bb134[0])
  _474 = move _487
  using: _487@Mir(bb134[1])
  goto -> bb128
  using: 
bb135:
  _496 = _6
  using: _6@Phi(bb114)
  _497 = _7
  using: _7@Mir(bb115[0])
  _495 = bzip2recover::bsPutBit(move _496, move _497) -> bb136
  using: _496@Mir(bb135[0]), _497@Mir(bb135[1])
bb136:
  _499 = _11
  using: _11@Phi(bb128)
  _498 = core::num::<impl u64>::wrapping_add(move _499, const 1_u64) -> bb137
  using: _499@Mir(bb136[0])
bb137:
  _11 = move _498
  using: _498@Mir(bb136[1])
  _501 = _11
  using: _11@Mir(bb137[0])
  _504 = const {alloc618: *mut [u64; 50000]}
  using: 
  _506 = _8
  using: _8@Phi(bb128)
  _505 = move _506 as usize (IntToInt)
  using: _506@Mir(bb137[3])
  _507 = const 50000_usize
  using: 
  _508 = Lt(_505, _507)
  using: _505@Mir(bb137[4]), _507@Mir(bb137[5])
  assert(move _508, "index out of bounds: the length is {} but the index is {}", move _507, _505) -> bb138
  using: _508@Entry, _507@Entry, _505@Entry
bb138:
  _503 = (*_504)[_505]
  using: _504@Mir(bb137[2]), _505@Mir(bb137[4])
  _509 = const 1_u64
  using: 
  _502 = core::num::<impl u64>::wrapping_add(move _503, move _509) -> bb139
  using: _503@Mir(bb138[0]), _509@Mir(bb138[1])
bb139:
  _500 = Eq(move _501, move _502)
  using: _501@Mir(bb137[1]), _502@Mir(bb138[2])
  switchInt(move _500) -> [0: bb155, otherwise: bb140]
  using: _500@Mir(bb139[0])
bb140:
  _512 = _4
  using: _4@Phi(bb114)
  _511 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _512) -> bb141
  using: _512@Mir(bb140[0])
bb141:
  _510 = Not(move _511)
  using: _511@Mir(bb140[1])
  switchInt(move _510) -> [0: bb151, otherwise: bb142]
  using: _510@Mir(bb141[0])
bb142:
  _514 = _6
  using: _6@Phi(bb136)
  _515 = const 23_u8
  using: 
  _513 = bzip2recover::bsPutUChar(move _514, move _515) -> bb143
  using: _514@Mir(bb142[0]), _515@Mir(bb142[1])
bb143:
  _517 = _6
  using: _6@Phi(bb136)
  _518 = const 114_u8
  using: 
  _516 = bzip2recover::bsPutUChar(move _517, move _518) -> bb144
  using: _517@Mir(bb143[0]), _518@Mir(bb143[1])
bb144:
  _520 = _6
  using: _6@Phi(bb136)
  _521 = const 69_u8
  using: 
  _519 = bzip2recover::bsPutUChar(move _520, move _521) -> bb145
  using: _520@Mir(bb144[0]), _521@Mir(bb144[1])
bb145:
  _523 = _6
  using: _6@Phi(bb136)
  _524 = const 56_u8
  using: 
  _522 = bzip2recover::bsPutUChar(move _523, move _524) -> bb146
  using: _523@Mir(bb145[0]), _524@Mir(bb145[1])
bb146:
  _526 = _6
  using: _6@Phi(bb136)
  _527 = const 80_u8
  using: 
  _525 = bzip2recover::bsPutUChar(move _526, move _527) -> bb147
  using: _526@Mir(bb146[0]), _527@Mir(bb146[1])
bb147:
  _529 = _6
  using: _6@Phi(bb136)
  _530 = const 144_u8
  using: 
  _528 = bzip2recover::bsPutUChar(move _529, move _530) -> bb148
  using: _529@Mir(bb147[0]), _530@Mir(bb147[1])
bb148:
  _532 = _6
  using: _6@Phi(bb136)
  _533 = _14
  using: _14@Phi(bb125)
  _531 = bzip2recover::bsPutUInt32(move _532, move _533) -> bb149
  using: _532@Mir(bb148[0]), _533@Mir(bb148[1])
bb149:
  _535 = _6
  using: _6@Phi(bb136)
  _534 = bzip2recover::bsClose(move _535) -> bb150
  using: _535@Mir(bb149[0])
bb150:
  _4 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  goto -> bb152
  using: 
bb151:
  _538 = _4
  using: _4@Phi(bb114)
  _537 = move _538 as usize (PointerExposeAddress)
  using: _538@Mir(bb151[0])
  _536 = Eq(move _537, const 0_usize)
  using: _537@Mir(bb151[1])
  assume(move _536)
  using: _536@Mir(bb151[2])
  goto -> bb152
  using: 
bb152:
  _540 = _8
  using: _8@Phi(bb128)
  _541 = _10
  using: _10@Phi(bb114)
  _539 = Ge(move _540, move _541)
  using: _540@Mir(bb152[0]), _541@Mir(bb152[1])
  switchInt(move _539) -> [0: bb153, otherwise: bb214]
  using: _539@Mir(bb152[2])
bb153:
  _542 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb128)
  assert(!move (_542.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb154
  using: _542@Entry, _8@Entry
bb154:
  _8 = move (_542.0: i32)
  using: _542@Mir(bb153[0])
  goto -> bb114
  using: 
bb155:
  _544 = _11
  using: _11@Mir(bb137[0])
  _546 = const {alloc617: *mut [u64; 50000]}
  using: 
  _548 = _8
  using: _8@Phi(bb128)
  _547 = move _548 as usize (IntToInt)
  using: _548@Mir(bb155[2])
  _549 = const 50000_usize
  using: 
  _550 = Lt(_547, _549)
  using: _547@Mir(bb155[3]), _549@Mir(bb155[4])
  assert(move _550, "index out of bounds: the length is {} but the index is {}", move _549, _547) -> bb156
  using: _550@Entry, _549@Entry, _547@Entry
bb156:
  _545 = (*_546)[_547]
  using: _546@Mir(bb155[1]), _547@Mir(bb155[3])
  _543 = Eq(move _544, move _545)
  using: _544@Mir(bb155[0]), _545@Mir(bb156[0])
  switchInt(move _543) -> [0: bb114, otherwise: bb157]
  using: _543@Mir(bb156[1])
bb157:
  _551 = const {0x0 as *mut i8}
  using: 
  _552 = const 0_i32
  using: 
  _553 = const 0_i32
  using: 
  _553 = const 0_i32
  using: 
  goto -> bb158
  using: 
bb158:
  _555 = _553
  using: _553@Phi(bb158)
  _556 = const 2000_i32
  using: 
  _554 = Lt(move _555, move _556)
  using: _555@Mir(bb158[0]), _556@Mir(bb158[1])
  switchInt(move _554) -> [0: bb162, otherwise: bb159]
  using: _554@Mir(bb158[2])
bb159:
  _557 = const 0_i32
  using: 
  _558 = const {alloc614: *mut [i8; 2000]}
  using: 
  _560 = _553
  using: _553@Phi(bb158)
  _559 = move _560 as usize (IntToInt)
  using: _560@Mir(bb159[2])
  _561 = const 2000_usize
  using: 
  _562 = Lt(_559, _561)
  using: _559@Mir(bb159[3]), _561@Mir(bb159[4])
  assert(move _562, "index out of bounds: the length is {} but the index is {}", move _561, _559) -> bb160
  using: _562@Entry, _561@Entry, _559@Entry
bb160:
  (*_558)[_559] = move _557 as i8 (IntToInt)
  using: _558@Mir(bb159[1]), _559@Mir(bb159[3]), _557@Mir(bb159[0])
  _563 = CheckedAdd(_553, const 1_i32)
  using: _553@Phi(bb158)
  assert(!move (_563.1: bool), "attempt to compute `{} + {}`, which would overflow", _553, const 1_i32) -> bb161
  using: _563@Entry, _553@Entry
bb161:
  _553 = move (_563.0: i32)
  using: _563@Mir(bb160[1])
  goto -> bb158
  using: 
bb162:
  _568 = const {alloc614: *mut [i8; 2000]}
  using: 
  _567 = &mut (*_568)
  using: _568@Mir(bb162[0])
  _566 = move _567 as &mut [i8] (Pointer(Unsize))
  using: _567@Mir(bb162[1])
  _565 = core::slice::<impl [i8]>::as_mut_ptr(move _566) -> bb163
  using: _566@Mir(bb162[2])
bb163:
  _573 = const {alloc578: *mut [i8; 2000]}
  using: 
  _572 = &mut (*_573)
  using: _573@Mir(bb163[0])
  _571 = move _572 as &mut [i8] (Pointer(Unsize))
  using: _572@Mir(bb163[1])
  _570 = core::slice::<impl [i8]>::as_mut_ptr(move _571) -> bb164
  using: _571@Mir(bb163[2])
bb164:
  _569 = move _570 as *const i8 (Pointer(MutToConstPointer))
  using: _570@Mir(bb163[3])
  _564 = bzip2recover::strcpy(move _565, move _569) -> bb165
  using: _565@Mir(bb162[3]), _569@Mir(bb164[0])
bb165:
  _579 = const {alloc614: *mut [i8; 2000]}
  using: 
  _578 = &mut (*_579)
  using: _579@Mir(bb165[0])
  _577 = move _578 as &mut [i8] (Pointer(Unsize))
  using: _578@Mir(bb165[1])
  _576 = core::slice::<impl [i8]>::as_mut_ptr(move _577) -> bb166
  using: _577@Mir(bb165[2])
bb166:
  _575 = move _576 as *const i8 (Pointer(MutToConstPointer))
  using: _576@Mir(bb165[3])
  _580 = const 47_i32
  using: 
  _574 = bzip2recover::strrchr(move _575, move _580) -> bb167
  using: _575@Mir(bb166[0]), _580@Mir(bb166[1])
bb167:
  _551 = move _574
  using: _574@Mir(bb166[2])
  _582 = _551
  using: _551@Mir(bb167[0])
  _581 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _582) -> bb168
  using: _582@Mir(bb167[1])
bb168:
  switchInt(move _581) -> [0: bb171, otherwise: bb169]
  using: _581@Mir(bb167[2])
bb169:
  _585 = _551
  using: _551@Mir(bb167[0])
  _584 = move _585 as usize (PointerExposeAddress)
  using: _585@Mir(bb169[0])
  _583 = Eq(move _584, const 0_usize)
  using: _584@Mir(bb169[1])
  assume(move _583)
  using: _583@Mir(bb169[2])
  _589 = const {alloc614: *mut [i8; 2000]}
  using: 
  _588 = &mut (*_589)
  using: _589@Mir(bb169[4])
  _587 = move _588 as &mut [i8] (Pointer(Unsize))
  using: _588@Mir(bb169[5])
  _586 = core::slice::<impl [i8]>::as_mut_ptr(move _587) -> bb170
  using: _587@Mir(bb169[6])
bb170:
  _551 = move _586
  using: _586@Mir(bb169[7])
  goto -> bb173
  using: 
bb171:
  _591 = _551
  using: _551@Mir(bb167[0])
  _590 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _591, const 1_isize) -> bb172
  using: _591@Mir(bb171[0])
bb172:
  _551 = move _590
  using: _590@Mir(bb171[1])
  goto -> bb173
  using: 
bb173:
  _594 = _551
  using: _551@Phi(bb173)
  _599 = const {alloc614: *mut [i8; 2000]}
  using: 
  _598 = &mut (*_599)
  using: _599@Mir(bb173[1])
  _597 = move _598 as &mut [i8] (Pointer(Unsize))
  using: _598@Mir(bb173[2])
  _596 = core::slice::<impl [i8]>::as_mut_ptr(move _597) -> bb174
  using: _597@Mir(bb173[3])
bb174:
  _595 = move _596 as *const i8 (Pointer(MutToConstPointer))
  using: _596@Mir(bb173[4])
  _593 = std::ptr::mut_ptr::<impl *mut i8>::offset_from(move _594, move _595) -> bb175
  using: _594@Mir(bb173[0]), _595@Mir(bb174[0])
bb175:
  _592 = move _593 as i64 (IntToInt)
  using: _593@Mir(bb174[1])
  _552 = move _592 as i32 (IntToInt)
  using: _592@Mir(bb175[0])
  _601 = _551
  using: _551@Phi(bb173)
  _605 = const b"rec%5d\x00"
  using: 
  _604 = &raw const (*_605)
  using: _605@Mir(bb175[3])
  _603 = move _604 as *const u8 (Pointer(ArrayToPointer))
  using: _604@Mir(bb175[4])
  _602 = move _603 as *const i8 (PtrToPtr)
  using: _603@Mir(bb175[5])
  _607 = _8
  using: _8@Phi(bb128)
  _608 = const 1_i32
  using: 
  _609 = CheckedAdd(_607, _608)
  using: _607@Mir(bb175[7]), _608@Mir(bb175[8])
  assert(!move (_609.1: bool), "attempt to compute `{} + {}`, which would overflow", move _607, move _608) -> bb176
  using: _609@Entry, _607@Entry, _608@Entry
bb176:
  _606 = move (_609.0: i32)
  using: _609@Mir(bb175[9])
  _600 = bzip2recover::sprintf(move _601, move _602, move _606) -> bb177
  using: _601@Mir(bb175[2]), _602@Mir(bb175[6]), _606@Mir(bb176[0])
bb177:
  _610 = _551
  using: _551@Phi(bb173)
  _15 = move _610
  using: _610@Mir(bb177[0])
  goto -> bb178
  using: 
bb178:
  _613 = (*_15)
  using: _15@Phi(bb178)
  _612 = move _613 as i32 (IntToInt)
  using: _613@Mir(bb178[0])
  _614 = const 0_i32
  using: 
  _611 = Ne(move _612, move _614)
  using: _612@Mir(bb178[1]), _614@Mir(bb178[2])
  switchInt(move _611) -> [0: bb183, otherwise: bb179]
  using: _611@Mir(bb178[3])
bb179:
  _617 = (*_15)
  using: _15@Phi(bb178)
  _616 = move _617 as i32 (IntToInt)
  using: _617@Mir(bb179[0])
  _618 = const 32_i32
  using: 
  _615 = Eq(move _616, move _618)
  using: _616@Mir(bb179[1]), _618@Mir(bb179[2])
  switchInt(move _615) -> [0: bb181, otherwise: bb180]
  using: _615@Mir(bb179[3])
bb180:
  _619 = const 48_i32
  using: 
  (*_15) = move _619 as i8 (IntToInt)
  using: _15@Phi(bb178), _619@Mir(bb180[0])
  goto -> bb181
  using: 
bb181:
  _621 = _15
  using: _15@Phi(bb181)
  _620 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _621, const 1_isize) -> bb182
  using: _621@Mir(bb181[0])
bb182:
  _15 = move _620
  using: _620@Mir(bb181[1])
  goto -> bb178
  using: 
bb183:
  _626 = const {alloc614: *mut [i8; 2000]}
  using: 
  _625 = &mut (*_626)
  using: _626@Mir(bb183[0])
  _624 = move _625 as &mut [i8] (Pointer(Unsize))
  using: _625@Mir(bb183[1])
  _623 = core::slice::<impl [i8]>::as_mut_ptr(move _624) -> bb184
  using: _624@Mir(bb183[2])
bb184:
  _632 = const {alloc578: *mut [i8; 2000]}
  using: 
  _631 = &mut (*_632)
  using: _632@Mir(bb184[0])
  _630 = move _631 as &mut [i8] (Pointer(Unsize))
  using: _631@Mir(bb184[1])
  _629 = core::slice::<impl [i8]>::as_mut_ptr(move _630) -> bb185
  using: _630@Mir(bb184[2])
bb185:
  _634 = _552
  using: _552@Mir(bb175[1])
  _633 = move _634 as isize (IntToInt)
  using: _634@Mir(bb185[0])
  _628 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _629, move _633) -> bb186
  using: _629@Mir(bb184[3]), _633@Mir(bb185[1])
bb186:
  _627 = move _628 as *const i8 (Pointer(MutToConstPointer))
  using: _628@Mir(bb185[2])
  _622 = bzip2recover::strcat(move _623, move _627) -> bb187
  using: _623@Mir(bb183[3]), _627@Mir(bb186[0])
bb187:
  _639 = const {alloc614: *mut [i8; 2000]}
  using: 
  _638 = &mut (*_639)
  using: _639@Mir(bb187[0])
  _637 = move _638 as &mut [i8] (Pointer(Unsize))
  using: _638@Mir(bb187[1])
  _636 = core::slice::<impl [i8]>::as_mut_ptr(move _637) -> bb188
  using: _637@Mir(bb187[2])
bb188:
  _635 = bzip2recover::endsInBz2(move _636) -> bb189
  using: _636@Mir(bb187[3])
bb189:
  switchInt(move _635) -> [0: bb190, otherwise: bb192]
  using: _635@Mir(bb188[0])
bb190:
  _644 = const {alloc614: *mut [i8; 2000]}
  using: 
  _643 = &mut (*_644)
  using: _644@Mir(bb190[0])
  _642 = move _643 as &mut [i8] (Pointer(Unsize))
  using: _643@Mir(bb190[1])
  _641 = core::slice::<impl [i8]>::as_mut_ptr(move _642) -> bb191
  using: _642@Mir(bb190[2])
bb191:
  _648 = const b".bz2\x00"
  using: 
  _647 = &raw const (*_648)
  using: _648@Mir(bb191[0])
  _646 = move _647 as *const u8 (Pointer(ArrayToPointer))
  using: _647@Mir(bb191[1])
  _645 = move _646 as *const i8 (PtrToPtr)
  using: _646@Mir(bb191[2])
  _640 = bzip2recover::strcat(move _641, move _645) -> bb192
  using: _641@Mir(bb190[3]), _645@Mir(bb191[3])
bb192:
  _651 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _650 = (*_651)
  using: _651@Mir(bb192[0])
  _655 = const b"   writing block %d to `%s\' ...\n\x00"
  using: 
  _654 = &raw const (*_655)
  using: _655@Mir(bb192[2])
  _653 = move _654 as *const u8 (Pointer(ArrayToPointer))
  using: _654@Mir(bb192[3])
  _652 = move _653 as *const i8 (PtrToPtr)
  using: _653@Mir(bb192[4])
  _657 = _8
  using: _8@Phi(bb128)
  _658 = const 1_i32
  using: 
  _659 = CheckedAdd(_657, _658)
  using: _657@Mir(bb192[6]), _658@Mir(bb192[7])
  assert(!move (_659.1: bool), "attempt to compute `{} + {}`, which would overflow", move _657, move _658) -> bb193
  using: _659@Entry, _657@Entry, _658@Entry
bb193:
  _656 = move (_659.0: i32)
  using: _659@Mir(bb192[8])
  _663 = const {alloc614: *mut [i8; 2000]}
  using: 
  _662 = &mut (*_663)
  using: _663@Mir(bb193[1])
  _661 = move _662 as &mut [i8] (Pointer(Unsize))
  using: _662@Mir(bb193[2])
  _660 = core::slice::<impl [i8]>::as_mut_ptr(move _661) -> bb194
  using: _661@Mir(bb193[3])
bb194:
  _649 = bzip2recover::fprintf(move _650, move _652, move _656, move _660) -> bb195
  using: _650@Mir(bb192[1]), _652@Mir(bb192[5]), _656@Mir(bb193[0]), _660@Mir(bb193[4])
bb195:
  _669 = const {alloc614: *mut [i8; 2000]}
  using: 
  _668 = &mut (*_669)
  using: _669@Mir(bb195[0])
  _667 = move _668 as &mut [i8] (Pointer(Unsize))
  using: _668@Mir(bb195[1])
  _666 = core::slice::<impl [i8]>::as_mut_ptr(move _667) -> bb196
  using: _667@Mir(bb195[2])
bb196:
  _665 = move _666 as *const i8 (Pointer(MutToConstPointer))
  using: _666@Mir(bb195[3])
  _673 = const b"wb\x00"
  using: 
  _672 = &raw const (*_673)
  using: _673@Mir(bb196[1])
  _671 = move _672 as *const u8 (Pointer(ArrayToPointer))
  using: _672@Mir(bb196[2])
  _670 = move _671 as *const i8 (PtrToPtr)
  using: _671@Mir(bb196[3])
  _664 = bzip2recover::fopen(move _665, move _670) -> bb197
  using: _665@Mir(bb196[0]), _670@Mir(bb196[4])
bb197:
  _4 = move _664
  using: _664@Mir(bb196[5])
  _675 = _4
  using: _4@Mir(bb197[0])
  _674 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _675) -> bb198
  using: _675@Mir(bb197[1])
bb198:
  switchInt(move _674) -> [0: bb203, otherwise: bb199]
  using: _674@Mir(bb197[2])
bb199:
  _678 = _4
  using: _4@Mir(bb197[0])
  _677 = move _678 as usize (PointerExposeAddress)
  using: _678@Mir(bb199[0])
  _676 = Eq(move _677, const 0_usize)
  using: _677@Mir(bb199[1])
  assume(move _676)
  using: _676@Mir(bb199[2])
  _681 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _680 = (*_681)
  using: _681@Mir(bb199[4])
  _685 = const b"%s: can\'t write `%s\'\n\x00"
  using: 
  _684 = &raw const (*_685)
  using: _685@Mir(bb199[6])
  _683 = move _684 as *const u8 (Pointer(ArrayToPointer))
  using: _684@Mir(bb199[7])
  _682 = move _683 as *const i8 (PtrToPtr)
  using: _683@Mir(bb199[8])
  _689 = const {alloc577: *mut [i8; 2000]}
  using: 
  _688 = &mut (*_689)
  using: _689@Mir(bb199[10])
  _687 = move _688 as &mut [i8] (Pointer(Unsize))
  using: _688@Mir(bb199[11])
  _686 = core::slice::<impl [i8]>::as_mut_ptr(move _687) -> bb200
  using: _687@Mir(bb199[12])
bb200:
  _693 = const {alloc614: *mut [i8; 2000]}
  using: 
  _692 = &mut (*_693)
  using: _693@Mir(bb200[0])
  _691 = move _692 as &mut [i8] (Pointer(Unsize))
  using: _692@Mir(bb200[1])
  _690 = core::slice::<impl [i8]>::as_mut_ptr(move _691) -> bb201
  using: _691@Mir(bb200[2])
bb201:
  _679 = bzip2recover::fprintf(move _680, move _682, move _686, move _690) -> bb202
  using: _680@Mir(bb199[5]), _682@Mir(bb199[9]), _686@Mir(bb199[13]), _690@Mir(bb200[3])
bb202:
  _695 = const 1_i32
  using: 
  _694 = bzip2recover::exit(move _695)
  using: _695@Mir(bb202[0])
bb203:
  _697 = _4
  using: _4@Mir(bb197[0])
  _696 = bzip2recover::bsOpenWriteStream(move _697) -> bb204
  using: _697@Mir(bb203[0])
bb204:
  _6 = move _696
  using: _696@Mir(bb203[1])
  _699 = _6
  using: _6@Mir(bb204[0])
  _700 = const 66_u8
  using: 
  _698 = bzip2recover::bsPutUChar(move _699, move _700) -> bb205
  using: _699@Mir(bb204[1]), _700@Mir(bb204[2])
bb205:
  _702 = _6
  using: _6@Mir(bb204[0])
  _703 = const 90_u8
  using: 
  _701 = bzip2recover::bsPutUChar(move _702, move _703) -> bb206
  using: _702@Mir(bb205[0]), _703@Mir(bb205[1])
bb206:
  _705 = _6
  using: _6@Mir(bb204[0])
  _706 = const 104_u8
  using: 
  _704 = bzip2recover::bsPutUChar(move _705, move _706) -> bb207
  using: _705@Mir(bb206[0]), _706@Mir(bb206[1])
bb207:
  _708 = _6
  using: _6@Mir(bb204[0])
  _709 = const 57_u8
  using: 
  _707 = bzip2recover::bsPutUChar(move _708, move _709) -> bb208
  using: _708@Mir(bb207[0]), _709@Mir(bb207[1])
bb208:
  _711 = _6
  using: _6@Mir(bb204[0])
  _712 = const 49_u8
  using: 
  _710 = bzip2recover::bsPutUChar(move _711, move _712) -> bb209
  using: _711@Mir(bb208[0]), _712@Mir(bb208[1])
bb209:
  _714 = _6
  using: _6@Mir(bb204[0])
  _715 = const 65_u8
  using: 
  _713 = bzip2recover::bsPutUChar(move _714, move _715) -> bb210
  using: _714@Mir(bb209[0]), _715@Mir(bb209[1])
bb210:
  _717 = _6
  using: _6@Mir(bb204[0])
  _718 = const 89_u8
  using: 
  _716 = bzip2recover::bsPutUChar(move _717, move _718) -> bb211
  using: _717@Mir(bb210[0]), _718@Mir(bb210[1])
bb211:
  _720 = _6
  using: _6@Mir(bb204[0])
  _721 = const 38_u8
  using: 
  _719 = bzip2recover::bsPutUChar(move _720, move _721) -> bb212
  using: _720@Mir(bb211[0]), _721@Mir(bb211[1])
bb212:
  _723 = _6
  using: _6@Mir(bb204[0])
  _724 = const 83_u8
  using: 
  _722 = bzip2recover::bsPutUChar(move _723, move _724) -> bb213
  using: _723@Mir(bb212[0]), _724@Mir(bb212[1])
bb213:
  _726 = _6
  using: _6@Mir(bb204[0])
  _727 = const 89_u8
  using: 
  _725 = bzip2recover::bsPutUChar(move _726, move _727) -> bb114
  using: _726@Mir(bb213[0]), _727@Mir(bb213[1])
bb214:
  _730 = const {alloc576: *mut *mut blocksort::__sFILE}
  using: 
  _729 = (*_730)
  using: _730@Mir(bb214[0])
  _734 = const b"%s: finished\n\x00"
  using: 
  _733 = &raw const (*_734)
  using: _734@Mir(bb214[2])
  _732 = move _733 as *const u8 (Pointer(ArrayToPointer))
  using: _733@Mir(bb214[3])
  _731 = move _732 as *const i8 (PtrToPtr)
  using: _732@Mir(bb214[4])
  _738 = const {alloc577: *mut [i8; 2000]}
  using: 
  _737 = &mut (*_738)
  using: _738@Mir(bb214[6])
  _736 = move _737 as &mut [i8] (Pointer(Unsize))
  using: _737@Mir(bb214[7])
  _735 = core::slice::<impl [i8]>::as_mut_ptr(move _736) -> bb215
  using: _736@Mir(bb214[8])
bb215:
  _728 = bzip2recover::fprintf(move _729, move _731, move _735) -> bb216
  using: _729@Mir(bb214[1]), _731@Mir(bb214[5]), _735@Mir(bb214[9])
bb216:
  _0 = const 0_i32
  using: 
  return
  using: _0@Mir(bb216[0])
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:301:42: 301:83 (#0) by default
rewrite call bzip2recover::strncpy @ workspace/bzip2/rust/bzip2recover.rs:301:5: 302:95 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:308:5: 310:61 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:312:9: 315:39 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzip2recover.rs:316:15: 316:51 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:331:17: 333:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:318:17: 320:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:323:17: 325:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:326:17: 328:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:336:9: 336:39 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:338:21: 338:62 (#0) by default
rewrite call bzip2recover::strlen @ workspace/bzip2/rust/bzip2recover.rs:338:8: 338:63 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:344:30: 344:71 (#0) by default
rewrite call bzip2recover::strlen @ workspace/bzip2/rust/bzip2recover.rs:344:17: 344:72 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:340:9: 345:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:346:9: 346:39 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:348:43: 348:84 (#0) by default
rewrite call bzip2recover::strcpy @ workspace/bzip2/rust/bzip2recover.rs:348:5: 348:85 (#0) by default
rewrite call bzip2recover::fopen @ workspace/bzip2/rust/bzip2recover.rs:350:9: 351:69 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:353:9: 356:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:357:9: 357:39 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:360:5: 362:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call core::num::<impl u64>::wrapping_add @ workspace/bzip2/rust/bzip2recover.rs:371:29: 371:44 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/bzip2/rust/bzip2recover.rs:374:29: 374:69 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/bzip2/rust/bzip2recover.rs:377:30: 378:73 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:380:21: 384:54 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/bzip2/rust/bzip2recover.rs:402:34: 403:77 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/bzip2/rust/bzip2recover.rs:409:40: 410:71 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:412:21: 417:54 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:433:9: 435:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:436:9: 436:39 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:438:5: 440:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fopen @ workspace/bzip2/rust/bzip2recover.rs:442:9: 443:69 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:445:9: 448:41 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:449:9: 449:39 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/bzip2/rust/bzip2recover.rs:467:48: 467:87 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/bzip2/rust/bzip2recover.rs:476:29: 476:44 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/bzip2/rust/bzip2recover.rs:479:33: 480:76 (#0) by default
rewrite call bzip2recover::strcpy @ workspace/bzip2/rust/bzip2recover.rs:505:13: 505:70 (#0) by default
rewrite call bzip2recover::strrchr @ workspace/bzip2/rust/bzip2recover.rs:506:21: 506:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:509:36: 509:45 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset_from @ workspace/bzip2/rust/bzip2recover.rs:512:23: 512:60 (#0) by default
rewrite call bzip2recover::sprintf @ workspace/bzip2/rust/bzip2recover.rs:514:13: 515:56 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:519:23: 519:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzip2recover.rs:522:44: 522:64 (#0) by default
rewrite call bzip2recover::strcat @ workspace/bzip2/rust/bzip2recover.rs:521:13: 522:65 (#0) by default
rewrite call bzip2recover::strcat @ workspace/bzip2/rust/bzip2recover.rs:524:17: 525:80 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:527:13: 530:46 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fopen @ workspace/bzip2/rust/bzip2recover.rs:532:17: 533:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:535:17: 538:50 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzip2recover::exit @ workspace/bzip2/rust/bzip2recover.rs:539:17: 539:47 (#0) by default
rewrite call bzip2recover::fprintf @ workspace/bzip2/rust/bzip2recover.rs:555:5: 557:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:356 ~ c2rust_lib[1043]::bzlib::__isctype)
bb0:
  _5 = _1
  using: _1@Entry
  _6 = const 0_i32
  using: 
  _4 = Lt(move _5, move _6)
  using: _5@Mir(bb0[0]), _6@Mir(bb0[1])
  switchInt(move _4) -> [0: bb2, otherwise: bb1]
  using: _4@Mir(bb0[2])
bb1:
  _3 = const true
  using: 
  goto -> bb3
  using: 
bb2:
  _8 = _1
  using: _1@Entry
  _9 = const 256_i32
  using: 
  _7 = Ge(move _8, move _9)
  using: _8@Mir(bb2[0]), _9@Mir(bb2[1])
  _3 = move _7
  using: _7@Mir(bb2[2])
  goto -> bb3
  using: 
bb3:
  switchInt(move _3) -> [0: bb5, otherwise: bb4]
  using: _3@Phi(bb3)
bb4:
  _0 = const 0_i32
  using: 
  goto -> bb7
  using: 
bb5:
  _14 = const {alloc653: *mut bzip2::_RuneLocale}
  using: 
  _16 = _1
  using: _1@Phi(bb3)
  _15 = move _16 as usize (IntToInt)
  using: _16@Mir(bb5[1])
  _17 = const 256_usize
  using: 
  _18 = Lt(_15, _17)
  using: _15@Mir(bb5[2]), _17@Mir(bb5[3])
  assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _15) -> bb6
  using: _18@Entry, _17@Entry, _15@Entry
bb6:
  _13 = ((*_14).5: [u32; 256])[_15]
  using: _14@Mir(bb5[0]), _15@Mir(bb5[2])
  _12 = move _13 as u64 (IntToInt)
  using: _13@Mir(bb6[0])
  _19 = _2
  using: _2@Entry
  _11 = BitAnd(move _12, move _19)
  using: _12@Mir(bb6[1]), _19@Mir(bb6[2])
  _10 = Ne(move _11, const 0_u64)
  using: _11@Mir(bb6[3])
  _0 = move _10 as i32 (IntToInt)
  using: _10@Mir(bb6[4])
  goto -> bb7
  using: 
bb7:
  return
  using: _0@Phi(bb7)
@DefId(0:357 ~ c2rust_lib[1043]::bzlib::isdigit)
bb0:
  _2 = _1
  using: _1@Entry
  _3 = const 1024_u64
  using: 
  _0 = bzlib::__isctype(move _2, move _3) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1])
bb1:
  return
  using: _0@Mir(bb0[2])
@DefId(0:358 ~ c2rust_lib[1043]::bzlib::BZ2_bz__AssertH__fail)
bb0:
  _4 = const {alloc660: *mut *mut blocksort::__sFILE}
  using: 
  _3 = (*_4)
  using: _4@Mir(bb0[0])
  _8 = const b"\n\nbzip2/libbzip2: internal error number %d.\nThis is a bug in bzip2/libbzip2, %s.\nPlease report it to: bzip2-devel@sourceware.org.  If this happened\nwhen you were using some program which uses libbzip2 as a\ncomponent, you should also report this bug to the author(s)\nof that program.  Please make an effort to report this bug;\ntimely and accurate bug reports eventually lead to higher\nquality software.  Thanks.\n\n\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[2])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[3])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[4])
  _9 = _1
  using: _1@Entry
  _10 = bzlib::BZ2_bzlibVersion() -> bb1
  using: 
bb1:
  _2 = bzlib::fprintf(move _3, move _5, move _9, move _10) -> bb2
  using: _3@Mir(bb0[1]), _5@Mir(bb0[5]), _9@Mir(bb0[6]), _10@Mir(bb0[7])
bb2:
  _12 = _1
  using: _1@Entry
  _13 = const 1007_i32
  using: 
  _11 = Eq(move _12, move _13)
  using: _12@Mir(bb2[0]), _13@Mir(bb2[1])
  switchInt(move _11) -> [0: bb4, otherwise: bb3]
  using: _11@Mir(bb2[2])
bb3:
  _16 = const {alloc660: *mut *mut blocksort::__sFILE}
  using: 
  _15 = (*_16)
  using: _16@Mir(bb3[0])
  _20 = const b"\n*** A special note about internal error number 1007 ***\n\nExperience suggests that a common cause of i.e. 1007\nis unreliable memory or other hardware.  The 1007 assertion\njust happens to cross-check the results of huge numbers of\nmemory reads/writes, and so acts (unintendedly) as a stress\ntest of your memory system.\n\nI suggest the following: try compressing the file again,\npossibly monitoring progress in detail with the -vv flag.\n\n* If the error cannot be reproduced, and/or happens at different\n  points in compression, you may have a flaky memory system.\n  Try a memory-test program.  I have used Memtest86\n  (www.memtest86.com).  At the time of writing it is free (GPLd).\n  Memtest86 tests memory much more thorougly than your BIOSs\n  power-on test, and may find failures that the BIOS doesn\'t.\n\n* If the error can be repeatably reproduced, this is a bug in\n  bzip2, and I would very much like to hear about it.  Please\n  let me know, and, ideally, save a copy of the file causing the\n  problem -- without which I will be unable to investigate it.\n\n\x00"
  using: 
  _19 = &raw const (*_20)
  using: _20@Mir(bb3[2])
  _18 = move _19 as *const u8 (Pointer(ArrayToPointer))
  using: _19@Mir(bb3[3])
  _17 = move _18 as *const i8 (PtrToPtr)
  using: _18@Mir(bb3[4])
  _14 = bzlib::fprintf(move _15, move _17) -> bb4
  using: _15@Mir(bb3[1]), _17@Mir(bb3[5])
bb4:
  _22 = const 3_i32
  using: 
  _21 = bzlib::exit(move _22)
  using: _22@Mir(bb4[0])
rewrite call bzlib::fprintf @ workspace/bzip2/rust/bzlib.rs:222:5: 225:32 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzlib::fprintf @ workspace/bzip2/rust/bzlib.rs:227:9: 229:65 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzlib::exit @ workspace/bzip2/rust/bzlib.rs:231:5: 231:35 (#0) by default
@DefId(0:359 ~ c2rust_lib[1043]::bzlib::bz_config_ok)
bb0:
  _3 = std::mem::size_of::<i32>() -> bb1
  using: 
bb1:
  _2 = move _3 as u64 (IntToInt)
  using: _3@Mir(bb0[0])
  _4 = const 4_u64
  using: 
  _1 = Ne(move _2, move _4)
  using: _2@Mir(bb1[0]), _4@Mir(bb1[1])
  switchInt(move _1) -> [0: bb3, otherwise: bb2]
  using: _1@Mir(bb1[2])
bb2:
  _0 = const 0_i32
  using: 
  goto -> bb10
  using: 
bb3:
  _7 = std::mem::size_of::<i16>() -> bb4
  using: 
bb4:
  _6 = move _7 as u64 (IntToInt)
  using: _7@Mir(bb3[0])
  _8 = const 2_u64
  using: 
  _5 = Ne(move _6, move _8)
  using: _6@Mir(bb4[0]), _8@Mir(bb4[1])
  switchInt(move _5) -> [0: bb6, otherwise: bb5]
  using: _5@Mir(bb4[2])
bb5:
  _0 = const 0_i32
  using: 
  goto -> bb10
  using: 
bb6:
  _11 = std::mem::size_of::<i8>() -> bb7
  using: 
bb7:
  _10 = move _11 as u64 (IntToInt)
  using: _11@Mir(bb6[0])
  _12 = const 1_u64
  using: 
  _9 = Ne(move _10, move _12)
  using: _10@Mir(bb7[0]), _12@Mir(bb7[1])
  switchInt(move _9) -> [0: bb9, otherwise: bb8]
  using: _9@Mir(bb7[2])
bb8:
  _0 = const 0_i32
  using: 
  goto -> bb10
  using: 
bb9:
  _0 = const 1_i32
  using: 
  goto -> bb10
  using: 
bb10:
  return
  using: _0@Phi(bb10)
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:235:8: 235:52 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:239:8: 239:54 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:243:8: 243:53 (#0) by default
@DefId(0:360 ~ c2rust_lib[1043]::bzlib::default_bzalloc)
bb0:
  _6 = _2
  using: _2@Entry
  _7 = _3
  using: _3@Entry
  _8 = CheckedMul(_6, _7)
  using: _6@Mir(bb0[0]), _7@Mir(bb0[1])
  assert(!move (_8.1: bool), "attempt to compute `{} * {}`, which would overflow", move _6, move _7) -> bb1
  using: _8@Entry, _6@Entry, _7@Entry
bb1:
  _5 = move (_8.0: i32)
  using: _8@Mir(bb0[2])
  _4 = move _5 as u64 (IntToInt)
  using: _5@Mir(bb1[0])
  _0 = bzlib::malloc(move _4) -> bb2
  using: _4@Mir(bb1[1])
bb2:
  return
  using: _0@Mir(bb1[2])
@DefId(0:361 ~ c2rust_lib[1043]::bzlib::default_bzfree)
bb0:
  _5 = _2
  using: _2@Entry
  _4 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _5) -> bb1
  using: _5@Mir(bb0[0])
bb1:
  _3 = Not(move _4)
  using: _4@Mir(bb0[1])
  switchInt(move _3) -> [0: bb3, otherwise: bb2]
  using: _3@Mir(bb1[0])
bb2:
  _7 = _2
  using: _2@Entry
  _6 = bzlib::free(move _7) -> bb4
  using: _7@Mir(bb2[0])
bb3:
  _10 = _2
  using: _2@Entry
  _9 = move _10 as usize (PointerExposeAddress)
  using: _10@Mir(bb3[0])
  _8 = Eq(move _9, const 0_usize)
  using: _9@Mir(bb3[1])
  assume(move _8)
  using: _8@Mir(bb3[2])
  goto -> bb4
  using: 
bb4:
  return
  using: _0@Entry
@DefId(0:362 ~ c2rust_lib[1043]::bzlib::prepare_new_block)
bb0:
  _2 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  ((*_1).17: i32) = move _3
  using: _1@Entry, _3@Mir(bb0[1])
  _4 = const 0_i32
  using: 
  ((*_1).19: i32) = move _4
  using: _1@Entry, _4@Mir(bb0[3])
  _5 = const 0_i32
  using: 
  ((*_1).20: i32) = move _5
  using: _1@Entry, _5@Mir(bb0[5])
  _6 = const 4294967295_i64
  using: 
  ((*_1).26: u32) = move _6 as u32 (IntToInt)
  using: _1@Entry, _6@Mir(bb0[7])
  _2 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _8 = _2
  using: _2@Phi(bb1)
  _9 = const 256_i32
  using: 
  _7 = Lt(move _8, move _9)
  using: _8@Mir(bb1[0]), _9@Mir(bb1[1])
  switchInt(move _7) -> [0: bb5, otherwise: bb2]
  using: _7@Mir(bb1[2])
bb2:
  _10 = const 0_i32
  using: 
  _12 = _2
  using: _2@Phi(bb1)
  _11 = move _12 as usize (IntToInt)
  using: _12@Mir(bb2[1])
  _13 = const 256_usize
  using: 
  _14 = Lt(_11, _13)
  using: _11@Mir(bb2[2]), _13@Mir(bb2[3])
  assert(move _14, "index out of bounds: the length is {} but the index is {}", move _13, _11) -> bb3
  using: _14@Entry, _13@Entry, _11@Entry
bb3:
  ((*_1).22: [u8; 256])[_11] = move _10 as u8 (IntToInt)
  using: _1@Phi(bb1), _11@Mir(bb2[2]), _10@Mir(bb2[0])
  _15 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb1)
  assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb4
  using: _15@Entry, _2@Entry
bb4:
  _2 = move (_15.0: i32)
  using: _15@Mir(bb3[1])
  goto -> bb1
  using: 
bb5:
  _16 = CheckedAdd(((*_1).29: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_16.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).29: i32), const 1_i32) -> bb6
  using: _16@Entry, _1@Entry
bb6:
  ((*_1).29: i32) = move (_16.0: i32)
  using: _1@Phi(bb1), _16@Mir(bb5[0])
  return
  using: _0@Entry
@DefId(0:363 ~ c2rust_lib[1043]::bzlib::init_RL)
bb0:
  _2 = const 256_i32
  using: 
  ((*_1).13: u32) = move _2 as u32 (IntToInt)
  using: _1@Entry, _2@Mir(bb0[0])
  _3 = const 0_i32
  using: 
  ((*_1).14: i32) = move _3
  using: _1@Entry, _3@Mir(bb0[2])
  return
  using: _0@Entry
@DefId(0:364 ~ c2rust_lib[1043]::bzlib::isempty_RL)
bb0:
  _4 = ((*_1).13: u32)
  using: _1@Entry
  _5 = const 256_u32
  using: 
  _3 = Lt(move _4, move _5)
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1])
  switchInt(move _3) -> [0: bb1, otherwise: bb2]
  using: _3@Mir(bb0[2])
bb1:
  _2 = const false
  using: 
  goto -> bb3
  using: 
bb2:
  _7 = ((*_1).14: i32)
  using: _1@Entry
  _8 = const 0_i32
  using: 
  _6 = Gt(move _7, move _8)
  using: _7@Mir(bb2[0]), _8@Mir(bb2[1])
  _2 = move _6
  using: _6@Mir(bb2[2])
  goto -> bb3
  using: 
bb3:
  switchInt(move _2) -> [0: bb5, otherwise: bb4]
  using: _2@Phi(bb3)
bb4:
  _0 = const 0_u8
  using: 
  goto -> bb6
  using: 
bb5:
  _0 = const 1_u8
  using: 
  goto -> bb6
  using: 
bb6:
  return
  using: _0@Phi(bb6)
@DefId(0:365 ~ c2rust_lib[1043]::bzlib::BZ2_bzCompressInit)
bb0:
  _5 = const 0_i32
  using: 
  _6 = const {0x0 as *mut blocksort::EState}
  using: 
  _7 = bzlib::bz_config_ok() -> bb1
  using: 
bb1:
  switchInt(move _7) -> [0: bb2, otherwise: bb3]
  using: _7@Mir(bb0[2])
bb2:
  _0 = const -9_i32
  using: 
  goto -> bb82
  using: 
bb3:
  _13 = _1
  using: _1@Entry
  _12 = std::ptr::mut_ptr::<impl *mut blocksort::bz_stream>::is_null(move _13) -> bb16
  using: _13@Mir(bb3[0])
bb4:
  _8 = const true
  using: 
  goto -> bb6
  using: 
bb5:
  _24 = _4
  using: _4@Phi(bb9)
  _25 = const 250_i32
  using: 
  _23 = Gt(move _24, move _25)
  using: _24@Mir(bb5[0]), _25@Mir(bb5[1])
  _8 = move _23
  using: _23@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  switchInt(move _8) -> [0: bb18, otherwise: bb17]
  using: _8@Phi(bb6)
bb7:
  _9 = const true
  using: 
  goto -> bb9
  using: 
bb8:
  _21 = _4
  using: _4@Entry
  _22 = const 0_i32
  using: 
  _20 = Lt(move _21, move _22)
  using: _21@Mir(bb8[0]), _22@Mir(bb8[1])
  _9 = move _20
  using: _20@Mir(bb8[2])
  goto -> bb9
  using: 
bb9:
  switchInt(move _9) -> [0: bb5, otherwise: bb4]
  using: _9@Phi(bb9)
bb10:
  _10 = const true
  using: 
  goto -> bb12
  using: 
bb11:
  _18 = _2
  using: _2@Phi(bb15)
  _19 = const 9_i32
  using: 
  _17 = Gt(move _18, move _19)
  using: _18@Mir(bb11[0]), _19@Mir(bb11[1])
  _10 = move _17
  using: _17@Mir(bb11[2])
  goto -> bb12
  using: 
bb12:
  switchInt(move _10) -> [0: bb8, otherwise: bb7]
  using: _10@Phi(bb12)
bb13:
  _11 = const true
  using: 
  goto -> bb15
  using: 
bb14:
  _15 = _2
  using: _2@Entry
  _16 = const 1_i32
  using: 
  _14 = Lt(move _15, move _16)
  using: _15@Mir(bb14[0]), _16@Mir(bb14[1])
  _11 = move _14
  using: _14@Mir(bb14[2])
  goto -> bb15
  using: 
bb15:
  switchInt(move _11) -> [0: bb11, otherwise: bb10]
  using: _11@Phi(bb15)
bb16:
  switchInt(move _12) -> [0: bb14, otherwise: bb13]
  using: _12@Mir(bb3[1])
bb17:
  _0 = const -2_i32
  using: 
  goto -> bb82
  using: 
bb18:
  _27 = _4
  using: _4@Phi(bb6)
  _28 = const 0_i32
  using: 
  _26 = Eq(move _27, move _28)
  using: _27@Mir(bb18[0]), _28@Mir(bb18[1])
  switchInt(move _26) -> [0: bb20, otherwise: bb19]
  using: _26@Mir(bb18[2])
bb19:
  _4 = const 30_i32
  using: 
  goto -> bb20
  using: 
bb20:
  _30 = &((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _1@Entry
  _29 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::is_none(move _30) -> bb21
  using: _30@Mir(bb20[0])
bb21:
  switchInt(move _29) -> [0: bb23, otherwise: bb22]
  using: _29@Mir(bb20[1])
bb22:
  _32 = bzlib::default_bzalloc as unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void (Pointer(ReifyFnPointer))
  using: 
  Deinit(_31)
  using: 
  ((_31 as Some).0: unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void) = move _32
  using: _32@Mir(bb22[0])
  discriminant(_31) = 1
  using: 
  ((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _31
  using: _1@Entry, _31@Mir(bb22[1])
  goto -> bb23
  using: 
bb23:
  _34 = &((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb23)
  _33 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::is_none(move _34) -> bb24
  using: _34@Mir(bb23[0])
bb24:
  switchInt(move _33) -> [0: bb26, otherwise: bb25]
  using: _33@Mir(bb23[1])
bb25:
  _36 = bzlib::default_bzfree as unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void) (Pointer(ReifyFnPointer))
  using: 
  Deinit(_35)
  using: 
  ((_35 as Some).0: unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)) = move _36
  using: _36@Mir(bb25[0])
  discriminant(_35) = 1
  using: 
  ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _35
  using: _1@Phi(bb23), _35@Mir(bb25[1])
  goto -> bb26
  using: 
bb26:
  _39 = ((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _1@Phi(bb26)
  _41 = const "non-null function pointer"
  using: 
  _40 = _41
  using: _41@Mir(bb26[1])
  _38 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _39, move _40) -> bb27
  using: _39@Mir(bb26[0]), _40@Mir(bb26[2])
bb27:
  _42 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb26)
  _45 = std::mem::size_of::<blocksort::EState>() -> bb28
  using: 
bb28:
  _44 = move _45 as u64 (IntToInt)
  using: _45@Mir(bb27[1])
  _43 = move _44 as i32 (IntToInt)
  using: _44@Mir(bb28[0])
  _46 = const 1_i32
  using: 
  _37 = move _38(move _42, move _43, move _46) -> bb29
  using: _38@Entry, _42@Mir(bb27[0]), _43@Mir(bb28[1]), _46@Mir(bb28[2])
bb29:
  _6 = move _37 as *mut blocksort::EState (PtrToPtr)
  using: _37@Mir(bb28[3])
  _48 = _6
  using: _6@Mir(bb29[0])
  _47 = std::ptr::mut_ptr::<impl *mut blocksort::EState>::is_null(move _48) -> bb30
  using: _48@Mir(bb29[1])
bb30:
  switchInt(move _47) -> [0: bb32, otherwise: bb31]
  using: _47@Mir(bb29[2])
bb31:
  _51 = _6
  using: _6@Mir(bb29[0])
  _50 = move _51 as usize (PointerExposeAddress)
  using: _51@Mir(bb31[0])
  _49 = Eq(move _50, const 0_usize)
  using: _50@Mir(bb31[1])
  assume(move _49)
  using: _49@Mir(bb31[2])
  _0 = const -3_i32
  using: 
  goto -> bb82
  using: 
bb32:
  _52 = _1
  using: _1@Phi(bb26)
  ((*_6).0: *mut blocksort::bz_stream) = move _52
  using: _6@Mir(bb29[0]), _52@Mir(bb32[0])
  ((*_6).4: *mut u32) = const 0_usize as *mut u32 (PointerFromExposedAddress)
  using: _6@Mir(bb29[0])
  ((*_6).5: *mut u32) = const 0_usize as *mut u32 (PointerFromExposedAddress)
  using: _6@Mir(bb29[0])
  ((*_6).6: *mut u32) = const 0_usize as *mut u32 (PointerFromExposedAddress)
  using: _6@Mir(bb29[0])
  _53 = const 100000_i32
  using: 
  _54 = _2
  using: _2@Phi(bb12)
  _55 = CheckedMul(_53, _54)
  using: _53@Mir(bb32[5]), _54@Mir(bb32[6])
  assert(!move (_55.1: bool), "attempt to compute `{} * {}`, which would overflow", move _53, move _54) -> bb33
  using: _55@Entry, _53@Entry, _54@Entry
bb33:
  _5 = move (_55.0: i32)
  using: _55@Mir(bb32[7])
  _58 = ((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _1@Phi(bb26)
  _60 = const "non-null function pointer"
  using: 
  _59 = _60
  using: _60@Mir(bb33[2])
  _57 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _58, move _59) -> bb34
  using: _58@Mir(bb33[1]), _59@Mir(bb33[3])
bb34:
  _61 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb26)
  _65 = _5
  using: _5@Mir(bb33[0])
  _64 = move _65 as u64 (IntToInt)
  using: _65@Mir(bb34[1])
  _67 = std::mem::size_of::<u32>() -> bb35
  using: 
bb35:
  _66 = move _67 as u64 (IntToInt)
  using: _67@Mir(bb34[3])
  _63 = core::num::<impl u64>::wrapping_mul(move _64, move _66) -> bb36
  using: _64@Mir(bb34[2]), _66@Mir(bb35[0])
bb36:
  _62 = move _63 as i32 (IntToInt)
  using: _63@Mir(bb35[1])
  _68 = const 1_i32
  using: 
  _56 = move _57(move _61, move _62, move _68) -> bb37
  using: _57@Entry, _61@Mir(bb34[0]), _62@Mir(bb36[0]), _68@Mir(bb36[1])
bb37:
  ((*_6).4: *mut u32) = move _56 as *mut u32 (PtrToPtr)
  using: _6@Mir(bb29[0]), _56@Mir(bb36[2])
  _71 = ((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _1@Phi(bb26)
  _73 = const "non-null function pointer"
  using: 
  _72 = _73
  using: _73@Mir(bb37[2])
  _70 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _71, move _72) -> bb38
  using: _71@Mir(bb37[1]), _72@Mir(bb37[3])
bb38:
  _74 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb26)
  _79 = _5
  using: _5@Mir(bb33[0])
  _80 = const 34_i32
  using: 
  _81 = CheckedAdd(_79, _80)
  using: _79@Mir(bb38[1]), _80@Mir(bb38[2])
  assert(!move (_81.1: bool), "attempt to compute `{} + {}`, which would overflow", move _79, move _80) -> bb39
  using: _81@Entry, _79@Entry, _80@Entry
bb39:
  _78 = move (_81.0: i32)
  using: _81@Mir(bb38[3])
  _77 = move _78 as u64 (IntToInt)
  using: _78@Mir(bb39[0])
  _83 = std::mem::size_of::<u32>() -> bb40
  using: 
bb40:
  _82 = move _83 as u64 (IntToInt)
  using: _83@Mir(bb39[2])
  _76 = core::num::<impl u64>::wrapping_mul(move _77, move _82) -> bb41
  using: _77@Mir(bb39[1]), _82@Mir(bb40[0])
bb41:
  _75 = move _76 as i32 (IntToInt)
  using: _76@Mir(bb40[1])
  _84 = const 1_i32
  using: 
  _69 = move _70(move _74, move _75, move _84) -> bb42
  using: _70@Entry, _74@Mir(bb38[0]), _75@Mir(bb41[0]), _84@Mir(bb41[1])
bb42:
  ((*_6).5: *mut u32) = move _69 as *mut u32 (PtrToPtr)
  using: _6@Mir(bb29[0]), _69@Mir(bb41[2])
  _87 = ((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _1@Phi(bb26)
  _89 = const "non-null function pointer"
  using: 
  _88 = _89
  using: _89@Mir(bb42[2])
  _86 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _87, move _88) -> bb43
  using: _87@Mir(bb42[1]), _88@Mir(bb42[3])
bb43:
  _90 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb26)
  _93 = const 65537_u64
  using: 
  _95 = std::mem::size_of::<u32>() -> bb44
  using: 
bb44:
  _94 = move _95 as u64 (IntToInt)
  using: _95@Mir(bb43[2])
  _92 = core::num::<impl u64>::wrapping_mul(move _93, move _94) -> bb45
  using: _93@Mir(bb43[1]), _94@Mir(bb44[0])
bb45:
  _91 = move _92 as i32 (IntToInt)
  using: _92@Mir(bb44[1])
  _96 = const 1_i32
  using: 
  _85 = move _86(move _90, move _91, move _96) -> bb46
  using: _86@Entry, _90@Mir(bb43[0]), _91@Mir(bb45[0]), _96@Mir(bb45[1])
bb46:
  ((*_6).6: *mut u32) = move _85 as *mut u32 (PtrToPtr)
  using: _6@Mir(bb29[0]), _85@Mir(bb45[2])
  _100 = ((*_6).4: *mut u32)
  using: _6@Mir(bb29[0])
  _99 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _100) -> bb53
  using: _100@Mir(bb46[1])
bb47:
  _97 = const true
  using: 
  goto -> bb49
  using: 
bb48:
  _104 = ((*_6).6: *mut u32)
  using: _6@Phi(bb52)
  _103 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _104) -> bb55
  using: _104@Mir(bb48[0])
bb49:
  switchInt(move _97) -> [0: bb77, otherwise: bb56]
  using: _97@Phi(bb49)
bb50:
  _98 = const true
  using: 
  goto -> bb52
  using: 
bb51:
  _102 = ((*_6).5: *mut u32)
  using: _6@Mir(bb29[0])
  _101 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _102) -> bb54
  using: _102@Mir(bb51[0])
bb52:
  switchInt(move _98) -> [0: bb48, otherwise: bb47]
  using: _98@Phi(bb52)
bb53:
  switchInt(move _99) -> [0: bb51, otherwise: bb50]
  using: _99@Mir(bb46[2])
bb54:
  _98 = move _101
  using: _101@Mir(bb51[1])
  goto -> bb52
  using: 
bb55:
  _97 = move _103
  using: _103@Mir(bb48[1])
  goto -> bb49
  using: 
bb56:
  _107 = ((*_6).4: *mut u32)
  using: _6@Phi(bb49)
  _106 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _107) -> bb57
  using: _107@Mir(bb56[0])
bb57:
  _105 = Not(move _106)
  using: _106@Mir(bb56[1])
  switchInt(move _105) -> [0: bb60, otherwise: bb58]
  using: _105@Mir(bb57[0])
bb58:
  _110 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb26)
  _112 = const "non-null function pointer"
  using: 
  _111 = _112
  using: _112@Mir(bb58[1])
  _109 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _110, move _111) -> bb59
  using: _110@Mir(bb58[0]), _111@Mir(bb58[2])
bb59:
  _113 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb26)
  _115 = ((*_6).4: *mut u32)
  using: _6@Phi(bb49)
  _114 = move _115 as *mut std::ffi::c_void (PtrToPtr)
  using: _115@Mir(bb59[1])
  _108 = move _109(move _113, move _114) -> bb61
  using: _109@Entry, _113@Mir(bb59[0]), _114@Mir(bb59[2])
bb60:
  _118 = ((*_6).4: *mut u32)
  using: _6@Phi(bb49)
  _117 = move _118 as usize (PointerExposeAddress)
  using: _118@Mir(bb60[0])
  _116 = Eq(move _117, const 0_usize)
  using: _117@Mir(bb60[1])
  assume(move _116)
  using: _116@Mir(bb60[2])
  goto -> bb61
  using: 
bb61:
  _121 = ((*_6).5: *mut u32)
  using: _6@Phi(bb61)
  _120 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _121) -> bb62
  using: _121@Mir(bb61[0])
bb62:
  _119 = Not(move _120)
  using: _120@Mir(bb61[1])
  switchInt(move _119) -> [0: bb65, otherwise: bb63]
  using: _119@Mir(bb62[0])
bb63:
  _124 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb61)
  _126 = const "non-null function pointer"
  using: 
  _125 = _126
  using: _126@Mir(bb63[1])
  _123 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _124, move _125) -> bb64
  using: _124@Mir(bb63[0]), _125@Mir(bb63[2])
bb64:
  _127 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb61)
  _129 = ((*_6).5: *mut u32)
  using: _6@Phi(bb61)
  _128 = move _129 as *mut std::ffi::c_void (PtrToPtr)
  using: _129@Mir(bb64[1])
  _122 = move _123(move _127, move _128) -> bb66
  using: _123@Entry, _127@Mir(bb64[0]), _128@Mir(bb64[2])
bb65:
  _132 = ((*_6).5: *mut u32)
  using: _6@Phi(bb61)
  _131 = move _132 as usize (PointerExposeAddress)
  using: _132@Mir(bb65[0])
  _130 = Eq(move _131, const 0_usize)
  using: _131@Mir(bb65[1])
  assume(move _130)
  using: _130@Mir(bb65[2])
  goto -> bb66
  using: 
bb66:
  _135 = ((*_6).6: *mut u32)
  using: _6@Phi(bb66)
  _134 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _135) -> bb67
  using: _135@Mir(bb66[0])
bb67:
  _133 = Not(move _134)
  using: _134@Mir(bb66[1])
  switchInt(move _133) -> [0: bb70, otherwise: bb68]
  using: _133@Mir(bb67[0])
bb68:
  _138 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb66)
  _140 = const "non-null function pointer"
  using: 
  _139 = _140
  using: _140@Mir(bb68[1])
  _137 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _138, move _139) -> bb69
  using: _138@Mir(bb68[0]), _139@Mir(bb68[2])
bb69:
  _141 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb66)
  _143 = ((*_6).6: *mut u32)
  using: _6@Phi(bb66)
  _142 = move _143 as *mut std::ffi::c_void (PtrToPtr)
  using: _143@Mir(bb69[1])
  _136 = move _137(move _141, move _142) -> bb71
  using: _137@Entry, _141@Mir(bb69[0]), _142@Mir(bb69[2])
bb70:
  _146 = ((*_6).6: *mut u32)
  using: _6@Phi(bb66)
  _145 = move _146 as usize (PointerExposeAddress)
  using: _146@Mir(bb70[0])
  _144 = Eq(move _145, const 0_usize)
  using: _145@Mir(bb70[1])
  assume(move _144)
  using: _144@Mir(bb70[2])
  goto -> bb71
  using: 
bb71:
  _149 = _6
  using: _6@Phi(bb71)
  _148 = std::ptr::mut_ptr::<impl *mut blocksort::EState>::is_null(move _149) -> bb72
  using: _149@Mir(bb71[0])
bb72:
  _147 = Not(move _148)
  using: _148@Mir(bb71[1])
  switchInt(move _147) -> [0: bb75, otherwise: bb73]
  using: _147@Mir(bb72[0])
bb73:
  _152 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb71)
  _154 = const "non-null function pointer"
  using: 
  _153 = _154
  using: _154@Mir(bb73[1])
  _151 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _152, move _153) -> bb74
  using: _152@Mir(bb73[0]), _153@Mir(bb73[2])
bb74:
  _155 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb71)
  _157 = _6
  using: _6@Phi(bb71)
  _156 = move _157 as *mut std::ffi::c_void (PtrToPtr)
  using: _157@Mir(bb74[1])
  _150 = move _151(move _155, move _156) -> bb76
  using: _151@Entry, _155@Mir(bb74[0]), _156@Mir(bb74[2])
bb75:
  _160 = _6
  using: _6@Phi(bb71)
  _159 = move _160 as usize (PointerExposeAddress)
  using: _160@Mir(bb75[0])
  _158 = Eq(move _159, const 0_usize)
  using: _159@Mir(bb75[1])
  assume(move _158)
  using: _158@Mir(bb75[2])
  goto -> bb76
  using: 
bb76:
  _0 = const -3_i32
  using: 
  goto -> bb82
  using: 
bb77:
  _161 = const 0_i32
  using: 
  ((*_6).29: i32) = move _161
  using: _6@Phi(bb76), _161@Mir(bb77[0])
  _162 = const 2_i32
  using: 
  ((*_6).2: i32) = move _162
  using: _6@Phi(bb76), _162@Mir(bb77[2])
  _163 = const 2_i32
  using: 
  ((*_6).1: i32) = move _163
  using: _6@Phi(bb76), _163@Mir(bb77[4])
  _164 = const 0_i32
  using: 
  ((*_6).27: u32) = move _164 as u32 (IntToInt)
  using: _6@Phi(bb76), _164@Mir(bb77[6])
  _165 = _2
  using: _2@Phi(bb12)
  ((*_6).30: i32) = move _165
  using: _6@Phi(bb76), _165@Mir(bb77[8])
  _167 = const 100000_i32
  using: 
  _168 = _2
  using: _2@Phi(bb12)
  _169 = CheckedMul(_167, _168)
  using: _167@Mir(bb77[10]), _168@Mir(bb77[11])
  assert(!move (_169.1: bool), "attempt to compute `{} * {}`, which would overflow", move _167, move _168) -> bb78
  using: _169@Entry, _167@Entry, _168@Entry
bb78:
  _166 = move (_169.0: i32)
  using: _169@Mir(bb77[12])
  _170 = const 19_i32
  using: 
  _171 = CheckedSub(_166, _170)
  using: _166@Mir(bb78[0]), _170@Mir(bb78[1])
  assert(!move (_171.1: bool), "attempt to compute `{} - {}`, which would overflow", move _166, move _170) -> bb79
  using: _171@Entry, _166@Entry, _170@Entry
bb79:
  ((*_6).18: i32) = move (_171.0: i32)
  using: _6@Phi(bb76), _171@Mir(bb78[2])
  _172 = _3
  using: _3@Entry
  ((*_6).28: i32) = move _172
  using: _6@Phi(bb76), _172@Mir(bb79[1])
  _173 = _4
  using: _4@Phi(bb20)
  ((*_6).12: i32) = move _173
  using: _6@Phi(bb76), _173@Mir(bb79[3])
  _174 = ((*_6).5: *mut u32)
  using: _6@Phi(bb76)
  ((*_6).9: *mut u8) = move _174 as *mut u8 (PtrToPtr)
  using: _6@Phi(bb76), _174@Mir(bb79[5])
  _175 = ((*_6).4: *mut u32)
  using: _6@Phi(bb76)
  ((*_6).10: *mut u16) = move _175 as *mut u16 (PtrToPtr)
  using: _6@Phi(bb76), _175@Mir(bb79[7])
  ((*_6).11: *mut u8) = const 0_usize as *mut u8 (PointerFromExposedAddress)
  using: _6@Phi(bb76)
  _176 = ((*_6).4: *mut u32)
  using: _6@Phi(bb76)
  ((*_6).8: *mut u32) = move _176
  using: _6@Phi(bb76), _176@Mir(bb79[10])
  _177 = _6
  using: _6@Phi(bb76)
  ((*_1).8: *mut std::ffi::c_void) = move _177 as *mut std::ffi::c_void (PtrToPtr)
  using: _1@Phi(bb76), _177@Mir(bb79[12])
  _178 = const 0_i32
  using: 
  ((*_1).2: u32) = move _178 as u32 (IntToInt)
  using: _1@Phi(bb76), _178@Mir(bb79[14])
  _179 = const 0_i32
  using: 
  ((*_1).3: u32) = move _179 as u32 (IntToInt)
  using: _1@Phi(bb76), _179@Mir(bb79[16])
  _180 = const 0_i32
  using: 
  ((*_1).6: u32) = move _180 as u32 (IntToInt)
  using: _1@Phi(bb76), _180@Mir(bb79[18])
  _181 = const 0_i32
  using: 
  ((*_1).7: u32) = move _181 as u32 (IntToInt)
  using: _1@Phi(bb76), _181@Mir(bb79[20])
  _183 = _6
  using: _6@Phi(bb76)
  _182 = bzlib::init_RL(move _183) -> bb80
  using: _183@Mir(bb79[22])
bb80:
  _185 = _6
  using: _6@Phi(bb76)
  _184 = bzlib::prepare_new_block(move _185) -> bb81
  using: _185@Mir(bb80[0])
bb81:
  _0 = const 0_i32
  using: 
  goto -> bb82
  using: 
bb82:
  return
  using: _0@Phi(bb82)
rewrite call std::option::Option::<T>::is_none @ workspace/bzip2/rust/bzlib.rs:301:24: 301:33 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_31) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_31) = 1 is ignored
rewrite call std::option::Option::<T>::is_none @ workspace/bzip2/rust/bzlib.rs:307:23: 307:32 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_35) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_35) = 1 is ignored
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:314:25: 314:60 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:315:61: 315:110 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:329:25: 329:60 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:331:102: 331:133 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:331:89: 333:120 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:339:25: 339:60 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:353:102: 353:133 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:353:89: 355:120 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:361:25: 361:60 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:365:102: 365:133 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:365:89: 367:120 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:374:28: 374:63 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:379:28: 379:63 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:384:28: 384:63 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:389:28: 389:63 (#0) by default
@DefId(0:366 ~ c2rust_lib[1043]::bzlib::add_pair_to_block)
bb0:
  _2 = const 0_i32
  using: 
  _4 = ((*_1).13: u32)
  using: _1@Entry
  _3 = move _4 as u8 (IntToInt)
  using: _4@Mir(bb0[1])
  _2 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _6 = _2
  using: _2@Phi(bb1)
  _7 = ((*_1).14: i32)
  using: _1@Phi(bb1)
  _5 = Lt(move _6, move _7)
  using: _6@Mir(bb1[0]), _7@Mir(bb1[1])
  switchInt(move _5) -> [0: bb7, otherwise: bb2]
  using: _5@Mir(bb1[2])
bb2:
  _9 = ((*_1).26: u32)
  using: _1@Phi(bb1)
  _10 = const 8_i32
  using: 
  _11 = CheckedShl(_9, _10)
  using: _9@Mir(bb2[0]), _10@Mir(bb2[1])
  assert(!move (_11.1: bool), "attempt to shift left by `{}`, which would overflow", move _10) -> bb3
  using: _11@Entry, _9@Entry, _10@Entry
bb3:
  _8 = move (_11.0: u32)
  using: _11@Mir(bb2[2])
  _13 = const {alloc723: *mut [u32; 256]}
  using: 
  _17 = ((*_1).26: u32)
  using: _1@Phi(bb1)
  _18 = const 24_i32
  using: 
  _19 = CheckedShr(_17, _18)
  using: _17@Mir(bb3[2]), _18@Mir(bb3[3])
  assert(!move (_19.1: bool), "attempt to shift right by `{}`, which would overflow", move _18) -> bb4
  using: _19@Entry, _17@Entry, _18@Entry
bb4:
  _16 = move (_19.0: u32)
  using: _19@Mir(bb3[4])
  _21 = _3
  using: _3@Phi(bb1)
  _20 = move _21 as u32 (IntToInt)
  using: _21@Mir(bb4[1])
  _15 = BitXor(move _16, move _20)
  using: _16@Mir(bb4[0]), _20@Mir(bb4[2])
  _14 = move _15 as usize (IntToInt)
  using: _15@Mir(bb4[3])
  _22 = const 256_usize
  using: 
  _23 = Lt(_14, _22)
  using: _14@Mir(bb4[4]), _22@Mir(bb4[5])
  assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _14) -> bb5
  using: _23@Entry, _22@Entry, _14@Entry
bb5:
  _12 = (*_13)[_14]
  using: _13@Mir(bb3[1]), _14@Mir(bb4[4])
  ((*_1).26: u32) = BitXor(move _8, move _12)
  using: _1@Phi(bb1), _8@Mir(bb3[0]), _12@Mir(bb5[0])
  _24 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb1)
  assert(!move (_24.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb6
  using: _24@Entry, _2@Entry
bb6:
  _2 = move (_24.0: i32)
  using: _24@Mir(bb5[2])
  goto -> bb1
  using: 
bb7:
  _25 = const 1_i32
  using: 
  _27 = ((*_1).13: u32)
  using: _1@Phi(bb1)
  _26 = move _27 as usize (IntToInt)
  using: _27@Mir(bb7[1])
  _28 = const 256_usize
  using: 
  _29 = Lt(_26, _28)
  using: _26@Mir(bb7[2]), _28@Mir(bb7[3])
  assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _26) -> bb8
  using: _29@Entry, _28@Entry, _26@Entry
bb8:
  ((*_1).22: [u8; 256])[_26] = move _25 as u8 (IntToInt)
  using: _1@Phi(bb1), _26@Mir(bb7[2]), _25@Mir(bb7[0])
  switchInt(((*_1).14: i32)) -> [1: bb10, 2: bb13, 3: bb18, otherwise: bb9]
  using: _1@Phi(bb1)
bb9:
  _66 = const 1_i32
  using: 
  _69 = ((*_1).14: i32)
  using: _1@Phi(bb1)
  _70 = const 4_i32
  using: 
  _71 = CheckedSub(_69, _70)
  using: _69@Mir(bb9[1]), _70@Mir(bb9[2])
  assert(!move (_71.1: bool), "attempt to compute `{} - {}`, which would overflow", move _69, move _70) -> bb25
  using: _71@Entry, _69@Entry, _70@Entry
bb10:
  _30 = _3
  using: _3@Phi(bb1)
  _32 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _34 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _33 = move _34 as isize (IntToInt)
  using: _34@Mir(bb10[2])
  _31 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _32, move _33) -> bb11
  using: _32@Mir(bb10[1]), _33@Mir(bb10[3])
bb11:
  (*_31) = move _30
  using: _31@Mir(bb10[4]), _30@Mir(bb10[0])
  _35 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_35.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb12
  using: _35@Entry, _1@Entry
bb12:
  ((*_1).17: i32) = move (_35.0: i32)
  using: _1@Phi(bb1), _35@Mir(bb11[1])
  goto -> bb38
  using: 
bb13:
  _36 = _3
  using: _3@Phi(bb1)
  _38 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _40 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _39 = move _40 as isize (IntToInt)
  using: _40@Mir(bb13[2])
  _37 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _38, move _39) -> bb14
  using: _38@Mir(bb13[1]), _39@Mir(bb13[3])
bb14:
  (*_37) = move _36
  using: _37@Mir(bb13[4]), _36@Mir(bb13[0])
  _41 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_41.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb15
  using: _41@Entry, _1@Entry
bb15:
  ((*_1).17: i32) = move (_41.0: i32)
  using: _1@Phi(bb1), _41@Mir(bb14[1])
  _42 = _3
  using: _3@Phi(bb1)
  _44 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _46 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _45 = move _46 as isize (IntToInt)
  using: _46@Mir(bb15[3])
  _43 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _44, move _45) -> bb16
  using: _44@Mir(bb15[2]), _45@Mir(bb15[4])
bb16:
  (*_43) = move _42
  using: _43@Mir(bb15[5]), _42@Mir(bb15[1])
  _47 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb17
  using: _47@Entry, _1@Entry
bb17:
  ((*_1).17: i32) = move (_47.0: i32)
  using: _1@Phi(bb1), _47@Mir(bb16[1])
  goto -> bb38
  using: 
bb18:
  _48 = _3
  using: _3@Phi(bb1)
  _50 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _52 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _51 = move _52 as isize (IntToInt)
  using: _52@Mir(bb18[2])
  _49 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _50, move _51) -> bb19
  using: _50@Mir(bb18[1]), _51@Mir(bb18[3])
bb19:
  (*_49) = move _48
  using: _49@Mir(bb18[4]), _48@Mir(bb18[0])
  _53 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb20
  using: _53@Entry, _1@Entry
bb20:
  ((*_1).17: i32) = move (_53.0: i32)
  using: _1@Phi(bb1), _53@Mir(bb19[1])
  _54 = _3
  using: _3@Phi(bb1)
  _56 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _58 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _57 = move _58 as isize (IntToInt)
  using: _58@Mir(bb20[3])
  _55 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _56, move _57) -> bb21
  using: _56@Mir(bb20[2]), _57@Mir(bb20[4])
bb21:
  (*_55) = move _54
  using: _55@Mir(bb20[5]), _54@Mir(bb20[1])
  _59 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_59.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb22
  using: _59@Entry, _1@Entry
bb22:
  ((*_1).17: i32) = move (_59.0: i32)
  using: _1@Phi(bb1), _59@Mir(bb21[1])
  _60 = _3
  using: _3@Phi(bb1)
  _62 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _64 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _63 = move _64 as isize (IntToInt)
  using: _64@Mir(bb22[3])
  _61 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _62, move _63) -> bb23
  using: _62@Mir(bb22[2]), _63@Mir(bb22[4])
bb23:
  (*_61) = move _60
  using: _61@Mir(bb22[5]), _60@Mir(bb22[1])
  _65 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb24
  using: _65@Entry, _1@Entry
bb24:
  ((*_1).17: i32) = move (_65.0: i32)
  using: _1@Phi(bb1), _65@Mir(bb23[1])
  goto -> bb38
  using: 
bb25:
  _68 = move (_71.0: i32)
  using: _71@Mir(bb9[3])
  _67 = move _68 as usize (IntToInt)
  using: _68@Mir(bb25[0])
  _72 = const 256_usize
  using: 
  _73 = Lt(_67, _72)
  using: _67@Mir(bb25[1]), _72@Mir(bb25[2])
  assert(move _73, "index out of bounds: the length is {} but the index is {}", move _72, _67) -> bb26
  using: _73@Entry, _72@Entry, _67@Entry
bb26:
  ((*_1).22: [u8; 256])[_67] = move _66 as u8 (IntToInt)
  using: _1@Phi(bb1), _67@Mir(bb25[1]), _66@Mir(bb9[0])
  _74 = _3
  using: _3@Phi(bb1)
  _76 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _78 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _77 = move _78 as isize (IntToInt)
  using: _78@Mir(bb26[3])
  _75 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _76, move _77) -> bb27
  using: _76@Mir(bb26[2]), _77@Mir(bb26[4])
bb27:
  (*_75) = move _74
  using: _75@Mir(bb26[5]), _74@Mir(bb26[1])
  _79 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_79.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb28
  using: _79@Entry, _1@Entry
bb28:
  ((*_1).17: i32) = move (_79.0: i32)
  using: _1@Phi(bb1), _79@Mir(bb27[1])
  _80 = _3
  using: _3@Phi(bb1)
  _82 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _84 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _83 = move _84 as isize (IntToInt)
  using: _84@Mir(bb28[3])
  _81 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _82, move _83) -> bb29
  using: _82@Mir(bb28[2]), _83@Mir(bb28[4])
bb29:
  (*_81) = move _80
  using: _81@Mir(bb28[5]), _80@Mir(bb28[1])
  _85 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_85.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb30
  using: _85@Entry, _1@Entry
bb30:
  ((*_1).17: i32) = move (_85.0: i32)
  using: _1@Phi(bb1), _85@Mir(bb29[1])
  _86 = _3
  using: _3@Phi(bb1)
  _88 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _90 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _89 = move _90 as isize (IntToInt)
  using: _90@Mir(bb30[3])
  _87 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _88, move _89) -> bb31
  using: _88@Mir(bb30[2]), _89@Mir(bb30[4])
bb31:
  (*_87) = move _86
  using: _87@Mir(bb30[5]), _86@Mir(bb30[1])
  _91 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_91.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb32
  using: _91@Entry, _1@Entry
bb32:
  ((*_1).17: i32) = move (_91.0: i32)
  using: _1@Phi(bb1), _91@Mir(bb31[1])
  _92 = _3
  using: _3@Phi(bb1)
  _94 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _96 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _95 = move _96 as isize (IntToInt)
  using: _96@Mir(bb32[3])
  _93 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _94, move _95) -> bb33
  using: _94@Mir(bb32[2]), _95@Mir(bb32[4])
bb33:
  (*_93) = move _92
  using: _93@Mir(bb32[5]), _92@Mir(bb32[1])
  _97 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_97.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb34
  using: _97@Entry, _1@Entry
bb34:
  ((*_1).17: i32) = move (_97.0: i32)
  using: _1@Phi(bb1), _97@Mir(bb33[1])
  _99 = ((*_1).14: i32)
  using: _1@Phi(bb1)
  _100 = const 4_i32
  using: 
  _101 = CheckedSub(_99, _100)
  using: _99@Mir(bb34[1]), _100@Mir(bb34[2])
  assert(!move (_101.1: bool), "attempt to compute `{} - {}`, which would overflow", move _99, move _100) -> bb35
  using: _101@Entry, _99@Entry, _100@Entry
bb35:
  _98 = move (_101.0: i32)
  using: _101@Mir(bb34[3])
  _103 = ((*_1).9: *mut u8)
  using: _1@Phi(bb1)
  _105 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _104 = move _105 as isize (IntToInt)
  using: _105@Mir(bb35[2])
  _102 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _103, move _104) -> bb36
  using: _103@Mir(bb35[1]), _104@Mir(bb35[3])
bb36:
  (*_102) = move _98 as u8 (IntToInt)
  using: _102@Mir(bb35[4]), _98@Mir(bb35[0])
  _106 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_106.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb37
  using: _106@Entry, _1@Entry
bb37:
  ((*_1).17: i32) = move (_106.0: i32)
  using: _1@Phi(bb1), _106@Mir(bb36[1])
  goto -> bb38
  using: 
bb38:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:432:25: 432:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:436:25: 436:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:438:25: 438:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:442:25: 442:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:444:25: 444:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:446:25: 446:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:452:25: 452:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:454:25: 454:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:456:25: 456:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:458:25: 458:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:460:25: 460:53 (#0) by default
@DefId(0:367 ~ c2rust_lib[1043]::bzlib::flush_RL)
bb0:
  _3 = ((*_1).13: u32)
  using: _1@Entry
  _4 = const 256_u32
  using: 
  _2 = Lt(move _3, move _4)
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1])
  switchInt(move _2) -> [0: bb2, otherwise: bb1]
  using: _2@Mir(bb0[2])
bb1:
  _6 = _1
  using: _1@Entry
  _5 = bzlib::add_pair_to_block(move _6) -> bb2
  using: _6@Mir(bb1[0])
bb2:
  _8 = _1
  using: _1@Phi(bb2)
  _7 = bzlib::init_RL(move _8) -> bb3
  using: _8@Mir(bb2[0])
bb3:
  return
  using: _0@Entry
@DefId(0:368 ~ c2rust_lib[1043]::bzlib::copy_input_until_stop)
bb0:
  _0 = const 0_u8
  using: 
  _3 = ((*_1).1: i32)
  using: _1@Entry
  _4 = const 2_i32
  using: 
  _2 = Eq(move _3, move _4)
  using: _3@Mir(bb0[1]), _4@Mir(bb0[2])
  switchInt(move _2) -> [0: bb29, otherwise: bb1]
  using: _2@Mir(bb0[3])
bb1:
  _6 = ((*_1).17: i32)
  using: _1@Phi(bb1)
  _7 = ((*_1).18: i32)
  using: _1@Phi(bb1)
  _5 = Ge(move _6, move _7)
  using: _6@Mir(bb1[0]), _7@Mir(bb1[1])
  switchInt(move _5) -> [0: bb2, otherwise: bb60]
  using: _5@Mir(bb1[2])
bb2:
  _156 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _9 = ((*_156).1: u32)
  using: _156@Mir(bb2[0])
  _10 = const 0_u32
  using: 
  _8 = Eq(move _9, move _10)
  using: _9@Mir(bb2[1]), _10@Mir(bb2[2])
  switchInt(move _8) -> [0: bb3, otherwise: bb60]
  using: _8@Mir(bb2[3])
bb3:
  _0 = const 1_u8
  using: 
  _157 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _14 = ((*_157).0: *mut i8)
  using: _157@Mir(bb3[1])
  _13 = move _14 as *mut u8 (PtrToPtr)
  using: _14@Mir(bb3[2])
  _12 = (*_13)
  using: _13@Mir(bb3[3])
  _11 = move _12 as u32 (IntToInt)
  using: _12@Mir(bb3[4])
  _17 = _11
  using: _11@Mir(bb3[5])
  _18 = ((*_1).13: u32)
  using: _1@Phi(bb1)
  _16 = Ne(move _17, move _18)
  using: _17@Mir(bb3[6]), _18@Mir(bb3[7])
  switchInt(move _16) -> [0: bb4, otherwise: bb5]
  using: _16@Mir(bb3[8])
bb4:
  _15 = const false
  using: 
  goto -> bb6
  using: 
bb5:
  _20 = ((*_1).14: i32)
  using: _1@Phi(bb1)
  _21 = const 1_i32
  using: 
  _19 = Eq(move _20, move _21)
  using: _20@Mir(bb5[0]), _21@Mir(bb5[1])
  _15 = move _19
  using: _19@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  switchInt(move _15) -> [0: bb14, otherwise: bb7]
  using: _15@Phi(bb6)
bb7:
  _23 = ((*_1).13: u32)
  using: _1@Phi(bb6)
  _22 = move _23 as u8 (IntToInt)
  using: _23@Mir(bb7[0])
  _25 = ((*_1).26: u32)
  using: _1@Phi(bb6)
  _26 = const 8_i32
  using: 
  _27 = CheckedShl(_25, _26)
  using: _25@Mir(bb7[2]), _26@Mir(bb7[3])
  assert(!move (_27.1: bool), "attempt to shift left by `{}`, which would overflow", move _26) -> bb8
  using: _27@Entry, _25@Entry, _26@Entry
bb8:
  _24 = move (_27.0: u32)
  using: _27@Mir(bb7[4])
  _29 = const {alloc723: *mut [u32; 256]}
  using: 
  _33 = ((*_1).26: u32)
  using: _1@Phi(bb6)
  _34 = const 24_i32
  using: 
  _35 = CheckedShr(_33, _34)
  using: _33@Mir(bb8[2]), _34@Mir(bb8[3])
  assert(!move (_35.1: bool), "attempt to shift right by `{}`, which would overflow", move _34) -> bb9
  using: _35@Entry, _33@Entry, _34@Entry
bb9:
  _32 = move (_35.0: u32)
  using: _35@Mir(bb8[4])
  _37 = _22
  using: _22@Mir(bb7[1])
  _36 = move _37 as u32 (IntToInt)
  using: _37@Mir(bb9[1])
  _31 = BitXor(move _32, move _36)
  using: _32@Mir(bb9[0]), _36@Mir(bb9[2])
  _30 = move _31 as usize (IntToInt)
  using: _31@Mir(bb9[3])
  _38 = const 256_usize
  using: 
  _39 = Lt(_30, _38)
  using: _30@Mir(bb9[4]), _38@Mir(bb9[5])
  assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _30) -> bb10
  using: _39@Entry, _38@Entry, _30@Entry
bb10:
  _28 = (*_29)[_30]
  using: _29@Mir(bb8[1]), _30@Mir(bb9[4])
  ((*_1).26: u32) = BitXor(move _24, move _28)
  using: _1@Phi(bb6), _24@Mir(bb8[0]), _28@Mir(bb10[0])
  _40 = const 1_i32
  using: 
  _42 = ((*_1).13: u32)
  using: _1@Phi(bb6)
  _41 = move _42 as usize (IntToInt)
  using: _42@Mir(bb10[3])
  _43 = const 256_usize
  using: 
  _44 = Lt(_41, _43)
  using: _41@Mir(bb10[4]), _43@Mir(bb10[5])
  assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _41) -> bb11
  using: _44@Entry, _43@Entry, _41@Entry
bb11:
  ((*_1).22: [u8; 256])[_41] = move _40 as u8 (IntToInt)
  using: _1@Phi(bb6), _41@Mir(bb10[4]), _40@Mir(bb10[2])
  _45 = _22
  using: _22@Mir(bb7[1])
  _47 = ((*_1).9: *mut u8)
  using: _1@Phi(bb6)
  _49 = ((*_1).17: i32)
  using: _1@Phi(bb6)
  _48 = move _49 as isize (IntToInt)
  using: _49@Mir(bb11[3])
  _46 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _47, move _48) -> bb12
  using: _47@Mir(bb11[2]), _48@Mir(bb11[4])
bb12:
  (*_46) = move _45
  using: _46@Mir(bb11[5]), _45@Mir(bb11[1])
  _50 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb6)
  assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb13
  using: _50@Entry, _1@Entry
bb13:
  ((*_1).17: i32) = move (_50.0: i32)
  using: _1@Phi(bb6), _50@Mir(bb12[1])
  _51 = _11
  using: _11@Mir(bb3[5])
  ((*_1).13: u32) = move _51
  using: _1@Phi(bb6), _51@Mir(bb13[1])
  goto -> bb23
  using: 
bb14:
  _54 = _11
  using: _11@Mir(bb3[5])
  _55 = ((*_1).13: u32)
  using: _1@Phi(bb6)
  _53 = Ne(move _54, move _55)
  using: _54@Mir(bb14[0]), _55@Mir(bb14[1])
  switchInt(move _53) -> [0: bb16, otherwise: bb15]
  using: _53@Mir(bb14[2])
bb15:
  _52 = const true
  using: 
  goto -> bb17
  using: 
bb16:
  _57 = ((*_1).14: i32)
  using: _1@Phi(bb6)
  _58 = const 255_i32
  using: 
  _56 = Eq(move _57, move _58)
  using: _57@Mir(bb16[0]), _58@Mir(bb16[1])
  _52 = move _56
  using: _56@Mir(bb16[2])
  goto -> bb17
  using: 
bb17:
  switchInt(move _52) -> [0: bb21, otherwise: bb18]
  using: _52@Phi(bb17)
bb18:
  _60 = ((*_1).13: u32)
  using: _1@Phi(bb17)
  _61 = const 256_u32
  using: 
  _59 = Lt(move _60, move _61)
  using: _60@Mir(bb18[0]), _61@Mir(bb18[1])
  switchInt(move _59) -> [0: bb20, otherwise: bb19]
  using: _59@Mir(bb18[2])
bb19:
  _63 = _1
  using: _1@Phi(bb17)
  _62 = bzlib::add_pair_to_block(move _63) -> bb20
  using: _63@Mir(bb19[0])
bb20:
  _64 = _11
  using: _11@Mir(bb3[5])
  ((*_1).13: u32) = move _64
  using: _1@Phi(bb20), _64@Mir(bb20[0])
  _65 = const 1_i32
  using: 
  ((*_1).14: i32) = move _65
  using: _1@Phi(bb20), _65@Mir(bb20[2])
  goto -> bb23
  using: 
bb21:
  _66 = CheckedAdd(((*_1).14: i32), const 1_i32)
  using: _1@Phi(bb20)
  assert(!move (_66.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).14: i32), const 1_i32) -> bb22
  using: _66@Entry, _1@Entry
bb22:
  ((*_1).14: i32) = move (_66.0: i32)
  using: _1@Phi(bb20), _66@Mir(bb21[0])
  goto -> bb23
  using: 
bb23:
  _158 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  _68 = ((*_158).0: *mut i8)
  using: _158@Mir(bb23[0])
  _67 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _68, const 1_isize) -> bb24
  using: _68@Mir(bb23[1])
bb24:
  _159 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  ((*_159).0: *mut i8) = move _67
  using: _159@Mir(bb24[0]), _67@Mir(bb23[2])
  _160 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  _70 = ((*_160).1: u32)
  using: _160@Mir(bb24[2])
  _69 = core::num::<impl u32>::wrapping_sub(move _70, const 1_u32) -> bb25
  using: _70@Mir(bb24[3])
bb25:
  _161 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  ((*_161).1: u32) = move _69
  using: _161@Mir(bb25[0]), _69@Mir(bb24[4])
  _162 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  _72 = ((*_162).2: u32)
  using: _162@Mir(bb25[2])
  _71 = core::num::<impl u32>::wrapping_add(move _72, const 1_u32) -> bb26
  using: _72@Mir(bb25[3])
bb26:
  _163 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  ((*_163).2: u32) = move _71
  using: _163@Mir(bb26[0]), _71@Mir(bb25[4])
  _164 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  _74 = ((*_164).2: u32)
  using: _164@Mir(bb26[2])
  _75 = const 0_u32
  using: 
  _73 = Eq(move _74, move _75)
  using: _74@Mir(bb26[3]), _75@Mir(bb26[4])
  switchInt(move _73) -> [0: bb1, otherwise: bb27]
  using: _73@Mir(bb26[5])
bb27:
  _165 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  _77 = ((*_165).3: u32)
  using: _165@Mir(bb27[0])
  _76 = core::num::<impl u32>::wrapping_add(move _77, const 1_u32) -> bb28
  using: _77@Mir(bb27[1])
bb28:
  _166 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb23)
  ((*_166).3: u32) = move _76
  using: _166@Mir(bb28[0]), _76@Mir(bb27[2])
  goto -> bb1
  using: 
bb29:
  _79 = ((*_1).17: i32)
  using: _1@Phi(bb29)
  _80 = ((*_1).18: i32)
  using: _1@Phi(bb29)
  _78 = Ge(move _79, move _80)
  using: _79@Mir(bb29[0]), _80@Mir(bb29[1])
  switchInt(move _78) -> [0: bb30, otherwise: bb60]
  using: _78@Mir(bb29[2])
bb30:
  _167 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb29)
  _82 = ((*_167).1: u32)
  using: _167@Mir(bb30[0])
  _83 = const 0_u32
  using: 
  _81 = Eq(move _82, move _83)
  using: _82@Mir(bb30[1]), _83@Mir(bb30[2])
  switchInt(move _81) -> [0: bb31, otherwise: bb60]
  using: _81@Mir(bb30[3])
bb31:
  _85 = ((*_1).3: u32)
  using: _1@Phi(bb29)
  _86 = const 0_u32
  using: 
  _84 = Eq(move _85, move _86)
  using: _85@Mir(bb31[0]), _86@Mir(bb31[1])
  switchInt(move _84) -> [0: bb32, otherwise: bb60]
  using: _84@Mir(bb31[2])
bb32:
  _0 = const 1_u8
  using: 
  _168 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb29)
  _90 = ((*_168).0: *mut i8)
  using: _168@Mir(bb32[1])
  _89 = move _90 as *mut u8 (PtrToPtr)
  using: _90@Mir(bb32[2])
  _88 = (*_89)
  using: _89@Mir(bb32[3])
  _87 = move _88 as u32 (IntToInt)
  using: _88@Mir(bb32[4])
  _93 = _87
  using: _87@Mir(bb32[5])
  _94 = ((*_1).13: u32)
  using: _1@Phi(bb29)
  _92 = Ne(move _93, move _94)
  using: _93@Mir(bb32[6]), _94@Mir(bb32[7])
  switchInt(move _92) -> [0: bb33, otherwise: bb34]
  using: _92@Mir(bb32[8])
bb33:
  _91 = const false
  using: 
  goto -> bb35
  using: 
bb34:
  _96 = ((*_1).14: i32)
  using: _1@Phi(bb29)
  _97 = const 1_i32
  using: 
  _95 = Eq(move _96, move _97)
  using: _96@Mir(bb34[0]), _97@Mir(bb34[1])
  _91 = move _95
  using: _95@Mir(bb34[2])
  goto -> bb35
  using: 
bb35:
  switchInt(move _91) -> [0: bb43, otherwise: bb36]
  using: _91@Phi(bb35)
bb36:
  _99 = ((*_1).13: u32)
  using: _1@Phi(bb35)
  _98 = move _99 as u8 (IntToInt)
  using: _99@Mir(bb36[0])
  _101 = ((*_1).26: u32)
  using: _1@Phi(bb35)
  _102 = const 8_i32
  using: 
  _103 = CheckedShl(_101, _102)
  using: _101@Mir(bb36[2]), _102@Mir(bb36[3])
  assert(!move (_103.1: bool), "attempt to shift left by `{}`, which would overflow", move _102) -> bb37
  using: _103@Entry, _101@Entry, _102@Entry
bb37:
  _100 = move (_103.0: u32)
  using: _103@Mir(bb36[4])
  _105 = const {alloc723: *mut [u32; 256]}
  using: 
  _109 = ((*_1).26: u32)
  using: _1@Phi(bb35)
  _110 = const 24_i32
  using: 
  _111 = CheckedShr(_109, _110)
  using: _109@Mir(bb37[2]), _110@Mir(bb37[3])
  assert(!move (_111.1: bool), "attempt to shift right by `{}`, which would overflow", move _110) -> bb38
  using: _111@Entry, _109@Entry, _110@Entry
bb38:
  _108 = move (_111.0: u32)
  using: _111@Mir(bb37[4])
  _113 = _98
  using: _98@Mir(bb36[1])
  _112 = move _113 as u32 (IntToInt)
  using: _113@Mir(bb38[1])
  _107 = BitXor(move _108, move _112)
  using: _108@Mir(bb38[0]), _112@Mir(bb38[2])
  _106 = move _107 as usize (IntToInt)
  using: _107@Mir(bb38[3])
  _114 = const 256_usize
  using: 
  _115 = Lt(_106, _114)
  using: _106@Mir(bb38[4]), _114@Mir(bb38[5])
  assert(move _115, "index out of bounds: the length is {} but the index is {}", move _114, _106) -> bb39
  using: _115@Entry, _114@Entry, _106@Entry
bb39:
  _104 = (*_105)[_106]
  using: _105@Mir(bb37[1]), _106@Mir(bb38[4])
  ((*_1).26: u32) = BitXor(move _100, move _104)
  using: _1@Phi(bb35), _100@Mir(bb37[0]), _104@Mir(bb39[0])
  _116 = const 1_i32
  using: 
  _118 = ((*_1).13: u32)
  using: _1@Phi(bb35)
  _117 = move _118 as usize (IntToInt)
  using: _118@Mir(bb39[3])
  _119 = const 256_usize
  using: 
  _120 = Lt(_117, _119)
  using: _117@Mir(bb39[4]), _119@Mir(bb39[5])
  assert(move _120, "index out of bounds: the length is {} but the index is {}", move _119, _117) -> bb40
  using: _120@Entry, _119@Entry, _117@Entry
bb40:
  ((*_1).22: [u8; 256])[_117] = move _116 as u8 (IntToInt)
  using: _1@Phi(bb35), _117@Mir(bb39[4]), _116@Mir(bb39[2])
  _121 = _98
  using: _98@Mir(bb36[1])
  _123 = ((*_1).9: *mut u8)
  using: _1@Phi(bb35)
  _125 = ((*_1).17: i32)
  using: _1@Phi(bb35)
  _124 = move _125 as isize (IntToInt)
  using: _125@Mir(bb40[3])
  _122 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _123, move _124) -> bb41
  using: _123@Mir(bb40[2]), _124@Mir(bb40[4])
bb41:
  (*_122) = move _121
  using: _122@Mir(bb40[5]), _121@Mir(bb40[1])
  _126 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb35)
  assert(!move (_126.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb42
  using: _126@Entry, _1@Entry
bb42:
  ((*_1).17: i32) = move (_126.0: i32)
  using: _1@Phi(bb35), _126@Mir(bb41[1])
  _127 = _87
  using: _87@Mir(bb32[5])
  ((*_1).13: u32) = move _127
  using: _1@Phi(bb35), _127@Mir(bb42[1])
  goto -> bb52
  using: 
bb43:
  _130 = _87
  using: _87@Mir(bb32[5])
  _131 = ((*_1).13: u32)
  using: _1@Phi(bb35)
  _129 = Ne(move _130, move _131)
  using: _130@Mir(bb43[0]), _131@Mir(bb43[1])
  switchInt(move _129) -> [0: bb45, otherwise: bb44]
  using: _129@Mir(bb43[2])
bb44:
  _128 = const true
  using: 
  goto -> bb46
  using: 
bb45:
  _133 = ((*_1).14: i32)
  using: _1@Phi(bb35)
  _134 = const 255_i32
  using: 
  _132 = Eq(move _133, move _134)
  using: _133@Mir(bb45[0]), _134@Mir(bb45[1])
  _128 = move _132
  using: _132@Mir(bb45[2])
  goto -> bb46
  using: 
bb46:
  switchInt(move _128) -> [0: bb50, otherwise: bb47]
  using: _128@Phi(bb46)
bb47:
  _136 = ((*_1).13: u32)
  using: _1@Phi(bb46)
  _137 = const 256_u32
  using: 
  _135 = Lt(move _136, move _137)
  using: _136@Mir(bb47[0]), _137@Mir(bb47[1])
  switchInt(move _135) -> [0: bb49, otherwise: bb48]
  using: _135@Mir(bb47[2])
bb48:
  _139 = _1
  using: _1@Phi(bb46)
  _138 = bzlib::add_pair_to_block(move _139) -> bb49
  using: _139@Mir(bb48[0])
bb49:
  _140 = _87
  using: _87@Mir(bb32[5])
  ((*_1).13: u32) = move _140
  using: _1@Phi(bb49), _140@Mir(bb49[0])
  _141 = const 1_i32
  using: 
  ((*_1).14: i32) = move _141
  using: _1@Phi(bb49), _141@Mir(bb49[2])
  goto -> bb52
  using: 
bb50:
  _142 = CheckedAdd(((*_1).14: i32), const 1_i32)
  using: _1@Phi(bb49)
  assert(!move (_142.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).14: i32), const 1_i32) -> bb51
  using: _142@Entry, _1@Entry
bb51:
  ((*_1).14: i32) = move (_142.0: i32)
  using: _1@Phi(bb49), _142@Mir(bb50[0])
  goto -> bb52
  using: 
bb52:
  _169 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  _144 = ((*_169).0: *mut i8)
  using: _169@Mir(bb52[0])
  _143 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _144, const 1_isize) -> bb53
  using: _144@Mir(bb52[1])
bb53:
  _170 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  ((*_170).0: *mut i8) = move _143
  using: _170@Mir(bb53[0]), _143@Mir(bb52[2])
  _171 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  _146 = ((*_171).1: u32)
  using: _171@Mir(bb53[2])
  _145 = core::num::<impl u32>::wrapping_sub(move _146, const 1_u32) -> bb54
  using: _146@Mir(bb53[3])
bb54:
  _172 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  ((*_172).1: u32) = move _145
  using: _172@Mir(bb54[0]), _145@Mir(bb53[4])
  _173 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  _148 = ((*_173).2: u32)
  using: _173@Mir(bb54[2])
  _147 = core::num::<impl u32>::wrapping_add(move _148, const 1_u32) -> bb55
  using: _148@Mir(bb54[3])
bb55:
  _174 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  ((*_174).2: u32) = move _147
  using: _174@Mir(bb55[0]), _147@Mir(bb54[4])
  _175 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  _150 = ((*_175).2: u32)
  using: _175@Mir(bb55[2])
  _151 = const 0_u32
  using: 
  _149 = Eq(move _150, move _151)
  using: _150@Mir(bb55[3]), _151@Mir(bb55[4])
  switchInt(move _149) -> [0: bb58, otherwise: bb56]
  using: _149@Mir(bb55[5])
bb56:
  _176 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  _153 = ((*_176).3: u32)
  using: _176@Mir(bb56[0])
  _152 = core::num::<impl u32>::wrapping_add(move _153, const 1_u32) -> bb57
  using: _153@Mir(bb56[1])
bb57:
  _177 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb52)
  ((*_177).3: u32) = move _152
  using: _177@Mir(bb57[0]), _152@Mir(bb56[2])
  goto -> bb58
  using: 
bb58:
  _155 = ((*_1).3: u32)
  using: _1@Phi(bb58)
  _154 = core::num::<impl u32>::wrapping_sub(move _155, const 1_u32) -> bb59
  using: _155@Mir(bb58[0])
bb59:
  ((*_1).3: u32) = move _154
  using: _1@Phi(bb58), _154@Mir(bb58[1])
  goto -> bb29
  using: 
bb60:
  return
  using: _0@Phi(bb60)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:500:29: 500:57 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:511:57: 511:66 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:512:59: 512:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:514:44: 514:59 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:518:48: 518:63 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:546:29: 546:57 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:557:57: 557:66 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:558:59: 558:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:560:44: 560:59 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:564:48: 564:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:566:57: 566:72 (#0) by default
@DefId(0:369 ~ c2rust_lib[1043]::bzlib::copy_output_until_stop)
bb0:
  _0 = const 0_u8
  using: 
  goto -> bb1
  using: 
bb1:
  _25 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _3 = ((*_25).5: u32)
  using: _25@Mir(bb1[0])
  _4 = const 0_u32
  using: 
  _2 = Eq(move _3, move _4)
  using: _3@Mir(bb1[1]), _4@Mir(bb1[2])
  switchInt(move _2) -> [0: bb2, otherwise: bb11]
  using: _2@Mir(bb1[3])
bb2:
  _6 = ((*_1).20: i32)
  using: _1@Phi(bb1)
  _7 = ((*_1).19: i32)
  using: _1@Phi(bb1)
  _5 = Ge(move _6, move _7)
  using: _6@Mir(bb2[0]), _7@Mir(bb2[1])
  switchInt(move _5) -> [0: bb3, otherwise: bb11]
  using: _5@Mir(bb2[2])
bb3:
  _0 = const 1_u8
  using: 
  _10 = ((*_1).11: *mut u8)
  using: _1@Phi(bb1)
  _12 = ((*_1).20: i32)
  using: _1@Phi(bb1)
  _11 = move _12 as isize (IntToInt)
  using: _12@Mir(bb3[2])
  _9 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _10, move _11) -> bb4
  using: _10@Mir(bb3[1]), _11@Mir(bb3[3])
bb4:
  _8 = (*_9)
  using: _9@Mir(bb3[4])
  _26 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _27 = deref_copy ((*_26).4: *mut i8)
  using: _26@Mir(bb4[1])
  (*_27) = move _8 as i8 (IntToInt)
  using: _27@Mir(bb4[2]), _8@Mir(bb4[0])
  _13 = CheckedAdd(((*_1).20: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).20: i32), const 1_i32) -> bb5
  using: _13@Entry, _1@Entry
bb5:
  ((*_1).20: i32) = move (_13.0: i32)
  using: _1@Phi(bb1), _13@Mir(bb4[4])
  _28 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _15 = ((*_28).5: u32)
  using: _28@Mir(bb5[1])
  _14 = core::num::<impl u32>::wrapping_sub(move _15, const 1_u32) -> bb6
  using: _15@Mir(bb5[2])
bb6:
  _29 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  ((*_29).5: u32) = move _14
  using: _29@Mir(bb6[0]), _14@Mir(bb5[3])
  _30 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _17 = ((*_30).4: *mut i8)
  using: _30@Mir(bb6[2])
  _16 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _17, const 1_isize) -> bb7
  using: _17@Mir(bb6[3])
bb7:
  _31 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  ((*_31).4: *mut i8) = move _16
  using: _31@Mir(bb7[0]), _16@Mir(bb6[4])
  _32 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _19 = ((*_32).6: u32)
  using: _32@Mir(bb7[2])
  _18 = core::num::<impl u32>::wrapping_add(move _19, const 1_u32) -> bb8
  using: _19@Mir(bb7[3])
bb8:
  _33 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  ((*_33).6: u32) = move _18
  using: _33@Mir(bb8[0]), _18@Mir(bb7[4])
  _34 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _21 = ((*_34).6: u32)
  using: _34@Mir(bb8[2])
  _22 = const 0_u32
  using: 
  _20 = Eq(move _21, move _22)
  using: _21@Mir(bb8[3]), _22@Mir(bb8[4])
  switchInt(move _20) -> [0: bb1, otherwise: bb9]
  using: _20@Mir(bb8[5])
bb9:
  _35 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  _24 = ((*_35).7: u32)
  using: _35@Mir(bb9[0])
  _23 = core::num::<impl u32>::wrapping_add(move _24, const 1_u32) -> bb10
  using: _24@Mir(bb9[1])
bb10:
  _36 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb1)
  ((*_36).7: u32) = move _23
  using: _36@Mir(bb10[0]), _23@Mir(bb9[2])
  goto -> bb1
  using: 
bb11:
  return
  using: _0@Phi(bb1)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:583:25: 583:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:585:57: 585:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:586:55: 586:64 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:588:41: 588:56 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:591:45: 591:60 (#0) by default
@DefId(0:370 ~ c2rust_lib[1043]::bzlib::handle_compress)
bb0:
  _2 = const 0_u8
  using: 
  _3 = const 0_u8
  using: 
  _5 = ((*_1).8: *mut std::ffi::c_void)
  using: _1@Entry
  _4 = move _5 as *mut blocksort::EState (PtrToPtr)
  using: _5@Mir(bb0[2])
  goto -> bb1
  using: 
bb1:
  _7 = ((*_4).2: i32)
  using: _4@Phi(bb1)
  _8 = const 1_i32
  using: 
  _6 = Eq(move _7, move _8)
  using: _7@Mir(bb1[0]), _8@Mir(bb1[1])
  switchInt(move _6) -> [0: bb21, otherwise: bb2]
  using: _6@Mir(bb1[2])
bb2:
  _11 = _3
  using: _3@Phi(bb1)
  _10 = move _11 as i32 (IntToInt)
  using: _11@Mir(bb2[0])
  _14 = _4
  using: _4@Phi(bb1)
  _13 = bzlib::copy_output_until_stop(move _14) -> bb3
  using: _14@Mir(bb2[2])
bb3:
  _12 = move _13 as i32 (IntToInt)
  using: _13@Mir(bb2[3])
  _9 = BitOr(move _10, move _12)
  using: _10@Mir(bb2[1]), _12@Mir(bb3[0])
  _3 = move _9 as u8 (IntToInt)
  using: _9@Mir(bb3[1])
  _16 = ((*_4).20: i32)
  using: _4@Phi(bb1)
  _17 = ((*_4).19: i32)
  using: _4@Phi(bb1)
  _15 = Lt(move _16, move _17)
  using: _16@Mir(bb3[3]), _17@Mir(bb3[4])
  switchInt(move _15) -> [0: bb4, otherwise: bb34]
  using: _15@Mir(bb3[5])
bb4:
  _21 = ((*_4).1: i32)
  using: _4@Phi(bb1)
  _22 = const 4_i32
  using: 
  _20 = Eq(move _21, move _22)
  using: _21@Mir(bb4[0]), _22@Mir(bb4[1])
  switchInt(move _20) -> [0: bb8, otherwise: bb9]
  using: _20@Mir(bb4[2])
bb5:
  _18 = const false
  using: 
  goto -> bb7
  using: 
bb6:
  _29 = _4
  using: _4@Phi(bb10)
  _28 = bzlib::isempty_RL(move _29) -> bb11
  using: _29@Mir(bb6[0])
bb7:
  switchInt(move _18) -> [0: bb12, otherwise: bb34]
  using: _18@Phi(bb7)
bb8:
  _19 = const false
  using: 
  goto -> bb10
  using: 
bb9:
  _24 = ((*_4).3: u32)
  using: _4@Phi(bb1)
  _25 = const 0_u32
  using: 
  _23 = Eq(move _24, move _25)
  using: _24@Mir(bb9[0]), _25@Mir(bb9[1])
  _19 = move _23
  using: _23@Mir(bb9[2])
  goto -> bb10
  using: 
bb10:
  switchInt(move _19) -> [0: bb5, otherwise: bb6]
  using: _19@Phi(bb10)
bb11:
  _27 = move _28 as i32 (IntToInt)
  using: _28@Mir(bb6[1])
  _26 = Ne(move _27, const 0_i32)
  using: _27@Mir(bb11[0])
  _18 = move _26
  using: _26@Mir(bb11[1])
  goto -> bb7
  using: 
bb12:
  _31 = _4
  using: _4@Phi(bb7)
  _30 = bzlib::prepare_new_block(move _31) -> bb13
  using: _31@Mir(bb12[0])
bb13:
  _32 = const 2_i32
  using: 
  ((*_4).2: i32) = move _32
  using: _4@Phi(bb7), _32@Mir(bb13[0])
  _36 = ((*_4).1: i32)
  using: _4@Phi(bb7)
  _37 = const 3_i32
  using: 
  _35 = Eq(move _36, move _37)
  using: _36@Mir(bb13[2]), _37@Mir(bb13[3])
  switchInt(move _35) -> [0: bb17, otherwise: bb18]
  using: _35@Mir(bb13[4])
bb14:
  _33 = const false
  using: 
  goto -> bb16
  using: 
bb15:
  _44 = _4
  using: _4@Phi(bb19)
  _43 = bzlib::isempty_RL(move _44) -> bb20
  using: _44@Mir(bb15[0])
bb16:
  switchInt(move _33) -> [0: bb21, otherwise: bb34]
  using: _33@Phi(bb16)
bb17:
  _34 = const false
  using: 
  goto -> bb19
  using: 
bb18:
  _39 = ((*_4).3: u32)
  using: _4@Phi(bb7)
  _40 = const 0_u32
  using: 
  _38 = Eq(move _39, move _40)
  using: _39@Mir(bb18[0]), _40@Mir(bb18[1])
  _34 = move _38
  using: _38@Mir(bb18[2])
  goto -> bb19
  using: 
bb19:
  switchInt(move _34) -> [0: bb14, otherwise: bb15]
  using: _34@Phi(bb19)
bb20:
  _42 = move _43 as i32 (IntToInt)
  using: _43@Mir(bb15[1])
  _41 = Ne(move _42, const 0_i32)
  using: _42@Mir(bb20[0])
  _33 = move _41
  using: _41@Mir(bb20[1])
  goto -> bb16
  using: 
bb21:
  _47 = ((*_4).2: i32)
  using: _4@Phi(bb21)
  _48 = const 2_i32
  using: 
  _46 = Eq(move _47, move _48)
  using: _47@Mir(bb21[0]), _48@Mir(bb21[1])
  _45 = Not(move _46)
  using: _46@Mir(bb21[2])
  switchInt(move _45) -> [0: bb22, otherwise: bb1]
  using: _45@Mir(bb21[3])
bb22:
  _51 = _2
  using: _2@Phi(bb1)
  _50 = move _51 as i32 (IntToInt)
  using: _51@Mir(bb22[0])
  _54 = _4
  using: _4@Phi(bb21)
  _53 = bzlib::copy_input_until_stop(move _54) -> bb23
  using: _54@Mir(bb22[2])
bb23:
  _52 = move _53 as i32 (IntToInt)
  using: _53@Mir(bb22[3])
  _49 = BitOr(move _50, move _52)
  using: _50@Mir(bb22[1]), _52@Mir(bb23[0])
  _2 = move _49 as u8 (IntToInt)
  using: _49@Mir(bb23[1])
  _57 = ((*_4).1: i32)
  using: _4@Phi(bb21)
  _58 = const 2_i32
  using: 
  _56 = Ne(move _57, move _58)
  using: _57@Mir(bb23[3]), _58@Mir(bb23[4])
  switchInt(move _56) -> [0: bb24, otherwise: bb25]
  using: _56@Mir(bb23[5])
bb24:
  _55 = const false
  using: 
  goto -> bb26
  using: 
bb25:
  _60 = ((*_4).3: u32)
  using: _4@Phi(bb21)
  _61 = const 0_u32
  using: 
  _59 = Eq(move _60, move _61)
  using: _60@Mir(bb25[0]), _61@Mir(bb25[1])
  _55 = move _59
  using: _59@Mir(bb25[2])
  goto -> bb26
  using: 
bb26:
  switchInt(move _55) -> [0: bb30, otherwise: bb27]
  using: _55@Phi(bb26)
bb27:
  _63 = _4
  using: _4@Phi(bb26)
  _62 = bzlib::flush_RL(move _63) -> bb28
  using: _63@Mir(bb27[0])
bb28:
  _65 = _4
  using: _4@Phi(bb26)
  _69 = ((*_4).1: i32)
  using: _4@Phi(bb26)
  _70 = const 4_i32
  using: 
  _68 = Eq(move _69, move _70)
  using: _69@Mir(bb28[1]), _70@Mir(bb28[2])
  _67 = move _68 as i32 (IntToInt)
  using: _68@Mir(bb28[3])
  _66 = move _67 as u8 (IntToInt)
  using: _67@Mir(bb28[4])
  _64 = compress::BZ2_compressBlock(move _65, move _66) -> bb29
  using: _65@Mir(bb28[0]), _66@Mir(bb28[5])
bb29:
  _71 = const 1_i32
  using: 
  ((*_4).2: i32) = move _71
  using: _4@Phi(bb26), _71@Mir(bb29[0])
  goto -> bb1
  using: 
bb30:
  _73 = ((*_4).17: i32)
  using: _4@Phi(bb26)
  _74 = ((*_4).18: i32)
  using: _4@Phi(bb26)
  _72 = Ge(move _73, move _74)
  using: _73@Mir(bb30[0]), _74@Mir(bb30[1])
  switchInt(move _72) -> [0: bb33, otherwise: bb31]
  using: _72@Mir(bb30[2])
bb31:
  _76 = _4
  using: _4@Phi(bb26)
  _77 = const 0_u8
  using: 
  _75 = compress::BZ2_compressBlock(move _76, move _77) -> bb32
  using: _76@Mir(bb31[0]), _77@Mir(bb31[1])
bb32:
  _78 = const 1_i32
  using: 
  ((*_4).2: i32) = move _78
  using: _4@Phi(bb26), _78@Mir(bb32[0])
  goto -> bb1
  using: 
bb33:
  _89 = deref_copy ((*_4).0: *mut blocksort::bz_stream)
  using: _4@Phi(bb26)
  _80 = ((*_89).1: u32)
  using: _89@Mir(bb33[0])
  _81 = const 0_u32
  using: 
  _79 = Eq(move _80, move _81)
  using: _80@Mir(bb33[1]), _81@Mir(bb33[2])
  switchInt(move _79) -> [0: bb1, otherwise: bb34]
  using: _79@Mir(bb33[3])
bb34:
  _85 = _2
  using: _2@Phi(bb34)
  _84 = move _85 as i32 (IntToInt)
  using: _85@Mir(bb34[0])
  switchInt(move _84) -> [0: bb36, otherwise: bb35]
  using: _84@Mir(bb34[1])
bb35:
  _83 = const true
  using: 
  goto -> bb37
  using: 
bb36:
  _88 = _3
  using: _3@Phi(bb34)
  _87 = move _88 as i32 (IntToInt)
  using: _88@Mir(bb36[0])
  _86 = Ne(move _87, const 0_i32)
  using: _87@Mir(bb36[1])
  _83 = move _86
  using: _86@Mir(bb36[2])
  goto -> bb37
  using: 
bb37:
  _82 = move _83 as i32 (IntToInt)
  using: _83@Phi(bb37)
  _0 = move _82 as u8 (IntToInt)
  using: _82@Mir(bb37[0])
  return
  using: _0@Mir(bb37[1])
@DefId(0:371 ~ c2rust_lib[1043]::bzlib::BZ2_bzCompress)
bb0:
  _3 = const 0_u8
  using: 
  _4 = const {0x0 as *mut blocksort::EState}
  using: 
  _6 = _1
  using: _1@Entry
  _5 = std::ptr::mut_ptr::<impl *mut blocksort::bz_stream>::is_null(move _6) -> bb1
  using: _6@Mir(bb0[2])
bb1:
  switchInt(move _5) -> [0: bb3, otherwise: bb2]
  using: _5@Mir(bb0[3])
bb2:
  _9 = _1
  using: _1@Entry
  _8 = move _9 as usize (PointerExposeAddress)
  using: _9@Mir(bb2[0])
  _7 = Eq(move _8, const 0_usize)
  using: _8@Mir(bb2[1])
  assume(move _7)
  using: _7@Mir(bb2[2])
  _0 = const -2_i32
  using: 
  goto -> bb53
  using: 
bb3:
  _10 = ((*_1).8: *mut std::ffi::c_void)
  using: _1@Entry
  _4 = move _10 as *mut blocksort::EState (PtrToPtr)
  using: _10@Mir(bb3[0])
  _12 = _4
  using: _4@Mir(bb3[1])
  _11 = std::ptr::mut_ptr::<impl *mut blocksort::EState>::is_null(move _12) -> bb4
  using: _12@Mir(bb3[2])
bb4:
  switchInt(move _11) -> [0: bb6, otherwise: bb5]
  using: _11@Mir(bb3[3])
bb5:
  _15 = _4
  using: _4@Mir(bb3[1])
  _14 = move _15 as usize (PointerExposeAddress)
  using: _15@Mir(bb5[0])
  _13 = Eq(move _14, const 0_usize)
  using: _14@Mir(bb5[1])
  assume(move _13)
  using: _13@Mir(bb5[2])
  _0 = const -2_i32
  using: 
  goto -> bb53
  using: 
bb6:
  _17 = ((*_4).0: *mut blocksort::bz_stream)
  using: _4@Mir(bb3[1])
  _18 = _1
  using: _1@Entry
  _16 = Ne(move _17, move _18)
  using: _17@Mir(bb6[0]), _18@Mir(bb6[1])
  switchInt(move _16) -> [0: bb8, otherwise: bb7]
  using: _16@Mir(bb6[2])
bb7:
  _0 = const -2_i32
  using: 
  goto -> bb53
  using: 
bb8:
  switchInt(((*_4).1: i32)) -> [1: bb10, 2: bb11, 3: bb21, 4: bb36, otherwise: bb9]
  using: _4@Phi(bb8)
bb9:
  _0 = const 0_i32
  using: 
  goto -> bb53
  using: 
bb10:
  _0 = const -1_i32
  using: 
  goto -> bb53
  using: 
bb11:
  _20 = _2
  using: _2@Phi(bb8)
  _21 = const 0_i32
  using: 
  _19 = Eq(move _20, move _21)
  using: _20@Mir(bb11[0]), _21@Mir(bb11[1])
  switchInt(move _19) -> [0: bb16, otherwise: bb12]
  using: _19@Mir(bb11[2])
bb12:
  _23 = _1
  using: _1@Phi(bb8)
  _22 = bzlib::handle_compress(move _23) -> bb13
  using: _23@Mir(bb12[0])
bb13:
  _3 = move _22
  using: _22@Mir(bb12[1])
  _25 = _3
  using: _3@Mir(bb13[0])
  _24 = move _25 as i32 (IntToInt)
  using: _25@Mir(bb13[1])
  switchInt(move _24) -> [0: bb15, otherwise: bb14]
  using: _24@Mir(bb13[2])
bb14:
  _0 = const 1_i32
  using: 
  goto -> bb53
  using: 
bb15:
  _0 = const -2_i32
  using: 
  goto -> bb53
  using: 
bb16:
  _27 = _2
  using: _2@Phi(bb8)
  _28 = const 1_i32
  using: 
  _26 = Eq(move _27, move _28)
  using: _27@Mir(bb16[0]), _28@Mir(bb16[1])
  switchInt(move _26) -> [0: bb18, otherwise: bb17]
  using: _26@Mir(bb16[2])
bb17:
  _29 = ((*_1).1: u32)
  using: _1@Phi(bb8)
  ((*_4).3: u32) = move _29
  using: _4@Phi(bb8), _29@Mir(bb17[0])
  _30 = const 3_i32
  using: 
  ((*_4).1: i32) = move _30
  using: _4@Phi(bb8), _30@Mir(bb17[2])
  goto -> bb8
  using: 
bb18:
  _32 = _2
  using: _2@Phi(bb8)
  _33 = const 2_i32
  using: 
  _31 = Eq(move _32, move _33)
  using: _32@Mir(bb18[0]), _33@Mir(bb18[1])
  switchInt(move _31) -> [0: bb20, otherwise: bb19]
  using: _31@Mir(bb18[2])
bb19:
  _34 = ((*_1).1: u32)
  using: _1@Phi(bb8)
  ((*_4).3: u32) = move _34
  using: _4@Phi(bb8), _34@Mir(bb19[0])
  _35 = const 4_i32
  using: 
  ((*_4).1: i32) = move _35
  using: _4@Phi(bb8), _35@Mir(bb19[2])
  goto -> bb8
  using: 
bb20:
  _0 = const -2_i32
  using: 
  goto -> bb53
  using: 
bb21:
  _37 = _2
  using: _2@Phi(bb8)
  _38 = const 1_i32
  using: 
  _36 = Ne(move _37, move _38)
  using: _37@Mir(bb21[0]), _38@Mir(bb21[1])
  switchInt(move _36) -> [0: bb23, otherwise: bb22]
  using: _36@Mir(bb21[2])
bb22:
  _0 = const -1_i32
  using: 
  goto -> bb53
  using: 
bb23:
  _40 = ((*_4).3: u32)
  using: _4@Phi(bb8)
  _77 = deref_copy ((*_4).0: *mut blocksort::bz_stream)
  using: _4@Phi(bb8)
  _41 = ((*_77).1: u32)
  using: _77@Mir(bb23[1])
  _39 = Ne(move _40, move _41)
  using: _40@Mir(bb23[0]), _41@Mir(bb23[2])
  switchInt(move _39) -> [0: bb25, otherwise: bb24]
  using: _39@Mir(bb23[3])
bb24:
  _0 = const -1_i32
  using: 
  goto -> bb53
  using: 
bb25:
  _43 = _1
  using: _1@Phi(bb8)
  _42 = bzlib::handle_compress(move _43) -> bb26
  using: _43@Mir(bb25[0])
bb26:
  _3 = move _42
  using: _42@Mir(bb25[1])
  _47 = ((*_4).3: u32)
  using: _4@Phi(bb8)
  _48 = const 0_u32
  using: 
  _46 = Gt(move _47, move _48)
  using: _47@Mir(bb26[1]), _48@Mir(bb26[2])
  switchInt(move _46) -> [0: bb31, otherwise: bb30]
  using: _46@Mir(bb26[3])
bb27:
  _44 = const true
  using: 
  goto -> bb29
  using: 
bb28:
  _53 = ((*_4).20: i32)
  using: _4@Phi(bb32)
  _54 = ((*_4).19: i32)
  using: _4@Phi(bb32)
  _52 = Lt(move _53, move _54)
  using: _53@Mir(bb28[0]), _54@Mir(bb28[1])
  _44 = move _52
  using: _52@Mir(bb28[2])
  goto -> bb29
  using: 
bb29:
  switchInt(move _44) -> [0: bb35, otherwise: bb34]
  using: _44@Phi(bb29)
bb30:
  _45 = const true
  using: 
  goto -> bb32
  using: 
bb31:
  _51 = _4
  using: _4@Phi(bb8)
  _50 = bzlib::isempty_RL(move _51) -> bb33
  using: _51@Mir(bb31[0])
bb32:
  switchInt(move _45) -> [0: bb28, otherwise: bb27]
  using: _45@Phi(bb32)
bb33:
  _49 = Eq(move _50, const 0_u8)
  using: _50@Mir(bb31[1])
  _45 = move _49
  using: _49@Mir(bb33[0])
  goto -> bb32
  using: 
bb34:
  _0 = const 2_i32
  using: 
  goto -> bb53
  using: 
bb35:
  _55 = const 2_i32
  using: 
  ((*_4).1: i32) = move _55
  using: _4@Phi(bb29), _55@Mir(bb35[0])
  _0 = const 1_i32
  using: 
  goto -> bb53
  using: 
bb36:
  _57 = _2
  using: _2@Phi(bb8)
  _58 = const 2_i32
  using: 
  _56 = Ne(move _57, move _58)
  using: _57@Mir(bb36[0]), _58@Mir(bb36[1])
  switchInt(move _56) -> [0: bb38, otherwise: bb37]
  using: _56@Mir(bb36[2])
bb37:
  _0 = const -1_i32
  using: 
  goto -> bb53
  using: 
bb38:
  _60 = ((*_4).3: u32)
  using: _4@Phi(bb29)
  _78 = deref_copy ((*_4).0: *mut blocksort::bz_stream)
  using: _4@Phi(bb29)
  _61 = ((*_78).1: u32)
  using: _78@Mir(bb38[1])
  _59 = Ne(move _60, move _61)
  using: _60@Mir(bb38[0]), _61@Mir(bb38[2])
  switchInt(move _59) -> [0: bb40, otherwise: bb39]
  using: _59@Mir(bb38[3])
bb39:
  _0 = const -1_i32
  using: 
  goto -> bb53
  using: 
bb40:
  _63 = _1
  using: _1@Phi(bb8)
  _62 = bzlib::handle_compress(move _63) -> bb41
  using: _63@Mir(bb40[0])
bb41:
  _3 = move _62
  using: _62@Mir(bb40[1])
  _64 = _3
  using: _3@Mir(bb41[0])
  switchInt(move _64) -> [0: bb42, otherwise: bb43]
  using: _64@Mir(bb41[1])
bb42:
  _0 = const -1_i32
  using: 
  goto -> bb53
  using: 
bb43:
  _68 = ((*_4).3: u32)
  using: _4@Phi(bb29)
  _69 = const 0_u32
  using: 
  _67 = Gt(move _68, move _69)
  using: _68@Mir(bb43[0]), _69@Mir(bb43[1])
  switchInt(move _67) -> [0: bb48, otherwise: bb47]
  using: _67@Mir(bb43[2])
bb44:
  _65 = const true
  using: 
  goto -> bb46
  using: 
bb45:
  _74 = ((*_4).20: i32)
  using: _4@Phi(bb49)
  _75 = ((*_4).19: i32)
  using: _4@Phi(bb49)
  _73 = Lt(move _74, move _75)
  using: _74@Mir(bb45[0]), _75@Mir(bb45[1])
  _65 = move _73
  using: _73@Mir(bb45[2])
  goto -> bb46
  using: 
bb46:
  switchInt(move _65) -> [0: bb52, otherwise: bb51]
  using: _65@Phi(bb46)
bb47:
  _66 = const true
  using: 
  goto -> bb49
  using: 
bb48:
  _72 = _4
  using: _4@Phi(bb29)
  _71 = bzlib::isempty_RL(move _72) -> bb50
  using: _72@Mir(bb48[0])
bb49:
  switchInt(move _66) -> [0: bb45, otherwise: bb44]
  using: _66@Phi(bb49)
bb50:
  _70 = Eq(move _71, const 0_u8)
  using: _71@Mir(bb48[1])
  _66 = move _70
  using: _70@Mir(bb50[0])
  goto -> bb49
  using: 
bb51:
  _0 = const 3_i32
  using: 
  goto -> bb53
  using: 
bb52:
  _76 = const 1_i32
  using: 
  ((*_4).1: i32) = move _76
  using: _4@Phi(bb46), _76@Mir(bb52[0])
  _0 = const 4_i32
  using: 
  goto -> bb53
  using: 
bb53:
  return
  using: _0@Phi(bb53)
@DefId(0:372 ~ c2rust_lib[1043]::bzlib::BZ2_bzCompressEnd)
bb0:
  _2 = const {0x0 as *mut blocksort::EState}
  using: 
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut blocksort::bz_stream>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[1])
bb1:
  switchInt(move _3) -> [0: bb3, otherwise: bb2]
  using: _3@Mir(bb0[2])
bb2:
  _7 = _1
  using: _1@Entry
  _6 = move _7 as usize (PointerExposeAddress)
  using: _7@Mir(bb2[0])
  _5 = Eq(move _6, const 0_usize)
  using: _6@Mir(bb2[1])
  assume(move _5)
  using: _5@Mir(bb2[2])
  _0 = const -2_i32
  using: 
  goto -> bb26
  using: 
bb3:
  _8 = ((*_1).8: *mut std::ffi::c_void)
  using: _1@Entry
  _2 = move _8 as *mut blocksort::EState (PtrToPtr)
  using: _8@Mir(bb3[0])
  _10 = _2
  using: _2@Mir(bb3[1])
  _9 = std::ptr::mut_ptr::<impl *mut blocksort::EState>::is_null(move _10) -> bb4
  using: _10@Mir(bb3[2])
bb4:
  switchInt(move _9) -> [0: bb6, otherwise: bb5]
  using: _9@Mir(bb3[3])
bb5:
  _13 = _2
  using: _2@Mir(bb3[1])
  _12 = move _13 as usize (PointerExposeAddress)
  using: _13@Mir(bb5[0])
  _11 = Eq(move _12, const 0_usize)
  using: _12@Mir(bb5[1])
  assume(move _11)
  using: _11@Mir(bb5[2])
  _0 = const -2_i32
  using: 
  goto -> bb26
  using: 
bb6:
  _15 = ((*_2).0: *mut blocksort::bz_stream)
  using: _2@Mir(bb3[1])
  _16 = _1
  using: _1@Entry
  _14 = Ne(move _15, move _16)
  using: _15@Mir(bb6[0]), _16@Mir(bb6[1])
  switchInt(move _14) -> [0: bb8, otherwise: bb7]
  using: _14@Mir(bb6[2])
bb7:
  _0 = const -2_i32
  using: 
  goto -> bb26
  using: 
bb8:
  _19 = ((*_2).4: *mut u32)
  using: _2@Mir(bb3[1])
  _18 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _19) -> bb9
  using: _19@Mir(bb8[0])
bb9:
  _17 = Not(move _18)
  using: _18@Mir(bb8[1])
  switchInt(move _17) -> [0: bb12, otherwise: bb10]
  using: _17@Mir(bb9[0])
bb10:
  _22 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Entry
  _24 = const "non-null function pointer"
  using: 
  _23 = _24
  using: _24@Mir(bb10[1])
  _21 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _22, move _23) -> bb11
  using: _22@Mir(bb10[0]), _23@Mir(bb10[2])
bb11:
  _25 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Entry
  _27 = ((*_2).4: *mut u32)
  using: _2@Mir(bb3[1])
  _26 = move _27 as *mut std::ffi::c_void (PtrToPtr)
  using: _27@Mir(bb11[1])
  _20 = move _21(move _25, move _26) -> bb13
  using: _21@Entry, _25@Mir(bb11[0]), _26@Mir(bb11[2])
bb12:
  _30 = ((*_2).4: *mut u32)
  using: _2@Mir(bb3[1])
  _29 = move _30 as usize (PointerExposeAddress)
  using: _30@Mir(bb12[0])
  _28 = Eq(move _29, const 0_usize)
  using: _29@Mir(bb12[1])
  assume(move _28)
  using: _28@Mir(bb12[2])
  goto -> bb13
  using: 
bb13:
  _33 = ((*_2).5: *mut u32)
  using: _2@Phi(bb13)
  _32 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _33) -> bb14
  using: _33@Mir(bb13[0])
bb14:
  _31 = Not(move _32)
  using: _32@Mir(bb13[1])
  switchInt(move _31) -> [0: bb17, otherwise: bb15]
  using: _31@Mir(bb14[0])
bb15:
  _36 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb13)
  _38 = const "non-null function pointer"
  using: 
  _37 = _38
  using: _38@Mir(bb15[1])
  _35 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _36, move _37) -> bb16
  using: _36@Mir(bb15[0]), _37@Mir(bb15[2])
bb16:
  _39 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb13)
  _41 = ((*_2).5: *mut u32)
  using: _2@Phi(bb13)
  _40 = move _41 as *mut std::ffi::c_void (PtrToPtr)
  using: _41@Mir(bb16[1])
  _34 = move _35(move _39, move _40) -> bb18
  using: _35@Entry, _39@Mir(bb16[0]), _40@Mir(bb16[2])
bb17:
  _44 = ((*_2).5: *mut u32)
  using: _2@Phi(bb13)
  _43 = move _44 as usize (PointerExposeAddress)
  using: _44@Mir(bb17[0])
  _42 = Eq(move _43, const 0_usize)
  using: _43@Mir(bb17[1])
  assume(move _42)
  using: _42@Mir(bb17[2])
  goto -> bb18
  using: 
bb18:
  _47 = ((*_2).6: *mut u32)
  using: _2@Phi(bb18)
  _46 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _47) -> bb19
  using: _47@Mir(bb18[0])
bb19:
  _45 = Not(move _46)
  using: _46@Mir(bb18[1])
  switchInt(move _45) -> [0: bb22, otherwise: bb20]
  using: _45@Mir(bb19[0])
bb20:
  _50 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb18)
  _52 = const "non-null function pointer"
  using: 
  _51 = _52
  using: _52@Mir(bb20[1])
  _49 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _50, move _51) -> bb21
  using: _50@Mir(bb20[0]), _51@Mir(bb20[2])
bb21:
  _53 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb18)
  _55 = ((*_2).6: *mut u32)
  using: _2@Phi(bb18)
  _54 = move _55 as *mut std::ffi::c_void (PtrToPtr)
  using: _55@Mir(bb21[1])
  _48 = move _49(move _53, move _54) -> bb23
  using: _49@Entry, _53@Mir(bb21[0]), _54@Mir(bb21[2])
bb22:
  _58 = ((*_2).6: *mut u32)
  using: _2@Phi(bb18)
  _57 = move _58 as usize (PointerExposeAddress)
  using: _58@Mir(bb22[0])
  _56 = Eq(move _57, const 0_usize)
  using: _57@Mir(bb22[1])
  assume(move _56)
  using: _56@Mir(bb22[2])
  goto -> bb23
  using: 
bb23:
  _61 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb23)
  _63 = const "non-null function pointer"
  using: 
  _62 = _63
  using: _63@Mir(bb23[1])
  _60 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _61, move _62) -> bb24
  using: _61@Mir(bb23[0]), _62@Mir(bb23[2])
bb24:
  _64 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb23)
  _65 = ((*_1).8: *mut std::ffi::c_void)
  using: _1@Phi(bb23)
  _59 = move _60(move _64, move _65) -> bb25
  using: _60@Entry, _64@Mir(bb24[0]), _65@Mir(bb24[1])
bb25:
  ((*_1).8: *mut std::ffi::c_void) = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: _1@Phi(bb23)
  _0 = const 0_i32
  using: 
  goto -> bb26
  using: 
bb26:
  return
  using: _0@Phi(bb26)
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:711:24: 711:59 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:716:24: 716:59 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:721:24: 721:59 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:725:20: 725:55 (#0) by default
@DefId(0:373 ~ c2rust_lib[1043]::bzlib::BZ2_bzDecompressInit)
bb0:
  _4 = const {0x0 as *mut bzlib::DState}
  using: 
  _5 = bzlib::bz_config_ok() -> bb1
  using: 
bb1:
  switchInt(move _5) -> [0: bb2, otherwise: bb3]
  using: _5@Mir(bb0[1])
bb2:
  _0 = const -9_i32
  using: 
  goto -> bb29
  using: 
bb3:
  _7 = _1
  using: _1@Entry
  _6 = std::ptr::mut_ptr::<impl *mut blocksort::bz_stream>::is_null(move _7) -> bb4
  using: _7@Mir(bb3[0])
bb4:
  switchInt(move _6) -> [0: bb6, otherwise: bb5]
  using: _6@Mir(bb3[1])
bb5:
  _10 = _1
  using: _1@Entry
  _9 = move _10 as usize (PointerExposeAddress)
  using: _10@Mir(bb5[0])
  _8 = Eq(move _9, const 0_usize)
  using: _9@Mir(bb5[1])
  assume(move _8)
  using: _8@Mir(bb5[2])
  _0 = const -2_i32
  using: 
  goto -> bb29
  using: 
bb6:
  _13 = _3
  using: _3@Entry
  _14 = const 0_i32
  using: 
  _12 = Ne(move _13, move _14)
  using: _13@Mir(bb6[0]), _14@Mir(bb6[1])
  switchInt(move _12) -> [0: bb7, otherwise: bb8]
  using: _12@Mir(bb6[2])
bb7:
  _11 = const false
  using: 
  goto -> bb9
  using: 
bb8:
  _16 = _3
  using: _3@Entry
  _17 = const 1_i32
  using: 
  _15 = Ne(move _16, move _17)
  using: _16@Mir(bb8[0]), _17@Mir(bb8[1])
  _11 = move _15
  using: _15@Mir(bb8[2])
  goto -> bb9
  using: 
bb9:
  switchInt(move _11) -> [0: bb11, otherwise: bb10]
  using: _11@Phi(bb9)
bb10:
  _0 = const -2_i32
  using: 
  goto -> bb29
  using: 
bb11:
  _20 = _2
  using: _2@Entry
  _21 = const 0_i32
  using: 
  _19 = Lt(move _20, move _21)
  using: _20@Mir(bb11[0]), _21@Mir(bb11[1])
  switchInt(move _19) -> [0: bb13, otherwise: bb12]
  using: _19@Mir(bb11[2])
bb12:
  _18 = const true
  using: 
  goto -> bb14
  using: 
bb13:
  _23 = _2
  using: _2@Entry
  _24 = const 4_i32
  using: 
  _22 = Gt(move _23, move _24)
  using: _23@Mir(bb13[0]), _24@Mir(bb13[1])
  _18 = move _22
  using: _22@Mir(bb13[2])
  goto -> bb14
  using: 
bb14:
  switchInt(move _18) -> [0: bb16, otherwise: bb15]
  using: _18@Phi(bb14)
bb15:
  _0 = const -2_i32
  using: 
  goto -> bb29
  using: 
bb16:
  _26 = &((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _1@Entry
  _25 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::is_none(move _26) -> bb17
  using: _26@Mir(bb16[0])
bb17:
  switchInt(move _25) -> [0: bb19, otherwise: bb18]
  using: _25@Mir(bb16[1])
bb18:
  _28 = bzlib::default_bzalloc as unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void (Pointer(ReifyFnPointer))
  using: 
  Deinit(_27)
  using: 
  ((_27 as Some).0: unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void) = move _28
  using: _28@Mir(bb18[0])
  discriminant(_27) = 1
  using: 
  ((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _27
  using: _1@Entry, _27@Mir(bb18[1])
  goto -> bb19
  using: 
bb19:
  _30 = &((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb19)
  _29 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::is_none(move _30) -> bb20
  using: _30@Mir(bb19[0])
bb20:
  switchInt(move _29) -> [0: bb22, otherwise: bb21]
  using: _29@Mir(bb19[1])
bb21:
  _32 = bzlib::default_bzfree as unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void) (Pointer(ReifyFnPointer))
  using: 
  Deinit(_31)
  using: 
  ((_31 as Some).0: unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)) = move _32
  using: _32@Mir(bb21[0])
  discriminant(_31) = 1
  using: 
  ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _31
  using: _1@Phi(bb19), _31@Mir(bb21[1])
  goto -> bb22
  using: 
bb22:
  _35 = ((*_1).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _1@Phi(bb22)
  _37 = const "non-null function pointer"
  using: 
  _36 = _37
  using: _37@Mir(bb22[1])
  _34 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _35, move _36) -> bb23
  using: _35@Mir(bb22[0]), _36@Mir(bb22[2])
bb23:
  _38 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb22)
  _41 = std::mem::size_of::<bzlib::DState>() -> bb24
  using: 
bb24:
  _40 = move _41 as u64 (IntToInt)
  using: _41@Mir(bb23[1])
  _39 = move _40 as i32 (IntToInt)
  using: _40@Mir(bb24[0])
  _42 = const 1_i32
  using: 
  _33 = move _34(move _38, move _39, move _42) -> bb25
  using: _34@Entry, _38@Mir(bb23[0]), _39@Mir(bb24[1]), _42@Mir(bb24[2])
bb25:
  _4 = move _33 as *mut bzlib::DState (PtrToPtr)
  using: _33@Mir(bb24[3])
  _44 = _4
  using: _4@Mir(bb25[0])
  _43 = std::ptr::mut_ptr::<impl *mut bzlib::DState>::is_null(move _44) -> bb26
  using: _44@Mir(bb25[1])
bb26:
  switchInt(move _43) -> [0: bb28, otherwise: bb27]
  using: _43@Mir(bb25[2])
bb27:
  _47 = _4
  using: _4@Mir(bb25[0])
  _46 = move _47 as usize (PointerExposeAddress)
  using: _47@Mir(bb27[0])
  _45 = Eq(move _46, const 0_usize)
  using: _46@Mir(bb27[1])
  assume(move _45)
  using: _45@Mir(bb27[2])
  _0 = const -3_i32
  using: 
  goto -> bb29
  using: 
bb28:
  _48 = _1
  using: _1@Phi(bb22)
  ((*_4).0: *mut blocksort::bz_stream) = move _48
  using: _4@Mir(bb25[0]), _48@Mir(bb28[0])
  _49 = _4
  using: _4@Mir(bb25[0])
  ((*_1).8: *mut std::ffi::c_void) = move _49 as *mut std::ffi::c_void (PtrToPtr)
  using: _1@Phi(bb22), _49@Mir(bb28[2])
  _50 = const 10_i32
  using: 
  ((*_4).1: i32) = move _50
  using: _4@Mir(bb25[0]), _50@Mir(bb28[4])
  _51 = const 0_i32
  using: 
  ((*_4).8: i32) = move _51
  using: _4@Mir(bb25[0]), _51@Mir(bb28[6])
  _52 = const 0_i32
  using: 
  ((*_4).7: u32) = move _52 as u32 (IntToInt)
  using: _4@Mir(bb25[0]), _52@Mir(bb28[8])
  _53 = const 0_i32
  using: 
  ((*_4).26: u32) = move _53 as u32 (IntToInt)
  using: _4@Mir(bb25[0]), _53@Mir(bb28[10])
  _54 = const 0_i32
  using: 
  ((*_1).2: u32) = move _54 as u32 (IntToInt)
  using: _1@Phi(bb22), _54@Mir(bb28[12])
  _55 = const 0_i32
  using: 
  ((*_1).3: u32) = move _55 as u32 (IntToInt)
  using: _1@Phi(bb22), _55@Mir(bb28[14])
  _56 = const 0_i32
  using: 
  ((*_1).6: u32) = move _56 as u32 (IntToInt)
  using: _1@Phi(bb22), _56@Mir(bb28[16])
  _57 = const 0_i32
  using: 
  ((*_1).7: u32) = move _57 as u32 (IntToInt)
  using: _1@Phi(bb22), _57@Mir(bb28[18])
  _58 = _3
  using: _3@Phi(bb9)
  ((*_4).10: u8) = move _58 as u8 (IntToInt)
  using: _4@Mir(bb25[0]), _58@Mir(bb28[20])
  ((*_4).22: *mut u8) = const 0_usize as *mut u8 (PointerFromExposedAddress)
  using: _4@Mir(bb25[0])
  ((*_4).21: *mut u16) = const 0_usize as *mut u16 (PointerFromExposedAddress)
  using: _4@Mir(bb25[0])
  ((*_4).20: *mut u32) = const 0_usize as *mut u32 (PointerFromExposedAddress)
  using: _4@Mir(bb25[0])
  _59 = const 0_i32
  using: 
  ((*_4).11: i32) = move _59
  using: _4@Mir(bb25[0]), _59@Mir(bb28[25])
  _60 = _2
  using: _2@Phi(bb14)
  ((*_4).12: i32) = move _60
  using: _4@Mir(bb25[0]), _60@Mir(bb28[27])
  _0 = const 0_i32
  using: 
  goto -> bb29
  using: 
bb29:
  return
  using: _0@Phi(bb29)
rewrite call std::option::Option::<T>::is_none @ workspace/bzip2/rust/bzlib.rs:748:24: 748:33 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_27) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_27) = 1 is ignored
rewrite call std::option::Option::<T>::is_none @ workspace/bzip2/rust/bzlib.rs:754:23: 754:32 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_31) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_31) = 1 is ignored
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:761:25: 761:60 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:762:61: 762:92 (#0) by default
@DefId(0:374 ~ c2rust_lib[1043]::bzlib::unRLE_obuf_to_output_FAST)
bb0:
  _3 = const 0_u8
  using: 
  _4 = ((*_1).4: u8)
  using: _1@Entry
  switchInt(move _4) -> [0: bb110, otherwise: bb1]
  using: _4@Mir(bb0[1])
bb1:
  goto -> bb2
  using: 
bb2:
  _504 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _6 = ((*_504).5: u32)
  using: _504@Mir(bb2[0])
  _7 = const 0_u32
  using: 
  _5 = Eq(move _6, move _7)
  using: _6@Mir(bb2[1]), _7@Mir(bb2[2])
  switchInt(move _5) -> [0: bb4, otherwise: bb3]
  using: _5@Mir(bb2[3])
bb3:
  _0 = const 0_u8
  using: 
  goto -> bb188
  using: 
bb4:
  _9 = ((*_1).3: i32)
  using: _1@Phi(bb2)
  _10 = const 0_i32
  using: 
  _8 = Eq(move _9, move _10)
  using: _9@Mir(bb4[0]), _10@Mir(bb4[1])
  switchInt(move _8) -> [0: bb5, otherwise: bb15]
  using: _8@Mir(bb4[2])
bb5:
  _11 = ((*_1).2: u8)
  using: _1@Phi(bb2)
  _505 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _13 = ((*_505).4: *mut i8)
  using: _505@Mir(bb5[1])
  _12 = move _13 as *mut u8 (PtrToPtr)
  using: _13@Mir(bb5[2])
  (*_12) = move _11
  using: _12@Mir(bb5[3]), _11@Mir(bb5[0])
  _15 = ((*_1).25: u32)
  using: _1@Phi(bb2)
  _16 = const 8_i32
  using: 
  _17 = CheckedShl(_15, _16)
  using: _15@Mir(bb5[5]), _16@Mir(bb5[6])
  assert(!move (_17.1: bool), "attempt to shift left by `{}`, which would overflow", move _16) -> bb6
  using: _17@Entry, _15@Entry, _16@Entry
bb6:
  _14 = move (_17.0: u32)
  using: _17@Mir(bb5[7])
  _19 = const {alloc723: *mut [u32; 256]}
  using: 
  _23 = ((*_1).25: u32)
  using: _1@Phi(bb2)
  _24 = const 24_i32
  using: 
  _25 = CheckedShr(_23, _24)
  using: _23@Mir(bb6[2]), _24@Mir(bb6[3])
  assert(!move (_25.1: bool), "attempt to shift right by `{}`, which would overflow", move _24) -> bb7
  using: _25@Entry, _23@Entry, _24@Entry
bb7:
  _22 = move (_25.0: u32)
  using: _25@Mir(bb6[4])
  _27 = ((*_1).2: u8)
  using: _1@Phi(bb2)
  _26 = move _27 as u32 (IntToInt)
  using: _27@Mir(bb7[1])
  _21 = BitXor(move _22, move _26)
  using: _22@Mir(bb7[0]), _26@Mir(bb7[2])
  _20 = move _21 as usize (IntToInt)
  using: _21@Mir(bb7[3])
  _28 = const 256_usize
  using: 
  _29 = Lt(_20, _28)
  using: _20@Mir(bb7[4]), _28@Mir(bb7[5])
  assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _20) -> bb8
  using: _29@Entry, _28@Entry, _20@Entry
bb8:
  _18 = (*_19)[_20]
  using: _19@Mir(bb6[1]), _20@Mir(bb7[4])
  ((*_1).25: u32) = BitXor(move _14, move _18)
  using: _1@Phi(bb2), _14@Mir(bb6[0]), _18@Mir(bb8[0])
  _30 = CheckedSub(((*_1).3: i32), const 1_i32)
  using: _1@Phi(bb2)
  assert(!move (_30.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).3: i32), const 1_i32) -> bb9
  using: _30@Entry, _1@Entry
bb9:
  ((*_1).3: i32) = move (_30.0: i32)
  using: _1@Phi(bb2), _30@Mir(bb8[2])
  _506 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _32 = ((*_506).4: *mut i8)
  using: _506@Mir(bb9[1])
  _31 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _32, const 1_isize) -> bb10
  using: _32@Mir(bb9[2])
bb10:
  _507 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_507).4: *mut i8) = move _31
  using: _507@Mir(bb10[0]), _31@Mir(bb9[3])
  _508 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _34 = ((*_508).5: u32)
  using: _508@Mir(bb10[2])
  _33 = core::num::<impl u32>::wrapping_sub(move _34, const 1_u32) -> bb11
  using: _34@Mir(bb10[3])
bb11:
  _509 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_509).5: u32) = move _33
  using: _509@Mir(bb11[0]), _33@Mir(bb10[4])
  _510 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _36 = ((*_510).6: u32)
  using: _510@Mir(bb11[2])
  _35 = core::num::<impl u32>::wrapping_add(move _36, const 1_u32) -> bb12
  using: _36@Mir(bb11[3])
bb12:
  _511 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_511).6: u32) = move _35
  using: _511@Mir(bb12[0]), _35@Mir(bb11[4])
  _512 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _38 = ((*_512).6: u32)
  using: _512@Mir(bb12[2])
  _39 = const 0_u32
  using: 
  _37 = Eq(move _38, move _39)
  using: _38@Mir(bb12[3]), _39@Mir(bb12[4])
  switchInt(move _37) -> [0: bb2, otherwise: bb13]
  using: _37@Mir(bb12[5])
bb13:
  _513 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _41 = ((*_513).7: u32)
  using: _513@Mir(bb13[0])
  _40 = core::num::<impl u32>::wrapping_add(move _41, const 1_u32) -> bb14
  using: _41@Mir(bb13[1])
bb14:
  _514 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_514).7: u32) = move _40
  using: _514@Mir(bb14[0]), _40@Mir(bb13[2])
  goto -> bb2
  using: 
bb15:
  _43 = ((*_1).17: i32)
  using: _1@Phi(bb2)
  _45 = ((*_1).51: i32)
  using: _1@Phi(bb2)
  _46 = const 1_i32
  using: 
  _47 = CheckedAdd(_45, _46)
  using: _45@Mir(bb15[1]), _46@Mir(bb15[2])
  assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", move _45, move _46) -> bb16
  using: _47@Entry, _45@Entry, _46@Entry
bb16:
  _44 = move (_47.0: i32)
  using: _47@Mir(bb15[3])
  _42 = Eq(move _43, move _44)
  using: _43@Mir(bb15[0]), _44@Mir(bb16[0])
  switchInt(move _42) -> [0: bb18, otherwise: bb17]
  using: _42@Mir(bb16[1])
bb17:
  _0 = const 0_u8
  using: 
  goto -> bb188
  using: 
bb18:
  _49 = ((*_1).17: i32)
  using: _1@Phi(bb2)
  _51 = ((*_1).51: i32)
  using: _1@Phi(bb2)
  _52 = const 1_i32
  using: 
  _53 = CheckedAdd(_51, _52)
  using: _51@Mir(bb18[1]), _52@Mir(bb18[2])
  assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", move _51, move _52) -> bb19
  using: _53@Entry, _51@Entry, _52@Entry
bb19:
  _50 = move (_53.0: i32)
  using: _53@Mir(bb18[3])
  _48 = Gt(move _49, move _50)
  using: _49@Mir(bb18[0]), _50@Mir(bb19[0])
  switchInt(move _48) -> [0: bb21, otherwise: bb20]
  using: _48@Mir(bb19[1])
bb20:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb21:
  _54 = const 1_i32
  using: 
  ((*_1).3: i32) = move _54
  using: _1@Phi(bb2), _54@Mir(bb21[0])
  _55 = ((*_1).15: i32)
  using: _1@Phi(bb2)
  ((*_1).2: u8) = move _55 as u8 (IntToInt)
  using: _1@Phi(bb2), _55@Mir(bb21[2])
  _57 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _59 = const 100000_u32
  using: 
  _61 = ((*_1).9: i32)
  using: _1@Phi(bb2)
  _60 = move _61 as u32 (IntToInt)
  using: _61@Mir(bb21[6])
  _58 = core::num::<impl u32>::wrapping_mul(move _59, move _60) -> bb22
  using: _59@Mir(bb21[5]), _60@Mir(bb21[7])
bb22:
  _56 = Ge(move _57, move _58)
  using: _57@Mir(bb21[4]), _58@Mir(bb21[8])
  switchInt(move _56) -> [0: bb24, otherwise: bb23]
  using: _56@Mir(bb22[0])
bb23:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb24:
  _64 = ((*_1).20: *mut u32)
  using: _1@Phi(bb2)
  _66 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _65 = move _66 as isize (IntToInt)
  using: _66@Mir(bb24[1])
  _63 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _64, move _65) -> bb25
  using: _64@Mir(bb24[0]), _65@Mir(bb24[2])
bb25:
  _62 = (*_63)
  using: _63@Mir(bb24[3])
  ((*_1).14: u32) = move _62
  using: _1@Phi(bb2), _62@Mir(bb25[0])
  _68 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _69 = const 255_u32
  using: 
  _67 = BitAnd(move _68, move _69)
  using: _68@Mir(bb25[2]), _69@Mir(bb25[3])
  _3 = move _67 as u8 (IntToInt)
  using: _67@Mir(bb25[4])
  _70 = const 8_i32
  using: 
  _71 = CheckedShr(((*_1).14: u32), _70)
  using: _1@Phi(bb2), _70@Mir(bb25[6])
  assert(!move (_71.1: bool), "attempt to shift right by `{}`, which would overflow", move _70) -> bb26
  using: _71@Entry, _1@Entry, _70@Entry
bb26:
  ((*_1).14: u32) = move (_71.0: u32)
  using: _1@Phi(bb2), _71@Mir(bb25[7])
  _73 = ((*_1).5: i32)
  using: _1@Phi(bb2)
  _74 = const 0_i32
  using: 
  _72 = Eq(move _73, move _74)
  using: _73@Mir(bb26[1]), _74@Mir(bb26[2])
  switchInt(move _72) -> [0: bb31, otherwise: bb27]
  using: _72@Mir(bb26[3])
bb27:
  _76 = const {alloc764: *mut [i32; 512]}
  using: 
  _78 = ((*_1).6: i32)
  using: _1@Phi(bb2)
  _77 = move _78 as usize (IntToInt)
  using: _78@Mir(bb27[1])
  _79 = const 512_usize
  using: 
  _80 = Lt(_77, _79)
  using: _77@Mir(bb27[2]), _79@Mir(bb27[3])
  assert(move _80, "index out of bounds: the length is {} but the index is {}", move _79, _77) -> bb28
  using: _80@Entry, _79@Entry, _77@Entry
bb28:
  _75 = (*_76)[_77]
  using: _76@Mir(bb27[0]), _77@Mir(bb27[2])
  ((*_1).5: i32) = move _75
  using: _1@Phi(bb2), _75@Mir(bb28[0])
  _81 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb2)
  assert(!move (_81.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb29
  using: _81@Entry, _1@Entry
bb29:
  ((*_1).6: i32) = move (_81.0: i32)
  using: _1@Phi(bb2), _81@Mir(bb28[2])
  _83 = ((*_1).6: i32)
  using: _1@Phi(bb2)
  _84 = const 512_i32
  using: 
  _82 = Eq(move _83, move _84)
  using: _83@Mir(bb29[1]), _84@Mir(bb29[2])
  switchInt(move _82) -> [0: bb31, otherwise: bb30]
  using: _82@Mir(bb29[3])
bb30:
  _85 = const 0_i32
  using: 
  ((*_1).6: i32) = move _85
  using: _1@Phi(bb2), _85@Mir(bb30[0])
  goto -> bb31
  using: 
bb31:
  _86 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb31)
  assert(!move (_86.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb32
  using: _86@Entry, _1@Entry
bb32:
  ((*_1).5: i32) = move (_86.0: i32)
  using: _1@Phi(bb31), _86@Mir(bb31[0])
  _89 = _3
  using: _3@Mir(bb25[5])
  _88 = move _89 as i32 (IntToInt)
  using: _89@Mir(bb32[1])
  _92 = ((*_1).5: i32)
  using: _1@Phi(bb31)
  _93 = const 1_i32
  using: 
  _91 = Eq(move _92, move _93)
  using: _92@Mir(bb32[3]), _93@Mir(bb32[4])
  switchInt(move _91) -> [0: bb34, otherwise: bb33]
  using: _91@Mir(bb32[5])
bb33:
  _90 = const 1_i32
  using: 
  goto -> bb35
  using: 
bb34:
  _90 = const 0_i32
  using: 
  goto -> bb35
  using: 
bb35:
  _87 = BitXor(move _88, move _90)
  using: _88@Mir(bb32[2]), _90@Phi(bb35)
  _3 = move _87 as u8 (IntToInt)
  using: _87@Mir(bb35[0])
  _94 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb31)
  assert(!move (_94.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb36
  using: _94@Entry, _1@Entry
bb36:
  ((*_1).17: i32) = move (_94.0: i32)
  using: _1@Phi(bb31), _94@Mir(bb35[2])
  _96 = ((*_1).17: i32)
  using: _1@Phi(bb31)
  _98 = ((*_1).51: i32)
  using: _1@Phi(bb31)
  _99 = const 1_i32
  using: 
  _100 = CheckedAdd(_98, _99)
  using: _98@Mir(bb36[2]), _99@Mir(bb36[3])
  assert(!move (_100.1: bool), "attempt to compute `{} + {}`, which would overflow", move _98, move _99) -> bb37
  using: _100@Entry, _98@Entry, _99@Entry
bb37:
  _97 = move (_100.0: i32)
  using: _100@Mir(bb36[4])
  _95 = Eq(move _96, move _97)
  using: _96@Mir(bb36[1]), _97@Mir(bb37[0])
  switchInt(move _95) -> [0: bb38, otherwise: bb1]
  using: _95@Mir(bb37[1])
bb38:
  _103 = _3
  using: _3@Mir(bb35[1])
  _102 = move _103 as i32 (IntToInt)
  using: _103@Mir(bb38[0])
  _104 = ((*_1).15: i32)
  using: _1@Phi(bb31)
  _101 = Ne(move _102, move _104)
  using: _102@Mir(bb38[1]), _104@Mir(bb38[2])
  switchInt(move _101) -> [0: bb40, otherwise: bb39]
  using: _101@Mir(bb38[3])
bb39:
  _105 = _3
  using: _3@Mir(bb35[1])
  ((*_1).15: i32) = move _105 as i32 (IntToInt)
  using: _1@Phi(bb31), _105@Mir(bb39[0])
  goto -> bb1
  using: 
bb40:
  _106 = const 2_i32
  using: 
  ((*_1).3: i32) = move _106
  using: _1@Phi(bb31), _106@Mir(bb40[0])
  _108 = ((*_1).14: u32)
  using: _1@Phi(bb31)
  _110 = const 100000_u32
  using: 
  _112 = ((*_1).9: i32)
  using: _1@Phi(bb31)
  _111 = move _112 as u32 (IntToInt)
  using: _112@Mir(bb40[4])
  _109 = core::num::<impl u32>::wrapping_mul(move _110, move _111) -> bb41
  using: _110@Mir(bb40[3]), _111@Mir(bb40[5])
bb41:
  _107 = Ge(move _108, move _109)
  using: _108@Mir(bb40[2]), _109@Mir(bb40[6])
  switchInt(move _107) -> [0: bb43, otherwise: bb42]
  using: _107@Mir(bb41[0])
bb42:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb43:
  _115 = ((*_1).20: *mut u32)
  using: _1@Phi(bb31)
  _117 = ((*_1).14: u32)
  using: _1@Phi(bb31)
  _116 = move _117 as isize (IntToInt)
  using: _117@Mir(bb43[1])
  _114 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _115, move _116) -> bb44
  using: _115@Mir(bb43[0]), _116@Mir(bb43[2])
bb44:
  _113 = (*_114)
  using: _114@Mir(bb43[3])
  ((*_1).14: u32) = move _113
  using: _1@Phi(bb31), _113@Mir(bb44[0])
  _119 = ((*_1).14: u32)
  using: _1@Phi(bb31)
  _120 = const 255_u32
  using: 
  _118 = BitAnd(move _119, move _120)
  using: _119@Mir(bb44[2]), _120@Mir(bb44[3])
  _3 = move _118 as u8 (IntToInt)
  using: _118@Mir(bb44[4])
  _121 = const 8_i32
  using: 
  _122 = CheckedShr(((*_1).14: u32), _121)
  using: _1@Phi(bb31), _121@Mir(bb44[6])
  assert(!move (_122.1: bool), "attempt to shift right by `{}`, which would overflow", move _121) -> bb45
  using: _122@Entry, _1@Entry, _121@Entry
bb45:
  ((*_1).14: u32) = move (_122.0: u32)
  using: _1@Phi(bb31), _122@Mir(bb44[7])
  _124 = ((*_1).5: i32)
  using: _1@Phi(bb31)
  _125 = const 0_i32
  using: 
  _123 = Eq(move _124, move _125)
  using: _124@Mir(bb45[1]), _125@Mir(bb45[2])
  switchInt(move _123) -> [0: bb50, otherwise: bb46]
  using: _123@Mir(bb45[3])
bb46:
  _127 = const {alloc764: *mut [i32; 512]}
  using: 
  _129 = ((*_1).6: i32)
  using: _1@Phi(bb31)
  _128 = move _129 as usize (IntToInt)
  using: _129@Mir(bb46[1])
  _130 = const 512_usize
  using: 
  _131 = Lt(_128, _130)
  using: _128@Mir(bb46[2]), _130@Mir(bb46[3])
  assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _128) -> bb47
  using: _131@Entry, _130@Entry, _128@Entry
bb47:
  _126 = (*_127)[_128]
  using: _127@Mir(bb46[0]), _128@Mir(bb46[2])
  ((*_1).5: i32) = move _126
  using: _1@Phi(bb31), _126@Mir(bb47[0])
  _132 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb31)
  assert(!move (_132.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb48
  using: _132@Entry, _1@Entry
bb48:
  ((*_1).6: i32) = move (_132.0: i32)
  using: _1@Phi(bb31), _132@Mir(bb47[2])
  _134 = ((*_1).6: i32)
  using: _1@Phi(bb31)
  _135 = const 512_i32
  using: 
  _133 = Eq(move _134, move _135)
  using: _134@Mir(bb48[1]), _135@Mir(bb48[2])
  switchInt(move _133) -> [0: bb50, otherwise: bb49]
  using: _133@Mir(bb48[3])
bb49:
  _136 = const 0_i32
  using: 
  ((*_1).6: i32) = move _136
  using: _1@Phi(bb31), _136@Mir(bb49[0])
  goto -> bb50
  using: 
bb50:
  _137 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb50)
  assert(!move (_137.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb51
  using: _137@Entry, _1@Entry
bb51:
  ((*_1).5: i32) = move (_137.0: i32)
  using: _1@Phi(bb50), _137@Mir(bb50[0])
  _140 = _3
  using: _3@Mir(bb44[5])
  _139 = move _140 as i32 (IntToInt)
  using: _140@Mir(bb51[1])
  _143 = ((*_1).5: i32)
  using: _1@Phi(bb50)
  _144 = const 1_i32
  using: 
  _142 = Eq(move _143, move _144)
  using: _143@Mir(bb51[3]), _144@Mir(bb51[4])
  switchInt(move _142) -> [0: bb53, otherwise: bb52]
  using: _142@Mir(bb51[5])
bb52:
  _141 = const 1_i32
  using: 
  goto -> bb54
  using: 
bb53:
  _141 = const 0_i32
  using: 
  goto -> bb54
  using: 
bb54:
  _138 = BitXor(move _139, move _141)
  using: _139@Mir(bb51[2]), _141@Phi(bb54)
  _3 = move _138 as u8 (IntToInt)
  using: _138@Mir(bb54[0])
  _145 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb50)
  assert(!move (_145.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb55
  using: _145@Entry, _1@Entry
bb55:
  ((*_1).17: i32) = move (_145.0: i32)
  using: _1@Phi(bb50), _145@Mir(bb54[2])
  _147 = ((*_1).17: i32)
  using: _1@Phi(bb50)
  _149 = ((*_1).51: i32)
  using: _1@Phi(bb50)
  _150 = const 1_i32
  using: 
  _151 = CheckedAdd(_149, _150)
  using: _149@Mir(bb55[2]), _150@Mir(bb55[3])
  assert(!move (_151.1: bool), "attempt to compute `{} + {}`, which would overflow", move _149, move _150) -> bb56
  using: _151@Entry, _149@Entry, _150@Entry
bb56:
  _148 = move (_151.0: i32)
  using: _151@Mir(bb55[4])
  _146 = Eq(move _147, move _148)
  using: _147@Mir(bb55[1]), _148@Mir(bb56[0])
  switchInt(move _146) -> [0: bb57, otherwise: bb1]
  using: _146@Mir(bb56[1])
bb57:
  _154 = _3
  using: _3@Mir(bb54[1])
  _153 = move _154 as i32 (IntToInt)
  using: _154@Mir(bb57[0])
  _155 = ((*_1).15: i32)
  using: _1@Phi(bb50)
  _152 = Ne(move _153, move _155)
  using: _153@Mir(bb57[1]), _155@Mir(bb57[2])
  switchInt(move _152) -> [0: bb59, otherwise: bb58]
  using: _152@Mir(bb57[3])
bb58:
  _156 = _3
  using: _3@Mir(bb54[1])
  ((*_1).15: i32) = move _156 as i32 (IntToInt)
  using: _1@Phi(bb50), _156@Mir(bb58[0])
  goto -> bb1
  using: 
bb59:
  _157 = const 3_i32
  using: 
  ((*_1).3: i32) = move _157
  using: _1@Phi(bb50), _157@Mir(bb59[0])
  _159 = ((*_1).14: u32)
  using: _1@Phi(bb50)
  _161 = const 100000_u32
  using: 
  _163 = ((*_1).9: i32)
  using: _1@Phi(bb50)
  _162 = move _163 as u32 (IntToInt)
  using: _163@Mir(bb59[4])
  _160 = core::num::<impl u32>::wrapping_mul(move _161, move _162) -> bb60
  using: _161@Mir(bb59[3]), _162@Mir(bb59[5])
bb60:
  _158 = Ge(move _159, move _160)
  using: _159@Mir(bb59[2]), _160@Mir(bb59[6])
  switchInt(move _158) -> [0: bb62, otherwise: bb61]
  using: _158@Mir(bb60[0])
bb61:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb62:
  _166 = ((*_1).20: *mut u32)
  using: _1@Phi(bb50)
  _168 = ((*_1).14: u32)
  using: _1@Phi(bb50)
  _167 = move _168 as isize (IntToInt)
  using: _168@Mir(bb62[1])
  _165 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _166, move _167) -> bb63
  using: _166@Mir(bb62[0]), _167@Mir(bb62[2])
bb63:
  _164 = (*_165)
  using: _165@Mir(bb62[3])
  ((*_1).14: u32) = move _164
  using: _1@Phi(bb50), _164@Mir(bb63[0])
  _170 = ((*_1).14: u32)
  using: _1@Phi(bb50)
  _171 = const 255_u32
  using: 
  _169 = BitAnd(move _170, move _171)
  using: _170@Mir(bb63[2]), _171@Mir(bb63[3])
  _3 = move _169 as u8 (IntToInt)
  using: _169@Mir(bb63[4])
  _172 = const 8_i32
  using: 
  _173 = CheckedShr(((*_1).14: u32), _172)
  using: _1@Phi(bb50), _172@Mir(bb63[6])
  assert(!move (_173.1: bool), "attempt to shift right by `{}`, which would overflow", move _172) -> bb64
  using: _173@Entry, _1@Entry, _172@Entry
bb64:
  ((*_1).14: u32) = move (_173.0: u32)
  using: _1@Phi(bb50), _173@Mir(bb63[7])
  _175 = ((*_1).5: i32)
  using: _1@Phi(bb50)
  _176 = const 0_i32
  using: 
  _174 = Eq(move _175, move _176)
  using: _175@Mir(bb64[1]), _176@Mir(bb64[2])
  switchInt(move _174) -> [0: bb69, otherwise: bb65]
  using: _174@Mir(bb64[3])
bb65:
  _178 = const {alloc764: *mut [i32; 512]}
  using: 
  _180 = ((*_1).6: i32)
  using: _1@Phi(bb50)
  _179 = move _180 as usize (IntToInt)
  using: _180@Mir(bb65[1])
  _181 = const 512_usize
  using: 
  _182 = Lt(_179, _181)
  using: _179@Mir(bb65[2]), _181@Mir(bb65[3])
  assert(move _182, "index out of bounds: the length is {} but the index is {}", move _181, _179) -> bb66
  using: _182@Entry, _181@Entry, _179@Entry
bb66:
  _177 = (*_178)[_179]
  using: _178@Mir(bb65[0]), _179@Mir(bb65[2])
  ((*_1).5: i32) = move _177
  using: _1@Phi(bb50), _177@Mir(bb66[0])
  _183 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb50)
  assert(!move (_183.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb67
  using: _183@Entry, _1@Entry
bb67:
  ((*_1).6: i32) = move (_183.0: i32)
  using: _1@Phi(bb50), _183@Mir(bb66[2])
  _185 = ((*_1).6: i32)
  using: _1@Phi(bb50)
  _186 = const 512_i32
  using: 
  _184 = Eq(move _185, move _186)
  using: _185@Mir(bb67[1]), _186@Mir(bb67[2])
  switchInt(move _184) -> [0: bb69, otherwise: bb68]
  using: _184@Mir(bb67[3])
bb68:
  _187 = const 0_i32
  using: 
  ((*_1).6: i32) = move _187
  using: _1@Phi(bb50), _187@Mir(bb68[0])
  goto -> bb69
  using: 
bb69:
  _188 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb69)
  assert(!move (_188.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb70
  using: _188@Entry, _1@Entry
bb70:
  ((*_1).5: i32) = move (_188.0: i32)
  using: _1@Phi(bb69), _188@Mir(bb69[0])
  _191 = _3
  using: _3@Mir(bb63[5])
  _190 = move _191 as i32 (IntToInt)
  using: _191@Mir(bb70[1])
  _194 = ((*_1).5: i32)
  using: _1@Phi(bb69)
  _195 = const 1_i32
  using: 
  _193 = Eq(move _194, move _195)
  using: _194@Mir(bb70[3]), _195@Mir(bb70[4])
  switchInt(move _193) -> [0: bb72, otherwise: bb71]
  using: _193@Mir(bb70[5])
bb71:
  _192 = const 1_i32
  using: 
  goto -> bb73
  using: 
bb72:
  _192 = const 0_i32
  using: 
  goto -> bb73
  using: 
bb73:
  _189 = BitXor(move _190, move _192)
  using: _190@Mir(bb70[2]), _192@Phi(bb73)
  _3 = move _189 as u8 (IntToInt)
  using: _189@Mir(bb73[0])
  _196 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb69)
  assert(!move (_196.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb74
  using: _196@Entry, _1@Entry
bb74:
  ((*_1).17: i32) = move (_196.0: i32)
  using: _1@Phi(bb69), _196@Mir(bb73[2])
  _198 = ((*_1).17: i32)
  using: _1@Phi(bb69)
  _200 = ((*_1).51: i32)
  using: _1@Phi(bb69)
  _201 = const 1_i32
  using: 
  _202 = CheckedAdd(_200, _201)
  using: _200@Mir(bb74[2]), _201@Mir(bb74[3])
  assert(!move (_202.1: bool), "attempt to compute `{} + {}`, which would overflow", move _200, move _201) -> bb75
  using: _202@Entry, _200@Entry, _201@Entry
bb75:
  _199 = move (_202.0: i32)
  using: _202@Mir(bb74[4])
  _197 = Eq(move _198, move _199)
  using: _198@Mir(bb74[1]), _199@Mir(bb75[0])
  switchInt(move _197) -> [0: bb76, otherwise: bb1]
  using: _197@Mir(bb75[1])
bb76:
  _205 = _3
  using: _3@Mir(bb73[1])
  _204 = move _205 as i32 (IntToInt)
  using: _205@Mir(bb76[0])
  _206 = ((*_1).15: i32)
  using: _1@Phi(bb69)
  _203 = Ne(move _204, move _206)
  using: _204@Mir(bb76[1]), _206@Mir(bb76[2])
  switchInt(move _203) -> [0: bb78, otherwise: bb77]
  using: _203@Mir(bb76[3])
bb77:
  _207 = _3
  using: _3@Mir(bb73[1])
  ((*_1).15: i32) = move _207 as i32 (IntToInt)
  using: _1@Phi(bb69), _207@Mir(bb77[0])
  goto -> bb1
  using: 
bb78:
  _209 = ((*_1).14: u32)
  using: _1@Phi(bb69)
  _211 = const 100000_u32
  using: 
  _213 = ((*_1).9: i32)
  using: _1@Phi(bb69)
  _212 = move _213 as u32 (IntToInt)
  using: _213@Mir(bb78[2])
  _210 = core::num::<impl u32>::wrapping_mul(move _211, move _212) -> bb79
  using: _211@Mir(bb78[1]), _212@Mir(bb78[3])
bb79:
  _208 = Ge(move _209, move _210)
  using: _209@Mir(bb78[0]), _210@Mir(bb78[4])
  switchInt(move _208) -> [0: bb81, otherwise: bb80]
  using: _208@Mir(bb79[0])
bb80:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb81:
  _216 = ((*_1).20: *mut u32)
  using: _1@Phi(bb69)
  _218 = ((*_1).14: u32)
  using: _1@Phi(bb69)
  _217 = move _218 as isize (IntToInt)
  using: _218@Mir(bb81[1])
  _215 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _216, move _217) -> bb82
  using: _216@Mir(bb81[0]), _217@Mir(bb81[2])
bb82:
  _214 = (*_215)
  using: _215@Mir(bb81[3])
  ((*_1).14: u32) = move _214
  using: _1@Phi(bb69), _214@Mir(bb82[0])
  _220 = ((*_1).14: u32)
  using: _1@Phi(bb69)
  _221 = const 255_u32
  using: 
  _219 = BitAnd(move _220, move _221)
  using: _220@Mir(bb82[2]), _221@Mir(bb82[3])
  _3 = move _219 as u8 (IntToInt)
  using: _219@Mir(bb82[4])
  _222 = const 8_i32
  using: 
  _223 = CheckedShr(((*_1).14: u32), _222)
  using: _1@Phi(bb69), _222@Mir(bb82[6])
  assert(!move (_223.1: bool), "attempt to shift right by `{}`, which would overflow", move _222) -> bb83
  using: _223@Entry, _1@Entry, _222@Entry
bb83:
  ((*_1).14: u32) = move (_223.0: u32)
  using: _1@Phi(bb69), _223@Mir(bb82[7])
  _225 = ((*_1).5: i32)
  using: _1@Phi(bb69)
  _226 = const 0_i32
  using: 
  _224 = Eq(move _225, move _226)
  using: _225@Mir(bb83[1]), _226@Mir(bb83[2])
  switchInt(move _224) -> [0: bb88, otherwise: bb84]
  using: _224@Mir(bb83[3])
bb84:
  _228 = const {alloc764: *mut [i32; 512]}
  using: 
  _230 = ((*_1).6: i32)
  using: _1@Phi(bb69)
  _229 = move _230 as usize (IntToInt)
  using: _230@Mir(bb84[1])
  _231 = const 512_usize
  using: 
  _232 = Lt(_229, _231)
  using: _229@Mir(bb84[2]), _231@Mir(bb84[3])
  assert(move _232, "index out of bounds: the length is {} but the index is {}", move _231, _229) -> bb85
  using: _232@Entry, _231@Entry, _229@Entry
bb85:
  _227 = (*_228)[_229]
  using: _228@Mir(bb84[0]), _229@Mir(bb84[2])
  ((*_1).5: i32) = move _227
  using: _1@Phi(bb69), _227@Mir(bb85[0])
  _233 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb69)
  assert(!move (_233.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb86
  using: _233@Entry, _1@Entry
bb86:
  ((*_1).6: i32) = move (_233.0: i32)
  using: _1@Phi(bb69), _233@Mir(bb85[2])
  _235 = ((*_1).6: i32)
  using: _1@Phi(bb69)
  _236 = const 512_i32
  using: 
  _234 = Eq(move _235, move _236)
  using: _235@Mir(bb86[1]), _236@Mir(bb86[2])
  switchInt(move _234) -> [0: bb88, otherwise: bb87]
  using: _234@Mir(bb86[3])
bb87:
  _237 = const 0_i32
  using: 
  ((*_1).6: i32) = move _237
  using: _1@Phi(bb69), _237@Mir(bb87[0])
  goto -> bb88
  using: 
bb88:
  _238 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb88)
  assert(!move (_238.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb89
  using: _238@Entry, _1@Entry
bb89:
  ((*_1).5: i32) = move (_238.0: i32)
  using: _1@Phi(bb88), _238@Mir(bb88[0])
  _241 = _3
  using: _3@Mir(bb82[5])
  _240 = move _241 as i32 (IntToInt)
  using: _241@Mir(bb89[1])
  _244 = ((*_1).5: i32)
  using: _1@Phi(bb88)
  _245 = const 1_i32
  using: 
  _243 = Eq(move _244, move _245)
  using: _244@Mir(bb89[3]), _245@Mir(bb89[4])
  switchInt(move _243) -> [0: bb91, otherwise: bb90]
  using: _243@Mir(bb89[5])
bb90:
  _242 = const 1_i32
  using: 
  goto -> bb92
  using: 
bb91:
  _242 = const 0_i32
  using: 
  goto -> bb92
  using: 
bb92:
  _239 = BitXor(move _240, move _242)
  using: _240@Mir(bb89[2]), _242@Phi(bb92)
  _3 = move _239 as u8 (IntToInt)
  using: _239@Mir(bb92[0])
  _246 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb88)
  assert(!move (_246.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb93
  using: _246@Entry, _1@Entry
bb93:
  ((*_1).17: i32) = move (_246.0: i32)
  using: _1@Phi(bb88), _246@Mir(bb92[2])
  _248 = _3
  using: _3@Mir(bb92[1])
  _247 = move _248 as i32 (IntToInt)
  using: _248@Mir(bb93[1])
  _249 = const 4_i32
  using: 
  _250 = CheckedAdd(_247, _249)
  using: _247@Mir(bb93[2]), _249@Mir(bb93[3])
  assert(!move (_250.1: bool), "attempt to compute `{} + {}`, which would overflow", move _247, move _249) -> bb94
  using: _250@Entry, _247@Entry, _249@Entry
bb94:
  ((*_1).3: i32) = move (_250.0: i32)
  using: _1@Phi(bb88), _250@Mir(bb93[4])
  _252 = ((*_1).14: u32)
  using: _1@Phi(bb88)
  _254 = const 100000_u32
  using: 
  _256 = ((*_1).9: i32)
  using: _1@Phi(bb88)
  _255 = move _256 as u32 (IntToInt)
  using: _256@Mir(bb94[3])
  _253 = core::num::<impl u32>::wrapping_mul(move _254, move _255) -> bb95
  using: _254@Mir(bb94[2]), _255@Mir(bb94[4])
bb95:
  _251 = Ge(move _252, move _253)
  using: _252@Mir(bb94[1]), _253@Mir(bb94[5])
  switchInt(move _251) -> [0: bb97, otherwise: bb96]
  using: _251@Mir(bb95[0])
bb96:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb97:
  _259 = ((*_1).20: *mut u32)
  using: _1@Phi(bb88)
  _261 = ((*_1).14: u32)
  using: _1@Phi(bb88)
  _260 = move _261 as isize (IntToInt)
  using: _261@Mir(bb97[1])
  _258 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _259, move _260) -> bb98
  using: _259@Mir(bb97[0]), _260@Mir(bb97[2])
bb98:
  _257 = (*_258)
  using: _258@Mir(bb97[3])
  ((*_1).14: u32) = move _257
  using: _1@Phi(bb88), _257@Mir(bb98[0])
  _264 = ((*_1).14: u32)
  using: _1@Phi(bb88)
  _265 = const 255_u32
  using: 
  _263 = BitAnd(move _264, move _265)
  using: _264@Mir(bb98[2]), _265@Mir(bb98[3])
  _262 = move _263 as u8 (IntToInt)
  using: _263@Mir(bb98[4])
  ((*_1).15: i32) = move _262 as i32 (IntToInt)
  using: _1@Phi(bb88), _262@Mir(bb98[5])
  _266 = const 8_i32
  using: 
  _267 = CheckedShr(((*_1).14: u32), _266)
  using: _1@Phi(bb88), _266@Mir(bb98[7])
  assert(!move (_267.1: bool), "attempt to shift right by `{}`, which would overflow", move _266) -> bb99
  using: _267@Entry, _1@Entry, _266@Entry
bb99:
  ((*_1).14: u32) = move (_267.0: u32)
  using: _1@Phi(bb88), _267@Mir(bb98[8])
  _269 = ((*_1).5: i32)
  using: _1@Phi(bb88)
  _270 = const 0_i32
  using: 
  _268 = Eq(move _269, move _270)
  using: _269@Mir(bb99[1]), _270@Mir(bb99[2])
  switchInt(move _268) -> [0: bb104, otherwise: bb100]
  using: _268@Mir(bb99[3])
bb100:
  _272 = const {alloc764: *mut [i32; 512]}
  using: 
  _274 = ((*_1).6: i32)
  using: _1@Phi(bb88)
  _273 = move _274 as usize (IntToInt)
  using: _274@Mir(bb100[1])
  _275 = const 512_usize
  using: 
  _276 = Lt(_273, _275)
  using: _273@Mir(bb100[2]), _275@Mir(bb100[3])
  assert(move _276, "index out of bounds: the length is {} but the index is {}", move _275, _273) -> bb101
  using: _276@Entry, _275@Entry, _273@Entry
bb101:
  _271 = (*_272)[_273]
  using: _272@Mir(bb100[0]), _273@Mir(bb100[2])
  ((*_1).5: i32) = move _271
  using: _1@Phi(bb88), _271@Mir(bb101[0])
  _277 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb88)
  assert(!move (_277.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb102
  using: _277@Entry, _1@Entry
bb102:
  ((*_1).6: i32) = move (_277.0: i32)
  using: _1@Phi(bb88), _277@Mir(bb101[2])
  _279 = ((*_1).6: i32)
  using: _1@Phi(bb88)
  _280 = const 512_i32
  using: 
  _278 = Eq(move _279, move _280)
  using: _279@Mir(bb102[1]), _280@Mir(bb102[2])
  switchInt(move _278) -> [0: bb104, otherwise: bb103]
  using: _278@Mir(bb102[3])
bb103:
  _281 = const 0_i32
  using: 
  ((*_1).6: i32) = move _281
  using: _1@Phi(bb88), _281@Mir(bb103[0])
  goto -> bb104
  using: 
bb104:
  _282 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb104)
  assert(!move (_282.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb105
  using: _282@Entry, _1@Entry
bb105:
  ((*_1).5: i32) = move (_282.0: i32)
  using: _1@Phi(bb104), _282@Mir(bb104[0])
  _285 = ((*_1).5: i32)
  using: _1@Phi(bb104)
  _286 = const 1_i32
  using: 
  _284 = Eq(move _285, move _286)
  using: _285@Mir(bb105[1]), _286@Mir(bb105[2])
  switchInt(move _284) -> [0: bb107, otherwise: bb106]
  using: _284@Mir(bb105[3])
bb106:
  _283 = const 1_i32
  using: 
  goto -> bb108
  using: 
bb107:
  _283 = const 0_i32
  using: 
  goto -> bb108
  using: 
bb108:
  ((*_1).15: i32) = BitXor(((*_1).15: i32), move _283)
  using: _1@Phi(bb104), _1@Phi(bb104), _283@Phi(bb108)
  _287 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb104)
  assert(!move (_287.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb109
  using: _287@Entry, _1@Entry
bb109:
  ((*_1).17: i32) = move (_287.0: i32)
  using: _1@Phi(bb104), _287@Mir(bb108[1])
  goto -> bb1
  using: 
bb110:
  _288 = ((*_1).25: u32)
  using: _1@Phi(bb104)
  _289 = ((*_1).2: u8)
  using: _1@Phi(bb104)
  _290 = ((*_1).3: i32)
  using: _1@Phi(bb104)
  _291 = ((*_1).17: i32)
  using: _1@Phi(bb104)
  _292 = ((*_1).15: i32)
  using: _1@Phi(bb104)
  _293 = ((*_1).20: *mut u32)
  using: _1@Phi(bb104)
  _294 = ((*_1).14: u32)
  using: _1@Phi(bb104)
  _515 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  _295 = ((*_515).4: *mut i8)
  using: _515@Mir(bb110[7])
  _516 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  _296 = ((*_516).5: u32)
  using: _516@Mir(bb110[9])
  _297 = ((*_1).9: i32)
  using: _1@Phi(bb104)
  _298 = _296
  using: _296@Mir(bb110[10])
  _300 = ((*_1).51: i32)
  using: _1@Phi(bb104)
  _301 = const 1_i32
  using: 
  _302 = CheckedAdd(_300, _301)
  using: _300@Mir(bb110[13]), _301@Mir(bb110[14])
  assert(!move (_302.1: bool), "attempt to compute `{} + {}`, which would overflow", move _300, move _301) -> bb111
  using: _302@Entry, _300@Entry, _301@Entry
bb111:
  _299 = move (_302.0: i32)
  using: _302@Mir(bb110[15])
  _303 = const 0_u32
  using: 
  goto -> bb112
  using: 
bb112:
  _305 = _290
  using: _290@Phi(bb112)
  _306 = const 0_i32
  using: 
  _304 = Gt(move _305, move _306)
  using: _305@Mir(bb112[0]), _306@Mir(bb112[1])
  switchInt(move _304) -> [0: bb123, otherwise: bb113]
  using: _304@Mir(bb112[2])
bb113:
  _308 = _296
  using: _296@Phi(bb113)
  _309 = const 0_u32
  using: 
  _307 = Eq(move _308, move _309)
  using: _308@Mir(bb113[0]), _309@Mir(bb113[1])
  switchInt(move _307) -> [0: bb114, otherwise: bb182]
  using: _307@Mir(bb113[2])
bb114:
  _311 = _290
  using: _290@Phi(bb113)
  _312 = const 1_i32
  using: 
  _310 = Eq(move _311, move _312)
  using: _311@Mir(bb114[0]), _312@Mir(bb114[1])
  switchInt(move _310) -> [0: bb115, otherwise: bb122]
  using: _310@Mir(bb114[2])
bb115:
  _313 = _289
  using: _289@Phi(bb113)
  _315 = _295
  using: _295@Phi(bb113)
  _314 = move _315 as *mut u8 (PtrToPtr)
  using: _315@Mir(bb115[1])
  (*_314) = move _313
  using: _314@Mir(bb115[2]), _313@Mir(bb115[0])
  _317 = _288
  using: _288@Phi(bb113)
  _318 = const 8_i32
  using: 
  _319 = CheckedShl(_317, _318)
  using: _317@Mir(bb115[4]), _318@Mir(bb115[5])
  assert(!move (_319.1: bool), "attempt to shift left by `{}`, which would overflow", move _318) -> bb116
  using: _319@Entry, _317@Entry, _318@Entry
bb116:
  _316 = move (_319.0: u32)
  using: _319@Mir(bb115[6])
  _321 = const {alloc723: *mut [u32; 256]}
  using: 
  _325 = _288
  using: _288@Phi(bb113)
  _326 = const 24_i32
  using: 
  _327 = CheckedShr(_325, _326)
  using: _325@Mir(bb116[2]), _326@Mir(bb116[3])
  assert(!move (_327.1: bool), "attempt to shift right by `{}`, which would overflow", move _326) -> bb117
  using: _327@Entry, _325@Entry, _326@Entry
bb117:
  _324 = move (_327.0: u32)
  using: _327@Mir(bb116[4])
  _329 = _289
  using: _289@Phi(bb113)
  _328 = move _329 as u32 (IntToInt)
  using: _329@Mir(bb117[1])
  _323 = BitXor(move _324, move _328)
  using: _324@Mir(bb117[0]), _328@Mir(bb117[2])
  _322 = move _323 as usize (IntToInt)
  using: _323@Mir(bb117[3])
  _330 = const 256_usize
  using: 
  _331 = Lt(_322, _330)
  using: _322@Mir(bb117[4]), _330@Mir(bb117[5])
  assert(move _331, "index out of bounds: the length is {} but the index is {}", move _330, _322) -> bb118
  using: _331@Entry, _330@Entry, _322@Entry
bb118:
  _320 = (*_321)[_322]
  using: _321@Mir(bb116[1]), _322@Mir(bb117[4])
  _288 = BitXor(move _316, move _320)
  using: _316@Mir(bb116[0]), _320@Mir(bb118[0])
  _332 = CheckedSub(_290, const 1_i32)
  using: _290@Phi(bb113)
  assert(!move (_332.1: bool), "attempt to compute `{} - {}`, which would overflow", _290, const 1_i32) -> bb119
  using: _332@Entry, _290@Entry
bb119:
  _290 = move (_332.0: i32)
  using: _332@Mir(bb118[2])
  _334 = _295
  using: _295@Phi(bb113)
  _333 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _334, const 1_isize) -> bb120
  using: _334@Mir(bb119[1])
bb120:
  _295 = move _333
  using: _333@Mir(bb119[2])
  _336 = _296
  using: _296@Phi(bb113)
  _335 = core::num::<impl u32>::wrapping_sub(move _336, const 1_u32) -> bb121
  using: _336@Mir(bb120[1])
bb121:
  _296 = move _335
  using: _335@Mir(bb120[2])
  goto -> bb113
  using: 
bb122:
  _2 = const 16910810822589621899_u64
  using: 
  goto -> bb124
  using: 
bb123:
  _2 = const 3024573345131975588_u64
  using: 
  goto -> bb124
  using: 
bb124:
  switchInt(_2) -> [16910810822589621899: bb126, otherwise: bb125]
  using: _2@Phi(bb124)
bb125:
  _364 = _291
  using: _291@Phi(bb124)
  _365 = _299
  using: _299@Phi(bb124)
  _363 = Gt(move _364, move _365)
  using: _364@Mir(bb125[0]), _365@Mir(bb125[1])
  switchInt(move _363) -> [0: bb135, otherwise: bb134]
  using: _363@Mir(bb125[2])
bb126:
  _338 = _296
  using: _296@Phi(bb124)
  _339 = const 0_u32
  using: 
  _337 = Eq(move _338, move _339)
  using: _338@Mir(bb126[0]), _339@Mir(bb126[1])
  switchInt(move _337) -> [0: bb128, otherwise: bb127]
  using: _337@Mir(bb126[2])
bb127:
  _290 = const 1_i32
  using: 
  goto -> bb182
  using: 
bb128:
  _340 = _289
  using: _289@Phi(bb124)
  _342 = _295
  using: _295@Phi(bb124)
  _341 = move _342 as *mut u8 (PtrToPtr)
  using: _342@Mir(bb128[1])
  (*_341) = move _340
  using: _341@Mir(bb128[2]), _340@Mir(bb128[0])
  _344 = _288
  using: _288@Phi(bb124)
  _345 = const 8_i32
  using: 
  _346 = CheckedShl(_344, _345)
  using: _344@Mir(bb128[4]), _345@Mir(bb128[5])
  assert(!move (_346.1: bool), "attempt to shift left by `{}`, which would overflow", move _345) -> bb129
  using: _346@Entry, _344@Entry, _345@Entry
bb129:
  _343 = move (_346.0: u32)
  using: _346@Mir(bb128[6])
  _348 = const {alloc723: *mut [u32; 256]}
  using: 
  _352 = _288
  using: _288@Phi(bb124)
  _353 = const 24_i32
  using: 
  _354 = CheckedShr(_352, _353)
  using: _352@Mir(bb129[2]), _353@Mir(bb129[3])
  assert(!move (_354.1: bool), "attempt to shift right by `{}`, which would overflow", move _353) -> bb130
  using: _354@Entry, _352@Entry, _353@Entry
bb130:
  _351 = move (_354.0: u32)
  using: _354@Mir(bb129[4])
  _356 = _289
  using: _289@Phi(bb124)
  _355 = move _356 as u32 (IntToInt)
  using: _356@Mir(bb130[1])
  _350 = BitXor(move _351, move _355)
  using: _351@Mir(bb130[0]), _355@Mir(bb130[2])
  _349 = move _350 as usize (IntToInt)
  using: _350@Mir(bb130[3])
  _357 = const 256_usize
  using: 
  _358 = Lt(_349, _357)
  using: _349@Mir(bb130[4]), _357@Mir(bb130[5])
  assert(move _358, "index out of bounds: the length is {} but the index is {}", move _357, _349) -> bb131
  using: _358@Entry, _357@Entry, _349@Entry
bb131:
  _347 = (*_348)[_349]
  using: _348@Mir(bb129[1]), _349@Mir(bb130[4])
  _288 = BitXor(move _343, move _347)
  using: _343@Mir(bb129[0]), _347@Mir(bb131[0])
  _360 = _295
  using: _295@Phi(bb124)
  _359 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _360, const 1_isize) -> bb132
  using: _360@Mir(bb131[2])
bb132:
  _295 = move _359
  using: _359@Mir(bb131[3])
  _362 = _296
  using: _296@Phi(bb124)
  _361 = core::num::<impl u32>::wrapping_sub(move _362, const 1_u32) -> bb133
  using: _362@Mir(bb132[1])
bb133:
  _296 = move _361
  using: _361@Mir(bb132[2])
  _2 = const 3024573345131975588_u64
  using: 
  goto -> bb124
  using: 
bb134:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb135:
  _367 = _291
  using: _291@Phi(bb124)
  _368 = _299
  using: _299@Phi(bb124)
  _366 = Eq(move _367, move _368)
  using: _367@Mir(bb135[0]), _368@Mir(bb135[1])
  switchInt(move _366) -> [0: bb137, otherwise: bb136]
  using: _366@Mir(bb135[2])
bb136:
  _290 = const 0_i32
  using: 
  goto -> bb182
  using: 
bb137:
  _369 = _292
  using: _292@Phi(bb124)
  _289 = move _369 as u8 (IntToInt)
  using: _369@Mir(bb137[0])
  _371 = _294
  using: _294@Phi(bb124)
  _373 = const 100000_u32
  using: 
  _375 = _297
  using: _297@Phi(bb124)
  _374 = move _375 as u32 (IntToInt)
  using: _375@Mir(bb137[4])
  _372 = core::num::<impl u32>::wrapping_mul(move _373, move _374) -> bb138
  using: _373@Mir(bb137[3]), _374@Mir(bb137[5])
bb138:
  _370 = Ge(move _371, move _372)
  using: _371@Mir(bb137[2]), _372@Mir(bb137[6])
  switchInt(move _370) -> [0: bb140, otherwise: bb139]
  using: _370@Mir(bb138[0])
bb139:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb140:
  _378 = _293
  using: _293@Phi(bb124)
  _380 = _294
  using: _294@Phi(bb124)
  _379 = move _380 as isize (IntToInt)
  using: _380@Mir(bb140[1])
  _377 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _378, move _379) -> bb141
  using: _378@Mir(bb140[0]), _379@Mir(bb140[2])
bb141:
  _376 = (*_377)
  using: _377@Mir(bb140[3])
  _294 = move _376
  using: _376@Mir(bb141[0])
  _382 = _294
  using: _294@Mir(bb141[1])
  _383 = const 255_u32
  using: 
  _381 = BitAnd(move _382, move _383)
  using: _382@Mir(bb141[2]), _383@Mir(bb141[3])
  _3 = move _381 as u8 (IntToInt)
  using: _381@Mir(bb141[4])
  _384 = const 8_i32
  using: 
  _385 = CheckedShr(_294, _384)
  using: _294@Mir(bb141[1]), _384@Mir(bb141[6])
  assert(!move (_385.1: bool), "attempt to shift right by `{}`, which would overflow", move _384) -> bb142
  using: _385@Entry, _294@Entry, _384@Entry
bb142:
  _294 = move (_385.0: u32)
  using: _385@Mir(bb141[7])
  _386 = CheckedAdd(_291, const 1_i32)
  using: _291@Phi(bb124)
  assert(!move (_386.1: bool), "attempt to compute `{} + {}`, which would overflow", _291, const 1_i32) -> bb143
  using: _386@Entry, _291@Entry
bb143:
  _291 = move (_386.0: i32)
  using: _386@Mir(bb142[1])
  _389 = _3
  using: _3@Mir(bb141[5])
  _388 = move _389 as i32 (IntToInt)
  using: _389@Mir(bb143[1])
  _390 = _292
  using: _292@Phi(bb124)
  _387 = Ne(move _388, move _390)
  using: _388@Mir(bb143[2]), _390@Mir(bb143[3])
  switchInt(move _387) -> [0: bb145, otherwise: bb144]
  using: _387@Mir(bb143[4])
bb144:
  _391 = _3
  using: _3@Mir(bb141[5])
  _292 = move _391 as i32 (IntToInt)
  using: _391@Mir(bb144[0])
  _2 = const 16910810822589621899_u64
  using: 
  goto -> bb124
  using: 
bb145:
  _393 = _291
  using: _291@Mir(bb143[0])
  _394 = _299
  using: _299@Phi(bb124)
  _392 = Eq(move _393, move _394)
  using: _393@Mir(bb145[0]), _394@Mir(bb145[1])
  switchInt(move _392) -> [0: bb147, otherwise: bb146]
  using: _392@Mir(bb145[2])
bb146:
  _2 = const 16910810822589621899_u64
  using: 
  goto -> bb124
  using: 
bb147:
  _290 = const 2_i32
  using: 
  _396 = _294
  using: _294@Mir(bb142[0])
  _398 = const 100000_u32
  using: 
  _400 = _297
  using: _297@Phi(bb124)
  _399 = move _400 as u32 (IntToInt)
  using: _400@Mir(bb147[3])
  _397 = core::num::<impl u32>::wrapping_mul(move _398, move _399) -> bb148
  using: _398@Mir(bb147[2]), _399@Mir(bb147[4])
bb148:
  _395 = Ge(move _396, move _397)
  using: _396@Mir(bb147[1]), _397@Mir(bb147[5])
  switchInt(move _395) -> [0: bb150, otherwise: bb149]
  using: _395@Mir(bb148[0])
bb149:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb150:
  _403 = _293
  using: _293@Phi(bb124)
  _405 = _294
  using: _294@Mir(bb142[0])
  _404 = move _405 as isize (IntToInt)
  using: _405@Mir(bb150[1])
  _402 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _403, move _404) -> bb151
  using: _403@Mir(bb150[0]), _404@Mir(bb150[2])
bb151:
  _401 = (*_402)
  using: _402@Mir(bb150[3])
  _294 = move _401
  using: _401@Mir(bb151[0])
  _407 = _294
  using: _294@Mir(bb151[1])
  _408 = const 255_u32
  using: 
  _406 = BitAnd(move _407, move _408)
  using: _407@Mir(bb151[2]), _408@Mir(bb151[3])
  _3 = move _406 as u8 (IntToInt)
  using: _406@Mir(bb151[4])
  _409 = const 8_i32
  using: 
  _410 = CheckedShr(_294, _409)
  using: _294@Mir(bb151[1]), _409@Mir(bb151[6])
  assert(!move (_410.1: bool), "attempt to shift right by `{}`, which would overflow", move _409) -> bb152
  using: _410@Entry, _294@Entry, _409@Entry
bb152:
  _294 = move (_410.0: u32)
  using: _410@Mir(bb151[7])
  _411 = CheckedAdd(_291, const 1_i32)
  using: _291@Mir(bb143[0])
  assert(!move (_411.1: bool), "attempt to compute `{} + {}`, which would overflow", _291, const 1_i32) -> bb153
  using: _411@Entry, _291@Entry
bb153:
  _291 = move (_411.0: i32)
  using: _411@Mir(bb152[1])
  _413 = _291
  using: _291@Mir(bb153[0])
  _414 = _299
  using: _299@Phi(bb124)
  _412 = Eq(move _413, move _414)
  using: _413@Mir(bb153[1]), _414@Mir(bb153[2])
  switchInt(move _412) -> [0: bb154, otherwise: bb112]
  using: _412@Mir(bb153[3])
bb154:
  _417 = _3
  using: _3@Mir(bb151[5])
  _416 = move _417 as i32 (IntToInt)
  using: _417@Mir(bb154[0])
  _418 = _292
  using: _292@Phi(bb124)
  _415 = Ne(move _416, move _418)
  using: _416@Mir(bb154[1]), _418@Mir(bb154[2])
  switchInt(move _415) -> [0: bb156, otherwise: bb155]
  using: _415@Mir(bb154[3])
bb155:
  _2 = const 18139099716546303047_u64
  using: 
  goto -> bb157
  using: 
bb156:
  _2 = const 919396821984190499_u64
  using: 
  goto -> bb157
  using: 
bb157:
  switchInt(_2) -> [18139099716546303047: bb159, otherwise: bb158]
  using: _2@Phi(bb157)
bb158:
  _290 = const 3_i32
  using: 
  _421 = _294
  using: _294@Mir(bb152[0])
  _423 = const 100000_u32
  using: 
  _425 = _297
  using: _297@Phi(bb124)
  _424 = move _425 as u32 (IntToInt)
  using: _425@Mir(bb158[3])
  _422 = core::num::<impl u32>::wrapping_mul(move _423, move _424) -> bb160
  using: _423@Mir(bb158[2]), _424@Mir(bb158[4])
bb159:
  _419 = _3
  using: _3@Mir(bb151[5])
  _292 = move _419 as i32 (IntToInt)
  using: _419@Mir(bb159[0])
  goto -> bb112
  using: 
bb160:
  _420 = Ge(move _421, move _422)
  using: _421@Mir(bb158[1]), _422@Mir(bb158[5])
  switchInt(move _420) -> [0: bb162, otherwise: bb161]
  using: _420@Mir(bb160[0])
bb161:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb162:
  _428 = _293
  using: _293@Phi(bb124)
  _430 = _294
  using: _294@Mir(bb152[0])
  _429 = move _430 as isize (IntToInt)
  using: _430@Mir(bb162[1])
  _427 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _428, move _429) -> bb163
  using: _428@Mir(bb162[0]), _429@Mir(bb162[2])
bb163:
  _426 = (*_427)
  using: _427@Mir(bb162[3])
  _294 = move _426
  using: _426@Mir(bb163[0])
  _432 = _294
  using: _294@Mir(bb163[1])
  _433 = const 255_u32
  using: 
  _431 = BitAnd(move _432, move _433)
  using: _432@Mir(bb163[2]), _433@Mir(bb163[3])
  _3 = move _431 as u8 (IntToInt)
  using: _431@Mir(bb163[4])
  _434 = const 8_i32
  using: 
  _435 = CheckedShr(_294, _434)
  using: _294@Mir(bb163[1]), _434@Mir(bb163[6])
  assert(!move (_435.1: bool), "attempt to shift right by `{}`, which would overflow", move _434) -> bb164
  using: _435@Entry, _294@Entry, _434@Entry
bb164:
  _294 = move (_435.0: u32)
  using: _435@Mir(bb163[7])
  _436 = CheckedAdd(_291, const 1_i32)
  using: _291@Mir(bb153[0])
  assert(!move (_436.1: bool), "attempt to compute `{} + {}`, which would overflow", _291, const 1_i32) -> bb165
  using: _436@Entry, _291@Entry
bb165:
  _291 = move (_436.0: i32)
  using: _436@Mir(bb164[1])
  _438 = _291
  using: _291@Mir(bb165[0])
  _439 = _299
  using: _299@Phi(bb124)
  _437 = Eq(move _438, move _439)
  using: _438@Mir(bb165[1]), _439@Mir(bb165[2])
  switchInt(move _437) -> [0: bb166, otherwise: bb112]
  using: _437@Mir(bb165[3])
bb166:
  _442 = _3
  using: _3@Mir(bb163[5])
  _441 = move _442 as i32 (IntToInt)
  using: _442@Mir(bb166[0])
  _443 = _292
  using: _292@Phi(bb124)
  _440 = Ne(move _441, move _443)
  using: _441@Mir(bb166[1]), _443@Mir(bb166[2])
  switchInt(move _440) -> [0: bb168, otherwise: bb167]
  using: _440@Mir(bb166[3])
bb167:
  _444 = _3
  using: _3@Mir(bb163[5])
  _292 = move _444 as i32 (IntToInt)
  using: _444@Mir(bb167[0])
  goto -> bb112
  using: 
bb168:
  _446 = _294
  using: _294@Mir(bb164[0])
  _448 = const 100000_u32
  using: 
  _450 = _297
  using: _297@Phi(bb124)
  _449 = move _450 as u32 (IntToInt)
  using: _450@Mir(bb168[2])
  _447 = core::num::<impl u32>::wrapping_mul(move _448, move _449) -> bb169
  using: _448@Mir(bb168[1]), _449@Mir(bb168[3])
bb169:
  _445 = Ge(move _446, move _447)
  using: _446@Mir(bb168[0]), _447@Mir(bb168[4])
  switchInt(move _445) -> [0: bb171, otherwise: bb170]
  using: _445@Mir(bb169[0])
bb170:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb171:
  _453 = _293
  using: _293@Phi(bb124)
  _455 = _294
  using: _294@Mir(bb164[0])
  _454 = move _455 as isize (IntToInt)
  using: _455@Mir(bb171[1])
  _452 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _453, move _454) -> bb172
  using: _453@Mir(bb171[0]), _454@Mir(bb171[2])
bb172:
  _451 = (*_452)
  using: _452@Mir(bb171[3])
  _294 = move _451
  using: _451@Mir(bb172[0])
  _457 = _294
  using: _294@Mir(bb172[1])
  _458 = const 255_u32
  using: 
  _456 = BitAnd(move _457, move _458)
  using: _457@Mir(bb172[2]), _458@Mir(bb172[3])
  _3 = move _456 as u8 (IntToInt)
  using: _456@Mir(bb172[4])
  _459 = const 8_i32
  using: 
  _460 = CheckedShr(_294, _459)
  using: _294@Mir(bb172[1]), _459@Mir(bb172[6])
  assert(!move (_460.1: bool), "attempt to shift right by `{}`, which would overflow", move _459) -> bb173
  using: _460@Entry, _294@Entry, _459@Entry
bb173:
  _294 = move (_460.0: u32)
  using: _460@Mir(bb172[7])
  _461 = CheckedAdd(_291, const 1_i32)
  using: _291@Mir(bb165[0])
  assert(!move (_461.1: bool), "attempt to compute `{} + {}`, which would overflow", _291, const 1_i32) -> bb174
  using: _461@Entry, _291@Entry
bb174:
  _291 = move (_461.0: i32)
  using: _461@Mir(bb173[1])
  _463 = _3
  using: _3@Mir(bb172[5])
  _462 = move _463 as i32 (IntToInt)
  using: _463@Mir(bb174[1])
  _464 = const 4_i32
  using: 
  _465 = CheckedAdd(_462, _464)
  using: _462@Mir(bb174[2]), _464@Mir(bb174[3])
  assert(!move (_465.1: bool), "attempt to compute `{} + {}`, which would overflow", move _462, move _464) -> bb175
  using: _465@Entry, _462@Entry, _464@Entry
bb175:
  _290 = move (_465.0: i32)
  using: _465@Mir(bb174[4])
  _467 = _294
  using: _294@Mir(bb173[0])
  _469 = const 100000_u32
  using: 
  _471 = _297
  using: _297@Phi(bb124)
  _470 = move _471 as u32 (IntToInt)
  using: _471@Mir(bb175[3])
  _468 = core::num::<impl u32>::wrapping_mul(move _469, move _470) -> bb176
  using: _469@Mir(bb175[2]), _470@Mir(bb175[4])
bb176:
  _466 = Ge(move _467, move _468)
  using: _467@Mir(bb175[1]), _468@Mir(bb175[5])
  switchInt(move _466) -> [0: bb178, otherwise: bb177]
  using: _466@Mir(bb176[0])
bb177:
  _0 = const 1_u8
  using: 
  goto -> bb188
  using: 
bb178:
  _474 = _293
  using: _293@Phi(bb124)
  _476 = _294
  using: _294@Mir(bb173[0])
  _475 = move _476 as isize (IntToInt)
  using: _476@Mir(bb178[1])
  _473 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _474, move _475) -> bb179
  using: _474@Mir(bb178[0]), _475@Mir(bb178[2])
bb179:
  _472 = (*_473)
  using: _473@Mir(bb178[3])
  _294 = move _472
  using: _472@Mir(bb179[0])
  _479 = _294
  using: _294@Mir(bb179[1])
  _480 = const 255_u32
  using: 
  _478 = BitAnd(move _479, move _480)
  using: _479@Mir(bb179[2]), _480@Mir(bb179[3])
  _477 = move _478 as u8 (IntToInt)
  using: _478@Mir(bb179[4])
  _292 = move _477 as i32 (IntToInt)
  using: _477@Mir(bb179[5])
  _481 = const 8_i32
  using: 
  _482 = CheckedShr(_294, _481)
  using: _294@Mir(bb179[1]), _481@Mir(bb179[7])
  assert(!move (_482.1: bool), "attempt to shift right by `{}`, which would overflow", move _481) -> bb180
  using: _482@Entry, _294@Entry, _481@Entry
bb180:
  _294 = move (_482.0: u32)
  using: _482@Mir(bb179[8])
  _483 = CheckedAdd(_291, const 1_i32)
  using: _291@Mir(bb174[0])
  assert(!move (_483.1: bool), "attempt to compute `{} + {}`, which would overflow", _291, const 1_i32) -> bb181
  using: _483@Entry, _291@Entry
bb181:
  _291 = move (_483.0: i32)
  using: _483@Mir(bb180[1])
  goto -> bb112
  using: 
bb182:
  _517 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  _484 = ((*_517).6: u32)
  using: _517@Mir(bb182[0])
  _303 = move _484
  using: _484@Mir(bb182[1])
  _518 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  _486 = ((*_518).6: u32)
  using: _518@Mir(bb182[3])
  _488 = _298
  using: _298@Mir(bb110[12])
  _489 = _296
  using: _296@Phi(bb182)
  _487 = core::num::<impl u32>::wrapping_sub(move _488, move _489) -> bb183
  using: _488@Mir(bb182[5]), _489@Mir(bb182[6])
bb183:
  _485 = core::num::<impl u32>::wrapping_add(move _486, move _487) -> bb184
  using: _486@Mir(bb182[4]), _487@Mir(bb182[7])
bb184:
  _519 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  ((*_519).6: u32) = move _485
  using: _519@Mir(bb184[0]), _485@Mir(bb183[0])
  _520 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  _491 = ((*_520).6: u32)
  using: _520@Mir(bb184[2])
  _492 = _303
  using: _303@Mir(bb182[2])
  _490 = Lt(move _491, move _492)
  using: _491@Mir(bb184[3]), _492@Mir(bb184[4])
  switchInt(move _490) -> [0: bb187, otherwise: bb185]
  using: _490@Mir(bb184[5])
bb185:
  _521 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  _494 = ((*_521).7: u32)
  using: _521@Mir(bb185[0])
  _493 = core::num::<impl u32>::wrapping_add(move _494, const 1_u32) -> bb186
  using: _494@Mir(bb185[1])
bb186:
  _522 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb104)
  ((*_522).7: u32) = move _493
  using: _522@Mir(bb186[0]), _493@Mir(bb185[2])
  goto -> bb187
  using: 
bb187:
  _495 = _288
  using: _288@Phi(bb182)
  ((*_1).25: u32) = move _495
  using: _1@Phi(bb187), _495@Mir(bb187[0])
  _496 = _289
  using: _289@Phi(bb182)
  ((*_1).2: u8) = move _496
  using: _1@Phi(bb187), _496@Mir(bb187[2])
  _497 = _290
  using: _290@Phi(bb182)
  ((*_1).3: i32) = move _497
  using: _1@Phi(bb187), _497@Mir(bb187[4])
  _498 = _291
  using: _291@Phi(bb182)
  ((*_1).17: i32) = move _498
  using: _1@Phi(bb187), _498@Mir(bb187[6])
  _499 = _292
  using: _292@Phi(bb182)
  ((*_1).15: i32) = move _499
  using: _1@Phi(bb187), _499@Mir(bb187[8])
  _500 = _293
  using: _293@Phi(bb182)
  ((*_1).20: *mut u32) = move _500
  using: _1@Phi(bb187), _500@Mir(bb187[10])
  _501 = _294
  using: _294@Phi(bb182)
  ((*_1).14: u32) = move _501
  using: _1@Phi(bb187), _501@Mir(bb187[12])
  _502 = _295
  using: _295@Phi(bb182)
  _523 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  ((*_523).4: *mut i8) = move _502
  using: _523@Mir(bb187[15]), _502@Mir(bb187[14])
  _503 = _296
  using: _296@Phi(bb182)
  _524 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  ((*_524).5: u32) = move _503
  using: _524@Mir(bb187[18]), _503@Mir(bb187[17])
  _0 = const 0_u8
  using: 
  goto -> bb188
  using: 
bb188:
  return
  using: _0@Phi(bb188)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:812:63: 812:72 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:814:44: 814:59 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:816:49: 816:64 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:820:53: 820:68 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:835:33: 835:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:838:34: 838:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:864:37: 864:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:868:38: 868:64 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:896:41: 897:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:900:42: 900:68 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:928:45: 929:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:932:46: 932:72 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:954:45: 955:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:958:46: 958:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1014:51: 1014:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:1015:53: 1015:68 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1037:59: 1037:68 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:1038:61: 1038:76 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1055:53: 1057:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1060:48: 1060:71 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1078:57: 1080:81 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1084:52: 1084:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1112:45: 1113:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1116:40: 1116:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1128:49: 1129:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1132:44: 1132:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1141:49: 1142:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1145:44: 1145:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:1157:69: 1157:95 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:1157:41: 1157:96 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:1160:45: 1160:60 (#0) by default
@DefId(0:375 ~ c2rust_lib[1043]::bzlib::BZ2_indexIntoF)
bb0:
  _0 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _0 = const 0_i32
  using: 
  _3 = const 256_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _6 = _0
  using: _0@Phi(bb1)
  _7 = _3
  using: _3@Phi(bb1)
  _8 = CheckedAdd(_6, _7)
  using: _6@Mir(bb1[0]), _7@Mir(bb1[1])
  assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _6, move _7) -> bb2
  using: _8@Entry, _6@Entry, _7@Entry
bb2:
  _5 = move (_8.0: i32)
  using: _8@Mir(bb1[2])
  _9 = const 1_i32
  using: 
  _10 = CheckedShr(_5, _9)
  using: _5@Mir(bb2[0]), _9@Mir(bb2[1])
  assert(!move (_10.1: bool), "attempt to shift right by `{}`, which would overflow", move _9) -> bb3
  using: _10@Entry, _5@Entry, _9@Entry
bb3:
  _4 = move (_10.0: i32)
  using: _10@Mir(bb2[2])
  _12 = _1
  using: _1@Phi(bb1)
  _15 = _2
  using: _2@Phi(bb1)
  _17 = _4
  using: _4@Mir(bb3[0])
  _16 = move _17 as isize (IntToInt)
  using: _17@Mir(bb3[3])
  _14 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _15, move _16) -> bb4
  using: _15@Mir(bb3[2]), _16@Mir(bb3[4])
bb4:
  _13 = (*_14)
  using: _14@Mir(bb3[5])
  _11 = Ge(move _12, move _13)
  using: _12@Mir(bb3[1]), _13@Mir(bb4[0])
  switchInt(move _11) -> [0: bb6, otherwise: bb5]
  using: _11@Mir(bb4[1])
bb5:
  _18 = _4
  using: _4@Mir(bb3[0])
  _0 = move _18
  using: _18@Mir(bb5[0])
  goto -> bb7
  using: 
bb6:
  _19 = _4
  using: _4@Mir(bb3[0])
  _3 = move _19
  using: _19@Mir(bb6[0])
  goto -> bb7
  using: 
bb7:
  _23 = _3
  using: _3@Phi(bb7)
  _24 = _0
  using: _0@Phi(bb7)
  _25 = CheckedSub(_23, _24)
  using: _23@Mir(bb7[0]), _24@Mir(bb7[1])
  assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _23, move _24) -> bb8
  using: _25@Entry, _23@Entry, _24@Entry
bb8:
  _22 = move (_25.0: i32)
  using: _25@Mir(bb7[2])
  _26 = const 1_i32
  using: 
  _21 = Ne(move _22, move _26)
  using: _22@Mir(bb8[0]), _26@Mir(bb8[1])
  _20 = Not(move _21)
  using: _21@Mir(bb8[2])
  switchInt(move _20) -> [0: bb1, otherwise: bb9]
  using: _20@Mir(bb8[3])
bb9:
  return
  using: _0@Phi(bb7)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1189:27: 1189:47 (#0) by default
@DefId(0:376 ~ c2rust_lib[1043]::bzlib::unRLE_obuf_to_output_SMALL)
bb0:
  _2 = const 0_u8
  using: 
  _3 = ((*_1).4: u8)
  using: _1@Entry
  switchInt(move _3) -> [0: bb140, otherwise: bb1]
  using: _3@Mir(bb0[1])
bb1:
  goto -> bb2
  using: 
bb2:
  _701 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _5 = ((*_701).5: u32)
  using: _701@Mir(bb2[0])
  _6 = const 0_u32
  using: 
  _4 = Eq(move _5, move _6)
  using: _5@Mir(bb2[1]), _6@Mir(bb2[2])
  switchInt(move _4) -> [0: bb4, otherwise: bb3]
  using: _4@Mir(bb2[3])
bb3:
  _0 = const 0_u8
  using: 
  goto -> bb234
  using: 
bb4:
  _8 = ((*_1).3: i32)
  using: _1@Phi(bb2)
  _9 = const 0_i32
  using: 
  _7 = Eq(move _8, move _9)
  using: _8@Mir(bb4[0]), _9@Mir(bb4[1])
  switchInt(move _7) -> [0: bb5, otherwise: bb15]
  using: _7@Mir(bb4[2])
bb5:
  _10 = ((*_1).2: u8)
  using: _1@Phi(bb2)
  _702 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _12 = ((*_702).4: *mut i8)
  using: _702@Mir(bb5[1])
  _11 = move _12 as *mut u8 (PtrToPtr)
  using: _12@Mir(bb5[2])
  (*_11) = move _10
  using: _11@Mir(bb5[3]), _10@Mir(bb5[0])
  _14 = ((*_1).25: u32)
  using: _1@Phi(bb2)
  _15 = const 8_i32
  using: 
  _16 = CheckedShl(_14, _15)
  using: _14@Mir(bb5[5]), _15@Mir(bb5[6])
  assert(!move (_16.1: bool), "attempt to shift left by `{}`, which would overflow", move _15) -> bb6
  using: _16@Entry, _14@Entry, _15@Entry
bb6:
  _13 = move (_16.0: u32)
  using: _16@Mir(bb5[7])
  _18 = const {alloc723: *mut [u32; 256]}
  using: 
  _22 = ((*_1).25: u32)
  using: _1@Phi(bb2)
  _23 = const 24_i32
  using: 
  _24 = CheckedShr(_22, _23)
  using: _22@Mir(bb6[2]), _23@Mir(bb6[3])
  assert(!move (_24.1: bool), "attempt to shift right by `{}`, which would overflow", move _23) -> bb7
  using: _24@Entry, _22@Entry, _23@Entry
bb7:
  _21 = move (_24.0: u32)
  using: _24@Mir(bb6[4])
  _26 = ((*_1).2: u8)
  using: _1@Phi(bb2)
  _25 = move _26 as u32 (IntToInt)
  using: _26@Mir(bb7[1])
  _20 = BitXor(move _21, move _25)
  using: _21@Mir(bb7[0]), _25@Mir(bb7[2])
  _19 = move _20 as usize (IntToInt)
  using: _20@Mir(bb7[3])
  _27 = const 256_usize
  using: 
  _28 = Lt(_19, _27)
  using: _19@Mir(bb7[4]), _27@Mir(bb7[5])
  assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _19) -> bb8
  using: _28@Entry, _27@Entry, _19@Entry
bb8:
  _17 = (*_18)[_19]
  using: _18@Mir(bb6[1]), _19@Mir(bb7[4])
  ((*_1).25: u32) = BitXor(move _13, move _17)
  using: _1@Phi(bb2), _13@Mir(bb6[0]), _17@Mir(bb8[0])
  _29 = CheckedSub(((*_1).3: i32), const 1_i32)
  using: _1@Phi(bb2)
  assert(!move (_29.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).3: i32), const 1_i32) -> bb9
  using: _29@Entry, _1@Entry
bb9:
  ((*_1).3: i32) = move (_29.0: i32)
  using: _1@Phi(bb2), _29@Mir(bb8[2])
  _703 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _31 = ((*_703).4: *mut i8)
  using: _703@Mir(bb9[1])
  _30 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _31, const 1_isize) -> bb10
  using: _31@Mir(bb9[2])
bb10:
  _704 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_704).4: *mut i8) = move _30
  using: _704@Mir(bb10[0]), _30@Mir(bb9[3])
  _705 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _33 = ((*_705).5: u32)
  using: _705@Mir(bb10[2])
  _32 = core::num::<impl u32>::wrapping_sub(move _33, const 1_u32) -> bb11
  using: _33@Mir(bb10[3])
bb11:
  _706 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_706).5: u32) = move _32
  using: _706@Mir(bb11[0]), _32@Mir(bb10[4])
  _707 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _35 = ((*_707).6: u32)
  using: _707@Mir(bb11[2])
  _34 = core::num::<impl u32>::wrapping_add(move _35, const 1_u32) -> bb12
  using: _35@Mir(bb11[3])
bb12:
  _708 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_708).6: u32) = move _34
  using: _708@Mir(bb12[0]), _34@Mir(bb11[4])
  _709 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _37 = ((*_709).6: u32)
  using: _709@Mir(bb12[2])
  _38 = const 0_u32
  using: 
  _36 = Eq(move _37, move _38)
  using: _37@Mir(bb12[3]), _38@Mir(bb12[4])
  switchInt(move _36) -> [0: bb2, otherwise: bb13]
  using: _36@Mir(bb12[5])
bb13:
  _710 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  _40 = ((*_710).7: u32)
  using: _710@Mir(bb13[0])
  _39 = core::num::<impl u32>::wrapping_add(move _40, const 1_u32) -> bb14
  using: _40@Mir(bb13[1])
bb14:
  _711 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb2)
  ((*_711).7: u32) = move _39
  using: _711@Mir(bb14[0]), _39@Mir(bb13[2])
  goto -> bb2
  using: 
bb15:
  _42 = ((*_1).17: i32)
  using: _1@Phi(bb2)
  _44 = ((*_1).51: i32)
  using: _1@Phi(bb2)
  _45 = const 1_i32
  using: 
  _46 = CheckedAdd(_44, _45)
  using: _44@Mir(bb15[1]), _45@Mir(bb15[2])
  assert(!move (_46.1: bool), "attempt to compute `{} + {}`, which would overflow", move _44, move _45) -> bb16
  using: _46@Entry, _44@Entry, _45@Entry
bb16:
  _43 = move (_46.0: i32)
  using: _46@Mir(bb15[3])
  _41 = Eq(move _42, move _43)
  using: _42@Mir(bb15[0]), _43@Mir(bb16[0])
  switchInt(move _41) -> [0: bb18, otherwise: bb17]
  using: _41@Mir(bb16[1])
bb17:
  _0 = const 0_u8
  using: 
  goto -> bb234
  using: 
bb18:
  _48 = ((*_1).17: i32)
  using: _1@Phi(bb2)
  _50 = ((*_1).51: i32)
  using: _1@Phi(bb2)
  _51 = const 1_i32
  using: 
  _52 = CheckedAdd(_50, _51)
  using: _50@Mir(bb18[1]), _51@Mir(bb18[2])
  assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", move _50, move _51) -> bb19
  using: _52@Entry, _50@Entry, _51@Entry
bb19:
  _49 = move (_52.0: i32)
  using: _52@Mir(bb18[3])
  _47 = Gt(move _48, move _49)
  using: _48@Mir(bb18[0]), _49@Mir(bb19[0])
  switchInt(move _47) -> [0: bb21, otherwise: bb20]
  using: _47@Mir(bb19[1])
bb20:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb21:
  _53 = const 1_i32
  using: 
  ((*_1).3: i32) = move _53
  using: _1@Phi(bb2), _53@Mir(bb21[0])
  _54 = ((*_1).15: i32)
  using: _1@Phi(bb2)
  ((*_1).2: u8) = move _54 as u8 (IntToInt)
  using: _1@Phi(bb2), _54@Mir(bb21[2])
  _56 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _58 = const 100000_u32
  using: 
  _60 = ((*_1).9: i32)
  using: _1@Phi(bb2)
  _59 = move _60 as u32 (IntToInt)
  using: _60@Mir(bb21[6])
  _57 = core::num::<impl u32>::wrapping_mul(move _58, move _59) -> bb22
  using: _58@Mir(bb21[5]), _59@Mir(bb21[7])
bb22:
  _55 = Ge(move _56, move _57)
  using: _56@Mir(bb21[4]), _57@Mir(bb21[8])
  switchInt(move _55) -> [0: bb24, otherwise: bb23]
  using: _55@Mir(bb22[0])
bb23:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb24:
  _63 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _62 = move _63 as i32 (IntToInt)
  using: _63@Mir(bb24[0])
  _66 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb2)
  _65 = move _66 as &mut [i32] (Pointer(Unsize))
  using: _66@Mir(bb24[2])
  _64 = core::slice::<impl [i32]>::as_mut_ptr(move _65) -> bb25
  using: _65@Mir(bb24[3])
bb25:
  _61 = bzlib::BZ2_indexIntoF(move _62, move _64) -> bb26
  using: _62@Mir(bb24[1]), _64@Mir(bb24[4])
bb26:
  _2 = move _61 as u8 (IntToInt)
  using: _61@Mir(bb25[0])
  _70 = ((*_1).21: *mut u16)
  using: _1@Phi(bb2)
  _72 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _71 = move _72 as isize (IntToInt)
  using: _72@Mir(bb26[2])
  _69 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _70, move _71) -> bb27
  using: _70@Mir(bb26[1]), _71@Mir(bb26[3])
bb27:
  _68 = (*_69)
  using: _69@Mir(bb26[4])
  _67 = move _68 as u32 (IntToInt)
  using: _68@Mir(bb27[0])
  _79 = ((*_1).22: *mut u8)
  using: _1@Phi(bb2)
  _82 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _83 = const 1_i32
  using: 
  _84 = CheckedShr(_82, _83)
  using: _82@Mir(bb27[3]), _83@Mir(bb27[4])
  assert(!move (_84.1: bool), "attempt to shift right by `{}`, which would overflow", move _83) -> bb28
  using: _84@Entry, _82@Entry, _83@Entry
bb28:
  _81 = move (_84.0: u32)
  using: _84@Mir(bb27[5])
  _80 = move _81 as isize (IntToInt)
  using: _81@Mir(bb28[0])
  _78 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _79, move _80) -> bb29
  using: _79@Mir(bb27[2]), _80@Mir(bb28[1])
bb29:
  _77 = (*_78)
  using: _78@Mir(bb28[2])
  _76 = move _77 as u32 (IntToInt)
  using: _77@Mir(bb29[0])
  _87 = ((*_1).14: u32)
  using: _1@Phi(bb2)
  _88 = const 2_i32
  using: 
  _89 = CheckedShl(_87, _88)
  using: _87@Mir(bb29[2]), _88@Mir(bb29[3])
  assert(!move (_89.1: bool), "attempt to shift left by `{}`, which would overflow", move _88) -> bb30
  using: _89@Entry, _87@Entry, _88@Entry
bb30:
  _86 = move (_89.0: u32)
  using: _89@Mir(bb29[4])
  _90 = const 4_u32
  using: 
  _85 = BitAnd(move _86, move _90)
  using: _86@Mir(bb30[0]), _90@Mir(bb30[1])
  _91 = CheckedShr(_76, _85)
  using: _76@Mir(bb29[1]), _85@Mir(bb30[2])
  assert(!move (_91.1: bool), "attempt to shift right by `{}`, which would overflow", move _85) -> bb31
  using: _91@Entry, _76@Entry, _85@Entry
bb31:
  _75 = move (_91.0: u32)
  using: _91@Mir(bb30[3])
  _92 = const 15_u32
  using: 
  _74 = BitAnd(move _75, move _92)
  using: _75@Mir(bb31[0]), _92@Mir(bb31[1])
  _93 = const 16_i32
  using: 
  _94 = CheckedShl(_74, _93)
  using: _74@Mir(bb31[2]), _93@Mir(bb31[3])
  assert(!move (_94.1: bool), "attempt to shift left by `{}`, which would overflow", move _93) -> bb32
  using: _94@Entry, _74@Entry, _93@Entry
bb32:
  _73 = move (_94.0: u32)
  using: _94@Mir(bb31[4])
  ((*_1).14: u32) = BitOr(move _67, move _73)
  using: _1@Phi(bb2), _67@Mir(bb27[1]), _73@Mir(bb32[0])
  _96 = ((*_1).5: i32)
  using: _1@Phi(bb2)
  _97 = const 0_i32
  using: 
  _95 = Eq(move _96, move _97)
  using: _96@Mir(bb32[2]), _97@Mir(bb32[3])
  switchInt(move _95) -> [0: bb37, otherwise: bb33]
  using: _95@Mir(bb32[4])
bb33:
  _99 = const {alloc764: *mut [i32; 512]}
  using: 
  _101 = ((*_1).6: i32)
  using: _1@Phi(bb2)
  _100 = move _101 as usize (IntToInt)
  using: _101@Mir(bb33[1])
  _102 = const 512_usize
  using: 
  _103 = Lt(_100, _102)
  using: _100@Mir(bb33[2]), _102@Mir(bb33[3])
  assert(move _103, "index out of bounds: the length is {} but the index is {}", move _102, _100) -> bb34
  using: _103@Entry, _102@Entry, _100@Entry
bb34:
  _98 = (*_99)[_100]
  using: _99@Mir(bb33[0]), _100@Mir(bb33[2])
  ((*_1).5: i32) = move _98
  using: _1@Phi(bb2), _98@Mir(bb34[0])
  _104 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb2)
  assert(!move (_104.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb35
  using: _104@Entry, _1@Entry
bb35:
  ((*_1).6: i32) = move (_104.0: i32)
  using: _1@Phi(bb2), _104@Mir(bb34[2])
  _106 = ((*_1).6: i32)
  using: _1@Phi(bb2)
  _107 = const 512_i32
  using: 
  _105 = Eq(move _106, move _107)
  using: _106@Mir(bb35[1]), _107@Mir(bb35[2])
  switchInt(move _105) -> [0: bb37, otherwise: bb36]
  using: _105@Mir(bb35[3])
bb36:
  _108 = const 0_i32
  using: 
  ((*_1).6: i32) = move _108
  using: _1@Phi(bb2), _108@Mir(bb36[0])
  goto -> bb37
  using: 
bb37:
  _109 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb37)
  assert(!move (_109.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb38
  using: _109@Entry, _1@Entry
bb38:
  ((*_1).5: i32) = move (_109.0: i32)
  using: _1@Phi(bb37), _109@Mir(bb37[0])
  _112 = _2
  using: _2@Mir(bb26[0])
  _111 = move _112 as i32 (IntToInt)
  using: _112@Mir(bb38[1])
  _115 = ((*_1).5: i32)
  using: _1@Phi(bb37)
  _116 = const 1_i32
  using: 
  _114 = Eq(move _115, move _116)
  using: _115@Mir(bb38[3]), _116@Mir(bb38[4])
  switchInt(move _114) -> [0: bb40, otherwise: bb39]
  using: _114@Mir(bb38[5])
bb39:
  _113 = const 1_i32
  using: 
  goto -> bb41
  using: 
bb40:
  _113 = const 0_i32
  using: 
  goto -> bb41
  using: 
bb41:
  _110 = BitXor(move _111, move _113)
  using: _111@Mir(bb38[2]), _113@Phi(bb41)
  _2 = move _110 as u8 (IntToInt)
  using: _110@Mir(bb41[0])
  _117 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb37)
  assert(!move (_117.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb42
  using: _117@Entry, _1@Entry
bb42:
  ((*_1).17: i32) = move (_117.0: i32)
  using: _1@Phi(bb37), _117@Mir(bb41[2])
  _119 = ((*_1).17: i32)
  using: _1@Phi(bb37)
  _121 = ((*_1).51: i32)
  using: _1@Phi(bb37)
  _122 = const 1_i32
  using: 
  _123 = CheckedAdd(_121, _122)
  using: _121@Mir(bb42[2]), _122@Mir(bb42[3])
  assert(!move (_123.1: bool), "attempt to compute `{} + {}`, which would overflow", move _121, move _122) -> bb43
  using: _123@Entry, _121@Entry, _122@Entry
bb43:
  _120 = move (_123.0: i32)
  using: _123@Mir(bb42[4])
  _118 = Eq(move _119, move _120)
  using: _119@Mir(bb42[1]), _120@Mir(bb43[0])
  switchInt(move _118) -> [0: bb44, otherwise: bb1]
  using: _118@Mir(bb43[1])
bb44:
  _126 = _2
  using: _2@Mir(bb41[1])
  _125 = move _126 as i32 (IntToInt)
  using: _126@Mir(bb44[0])
  _127 = ((*_1).15: i32)
  using: _1@Phi(bb37)
  _124 = Ne(move _125, move _127)
  using: _125@Mir(bb44[1]), _127@Mir(bb44[2])
  switchInt(move _124) -> [0: bb46, otherwise: bb45]
  using: _124@Mir(bb44[3])
bb45:
  _128 = _2
  using: _2@Mir(bb41[1])
  ((*_1).15: i32) = move _128 as i32 (IntToInt)
  using: _1@Phi(bb37), _128@Mir(bb45[0])
  goto -> bb1
  using: 
bb46:
  _129 = const 2_i32
  using: 
  ((*_1).3: i32) = move _129
  using: _1@Phi(bb37), _129@Mir(bb46[0])
  _131 = ((*_1).14: u32)
  using: _1@Phi(bb37)
  _133 = const 100000_u32
  using: 
  _135 = ((*_1).9: i32)
  using: _1@Phi(bb37)
  _134 = move _135 as u32 (IntToInt)
  using: _135@Mir(bb46[4])
  _132 = core::num::<impl u32>::wrapping_mul(move _133, move _134) -> bb47
  using: _133@Mir(bb46[3]), _134@Mir(bb46[5])
bb47:
  _130 = Ge(move _131, move _132)
  using: _131@Mir(bb46[2]), _132@Mir(bb46[6])
  switchInt(move _130) -> [0: bb49, otherwise: bb48]
  using: _130@Mir(bb47[0])
bb48:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb49:
  _138 = ((*_1).14: u32)
  using: _1@Phi(bb37)
  _137 = move _138 as i32 (IntToInt)
  using: _138@Mir(bb49[0])
  _141 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb37)
  _140 = move _141 as &mut [i32] (Pointer(Unsize))
  using: _141@Mir(bb49[2])
  _139 = core::slice::<impl [i32]>::as_mut_ptr(move _140) -> bb50
  using: _140@Mir(bb49[3])
bb50:
  _136 = bzlib::BZ2_indexIntoF(move _137, move _139) -> bb51
  using: _137@Mir(bb49[1]), _139@Mir(bb49[4])
bb51:
  _2 = move _136 as u8 (IntToInt)
  using: _136@Mir(bb50[0])
  _145 = ((*_1).21: *mut u16)
  using: _1@Phi(bb37)
  _147 = ((*_1).14: u32)
  using: _1@Phi(bb37)
  _146 = move _147 as isize (IntToInt)
  using: _147@Mir(bb51[2])
  _144 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _145, move _146) -> bb52
  using: _145@Mir(bb51[1]), _146@Mir(bb51[3])
bb52:
  _143 = (*_144)
  using: _144@Mir(bb51[4])
  _142 = move _143 as u32 (IntToInt)
  using: _143@Mir(bb52[0])
  _154 = ((*_1).22: *mut u8)
  using: _1@Phi(bb37)
  _157 = ((*_1).14: u32)
  using: _1@Phi(bb37)
  _158 = const 1_i32
  using: 
  _159 = CheckedShr(_157, _158)
  using: _157@Mir(bb52[3]), _158@Mir(bb52[4])
  assert(!move (_159.1: bool), "attempt to shift right by `{}`, which would overflow", move _158) -> bb53
  using: _159@Entry, _157@Entry, _158@Entry
bb53:
  _156 = move (_159.0: u32)
  using: _159@Mir(bb52[5])
  _155 = move _156 as isize (IntToInt)
  using: _156@Mir(bb53[0])
  _153 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _154, move _155) -> bb54
  using: _154@Mir(bb52[2]), _155@Mir(bb53[1])
bb54:
  _152 = (*_153)
  using: _153@Mir(bb53[2])
  _151 = move _152 as u32 (IntToInt)
  using: _152@Mir(bb54[0])
  _162 = ((*_1).14: u32)
  using: _1@Phi(bb37)
  _163 = const 2_i32
  using: 
  _164 = CheckedShl(_162, _163)
  using: _162@Mir(bb54[2]), _163@Mir(bb54[3])
  assert(!move (_164.1: bool), "attempt to shift left by `{}`, which would overflow", move _163) -> bb55
  using: _164@Entry, _162@Entry, _163@Entry
bb55:
  _161 = move (_164.0: u32)
  using: _164@Mir(bb54[4])
  _165 = const 4_u32
  using: 
  _160 = BitAnd(move _161, move _165)
  using: _161@Mir(bb55[0]), _165@Mir(bb55[1])
  _166 = CheckedShr(_151, _160)
  using: _151@Mir(bb54[1]), _160@Mir(bb55[2])
  assert(!move (_166.1: bool), "attempt to shift right by `{}`, which would overflow", move _160) -> bb56
  using: _166@Entry, _151@Entry, _160@Entry
bb56:
  _150 = move (_166.0: u32)
  using: _166@Mir(bb55[3])
  _167 = const 15_u32
  using: 
  _149 = BitAnd(move _150, move _167)
  using: _150@Mir(bb56[0]), _167@Mir(bb56[1])
  _168 = const 16_i32
  using: 
  _169 = CheckedShl(_149, _168)
  using: _149@Mir(bb56[2]), _168@Mir(bb56[3])
  assert(!move (_169.1: bool), "attempt to shift left by `{}`, which would overflow", move _168) -> bb57
  using: _169@Entry, _149@Entry, _168@Entry
bb57:
  _148 = move (_169.0: u32)
  using: _169@Mir(bb56[4])
  ((*_1).14: u32) = BitOr(move _142, move _148)
  using: _1@Phi(bb37), _142@Mir(bb52[1]), _148@Mir(bb57[0])
  _171 = ((*_1).5: i32)
  using: _1@Phi(bb37)
  _172 = const 0_i32
  using: 
  _170 = Eq(move _171, move _172)
  using: _171@Mir(bb57[2]), _172@Mir(bb57[3])
  switchInt(move _170) -> [0: bb62, otherwise: bb58]
  using: _170@Mir(bb57[4])
bb58:
  _174 = const {alloc764: *mut [i32; 512]}
  using: 
  _176 = ((*_1).6: i32)
  using: _1@Phi(bb37)
  _175 = move _176 as usize (IntToInt)
  using: _176@Mir(bb58[1])
  _177 = const 512_usize
  using: 
  _178 = Lt(_175, _177)
  using: _175@Mir(bb58[2]), _177@Mir(bb58[3])
  assert(move _178, "index out of bounds: the length is {} but the index is {}", move _177, _175) -> bb59
  using: _178@Entry, _177@Entry, _175@Entry
bb59:
  _173 = (*_174)[_175]
  using: _174@Mir(bb58[0]), _175@Mir(bb58[2])
  ((*_1).5: i32) = move _173
  using: _1@Phi(bb37), _173@Mir(bb59[0])
  _179 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb37)
  assert(!move (_179.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb60
  using: _179@Entry, _1@Entry
bb60:
  ((*_1).6: i32) = move (_179.0: i32)
  using: _1@Phi(bb37), _179@Mir(bb59[2])
  _181 = ((*_1).6: i32)
  using: _1@Phi(bb37)
  _182 = const 512_i32
  using: 
  _180 = Eq(move _181, move _182)
  using: _181@Mir(bb60[1]), _182@Mir(bb60[2])
  switchInt(move _180) -> [0: bb62, otherwise: bb61]
  using: _180@Mir(bb60[3])
bb61:
  _183 = const 0_i32
  using: 
  ((*_1).6: i32) = move _183
  using: _1@Phi(bb37), _183@Mir(bb61[0])
  goto -> bb62
  using: 
bb62:
  _184 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb62)
  assert(!move (_184.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb63
  using: _184@Entry, _1@Entry
bb63:
  ((*_1).5: i32) = move (_184.0: i32)
  using: _1@Phi(bb62), _184@Mir(bb62[0])
  _187 = _2
  using: _2@Mir(bb51[0])
  _186 = move _187 as i32 (IntToInt)
  using: _187@Mir(bb63[1])
  _190 = ((*_1).5: i32)
  using: _1@Phi(bb62)
  _191 = const 1_i32
  using: 
  _189 = Eq(move _190, move _191)
  using: _190@Mir(bb63[3]), _191@Mir(bb63[4])
  switchInt(move _189) -> [0: bb65, otherwise: bb64]
  using: _189@Mir(bb63[5])
bb64:
  _188 = const 1_i32
  using: 
  goto -> bb66
  using: 
bb65:
  _188 = const 0_i32
  using: 
  goto -> bb66
  using: 
bb66:
  _185 = BitXor(move _186, move _188)
  using: _186@Mir(bb63[2]), _188@Phi(bb66)
  _2 = move _185 as u8 (IntToInt)
  using: _185@Mir(bb66[0])
  _192 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb62)
  assert(!move (_192.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb67
  using: _192@Entry, _1@Entry
bb67:
  ((*_1).17: i32) = move (_192.0: i32)
  using: _1@Phi(bb62), _192@Mir(bb66[2])
  _194 = ((*_1).17: i32)
  using: _1@Phi(bb62)
  _196 = ((*_1).51: i32)
  using: _1@Phi(bb62)
  _197 = const 1_i32
  using: 
  _198 = CheckedAdd(_196, _197)
  using: _196@Mir(bb67[2]), _197@Mir(bb67[3])
  assert(!move (_198.1: bool), "attempt to compute `{} + {}`, which would overflow", move _196, move _197) -> bb68
  using: _198@Entry, _196@Entry, _197@Entry
bb68:
  _195 = move (_198.0: i32)
  using: _198@Mir(bb67[4])
  _193 = Eq(move _194, move _195)
  using: _194@Mir(bb67[1]), _195@Mir(bb68[0])
  switchInt(move _193) -> [0: bb69, otherwise: bb1]
  using: _193@Mir(bb68[1])
bb69:
  _201 = _2
  using: _2@Mir(bb66[1])
  _200 = move _201 as i32 (IntToInt)
  using: _201@Mir(bb69[0])
  _202 = ((*_1).15: i32)
  using: _1@Phi(bb62)
  _199 = Ne(move _200, move _202)
  using: _200@Mir(bb69[1]), _202@Mir(bb69[2])
  switchInt(move _199) -> [0: bb71, otherwise: bb70]
  using: _199@Mir(bb69[3])
bb70:
  _203 = _2
  using: _2@Mir(bb66[1])
  ((*_1).15: i32) = move _203 as i32 (IntToInt)
  using: _1@Phi(bb62), _203@Mir(bb70[0])
  goto -> bb1
  using: 
bb71:
  _204 = const 3_i32
  using: 
  ((*_1).3: i32) = move _204
  using: _1@Phi(bb62), _204@Mir(bb71[0])
  _206 = ((*_1).14: u32)
  using: _1@Phi(bb62)
  _208 = const 100000_u32
  using: 
  _210 = ((*_1).9: i32)
  using: _1@Phi(bb62)
  _209 = move _210 as u32 (IntToInt)
  using: _210@Mir(bb71[4])
  _207 = core::num::<impl u32>::wrapping_mul(move _208, move _209) -> bb72
  using: _208@Mir(bb71[3]), _209@Mir(bb71[5])
bb72:
  _205 = Ge(move _206, move _207)
  using: _206@Mir(bb71[2]), _207@Mir(bb71[6])
  switchInt(move _205) -> [0: bb74, otherwise: bb73]
  using: _205@Mir(bb72[0])
bb73:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb74:
  _213 = ((*_1).14: u32)
  using: _1@Phi(bb62)
  _212 = move _213 as i32 (IntToInt)
  using: _213@Mir(bb74[0])
  _216 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb62)
  _215 = move _216 as &mut [i32] (Pointer(Unsize))
  using: _216@Mir(bb74[2])
  _214 = core::slice::<impl [i32]>::as_mut_ptr(move _215) -> bb75
  using: _215@Mir(bb74[3])
bb75:
  _211 = bzlib::BZ2_indexIntoF(move _212, move _214) -> bb76
  using: _212@Mir(bb74[1]), _214@Mir(bb74[4])
bb76:
  _2 = move _211 as u8 (IntToInt)
  using: _211@Mir(bb75[0])
  _220 = ((*_1).21: *mut u16)
  using: _1@Phi(bb62)
  _222 = ((*_1).14: u32)
  using: _1@Phi(bb62)
  _221 = move _222 as isize (IntToInt)
  using: _222@Mir(bb76[2])
  _219 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _220, move _221) -> bb77
  using: _220@Mir(bb76[1]), _221@Mir(bb76[3])
bb77:
  _218 = (*_219)
  using: _219@Mir(bb76[4])
  _217 = move _218 as u32 (IntToInt)
  using: _218@Mir(bb77[0])
  _229 = ((*_1).22: *mut u8)
  using: _1@Phi(bb62)
  _232 = ((*_1).14: u32)
  using: _1@Phi(bb62)
  _233 = const 1_i32
  using: 
  _234 = CheckedShr(_232, _233)
  using: _232@Mir(bb77[3]), _233@Mir(bb77[4])
  assert(!move (_234.1: bool), "attempt to shift right by `{}`, which would overflow", move _233) -> bb78
  using: _234@Entry, _232@Entry, _233@Entry
bb78:
  _231 = move (_234.0: u32)
  using: _234@Mir(bb77[5])
  _230 = move _231 as isize (IntToInt)
  using: _231@Mir(bb78[0])
  _228 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _229, move _230) -> bb79
  using: _229@Mir(bb77[2]), _230@Mir(bb78[1])
bb79:
  _227 = (*_228)
  using: _228@Mir(bb78[2])
  _226 = move _227 as u32 (IntToInt)
  using: _227@Mir(bb79[0])
  _237 = ((*_1).14: u32)
  using: _1@Phi(bb62)
  _238 = const 2_i32
  using: 
  _239 = CheckedShl(_237, _238)
  using: _237@Mir(bb79[2]), _238@Mir(bb79[3])
  assert(!move (_239.1: bool), "attempt to shift left by `{}`, which would overflow", move _238) -> bb80
  using: _239@Entry, _237@Entry, _238@Entry
bb80:
  _236 = move (_239.0: u32)
  using: _239@Mir(bb79[4])
  _240 = const 4_u32
  using: 
  _235 = BitAnd(move _236, move _240)
  using: _236@Mir(bb80[0]), _240@Mir(bb80[1])
  _241 = CheckedShr(_226, _235)
  using: _226@Mir(bb79[1]), _235@Mir(bb80[2])
  assert(!move (_241.1: bool), "attempt to shift right by `{}`, which would overflow", move _235) -> bb81
  using: _241@Entry, _226@Entry, _235@Entry
bb81:
  _225 = move (_241.0: u32)
  using: _241@Mir(bb80[3])
  _242 = const 15_u32
  using: 
  _224 = BitAnd(move _225, move _242)
  using: _225@Mir(bb81[0]), _242@Mir(bb81[1])
  _243 = const 16_i32
  using: 
  _244 = CheckedShl(_224, _243)
  using: _224@Mir(bb81[2]), _243@Mir(bb81[3])
  assert(!move (_244.1: bool), "attempt to shift left by `{}`, which would overflow", move _243) -> bb82
  using: _244@Entry, _224@Entry, _243@Entry
bb82:
  _223 = move (_244.0: u32)
  using: _244@Mir(bb81[4])
  ((*_1).14: u32) = BitOr(move _217, move _223)
  using: _1@Phi(bb62), _217@Mir(bb77[1]), _223@Mir(bb82[0])
  _246 = ((*_1).5: i32)
  using: _1@Phi(bb62)
  _247 = const 0_i32
  using: 
  _245 = Eq(move _246, move _247)
  using: _246@Mir(bb82[2]), _247@Mir(bb82[3])
  switchInt(move _245) -> [0: bb87, otherwise: bb83]
  using: _245@Mir(bb82[4])
bb83:
  _249 = const {alloc764: *mut [i32; 512]}
  using: 
  _251 = ((*_1).6: i32)
  using: _1@Phi(bb62)
  _250 = move _251 as usize (IntToInt)
  using: _251@Mir(bb83[1])
  _252 = const 512_usize
  using: 
  _253 = Lt(_250, _252)
  using: _250@Mir(bb83[2]), _252@Mir(bb83[3])
  assert(move _253, "index out of bounds: the length is {} but the index is {}", move _252, _250) -> bb84
  using: _253@Entry, _252@Entry, _250@Entry
bb84:
  _248 = (*_249)[_250]
  using: _249@Mir(bb83[0]), _250@Mir(bb83[2])
  ((*_1).5: i32) = move _248
  using: _1@Phi(bb62), _248@Mir(bb84[0])
  _254 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb62)
  assert(!move (_254.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb85
  using: _254@Entry, _1@Entry
bb85:
  ((*_1).6: i32) = move (_254.0: i32)
  using: _1@Phi(bb62), _254@Mir(bb84[2])
  _256 = ((*_1).6: i32)
  using: _1@Phi(bb62)
  _257 = const 512_i32
  using: 
  _255 = Eq(move _256, move _257)
  using: _256@Mir(bb85[1]), _257@Mir(bb85[2])
  switchInt(move _255) -> [0: bb87, otherwise: bb86]
  using: _255@Mir(bb85[3])
bb86:
  _258 = const 0_i32
  using: 
  ((*_1).6: i32) = move _258
  using: _1@Phi(bb62), _258@Mir(bb86[0])
  goto -> bb87
  using: 
bb87:
  _259 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb87)
  assert(!move (_259.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb88
  using: _259@Entry, _1@Entry
bb88:
  ((*_1).5: i32) = move (_259.0: i32)
  using: _1@Phi(bb87), _259@Mir(bb87[0])
  _262 = _2
  using: _2@Mir(bb76[0])
  _261 = move _262 as i32 (IntToInt)
  using: _262@Mir(bb88[1])
  _265 = ((*_1).5: i32)
  using: _1@Phi(bb87)
  _266 = const 1_i32
  using: 
  _264 = Eq(move _265, move _266)
  using: _265@Mir(bb88[3]), _266@Mir(bb88[4])
  switchInt(move _264) -> [0: bb90, otherwise: bb89]
  using: _264@Mir(bb88[5])
bb89:
  _263 = const 1_i32
  using: 
  goto -> bb91
  using: 
bb90:
  _263 = const 0_i32
  using: 
  goto -> bb91
  using: 
bb91:
  _260 = BitXor(move _261, move _263)
  using: _261@Mir(bb88[2]), _263@Phi(bb91)
  _2 = move _260 as u8 (IntToInt)
  using: _260@Mir(bb91[0])
  _267 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb87)
  assert(!move (_267.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb92
  using: _267@Entry, _1@Entry
bb92:
  ((*_1).17: i32) = move (_267.0: i32)
  using: _1@Phi(bb87), _267@Mir(bb91[2])
  _269 = ((*_1).17: i32)
  using: _1@Phi(bb87)
  _271 = ((*_1).51: i32)
  using: _1@Phi(bb87)
  _272 = const 1_i32
  using: 
  _273 = CheckedAdd(_271, _272)
  using: _271@Mir(bb92[2]), _272@Mir(bb92[3])
  assert(!move (_273.1: bool), "attempt to compute `{} + {}`, which would overflow", move _271, move _272) -> bb93
  using: _273@Entry, _271@Entry, _272@Entry
bb93:
  _270 = move (_273.0: i32)
  using: _273@Mir(bb92[4])
  _268 = Eq(move _269, move _270)
  using: _269@Mir(bb92[1]), _270@Mir(bb93[0])
  switchInt(move _268) -> [0: bb94, otherwise: bb1]
  using: _268@Mir(bb93[1])
bb94:
  _276 = _2
  using: _2@Mir(bb91[1])
  _275 = move _276 as i32 (IntToInt)
  using: _276@Mir(bb94[0])
  _277 = ((*_1).15: i32)
  using: _1@Phi(bb87)
  _274 = Ne(move _275, move _277)
  using: _275@Mir(bb94[1]), _277@Mir(bb94[2])
  switchInt(move _274) -> [0: bb96, otherwise: bb95]
  using: _274@Mir(bb94[3])
bb95:
  _278 = _2
  using: _2@Mir(bb91[1])
  ((*_1).15: i32) = move _278 as i32 (IntToInt)
  using: _1@Phi(bb87), _278@Mir(bb95[0])
  goto -> bb1
  using: 
bb96:
  _280 = ((*_1).14: u32)
  using: _1@Phi(bb87)
  _282 = const 100000_u32
  using: 
  _284 = ((*_1).9: i32)
  using: _1@Phi(bb87)
  _283 = move _284 as u32 (IntToInt)
  using: _284@Mir(bb96[2])
  _281 = core::num::<impl u32>::wrapping_mul(move _282, move _283) -> bb97
  using: _282@Mir(bb96[1]), _283@Mir(bb96[3])
bb97:
  _279 = Ge(move _280, move _281)
  using: _280@Mir(bb96[0]), _281@Mir(bb96[4])
  switchInt(move _279) -> [0: bb99, otherwise: bb98]
  using: _279@Mir(bb97[0])
bb98:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb99:
  _287 = ((*_1).14: u32)
  using: _1@Phi(bb87)
  _286 = move _287 as i32 (IntToInt)
  using: _287@Mir(bb99[0])
  _290 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb87)
  _289 = move _290 as &mut [i32] (Pointer(Unsize))
  using: _290@Mir(bb99[2])
  _288 = core::slice::<impl [i32]>::as_mut_ptr(move _289) -> bb100
  using: _289@Mir(bb99[3])
bb100:
  _285 = bzlib::BZ2_indexIntoF(move _286, move _288) -> bb101
  using: _286@Mir(bb99[1]), _288@Mir(bb99[4])
bb101:
  _2 = move _285 as u8 (IntToInt)
  using: _285@Mir(bb100[0])
  _294 = ((*_1).21: *mut u16)
  using: _1@Phi(bb87)
  _296 = ((*_1).14: u32)
  using: _1@Phi(bb87)
  _295 = move _296 as isize (IntToInt)
  using: _296@Mir(bb101[2])
  _293 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _294, move _295) -> bb102
  using: _294@Mir(bb101[1]), _295@Mir(bb101[3])
bb102:
  _292 = (*_293)
  using: _293@Mir(bb101[4])
  _291 = move _292 as u32 (IntToInt)
  using: _292@Mir(bb102[0])
  _303 = ((*_1).22: *mut u8)
  using: _1@Phi(bb87)
  _306 = ((*_1).14: u32)
  using: _1@Phi(bb87)
  _307 = const 1_i32
  using: 
  _308 = CheckedShr(_306, _307)
  using: _306@Mir(bb102[3]), _307@Mir(bb102[4])
  assert(!move (_308.1: bool), "attempt to shift right by `{}`, which would overflow", move _307) -> bb103
  using: _308@Entry, _306@Entry, _307@Entry
bb103:
  _305 = move (_308.0: u32)
  using: _308@Mir(bb102[5])
  _304 = move _305 as isize (IntToInt)
  using: _305@Mir(bb103[0])
  _302 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _303, move _304) -> bb104
  using: _303@Mir(bb102[2]), _304@Mir(bb103[1])
bb104:
  _301 = (*_302)
  using: _302@Mir(bb103[2])
  _300 = move _301 as u32 (IntToInt)
  using: _301@Mir(bb104[0])
  _311 = ((*_1).14: u32)
  using: _1@Phi(bb87)
  _312 = const 2_i32
  using: 
  _313 = CheckedShl(_311, _312)
  using: _311@Mir(bb104[2]), _312@Mir(bb104[3])
  assert(!move (_313.1: bool), "attempt to shift left by `{}`, which would overflow", move _312) -> bb105
  using: _313@Entry, _311@Entry, _312@Entry
bb105:
  _310 = move (_313.0: u32)
  using: _313@Mir(bb104[4])
  _314 = const 4_u32
  using: 
  _309 = BitAnd(move _310, move _314)
  using: _310@Mir(bb105[0]), _314@Mir(bb105[1])
  _315 = CheckedShr(_300, _309)
  using: _300@Mir(bb104[1]), _309@Mir(bb105[2])
  assert(!move (_315.1: bool), "attempt to shift right by `{}`, which would overflow", move _309) -> bb106
  using: _315@Entry, _300@Entry, _309@Entry
bb106:
  _299 = move (_315.0: u32)
  using: _315@Mir(bb105[3])
  _316 = const 15_u32
  using: 
  _298 = BitAnd(move _299, move _316)
  using: _299@Mir(bb106[0]), _316@Mir(bb106[1])
  _317 = const 16_i32
  using: 
  _318 = CheckedShl(_298, _317)
  using: _298@Mir(bb106[2]), _317@Mir(bb106[3])
  assert(!move (_318.1: bool), "attempt to shift left by `{}`, which would overflow", move _317) -> bb107
  using: _318@Entry, _298@Entry, _317@Entry
bb107:
  _297 = move (_318.0: u32)
  using: _318@Mir(bb106[4])
  ((*_1).14: u32) = BitOr(move _291, move _297)
  using: _1@Phi(bb87), _291@Mir(bb102[1]), _297@Mir(bb107[0])
  _320 = ((*_1).5: i32)
  using: _1@Phi(bb87)
  _321 = const 0_i32
  using: 
  _319 = Eq(move _320, move _321)
  using: _320@Mir(bb107[2]), _321@Mir(bb107[3])
  switchInt(move _319) -> [0: bb112, otherwise: bb108]
  using: _319@Mir(bb107[4])
bb108:
  _323 = const {alloc764: *mut [i32; 512]}
  using: 
  _325 = ((*_1).6: i32)
  using: _1@Phi(bb87)
  _324 = move _325 as usize (IntToInt)
  using: _325@Mir(bb108[1])
  _326 = const 512_usize
  using: 
  _327 = Lt(_324, _326)
  using: _324@Mir(bb108[2]), _326@Mir(bb108[3])
  assert(move _327, "index out of bounds: the length is {} but the index is {}", move _326, _324) -> bb109
  using: _327@Entry, _326@Entry, _324@Entry
bb109:
  _322 = (*_323)[_324]
  using: _323@Mir(bb108[0]), _324@Mir(bb108[2])
  ((*_1).5: i32) = move _322
  using: _1@Phi(bb87), _322@Mir(bb109[0])
  _328 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb87)
  assert(!move (_328.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb110
  using: _328@Entry, _1@Entry
bb110:
  ((*_1).6: i32) = move (_328.0: i32)
  using: _1@Phi(bb87), _328@Mir(bb109[2])
  _330 = ((*_1).6: i32)
  using: _1@Phi(bb87)
  _331 = const 512_i32
  using: 
  _329 = Eq(move _330, move _331)
  using: _330@Mir(bb110[1]), _331@Mir(bb110[2])
  switchInt(move _329) -> [0: bb112, otherwise: bb111]
  using: _329@Mir(bb110[3])
bb111:
  _332 = const 0_i32
  using: 
  ((*_1).6: i32) = move _332
  using: _1@Phi(bb87), _332@Mir(bb111[0])
  goto -> bb112
  using: 
bb112:
  _333 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb112)
  assert(!move (_333.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb113
  using: _333@Entry, _1@Entry
bb113:
  ((*_1).5: i32) = move (_333.0: i32)
  using: _1@Phi(bb112), _333@Mir(bb112[0])
  _336 = _2
  using: _2@Mir(bb101[0])
  _335 = move _336 as i32 (IntToInt)
  using: _336@Mir(bb113[1])
  _339 = ((*_1).5: i32)
  using: _1@Phi(bb112)
  _340 = const 1_i32
  using: 
  _338 = Eq(move _339, move _340)
  using: _339@Mir(bb113[3]), _340@Mir(bb113[4])
  switchInt(move _338) -> [0: bb115, otherwise: bb114]
  using: _338@Mir(bb113[5])
bb114:
  _337 = const 1_i32
  using: 
  goto -> bb116
  using: 
bb115:
  _337 = const 0_i32
  using: 
  goto -> bb116
  using: 
bb116:
  _334 = BitXor(move _335, move _337)
  using: _335@Mir(bb113[2]), _337@Phi(bb116)
  _2 = move _334 as u8 (IntToInt)
  using: _334@Mir(bb116[0])
  _341 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb112)
  assert(!move (_341.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb117
  using: _341@Entry, _1@Entry
bb117:
  ((*_1).17: i32) = move (_341.0: i32)
  using: _1@Phi(bb112), _341@Mir(bb116[2])
  _343 = _2
  using: _2@Mir(bb116[1])
  _342 = move _343 as i32 (IntToInt)
  using: _343@Mir(bb117[1])
  _344 = const 4_i32
  using: 
  _345 = CheckedAdd(_342, _344)
  using: _342@Mir(bb117[2]), _344@Mir(bb117[3])
  assert(!move (_345.1: bool), "attempt to compute `{} + {}`, which would overflow", move _342, move _344) -> bb118
  using: _345@Entry, _342@Entry, _344@Entry
bb118:
  ((*_1).3: i32) = move (_345.0: i32)
  using: _1@Phi(bb112), _345@Mir(bb117[4])
  _347 = ((*_1).14: u32)
  using: _1@Phi(bb112)
  _349 = const 100000_u32
  using: 
  _351 = ((*_1).9: i32)
  using: _1@Phi(bb112)
  _350 = move _351 as u32 (IntToInt)
  using: _351@Mir(bb118[3])
  _348 = core::num::<impl u32>::wrapping_mul(move _349, move _350) -> bb119
  using: _349@Mir(bb118[2]), _350@Mir(bb118[4])
bb119:
  _346 = Ge(move _347, move _348)
  using: _347@Mir(bb118[1]), _348@Mir(bb118[5])
  switchInt(move _346) -> [0: bb121, otherwise: bb120]
  using: _346@Mir(bb119[0])
bb120:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb121:
  _354 = ((*_1).14: u32)
  using: _1@Phi(bb112)
  _353 = move _354 as i32 (IntToInt)
  using: _354@Mir(bb121[0])
  _357 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb112)
  _356 = move _357 as &mut [i32] (Pointer(Unsize))
  using: _357@Mir(bb121[2])
  _355 = core::slice::<impl [i32]>::as_mut_ptr(move _356) -> bb122
  using: _356@Mir(bb121[3])
bb122:
  _352 = bzlib::BZ2_indexIntoF(move _353, move _355) -> bb123
  using: _353@Mir(bb121[1]), _355@Mir(bb121[4])
bb123:
  ((*_1).15: i32) = move _352
  using: _1@Phi(bb112), _352@Mir(bb122[0])
  _361 = ((*_1).21: *mut u16)
  using: _1@Phi(bb112)
  _363 = ((*_1).14: u32)
  using: _1@Phi(bb112)
  _362 = move _363 as isize (IntToInt)
  using: _363@Mir(bb123[2])
  _360 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _361, move _362) -> bb124
  using: _361@Mir(bb123[1]), _362@Mir(bb123[3])
bb124:
  _359 = (*_360)
  using: _360@Mir(bb123[4])
  _358 = move _359 as u32 (IntToInt)
  using: _359@Mir(bb124[0])
  _370 = ((*_1).22: *mut u8)
  using: _1@Phi(bb112)
  _373 = ((*_1).14: u32)
  using: _1@Phi(bb112)
  _374 = const 1_i32
  using: 
  _375 = CheckedShr(_373, _374)
  using: _373@Mir(bb124[3]), _374@Mir(bb124[4])
  assert(!move (_375.1: bool), "attempt to shift right by `{}`, which would overflow", move _374) -> bb125
  using: _375@Entry, _373@Entry, _374@Entry
bb125:
  _372 = move (_375.0: u32)
  using: _375@Mir(bb124[5])
  _371 = move _372 as isize (IntToInt)
  using: _372@Mir(bb125[0])
  _369 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _370, move _371) -> bb126
  using: _370@Mir(bb124[2]), _371@Mir(bb125[1])
bb126:
  _368 = (*_369)
  using: _369@Mir(bb125[2])
  _367 = move _368 as u32 (IntToInt)
  using: _368@Mir(bb126[0])
  _378 = ((*_1).14: u32)
  using: _1@Phi(bb112)
  _379 = const 2_i32
  using: 
  _380 = CheckedShl(_378, _379)
  using: _378@Mir(bb126[2]), _379@Mir(bb126[3])
  assert(!move (_380.1: bool), "attempt to shift left by `{}`, which would overflow", move _379) -> bb127
  using: _380@Entry, _378@Entry, _379@Entry
bb127:
  _377 = move (_380.0: u32)
  using: _380@Mir(bb126[4])
  _381 = const 4_u32
  using: 
  _376 = BitAnd(move _377, move _381)
  using: _377@Mir(bb127[0]), _381@Mir(bb127[1])
  _382 = CheckedShr(_367, _376)
  using: _367@Mir(bb126[1]), _376@Mir(bb127[2])
  assert(!move (_382.1: bool), "attempt to shift right by `{}`, which would overflow", move _376) -> bb128
  using: _382@Entry, _367@Entry, _376@Entry
bb128:
  _366 = move (_382.0: u32)
  using: _382@Mir(bb127[3])
  _383 = const 15_u32
  using: 
  _365 = BitAnd(move _366, move _383)
  using: _366@Mir(bb128[0]), _383@Mir(bb128[1])
  _384 = const 16_i32
  using: 
  _385 = CheckedShl(_365, _384)
  using: _365@Mir(bb128[2]), _384@Mir(bb128[3])
  assert(!move (_385.1: bool), "attempt to shift left by `{}`, which would overflow", move _384) -> bb129
  using: _385@Entry, _365@Entry, _384@Entry
bb129:
  _364 = move (_385.0: u32)
  using: _385@Mir(bb128[4])
  ((*_1).14: u32) = BitOr(move _358, move _364)
  using: _1@Phi(bb112), _358@Mir(bb124[1]), _364@Mir(bb129[0])
  _387 = ((*_1).5: i32)
  using: _1@Phi(bb112)
  _388 = const 0_i32
  using: 
  _386 = Eq(move _387, move _388)
  using: _387@Mir(bb129[2]), _388@Mir(bb129[3])
  switchInt(move _386) -> [0: bb134, otherwise: bb130]
  using: _386@Mir(bb129[4])
bb130:
  _390 = const {alloc764: *mut [i32; 512]}
  using: 
  _392 = ((*_1).6: i32)
  using: _1@Phi(bb112)
  _391 = move _392 as usize (IntToInt)
  using: _392@Mir(bb130[1])
  _393 = const 512_usize
  using: 
  _394 = Lt(_391, _393)
  using: _391@Mir(bb130[2]), _393@Mir(bb130[3])
  assert(move _394, "index out of bounds: the length is {} but the index is {}", move _393, _391) -> bb131
  using: _394@Entry, _393@Entry, _391@Entry
bb131:
  _389 = (*_390)[_391]
  using: _390@Mir(bb130[0]), _391@Mir(bb130[2])
  ((*_1).5: i32) = move _389
  using: _1@Phi(bb112), _389@Mir(bb131[0])
  _395 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb112)
  assert(!move (_395.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb132
  using: _395@Entry, _1@Entry
bb132:
  ((*_1).6: i32) = move (_395.0: i32)
  using: _1@Phi(bb112), _395@Mir(bb131[2])
  _397 = ((*_1).6: i32)
  using: _1@Phi(bb112)
  _398 = const 512_i32
  using: 
  _396 = Eq(move _397, move _398)
  using: _397@Mir(bb132[1]), _398@Mir(bb132[2])
  switchInt(move _396) -> [0: bb134, otherwise: bb133]
  using: _396@Mir(bb132[3])
bb133:
  _399 = const 0_i32
  using: 
  ((*_1).6: i32) = move _399
  using: _1@Phi(bb112), _399@Mir(bb133[0])
  goto -> bb134
  using: 
bb134:
  _400 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb134)
  assert(!move (_400.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb135
  using: _400@Entry, _1@Entry
bb135:
  ((*_1).5: i32) = move (_400.0: i32)
  using: _1@Phi(bb134), _400@Mir(bb134[0])
  _403 = ((*_1).5: i32)
  using: _1@Phi(bb134)
  _404 = const 1_i32
  using: 
  _402 = Eq(move _403, move _404)
  using: _403@Mir(bb135[1]), _404@Mir(bb135[2])
  switchInt(move _402) -> [0: bb137, otherwise: bb136]
  using: _402@Mir(bb135[3])
bb136:
  _401 = const 1_i32
  using: 
  goto -> bb138
  using: 
bb137:
  _401 = const 0_i32
  using: 
  goto -> bb138
  using: 
bb138:
  ((*_1).15: i32) = BitXor(((*_1).15: i32), move _401)
  using: _1@Phi(bb134), _1@Phi(bb134), _401@Phi(bb138)
  _405 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb134)
  assert(!move (_405.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb139
  using: _405@Entry, _1@Entry
bb139:
  ((*_1).17: i32) = move (_405.0: i32)
  using: _1@Phi(bb134), _405@Mir(bb138[1])
  goto -> bb1
  using: 
bb140:
  goto -> bb141
  using: 
bb141:
  _712 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  _407 = ((*_712).5: u32)
  using: _712@Mir(bb141[0])
  _408 = const 0_u32
  using: 
  _406 = Eq(move _407, move _408)
  using: _407@Mir(bb141[1]), _408@Mir(bb141[2])
  switchInt(move _406) -> [0: bb143, otherwise: bb142]
  using: _406@Mir(bb141[3])
bb142:
  _0 = const 0_u8
  using: 
  goto -> bb234
  using: 
bb143:
  _410 = ((*_1).3: i32)
  using: _1@Phi(bb141)
  _411 = const 0_i32
  using: 
  _409 = Eq(move _410, move _411)
  using: _410@Mir(bb143[0]), _411@Mir(bb143[1])
  switchInt(move _409) -> [0: bb144, otherwise: bb154]
  using: _409@Mir(bb143[2])
bb144:
  _412 = ((*_1).2: u8)
  using: _1@Phi(bb141)
  _713 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  _414 = ((*_713).4: *mut i8)
  using: _713@Mir(bb144[1])
  _413 = move _414 as *mut u8 (PtrToPtr)
  using: _414@Mir(bb144[2])
  (*_413) = move _412
  using: _413@Mir(bb144[3]), _412@Mir(bb144[0])
  _416 = ((*_1).25: u32)
  using: _1@Phi(bb141)
  _417 = const 8_i32
  using: 
  _418 = CheckedShl(_416, _417)
  using: _416@Mir(bb144[5]), _417@Mir(bb144[6])
  assert(!move (_418.1: bool), "attempt to shift left by `{}`, which would overflow", move _417) -> bb145
  using: _418@Entry, _416@Entry, _417@Entry
bb145:
  _415 = move (_418.0: u32)
  using: _418@Mir(bb144[7])
  _420 = const {alloc723: *mut [u32; 256]}
  using: 
  _424 = ((*_1).25: u32)
  using: _1@Phi(bb141)
  _425 = const 24_i32
  using: 
  _426 = CheckedShr(_424, _425)
  using: _424@Mir(bb145[2]), _425@Mir(bb145[3])
  assert(!move (_426.1: bool), "attempt to shift right by `{}`, which would overflow", move _425) -> bb146
  using: _426@Entry, _424@Entry, _425@Entry
bb146:
  _423 = move (_426.0: u32)
  using: _426@Mir(bb145[4])
  _428 = ((*_1).2: u8)
  using: _1@Phi(bb141)
  _427 = move _428 as u32 (IntToInt)
  using: _428@Mir(bb146[1])
  _422 = BitXor(move _423, move _427)
  using: _423@Mir(bb146[0]), _427@Mir(bb146[2])
  _421 = move _422 as usize (IntToInt)
  using: _422@Mir(bb146[3])
  _429 = const 256_usize
  using: 
  _430 = Lt(_421, _429)
  using: _421@Mir(bb146[4]), _429@Mir(bb146[5])
  assert(move _430, "index out of bounds: the length is {} but the index is {}", move _429, _421) -> bb147
  using: _430@Entry, _429@Entry, _421@Entry
bb147:
  _419 = (*_420)[_421]
  using: _420@Mir(bb145[1]), _421@Mir(bb146[4])
  ((*_1).25: u32) = BitXor(move _415, move _419)
  using: _1@Phi(bb141), _415@Mir(bb145[0]), _419@Mir(bb147[0])
  _431 = CheckedSub(((*_1).3: i32), const 1_i32)
  using: _1@Phi(bb141)
  assert(!move (_431.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).3: i32), const 1_i32) -> bb148
  using: _431@Entry, _1@Entry
bb148:
  ((*_1).3: i32) = move (_431.0: i32)
  using: _1@Phi(bb141), _431@Mir(bb147[2])
  _714 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  _433 = ((*_714).4: *mut i8)
  using: _714@Mir(bb148[1])
  _432 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _433, const 1_isize) -> bb149
  using: _433@Mir(bb148[2])
bb149:
  _715 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  ((*_715).4: *mut i8) = move _432
  using: _715@Mir(bb149[0]), _432@Mir(bb148[3])
  _716 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  _435 = ((*_716).5: u32)
  using: _716@Mir(bb149[2])
  _434 = core::num::<impl u32>::wrapping_sub(move _435, const 1_u32) -> bb150
  using: _435@Mir(bb149[3])
bb150:
  _717 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  ((*_717).5: u32) = move _434
  using: _717@Mir(bb150[0]), _434@Mir(bb149[4])
  _718 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  _437 = ((*_718).6: u32)
  using: _718@Mir(bb150[2])
  _436 = core::num::<impl u32>::wrapping_add(move _437, const 1_u32) -> bb151
  using: _437@Mir(bb150[3])
bb151:
  _719 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  ((*_719).6: u32) = move _436
  using: _719@Mir(bb151[0]), _436@Mir(bb150[4])
  _720 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  _439 = ((*_720).6: u32)
  using: _720@Mir(bb151[2])
  _440 = const 0_u32
  using: 
  _438 = Eq(move _439, move _440)
  using: _439@Mir(bb151[3]), _440@Mir(bb151[4])
  switchInt(move _438) -> [0: bb141, otherwise: bb152]
  using: _438@Mir(bb151[5])
bb152:
  _721 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  _442 = ((*_721).7: u32)
  using: _721@Mir(bb152[0])
  _441 = core::num::<impl u32>::wrapping_add(move _442, const 1_u32) -> bb153
  using: _442@Mir(bb152[1])
bb153:
  _722 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb141)
  ((*_722).7: u32) = move _441
  using: _722@Mir(bb153[0]), _441@Mir(bb152[2])
  goto -> bb141
  using: 
bb154:
  _444 = ((*_1).17: i32)
  using: _1@Phi(bb141)
  _446 = ((*_1).51: i32)
  using: _1@Phi(bb141)
  _447 = const 1_i32
  using: 
  _448 = CheckedAdd(_446, _447)
  using: _446@Mir(bb154[1]), _447@Mir(bb154[2])
  assert(!move (_448.1: bool), "attempt to compute `{} + {}`, which would overflow", move _446, move _447) -> bb155
  using: _448@Entry, _446@Entry, _447@Entry
bb155:
  _445 = move (_448.0: i32)
  using: _448@Mir(bb154[3])
  _443 = Eq(move _444, move _445)
  using: _444@Mir(bb154[0]), _445@Mir(bb155[0])
  switchInt(move _443) -> [0: bb157, otherwise: bb156]
  using: _443@Mir(bb155[1])
bb156:
  _0 = const 0_u8
  using: 
  goto -> bb234
  using: 
bb157:
  _450 = ((*_1).17: i32)
  using: _1@Phi(bb141)
  _452 = ((*_1).51: i32)
  using: _1@Phi(bb141)
  _453 = const 1_i32
  using: 
  _454 = CheckedAdd(_452, _453)
  using: _452@Mir(bb157[1]), _453@Mir(bb157[2])
  assert(!move (_454.1: bool), "attempt to compute `{} + {}`, which would overflow", move _452, move _453) -> bb158
  using: _454@Entry, _452@Entry, _453@Entry
bb158:
  _451 = move (_454.0: i32)
  using: _454@Mir(bb157[3])
  _449 = Gt(move _450, move _451)
  using: _450@Mir(bb157[0]), _451@Mir(bb158[0])
  switchInt(move _449) -> [0: bb160, otherwise: bb159]
  using: _449@Mir(bb158[1])
bb159:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb160:
  _455 = const 1_i32
  using: 
  ((*_1).3: i32) = move _455
  using: _1@Phi(bb141), _455@Mir(bb160[0])
  _456 = ((*_1).15: i32)
  using: _1@Phi(bb141)
  ((*_1).2: u8) = move _456 as u8 (IntToInt)
  using: _1@Phi(bb141), _456@Mir(bb160[2])
  _458 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _460 = const 100000_u32
  using: 
  _462 = ((*_1).9: i32)
  using: _1@Phi(bb141)
  _461 = move _462 as u32 (IntToInt)
  using: _462@Mir(bb160[6])
  _459 = core::num::<impl u32>::wrapping_mul(move _460, move _461) -> bb161
  using: _460@Mir(bb160[5]), _461@Mir(bb160[7])
bb161:
  _457 = Ge(move _458, move _459)
  using: _458@Mir(bb160[4]), _459@Mir(bb160[8])
  switchInt(move _457) -> [0: bb163, otherwise: bb162]
  using: _457@Mir(bb161[0])
bb162:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb163:
  _465 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _464 = move _465 as i32 (IntToInt)
  using: _465@Mir(bb163[0])
  _468 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb141)
  _467 = move _468 as &mut [i32] (Pointer(Unsize))
  using: _468@Mir(bb163[2])
  _466 = core::slice::<impl [i32]>::as_mut_ptr(move _467) -> bb164
  using: _467@Mir(bb163[3])
bb164:
  _463 = bzlib::BZ2_indexIntoF(move _464, move _466) -> bb165
  using: _464@Mir(bb163[1]), _466@Mir(bb163[4])
bb165:
  _2 = move _463 as u8 (IntToInt)
  using: _463@Mir(bb164[0])
  _472 = ((*_1).21: *mut u16)
  using: _1@Phi(bb141)
  _474 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _473 = move _474 as isize (IntToInt)
  using: _474@Mir(bb165[2])
  _471 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _472, move _473) -> bb166
  using: _472@Mir(bb165[1]), _473@Mir(bb165[3])
bb166:
  _470 = (*_471)
  using: _471@Mir(bb165[4])
  _469 = move _470 as u32 (IntToInt)
  using: _470@Mir(bb166[0])
  _481 = ((*_1).22: *mut u8)
  using: _1@Phi(bb141)
  _484 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _485 = const 1_i32
  using: 
  _486 = CheckedShr(_484, _485)
  using: _484@Mir(bb166[3]), _485@Mir(bb166[4])
  assert(!move (_486.1: bool), "attempt to shift right by `{}`, which would overflow", move _485) -> bb167
  using: _486@Entry, _484@Entry, _485@Entry
bb167:
  _483 = move (_486.0: u32)
  using: _486@Mir(bb166[5])
  _482 = move _483 as isize (IntToInt)
  using: _483@Mir(bb167[0])
  _480 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _481, move _482) -> bb168
  using: _481@Mir(bb166[2]), _482@Mir(bb167[1])
bb168:
  _479 = (*_480)
  using: _480@Mir(bb167[2])
  _478 = move _479 as u32 (IntToInt)
  using: _479@Mir(bb168[0])
  _489 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _490 = const 2_i32
  using: 
  _491 = CheckedShl(_489, _490)
  using: _489@Mir(bb168[2]), _490@Mir(bb168[3])
  assert(!move (_491.1: bool), "attempt to shift left by `{}`, which would overflow", move _490) -> bb169
  using: _491@Entry, _489@Entry, _490@Entry
bb169:
  _488 = move (_491.0: u32)
  using: _491@Mir(bb168[4])
  _492 = const 4_u32
  using: 
  _487 = BitAnd(move _488, move _492)
  using: _488@Mir(bb169[0]), _492@Mir(bb169[1])
  _493 = CheckedShr(_478, _487)
  using: _478@Mir(bb168[1]), _487@Mir(bb169[2])
  assert(!move (_493.1: bool), "attempt to shift right by `{}`, which would overflow", move _487) -> bb170
  using: _493@Entry, _478@Entry, _487@Entry
bb170:
  _477 = move (_493.0: u32)
  using: _493@Mir(bb169[3])
  _494 = const 15_u32
  using: 
  _476 = BitAnd(move _477, move _494)
  using: _477@Mir(bb170[0]), _494@Mir(bb170[1])
  _495 = const 16_i32
  using: 
  _496 = CheckedShl(_476, _495)
  using: _476@Mir(bb170[2]), _495@Mir(bb170[3])
  assert(!move (_496.1: bool), "attempt to shift left by `{}`, which would overflow", move _495) -> bb171
  using: _496@Entry, _476@Entry, _495@Entry
bb171:
  _475 = move (_496.0: u32)
  using: _496@Mir(bb170[4])
  ((*_1).14: u32) = BitOr(move _469, move _475)
  using: _1@Phi(bb141), _469@Mir(bb166[1]), _475@Mir(bb171[0])
  _497 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb141)
  assert(!move (_497.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb172
  using: _497@Entry, _1@Entry
bb172:
  ((*_1).17: i32) = move (_497.0: i32)
  using: _1@Phi(bb141), _497@Mir(bb171[2])
  _499 = ((*_1).17: i32)
  using: _1@Phi(bb141)
  _501 = ((*_1).51: i32)
  using: _1@Phi(bb141)
  _502 = const 1_i32
  using: 
  _503 = CheckedAdd(_501, _502)
  using: _501@Mir(bb172[2]), _502@Mir(bb172[3])
  assert(!move (_503.1: bool), "attempt to compute `{} + {}`, which would overflow", move _501, move _502) -> bb173
  using: _503@Entry, _501@Entry, _502@Entry
bb173:
  _500 = move (_503.0: i32)
  using: _503@Mir(bb172[4])
  _498 = Eq(move _499, move _500)
  using: _499@Mir(bb172[1]), _500@Mir(bb173[0])
  switchInt(move _498) -> [0: bb174, otherwise: bb140]
  using: _498@Mir(bb173[1])
bb174:
  _506 = _2
  using: _2@Mir(bb165[0])
  _505 = move _506 as i32 (IntToInt)
  using: _506@Mir(bb174[0])
  _507 = ((*_1).15: i32)
  using: _1@Phi(bb141)
  _504 = Ne(move _505, move _507)
  using: _505@Mir(bb174[1]), _507@Mir(bb174[2])
  switchInt(move _504) -> [0: bb176, otherwise: bb175]
  using: _504@Mir(bb174[3])
bb175:
  _508 = _2
  using: _2@Mir(bb165[0])
  ((*_1).15: i32) = move _508 as i32 (IntToInt)
  using: _1@Phi(bb141), _508@Mir(bb175[0])
  goto -> bb140
  using: 
bb176:
  _509 = const 2_i32
  using: 
  ((*_1).3: i32) = move _509
  using: _1@Phi(bb141), _509@Mir(bb176[0])
  _511 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _513 = const 100000_u32
  using: 
  _515 = ((*_1).9: i32)
  using: _1@Phi(bb141)
  _514 = move _515 as u32 (IntToInt)
  using: _515@Mir(bb176[4])
  _512 = core::num::<impl u32>::wrapping_mul(move _513, move _514) -> bb177
  using: _513@Mir(bb176[3]), _514@Mir(bb176[5])
bb177:
  _510 = Ge(move _511, move _512)
  using: _511@Mir(bb176[2]), _512@Mir(bb176[6])
  switchInt(move _510) -> [0: bb179, otherwise: bb178]
  using: _510@Mir(bb177[0])
bb178:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb179:
  _518 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _517 = move _518 as i32 (IntToInt)
  using: _518@Mir(bb179[0])
  _521 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb141)
  _520 = move _521 as &mut [i32] (Pointer(Unsize))
  using: _521@Mir(bb179[2])
  _519 = core::slice::<impl [i32]>::as_mut_ptr(move _520) -> bb180
  using: _520@Mir(bb179[3])
bb180:
  _516 = bzlib::BZ2_indexIntoF(move _517, move _519) -> bb181
  using: _517@Mir(bb179[1]), _519@Mir(bb179[4])
bb181:
  _2 = move _516 as u8 (IntToInt)
  using: _516@Mir(bb180[0])
  _525 = ((*_1).21: *mut u16)
  using: _1@Phi(bb141)
  _527 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _526 = move _527 as isize (IntToInt)
  using: _527@Mir(bb181[2])
  _524 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _525, move _526) -> bb182
  using: _525@Mir(bb181[1]), _526@Mir(bb181[3])
bb182:
  _523 = (*_524)
  using: _524@Mir(bb181[4])
  _522 = move _523 as u32 (IntToInt)
  using: _523@Mir(bb182[0])
  _534 = ((*_1).22: *mut u8)
  using: _1@Phi(bb141)
  _537 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _538 = const 1_i32
  using: 
  _539 = CheckedShr(_537, _538)
  using: _537@Mir(bb182[3]), _538@Mir(bb182[4])
  assert(!move (_539.1: bool), "attempt to shift right by `{}`, which would overflow", move _538) -> bb183
  using: _539@Entry, _537@Entry, _538@Entry
bb183:
  _536 = move (_539.0: u32)
  using: _539@Mir(bb182[5])
  _535 = move _536 as isize (IntToInt)
  using: _536@Mir(bb183[0])
  _533 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _534, move _535) -> bb184
  using: _534@Mir(bb182[2]), _535@Mir(bb183[1])
bb184:
  _532 = (*_533)
  using: _533@Mir(bb183[2])
  _531 = move _532 as u32 (IntToInt)
  using: _532@Mir(bb184[0])
  _542 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _543 = const 2_i32
  using: 
  _544 = CheckedShl(_542, _543)
  using: _542@Mir(bb184[2]), _543@Mir(bb184[3])
  assert(!move (_544.1: bool), "attempt to shift left by `{}`, which would overflow", move _543) -> bb185
  using: _544@Entry, _542@Entry, _543@Entry
bb185:
  _541 = move (_544.0: u32)
  using: _544@Mir(bb184[4])
  _545 = const 4_u32
  using: 
  _540 = BitAnd(move _541, move _545)
  using: _541@Mir(bb185[0]), _545@Mir(bb185[1])
  _546 = CheckedShr(_531, _540)
  using: _531@Mir(bb184[1]), _540@Mir(bb185[2])
  assert(!move (_546.1: bool), "attempt to shift right by `{}`, which would overflow", move _540) -> bb186
  using: _546@Entry, _531@Entry, _540@Entry
bb186:
  _530 = move (_546.0: u32)
  using: _546@Mir(bb185[3])
  _547 = const 15_u32
  using: 
  _529 = BitAnd(move _530, move _547)
  using: _530@Mir(bb186[0]), _547@Mir(bb186[1])
  _548 = const 16_i32
  using: 
  _549 = CheckedShl(_529, _548)
  using: _529@Mir(bb186[2]), _548@Mir(bb186[3])
  assert(!move (_549.1: bool), "attempt to shift left by `{}`, which would overflow", move _548) -> bb187
  using: _549@Entry, _529@Entry, _548@Entry
bb187:
  _528 = move (_549.0: u32)
  using: _549@Mir(bb186[4])
  ((*_1).14: u32) = BitOr(move _522, move _528)
  using: _1@Phi(bb141), _522@Mir(bb182[1]), _528@Mir(bb187[0])
  _550 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb141)
  assert(!move (_550.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb188
  using: _550@Entry, _1@Entry
bb188:
  ((*_1).17: i32) = move (_550.0: i32)
  using: _1@Phi(bb141), _550@Mir(bb187[2])
  _552 = ((*_1).17: i32)
  using: _1@Phi(bb141)
  _554 = ((*_1).51: i32)
  using: _1@Phi(bb141)
  _555 = const 1_i32
  using: 
  _556 = CheckedAdd(_554, _555)
  using: _554@Mir(bb188[2]), _555@Mir(bb188[3])
  assert(!move (_556.1: bool), "attempt to compute `{} + {}`, which would overflow", move _554, move _555) -> bb189
  using: _556@Entry, _554@Entry, _555@Entry
bb189:
  _553 = move (_556.0: i32)
  using: _556@Mir(bb188[4])
  _551 = Eq(move _552, move _553)
  using: _552@Mir(bb188[1]), _553@Mir(bb189[0])
  switchInt(move _551) -> [0: bb190, otherwise: bb140]
  using: _551@Mir(bb189[1])
bb190:
  _559 = _2
  using: _2@Mir(bb181[0])
  _558 = move _559 as i32 (IntToInt)
  using: _559@Mir(bb190[0])
  _560 = ((*_1).15: i32)
  using: _1@Phi(bb141)
  _557 = Ne(move _558, move _560)
  using: _558@Mir(bb190[1]), _560@Mir(bb190[2])
  switchInt(move _557) -> [0: bb192, otherwise: bb191]
  using: _557@Mir(bb190[3])
bb191:
  _561 = _2
  using: _2@Mir(bb181[0])
  ((*_1).15: i32) = move _561 as i32 (IntToInt)
  using: _1@Phi(bb141), _561@Mir(bb191[0])
  goto -> bb140
  using: 
bb192:
  _562 = const 3_i32
  using: 
  ((*_1).3: i32) = move _562
  using: _1@Phi(bb141), _562@Mir(bb192[0])
  _564 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _566 = const 100000_u32
  using: 
  _568 = ((*_1).9: i32)
  using: _1@Phi(bb141)
  _567 = move _568 as u32 (IntToInt)
  using: _568@Mir(bb192[4])
  _565 = core::num::<impl u32>::wrapping_mul(move _566, move _567) -> bb193
  using: _566@Mir(bb192[3]), _567@Mir(bb192[5])
bb193:
  _563 = Ge(move _564, move _565)
  using: _564@Mir(bb192[2]), _565@Mir(bb192[6])
  switchInt(move _563) -> [0: bb195, otherwise: bb194]
  using: _563@Mir(bb193[0])
bb194:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb195:
  _571 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _570 = move _571 as i32 (IntToInt)
  using: _571@Mir(bb195[0])
  _574 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb141)
  _573 = move _574 as &mut [i32] (Pointer(Unsize))
  using: _574@Mir(bb195[2])
  _572 = core::slice::<impl [i32]>::as_mut_ptr(move _573) -> bb196
  using: _573@Mir(bb195[3])
bb196:
  _569 = bzlib::BZ2_indexIntoF(move _570, move _572) -> bb197
  using: _570@Mir(bb195[1]), _572@Mir(bb195[4])
bb197:
  _2 = move _569 as u8 (IntToInt)
  using: _569@Mir(bb196[0])
  _578 = ((*_1).21: *mut u16)
  using: _1@Phi(bb141)
  _580 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _579 = move _580 as isize (IntToInt)
  using: _580@Mir(bb197[2])
  _577 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _578, move _579) -> bb198
  using: _578@Mir(bb197[1]), _579@Mir(bb197[3])
bb198:
  _576 = (*_577)
  using: _577@Mir(bb197[4])
  _575 = move _576 as u32 (IntToInt)
  using: _576@Mir(bb198[0])
  _587 = ((*_1).22: *mut u8)
  using: _1@Phi(bb141)
  _590 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _591 = const 1_i32
  using: 
  _592 = CheckedShr(_590, _591)
  using: _590@Mir(bb198[3]), _591@Mir(bb198[4])
  assert(!move (_592.1: bool), "attempt to shift right by `{}`, which would overflow", move _591) -> bb199
  using: _592@Entry, _590@Entry, _591@Entry
bb199:
  _589 = move (_592.0: u32)
  using: _592@Mir(bb198[5])
  _588 = move _589 as isize (IntToInt)
  using: _589@Mir(bb199[0])
  _586 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _587, move _588) -> bb200
  using: _587@Mir(bb198[2]), _588@Mir(bb199[1])
bb200:
  _585 = (*_586)
  using: _586@Mir(bb199[2])
  _584 = move _585 as u32 (IntToInt)
  using: _585@Mir(bb200[0])
  _595 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _596 = const 2_i32
  using: 
  _597 = CheckedShl(_595, _596)
  using: _595@Mir(bb200[2]), _596@Mir(bb200[3])
  assert(!move (_597.1: bool), "attempt to shift left by `{}`, which would overflow", move _596) -> bb201
  using: _597@Entry, _595@Entry, _596@Entry
bb201:
  _594 = move (_597.0: u32)
  using: _597@Mir(bb200[4])
  _598 = const 4_u32
  using: 
  _593 = BitAnd(move _594, move _598)
  using: _594@Mir(bb201[0]), _598@Mir(bb201[1])
  _599 = CheckedShr(_584, _593)
  using: _584@Mir(bb200[1]), _593@Mir(bb201[2])
  assert(!move (_599.1: bool), "attempt to shift right by `{}`, which would overflow", move _593) -> bb202
  using: _599@Entry, _584@Entry, _593@Entry
bb202:
  _583 = move (_599.0: u32)
  using: _599@Mir(bb201[3])
  _600 = const 15_u32
  using: 
  _582 = BitAnd(move _583, move _600)
  using: _583@Mir(bb202[0]), _600@Mir(bb202[1])
  _601 = const 16_i32
  using: 
  _602 = CheckedShl(_582, _601)
  using: _582@Mir(bb202[2]), _601@Mir(bb202[3])
  assert(!move (_602.1: bool), "attempt to shift left by `{}`, which would overflow", move _601) -> bb203
  using: _602@Entry, _582@Entry, _601@Entry
bb203:
  _581 = move (_602.0: u32)
  using: _602@Mir(bb202[4])
  ((*_1).14: u32) = BitOr(move _575, move _581)
  using: _1@Phi(bb141), _575@Mir(bb198[1]), _581@Mir(bb203[0])
  _603 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb141)
  assert(!move (_603.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb204
  using: _603@Entry, _1@Entry
bb204:
  ((*_1).17: i32) = move (_603.0: i32)
  using: _1@Phi(bb141), _603@Mir(bb203[2])
  _605 = ((*_1).17: i32)
  using: _1@Phi(bb141)
  _607 = ((*_1).51: i32)
  using: _1@Phi(bb141)
  _608 = const 1_i32
  using: 
  _609 = CheckedAdd(_607, _608)
  using: _607@Mir(bb204[2]), _608@Mir(bb204[3])
  assert(!move (_609.1: bool), "attempt to compute `{} + {}`, which would overflow", move _607, move _608) -> bb205
  using: _609@Entry, _607@Entry, _608@Entry
bb205:
  _606 = move (_609.0: i32)
  using: _609@Mir(bb204[4])
  _604 = Eq(move _605, move _606)
  using: _605@Mir(bb204[1]), _606@Mir(bb205[0])
  switchInt(move _604) -> [0: bb206, otherwise: bb140]
  using: _604@Mir(bb205[1])
bb206:
  _612 = _2
  using: _2@Mir(bb197[0])
  _611 = move _612 as i32 (IntToInt)
  using: _612@Mir(bb206[0])
  _613 = ((*_1).15: i32)
  using: _1@Phi(bb141)
  _610 = Ne(move _611, move _613)
  using: _611@Mir(bb206[1]), _613@Mir(bb206[2])
  switchInt(move _610) -> [0: bb208, otherwise: bb207]
  using: _610@Mir(bb206[3])
bb207:
  _614 = _2
  using: _2@Mir(bb197[0])
  ((*_1).15: i32) = move _614 as i32 (IntToInt)
  using: _1@Phi(bb141), _614@Mir(bb207[0])
  goto -> bb140
  using: 
bb208:
  _616 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _618 = const 100000_u32
  using: 
  _620 = ((*_1).9: i32)
  using: _1@Phi(bb141)
  _619 = move _620 as u32 (IntToInt)
  using: _620@Mir(bb208[2])
  _617 = core::num::<impl u32>::wrapping_mul(move _618, move _619) -> bb209
  using: _618@Mir(bb208[1]), _619@Mir(bb208[3])
bb209:
  _615 = Ge(move _616, move _617)
  using: _616@Mir(bb208[0]), _617@Mir(bb208[4])
  switchInt(move _615) -> [0: bb211, otherwise: bb210]
  using: _615@Mir(bb209[0])
bb210:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb211:
  _623 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _622 = move _623 as i32 (IntToInt)
  using: _623@Mir(bb211[0])
  _626 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb141)
  _625 = move _626 as &mut [i32] (Pointer(Unsize))
  using: _626@Mir(bb211[2])
  _624 = core::slice::<impl [i32]>::as_mut_ptr(move _625) -> bb212
  using: _625@Mir(bb211[3])
bb212:
  _621 = bzlib::BZ2_indexIntoF(move _622, move _624) -> bb213
  using: _622@Mir(bb211[1]), _624@Mir(bb211[4])
bb213:
  _2 = move _621 as u8 (IntToInt)
  using: _621@Mir(bb212[0])
  _630 = ((*_1).21: *mut u16)
  using: _1@Phi(bb141)
  _632 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _631 = move _632 as isize (IntToInt)
  using: _632@Mir(bb213[2])
  _629 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _630, move _631) -> bb214
  using: _630@Mir(bb213[1]), _631@Mir(bb213[3])
bb214:
  _628 = (*_629)
  using: _629@Mir(bb213[4])
  _627 = move _628 as u32 (IntToInt)
  using: _628@Mir(bb214[0])
  _639 = ((*_1).22: *mut u8)
  using: _1@Phi(bb141)
  _642 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _643 = const 1_i32
  using: 
  _644 = CheckedShr(_642, _643)
  using: _642@Mir(bb214[3]), _643@Mir(bb214[4])
  assert(!move (_644.1: bool), "attempt to shift right by `{}`, which would overflow", move _643) -> bb215
  using: _644@Entry, _642@Entry, _643@Entry
bb215:
  _641 = move (_644.0: u32)
  using: _644@Mir(bb214[5])
  _640 = move _641 as isize (IntToInt)
  using: _641@Mir(bb215[0])
  _638 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _639, move _640) -> bb216
  using: _639@Mir(bb214[2]), _640@Mir(bb215[1])
bb216:
  _637 = (*_638)
  using: _638@Mir(bb215[2])
  _636 = move _637 as u32 (IntToInt)
  using: _637@Mir(bb216[0])
  _647 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _648 = const 2_i32
  using: 
  _649 = CheckedShl(_647, _648)
  using: _647@Mir(bb216[2]), _648@Mir(bb216[3])
  assert(!move (_649.1: bool), "attempt to shift left by `{}`, which would overflow", move _648) -> bb217
  using: _649@Entry, _647@Entry, _648@Entry
bb217:
  _646 = move (_649.0: u32)
  using: _649@Mir(bb216[4])
  _650 = const 4_u32
  using: 
  _645 = BitAnd(move _646, move _650)
  using: _646@Mir(bb217[0]), _650@Mir(bb217[1])
  _651 = CheckedShr(_636, _645)
  using: _636@Mir(bb216[1]), _645@Mir(bb217[2])
  assert(!move (_651.1: bool), "attempt to shift right by `{}`, which would overflow", move _645) -> bb218
  using: _651@Entry, _636@Entry, _645@Entry
bb218:
  _635 = move (_651.0: u32)
  using: _651@Mir(bb217[3])
  _652 = const 15_u32
  using: 
  _634 = BitAnd(move _635, move _652)
  using: _635@Mir(bb218[0]), _652@Mir(bb218[1])
  _653 = const 16_i32
  using: 
  _654 = CheckedShl(_634, _653)
  using: _634@Mir(bb218[2]), _653@Mir(bb218[3])
  assert(!move (_654.1: bool), "attempt to shift left by `{}`, which would overflow", move _653) -> bb219
  using: _654@Entry, _634@Entry, _653@Entry
bb219:
  _633 = move (_654.0: u32)
  using: _654@Mir(bb218[4])
  ((*_1).14: u32) = BitOr(move _627, move _633)
  using: _1@Phi(bb141), _627@Mir(bb214[1]), _633@Mir(bb219[0])
  _655 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb141)
  assert(!move (_655.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb220
  using: _655@Entry, _1@Entry
bb220:
  ((*_1).17: i32) = move (_655.0: i32)
  using: _1@Phi(bb141), _655@Mir(bb219[2])
  _657 = _2
  using: _2@Mir(bb213[0])
  _656 = move _657 as i32 (IntToInt)
  using: _657@Mir(bb220[1])
  _658 = const 4_i32
  using: 
  _659 = CheckedAdd(_656, _658)
  using: _656@Mir(bb220[2]), _658@Mir(bb220[3])
  assert(!move (_659.1: bool), "attempt to compute `{} + {}`, which would overflow", move _656, move _658) -> bb221
  using: _659@Entry, _656@Entry, _658@Entry
bb221:
  ((*_1).3: i32) = move (_659.0: i32)
  using: _1@Phi(bb141), _659@Mir(bb220[4])
  _661 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _663 = const 100000_u32
  using: 
  _665 = ((*_1).9: i32)
  using: _1@Phi(bb141)
  _664 = move _665 as u32 (IntToInt)
  using: _665@Mir(bb221[3])
  _662 = core::num::<impl u32>::wrapping_mul(move _663, move _664) -> bb222
  using: _663@Mir(bb221[2]), _664@Mir(bb221[4])
bb222:
  _660 = Ge(move _661, move _662)
  using: _661@Mir(bb221[1]), _662@Mir(bb221[5])
  switchInt(move _660) -> [0: bb224, otherwise: bb223]
  using: _660@Mir(bb222[0])
bb223:
  _0 = const 1_u8
  using: 
  goto -> bb234
  using: 
bb224:
  _668 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _667 = move _668 as i32 (IntToInt)
  using: _668@Mir(bb224[0])
  _671 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb141)
  _670 = move _671 as &mut [i32] (Pointer(Unsize))
  using: _671@Mir(bb224[2])
  _669 = core::slice::<impl [i32]>::as_mut_ptr(move _670) -> bb225
  using: _670@Mir(bb224[3])
bb225:
  _666 = bzlib::BZ2_indexIntoF(move _667, move _669) -> bb226
  using: _667@Mir(bb224[1]), _669@Mir(bb224[4])
bb226:
  ((*_1).15: i32) = move _666
  using: _1@Phi(bb141), _666@Mir(bb225[0])
  _675 = ((*_1).21: *mut u16)
  using: _1@Phi(bb141)
  _677 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _676 = move _677 as isize (IntToInt)
  using: _677@Mir(bb226[2])
  _674 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _675, move _676) -> bb227
  using: _675@Mir(bb226[1]), _676@Mir(bb226[3])
bb227:
  _673 = (*_674)
  using: _674@Mir(bb226[4])
  _672 = move _673 as u32 (IntToInt)
  using: _673@Mir(bb227[0])
  _684 = ((*_1).22: *mut u8)
  using: _1@Phi(bb141)
  _687 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _688 = const 1_i32
  using: 
  _689 = CheckedShr(_687, _688)
  using: _687@Mir(bb227[3]), _688@Mir(bb227[4])
  assert(!move (_689.1: bool), "attempt to shift right by `{}`, which would overflow", move _688) -> bb228
  using: _689@Entry, _687@Entry, _688@Entry
bb228:
  _686 = move (_689.0: u32)
  using: _689@Mir(bb227[5])
  _685 = move _686 as isize (IntToInt)
  using: _686@Mir(bb228[0])
  _683 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _684, move _685) -> bb229
  using: _684@Mir(bb227[2]), _685@Mir(bb228[1])
bb229:
  _682 = (*_683)
  using: _683@Mir(bb228[2])
  _681 = move _682 as u32 (IntToInt)
  using: _682@Mir(bb229[0])
  _692 = ((*_1).14: u32)
  using: _1@Phi(bb141)
  _693 = const 2_i32
  using: 
  _694 = CheckedShl(_692, _693)
  using: _692@Mir(bb229[2]), _693@Mir(bb229[3])
  assert(!move (_694.1: bool), "attempt to shift left by `{}`, which would overflow", move _693) -> bb230
  using: _694@Entry, _692@Entry, _693@Entry
bb230:
  _691 = move (_694.0: u32)
  using: _694@Mir(bb229[4])
  _695 = const 4_u32
  using: 
  _690 = BitAnd(move _691, move _695)
  using: _691@Mir(bb230[0]), _695@Mir(bb230[1])
  _696 = CheckedShr(_681, _690)
  using: _681@Mir(bb229[1]), _690@Mir(bb230[2])
  assert(!move (_696.1: bool), "attempt to shift right by `{}`, which would overflow", move _690) -> bb231
  using: _696@Entry, _681@Entry, _690@Entry
bb231:
  _680 = move (_696.0: u32)
  using: _696@Mir(bb230[3])
  _697 = const 15_u32
  using: 
  _679 = BitAnd(move _680, move _697)
  using: _680@Mir(bb231[0]), _697@Mir(bb231[1])
  _698 = const 16_i32
  using: 
  _699 = CheckedShl(_679, _698)
  using: _679@Mir(bb231[2]), _698@Mir(bb231[3])
  assert(!move (_699.1: bool), "attempt to shift left by `{}`, which would overflow", move _698) -> bb232
  using: _699@Entry, _679@Entry, _698@Entry
bb232:
  _678 = move (_699.0: u32)
  using: _699@Mir(bb231[4])
  ((*_1).14: u32) = BitOr(move _672, move _678)
  using: _1@Phi(bb141), _672@Mir(bb227[1]), _678@Mir(bb232[0])
  _700 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb141)
  assert(!move (_700.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb233
  using: _700@Entry, _1@Entry
bb233:
  ((*_1).17: i32) = move (_700.0: i32)
  using: _1@Phi(bb141), _700@Mir(bb232[2])
  goto -> bb140
  using: 
bb234:
  return
  using: _0@Phi(bb234)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1217:63: 1217:72 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:1219:44: 1219:59 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:1221:49: 1221:64 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:1225:53: 1225:68 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1240:33: 1240:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1247:28: 1247:54 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1248:32: 1249:49 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1277:37: 1277:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1285:32: 1285:58 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1286:36: 1287:53 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1315:41: 1316:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1323:36: 1323:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1324:40: 1325:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1353:45: 1354:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1361:40: 1361:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1362:44: 1364:61 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1386:45: 1387:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1394:40: 1394:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1395:44: 1397:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1436:63: 1436:72 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:1438:44: 1438:59 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:1440:49: 1440:64 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/bzlib.rs:1444:53: 1444:68 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1459:33: 1459:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1466:28: 1466:54 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1467:32: 1468:49 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1483:37: 1483:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1491:32: 1491:58 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1492:36: 1493:53 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1508:41: 1509:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1516:36: 1516:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1517:40: 1518:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1533:45: 1534:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1541:40: 1541:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1542:44: 1544:61 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/bzlib.rs:1553:45: 1554:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1561:40: 1561:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1562:44: 1564:61 (#0) by default
@DefId(0:377 ~ c2rust_lib[1043]::bzlib::BZ2_bzDecompress)
bb0:
  _2 = const 0_u8
  using: 
  _3 = const {0x0 as *mut bzlib::DState}
  using: 
  _5 = _1
  using: _1@Entry
  _4 = std::ptr::mut_ptr::<impl *mut blocksort::bz_stream>::is_null(move _5) -> bb1
  using: _5@Mir(bb0[2])
bb1:
  switchInt(move _4) -> [0: bb3, otherwise: bb2]
  using: _4@Mir(bb0[3])
bb2:
  _8 = _1
  using: _1@Entry
  _7 = move _8 as usize (PointerExposeAddress)
  using: _8@Mir(bb2[0])
  _6 = Eq(move _7, const 0_usize)
  using: _7@Mir(bb2[1])
  assume(move _6)
  using: _6@Mir(bb2[2])
  _0 = const -2_i32
  using: 
  goto -> bb43
  using: 
bb3:
  _9 = ((*_1).8: *mut std::ffi::c_void)
  using: _1@Entry
  _3 = move _9 as *mut bzlib::DState (PtrToPtr)
  using: _9@Mir(bb3[0])
  _11 = _3
  using: _3@Mir(bb3[1])
  _10 = std::ptr::mut_ptr::<impl *mut bzlib::DState>::is_null(move _11) -> bb4
  using: _11@Mir(bb3[2])
bb4:
  switchInt(move _10) -> [0: bb6, otherwise: bb5]
  using: _10@Mir(bb3[3])
bb5:
  _14 = _3
  using: _3@Mir(bb3[1])
  _13 = move _14 as usize (PointerExposeAddress)
  using: _14@Mir(bb5[0])
  _12 = Eq(move _13, const 0_usize)
  using: _13@Mir(bb5[1])
  assume(move _12)
  using: _12@Mir(bb5[2])
  _0 = const -2_i32
  using: 
  goto -> bb43
  using: 
bb6:
  _16 = ((*_3).0: *mut blocksort::bz_stream)
  using: _3@Mir(bb3[1])
  _17 = _1
  using: _1@Entry
  _15 = Ne(move _16, move _17)
  using: _16@Mir(bb6[0]), _17@Mir(bb6[1])
  switchInt(move _15) -> [0: bb8, otherwise: bb7]
  using: _15@Mir(bb6[2])
bb7:
  _0 = const -2_i32
  using: 
  goto -> bb43
  using: 
bb8:
  _19 = ((*_3).1: i32)
  using: _3@Phi(bb8)
  _20 = const 1_i32
  using: 
  _18 = Eq(move _19, move _20)
  using: _19@Mir(bb8[0]), _20@Mir(bb8[1])
  switchInt(move _18) -> [0: bb10, otherwise: bb9]
  using: _18@Mir(bb8[2])
bb9:
  _0 = const -1_i32
  using: 
  goto -> bb43
  using: 
bb10:
  _22 = ((*_3).1: i32)
  using: _3@Phi(bb8)
  _23 = const 2_i32
  using: 
  _21 = Eq(move _22, move _23)
  using: _22@Mir(bb10[0]), _23@Mir(bb10[1])
  switchInt(move _21) -> [0: bb33, otherwise: bb11]
  using: _21@Mir(bb10[2])
bb11:
  _24 = ((*_3).10: u8)
  using: _3@Phi(bb8)
  switchInt(move _24) -> [0: bb14, otherwise: bb12]
  using: _24@Mir(bb11[0])
bb12:
  _26 = _3
  using: _3@Phi(bb8)
  _25 = bzlib::unRLE_obuf_to_output_SMALL(move _26) -> bb13
  using: _26@Mir(bb12[0])
bb13:
  _2 = move _25
  using: _25@Mir(bb12[1])
  goto -> bb16
  using: 
bb14:
  _28 = _3
  using: _3@Phi(bb8)
  _27 = bzlib::unRLE_obuf_to_output_FAST(move _28) -> bb15
  using: _28@Mir(bb14[0])
bb15:
  _2 = move _27
  using: _27@Mir(bb14[1])
  goto -> bb16
  using: 
bb16:
  _29 = _2
  using: _2@Phi(bb16)
  switchInt(move _29) -> [0: bb18, otherwise: bb17]
  using: _29@Mir(bb16[0])
bb17:
  _0 = const -4_i32
  using: 
  goto -> bb43
  using: 
bb18:
  _32 = ((*_3).17: i32)
  using: _3@Phi(bb16)
  _34 = ((*_3).51: i32)
  using: _3@Phi(bb16)
  _35 = const 1_i32
  using: 
  _36 = CheckedAdd(_34, _35)
  using: _34@Mir(bb18[1]), _35@Mir(bb18[2])
  assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", move _34, move _35) -> bb22
  using: _36@Entry, _34@Entry, _35@Entry
bb19:
  _30 = const false
  using: 
  goto -> bb21
  using: 
bb20:
  _38 = ((*_3).3: i32)
  using: _3@Phi(bb16)
  _39 = const 0_i32
  using: 
  _37 = Eq(move _38, move _39)
  using: _38@Mir(bb20[0]), _39@Mir(bb20[1])
  _30 = move _37
  using: _37@Mir(bb20[2])
  goto -> bb21
  using: 
bb21:
  switchInt(move _30) -> [0: bb32, otherwise: bb23]
  using: _30@Phi(bb21)
bb22:
  _33 = move (_36.0: i32)
  using: _36@Mir(bb18[3])
  _31 = Eq(move _32, move _33)
  using: _32@Mir(bb18[0]), _33@Mir(bb22[0])
  switchInt(move _31) -> [0: bb19, otherwise: bb20]
  using: _31@Mir(bb22[1])
bb23:
  _40 = ((*_3).25: u32)
  using: _3@Phi(bb21)
  ((*_3).25: u32) = Not(move _40)
  using: _3@Phi(bb21), _40@Mir(bb23[0])
  _42 = ((*_3).12: i32)
  using: _3@Phi(bb21)
  _43 = const 3_i32
  using: 
  _41 = Ge(move _42, move _43)
  using: _42@Mir(bb23[2]), _43@Mir(bb23[3])
  switchInt(move _41) -> [0: bb25, otherwise: bb24]
  using: _41@Mir(bb23[4])
bb24:
  _46 = const {alloc660: *mut *mut blocksort::__sFILE}
  using: 
  _45 = (*_46)
  using: _46@Mir(bb24[0])
  _50 = const b" {0x%08x, 0x%08x}\x00"
  using: 
  _49 = &raw const (*_50)
  using: _50@Mir(bb24[2])
  _48 = move _49 as *const u8 (Pointer(ArrayToPointer))
  using: _49@Mir(bb24[3])
  _47 = move _48 as *const i8 (PtrToPtr)
  using: _48@Mir(bb24[4])
  _51 = ((*_3).23: u32)
  using: _3@Phi(bb21)
  _52 = ((*_3).25: u32)
  using: _3@Phi(bb21)
  _44 = bzlib::fprintf(move _45, move _47, move _51, move _52) -> bb25
  using: _45@Mir(bb24[1]), _47@Mir(bb24[5]), _51@Mir(bb24[6]), _52@Mir(bb24[7])
bb25:
  _54 = ((*_3).12: i32)
  using: _3@Phi(bb25)
  _55 = const 2_i32
  using: 
  _53 = Ge(move _54, move _55)
  using: _54@Mir(bb25[0]), _55@Mir(bb25[1])
  switchInt(move _53) -> [0: bb27, otherwise: bb26]
  using: _53@Mir(bb25[2])
bb26:
  _58 = const {alloc660: *mut *mut blocksort::__sFILE}
  using: 
  _57 = (*_58)
  using: _58@Mir(bb26[0])
  _62 = const b"]\x00"
  using: 
  _61 = &raw const (*_62)
  using: _62@Mir(bb26[2])
  _60 = move _61 as *const u8 (Pointer(ArrayToPointer))
  using: _61@Mir(bb26[3])
  _59 = move _60 as *const i8 (PtrToPtr)
  using: _60@Mir(bb26[4])
  _56 = bzlib::fprintf(move _57, move _59) -> bb27
  using: _57@Mir(bb26[1]), _59@Mir(bb26[5])
bb27:
  _64 = ((*_3).25: u32)
  using: _3@Phi(bb25)
  _65 = ((*_3).23: u32)
  using: _3@Phi(bb25)
  _63 = Ne(move _64, move _65)
  using: _64@Mir(bb27[0]), _65@Mir(bb27[1])
  switchInt(move _63) -> [0: bb29, otherwise: bb28]
  using: _63@Mir(bb27[2])
bb28:
  _0 = const -4_i32
  using: 
  goto -> bb43
  using: 
bb29:
  _67 = ((*_3).26: u32)
  using: _3@Phi(bb25)
  _68 = const 1_i32
  using: 
  _69 = CheckedShl(_67, _68)
  using: _67@Mir(bb29[0]), _68@Mir(bb29[1])
  assert(!move (_69.1: bool), "attempt to shift left by `{}`, which would overflow", move _68) -> bb30
  using: _69@Entry, _67@Entry, _68@Entry
bb30:
  _66 = move (_69.0: u32)
  using: _69@Mir(bb29[2])
  _71 = ((*_3).26: u32)
  using: _3@Phi(bb25)
  _72 = const 31_i32
  using: 
  _73 = CheckedShr(_71, _72)
  using: _71@Mir(bb30[1]), _72@Mir(bb30[2])
  assert(!move (_73.1: bool), "attempt to shift right by `{}`, which would overflow", move _72) -> bb31
  using: _73@Entry, _71@Entry, _72@Entry
bb31:
  _70 = move (_73.0: u32)
  using: _73@Mir(bb30[3])
  ((*_3).26: u32) = BitOr(move _66, move _70)
  using: _3@Phi(bb25), _66@Mir(bb30[0]), _70@Mir(bb31[0])
  _74 = ((*_3).25: u32)
  using: _3@Phi(bb25)
  ((*_3).26: u32) = BitXor(((*_3).26: u32), move _74)
  using: _3@Phi(bb25), _3@Phi(bb25), _74@Mir(bb31[2])
  _75 = const 14_i32
  using: 
  ((*_3).1: i32) = move _75
  using: _3@Phi(bb25), _75@Mir(bb31[4])
  goto -> bb33
  using: 
bb32:
  _0 = const 0_i32
  using: 
  goto -> bb43
  using: 
bb33:
  _77 = ((*_3).1: i32)
  using: _3@Phi(bb33)
  _78 = const 10_i32
  using: 
  _76 = Ge(move _77, move _78)
  using: _77@Mir(bb33[0]), _78@Mir(bb33[1])
  switchInt(move _76) -> [0: bb8, otherwise: bb34]
  using: _76@Mir(bb33[2])
bb34:
  _80 = _3
  using: _3@Phi(bb33)
  _79 = decompress::BZ2_decompress(move _80) -> bb35
  using: _80@Mir(bb34[0])
bb35:
  _82 = _79
  using: _79@Mir(bb34[1])
  _83 = const 4_i32
  using: 
  _81 = Eq(move _82, move _83)
  using: _82@Mir(bb35[0]), _83@Mir(bb35[1])
  switchInt(move _81) -> [0: bb41, otherwise: bb36]
  using: _81@Mir(bb35[2])
bb36:
  _85 = ((*_3).12: i32)
  using: _3@Phi(bb33)
  _86 = const 3_i32
  using: 
  _84 = Ge(move _85, move _86)
  using: _85@Mir(bb36[0]), _86@Mir(bb36[1])
  switchInt(move _84) -> [0: bb38, otherwise: bb37]
  using: _84@Mir(bb36[2])
bb37:
  _89 = const {alloc660: *mut *mut blocksort::__sFILE}
  using: 
  _88 = (*_89)
  using: _89@Mir(bb37[0])
  _93 = const b"\n    combined CRCs: stored = 0x%08x, computed = 0x%08x\x00"
  using: 
  _92 = &raw const (*_93)
  using: _93@Mir(bb37[2])
  _91 = move _92 as *const u8 (Pointer(ArrayToPointer))
  using: _92@Mir(bb37[3])
  _90 = move _91 as *const i8 (PtrToPtr)
  using: _91@Mir(bb37[4])
  _94 = ((*_3).24: u32)
  using: _3@Phi(bb33)
  _95 = ((*_3).26: u32)
  using: _3@Phi(bb33)
  _87 = bzlib::fprintf(move _88, move _90, move _94, move _95) -> bb38
  using: _88@Mir(bb37[1]), _90@Mir(bb37[5]), _94@Mir(bb37[6]), _95@Mir(bb37[7])
bb38:
  _97 = ((*_3).26: u32)
  using: _3@Phi(bb38)
  _98 = ((*_3).24: u32)
  using: _3@Phi(bb38)
  _96 = Ne(move _97, move _98)
  using: _97@Mir(bb38[0]), _98@Mir(bb38[1])
  switchInt(move _96) -> [0: bb40, otherwise: bb39]
  using: _96@Mir(bb38[2])
bb39:
  _0 = const -4_i32
  using: 
  goto -> bb43
  using: 
bb40:
  _0 = _79
  using: _79@Mir(bb34[1])
  goto -> bb43
  using: 
bb41:
  _100 = ((*_3).1: i32)
  using: _3@Phi(bb38)
  _101 = const 2_i32
  using: 
  _99 = Ne(move _100, move _101)
  using: _100@Mir(bb41[0]), _101@Mir(bb41[1])
  switchInt(move _99) -> [0: bb8, otherwise: bb42]
  using: _99@Mir(bb41[2])
bb42:
  _0 = _79
  using: _79@Mir(bb34[1])
  goto -> bb43
  using: 
bb43:
  return
  using: _0@Phi(bb43)
rewrite call bzlib::fprintf @ workspace/bzip2/rust/bzlib.rs:1598:21: 1601:53 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzlib::fprintf @ workspace/bzip2/rust/bzlib.rs:1604:21: 1605:82 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzlib::fprintf @ workspace/bzip2/rust/bzlib.rs:1621:21: 1625:56 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:378 ~ c2rust_lib[1043]::bzlib::BZ2_bzDecompressEnd)
bb0:
  _2 = const {0x0 as *mut bzlib::DState}
  using: 
  _4 = _1
  using: _1@Entry
  _3 = std::ptr::mut_ptr::<impl *mut blocksort::bz_stream>::is_null(move _4) -> bb1
  using: _4@Mir(bb0[1])
bb1:
  switchInt(move _3) -> [0: bb3, otherwise: bb2]
  using: _3@Mir(bb0[2])
bb2:
  _7 = _1
  using: _1@Entry
  _6 = move _7 as usize (PointerExposeAddress)
  using: _7@Mir(bb2[0])
  _5 = Eq(move _6, const 0_usize)
  using: _6@Mir(bb2[1])
  assume(move _5)
  using: _5@Mir(bb2[2])
  _0 = const -2_i32
  using: 
  goto -> bb26
  using: 
bb3:
  _8 = ((*_1).8: *mut std::ffi::c_void)
  using: _1@Entry
  _2 = move _8 as *mut bzlib::DState (PtrToPtr)
  using: _8@Mir(bb3[0])
  _10 = _2
  using: _2@Mir(bb3[1])
  _9 = std::ptr::mut_ptr::<impl *mut bzlib::DState>::is_null(move _10) -> bb4
  using: _10@Mir(bb3[2])
bb4:
  switchInt(move _9) -> [0: bb6, otherwise: bb5]
  using: _9@Mir(bb3[3])
bb5:
  _13 = _2
  using: _2@Mir(bb3[1])
  _12 = move _13 as usize (PointerExposeAddress)
  using: _13@Mir(bb5[0])
  _11 = Eq(move _12, const 0_usize)
  using: _12@Mir(bb5[1])
  assume(move _11)
  using: _11@Mir(bb5[2])
  _0 = const -2_i32
  using: 
  goto -> bb26
  using: 
bb6:
  _15 = ((*_2).0: *mut blocksort::bz_stream)
  using: _2@Mir(bb3[1])
  _16 = _1
  using: _1@Entry
  _14 = Ne(move _15, move _16)
  using: _15@Mir(bb6[0]), _16@Mir(bb6[1])
  switchInt(move _14) -> [0: bb8, otherwise: bb7]
  using: _14@Mir(bb6[2])
bb7:
  _0 = const -2_i32
  using: 
  goto -> bb26
  using: 
bb8:
  _19 = ((*_2).20: *mut u32)
  using: _2@Mir(bb3[1])
  _18 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _19) -> bb9
  using: _19@Mir(bb8[0])
bb9:
  _17 = Not(move _18)
  using: _18@Mir(bb8[1])
  switchInt(move _17) -> [0: bb12, otherwise: bb10]
  using: _17@Mir(bb9[0])
bb10:
  _22 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Entry
  _24 = const "non-null function pointer"
  using: 
  _23 = _24
  using: _24@Mir(bb10[1])
  _21 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _22, move _23) -> bb11
  using: _22@Mir(bb10[0]), _23@Mir(bb10[2])
bb11:
  _25 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Entry
  _27 = ((*_2).20: *mut u32)
  using: _2@Mir(bb3[1])
  _26 = move _27 as *mut std::ffi::c_void (PtrToPtr)
  using: _27@Mir(bb11[1])
  _20 = move _21(move _25, move _26) -> bb13
  using: _21@Entry, _25@Mir(bb11[0]), _26@Mir(bb11[2])
bb12:
  _30 = ((*_2).20: *mut u32)
  using: _2@Mir(bb3[1])
  _29 = move _30 as usize (PointerExposeAddress)
  using: _30@Mir(bb12[0])
  _28 = Eq(move _29, const 0_usize)
  using: _29@Mir(bb12[1])
  assume(move _28)
  using: _28@Mir(bb12[2])
  goto -> bb13
  using: 
bb13:
  _33 = ((*_2).21: *mut u16)
  using: _2@Phi(bb13)
  _32 = std::ptr::mut_ptr::<impl *mut u16>::is_null(move _33) -> bb14
  using: _33@Mir(bb13[0])
bb14:
  _31 = Not(move _32)
  using: _32@Mir(bb13[1])
  switchInt(move _31) -> [0: bb17, otherwise: bb15]
  using: _31@Mir(bb14[0])
bb15:
  _36 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb13)
  _38 = const "non-null function pointer"
  using: 
  _37 = _38
  using: _38@Mir(bb15[1])
  _35 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _36, move _37) -> bb16
  using: _36@Mir(bb15[0]), _37@Mir(bb15[2])
bb16:
  _39 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb13)
  _41 = ((*_2).21: *mut u16)
  using: _2@Phi(bb13)
  _40 = move _41 as *mut std::ffi::c_void (PtrToPtr)
  using: _41@Mir(bb16[1])
  _34 = move _35(move _39, move _40) -> bb18
  using: _35@Entry, _39@Mir(bb16[0]), _40@Mir(bb16[2])
bb17:
  _44 = ((*_2).21: *mut u16)
  using: _2@Phi(bb13)
  _43 = move _44 as usize (PointerExposeAddress)
  using: _44@Mir(bb17[0])
  _42 = Eq(move _43, const 0_usize)
  using: _43@Mir(bb17[1])
  assume(move _42)
  using: _42@Mir(bb17[2])
  goto -> bb18
  using: 
bb18:
  _47 = ((*_2).22: *mut u8)
  using: _2@Phi(bb18)
  _46 = std::ptr::mut_ptr::<impl *mut u8>::is_null(move _47) -> bb19
  using: _47@Mir(bb18[0])
bb19:
  _45 = Not(move _46)
  using: _46@Mir(bb18[1])
  switchInt(move _45) -> [0: bb22, otherwise: bb20]
  using: _45@Mir(bb19[0])
bb20:
  _50 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb18)
  _52 = const "non-null function pointer"
  using: 
  _51 = _52
  using: _52@Mir(bb20[1])
  _49 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _50, move _51) -> bb21
  using: _50@Mir(bb20[0]), _51@Mir(bb20[2])
bb21:
  _53 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb18)
  _55 = ((*_2).22: *mut u8)
  using: _2@Phi(bb18)
  _54 = move _55 as *mut std::ffi::c_void (PtrToPtr)
  using: _55@Mir(bb21[1])
  _48 = move _49(move _53, move _54) -> bb23
  using: _49@Entry, _53@Mir(bb21[0]), _54@Mir(bb21[2])
bb22:
  _58 = ((*_2).22: *mut u8)
  using: _2@Phi(bb18)
  _57 = move _58 as usize (PointerExposeAddress)
  using: _58@Mir(bb22[0])
  _56 = Eq(move _57, const 0_usize)
  using: _57@Mir(bb22[1])
  assume(move _56)
  using: _56@Mir(bb22[2])
  goto -> bb23
  using: 
bb23:
  _61 = ((*_1).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>)
  using: _1@Phi(bb23)
  _63 = const "non-null function pointer"
  using: 
  _62 = _63
  using: _63@Mir(bb23[1])
  _60 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>::expect(move _61, move _62) -> bb24
  using: _61@Mir(bb23[0]), _62@Mir(bb23[2])
bb24:
  _64 = ((*_1).11: *mut std::ffi::c_void)
  using: _1@Phi(bb23)
  _65 = ((*_1).8: *mut std::ffi::c_void)
  using: _1@Phi(bb23)
  _59 = move _60(move _64, move _65) -> bb25
  using: _60@Entry, _64@Mir(bb24[0]), _65@Mir(bb24[1])
bb25:
  ((*_1).8: *mut std::ffi::c_void) = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: _1@Phi(bb23)
  _0 = const 0_i32
  using: 
  goto -> bb26
  using: 
bb26:
  return
  using: _0@Phi(bb26)
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:1649:24: 1649:59 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:1654:24: 1654:59 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:1659:24: 1659:59 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/bzlib.rs:1663:20: 1663:55 (#0) by default
@DefId(0:379 ~ c2rust_lib[1043]::bzlib::myfeof)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = bzlib::fgetc(move _3) -> bb1
  using: _3@Mir(bb0[0])
bb1:
  _5 = _2
  using: _2@Mir(bb0[1])
  _6 = const -1_i32
  using: 
  _4 = Eq(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb3, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _0 = const 1_u8
  using: 
  goto -> bb5
  using: 
bb3:
  _8 = _2
  using: _2@Mir(bb0[1])
  _9 = _1
  using: _1@Entry
  _7 = bzlib::ungetc(move _8, move _9) -> bb4
  using: _8@Mir(bb3[0]), _9@Mir(bb3[1])
bb4:
  _0 = const 0_u8
  using: 
  goto -> bb5
  using: 
bb5:
  return
  using: _0@Phi(bb5)
rewrite call bzlib::fgetc @ workspace/bzip2/rust/bzlib.rs:1670:24: 1670:32 (#0) by default
rewrite call bzlib::ungetc @ workspace/bzip2/rust/bzlib.rs:1672:5: 1672:17 (#0) by default
@DefId(0:380 ~ c2rust_lib[1043]::bzlib::BZ2_bzWriteOpen)
bb0:
  _6 = const 0_i32
  using: 
  _7 = const {0x0 as *mut bzlib::bzFile}
  using: 
  _10 = _1
  using: _1@Entry
  _9 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _10) -> bb1
  using: _10@Mir(bb0[2])
bb1:
  _8 = Not(move _9)
  using: _9@Mir(bb0[3])
  switchInt(move _8) -> [0: bb3, otherwise: bb2]
  using: _8@Mir(bb1[0])
bb2:
  _11 = const 0_i32
  using: 
  (*_1) = move _11
  using: _1@Entry, _11@Mir(bb2[0])
  goto -> bb4
  using: 
bb3:
  _14 = _1
  using: _1@Entry
  _13 = move _14 as usize (PointerExposeAddress)
  using: _14@Mir(bb3[0])
  _12 = Eq(move _13, const 0_usize)
  using: _13@Mir(bb3[1])
  assume(move _12)
  using: _12@Mir(bb3[2])
  goto -> bb4
  using: 
bb4:
  _17 = _7
  using: _7@Mir(bb0[1])
  _16 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _17) -> bb5
  using: _17@Mir(bb4[0])
bb5:
  _15 = Not(move _16)
  using: _16@Mir(bb4[1])
  switchInt(move _15) -> [0: bb7, otherwise: bb6]
  using: _15@Mir(bb5[0])
bb6:
  _18 = const 0_i32
  using: 
  ((*_7).5: i32) = move _18
  using: _7@Mir(bb0[1]), _18@Mir(bb6[0])
  goto -> bb8
  using: 
bb7:
  _21 = _7
  using: _7@Mir(bb0[1])
  _20 = move _21 as usize (PointerExposeAddress)
  using: _21@Mir(bb7[0])
  _19 = Eq(move _20, const 0_usize)
  using: _20@Mir(bb7[1])
  assume(move _19)
  using: _19@Mir(bb7[2])
  goto -> bb8
  using: 
bb8:
  _26 = _2
  using: _2@Entry
  _25 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _26) -> bb18
  using: _26@Mir(bb8[0])
bb9:
  _22 = const true
  using: 
  goto -> bb11
  using: 
bb10:
  _43 = _4
  using: _4@Entry
  _44 = const 0_i32
  using: 
  _42 = Lt(move _43, move _44)
  using: _43@Mir(bb10[0]), _44@Mir(bb10[1])
  switchInt(move _42) -> [0: bb26, otherwise: bb25]
  using: _42@Mir(bb10[2])
bb11:
  switchInt(move _22) -> [0: bb37, otherwise: bb28]
  using: _22@Phi(bb11)
bb12:
  _23 = const true
  using: 
  goto -> bb14
  using: 
bb13:
  _36 = _5
  using: _5@Entry
  _37 = const 0_i32
  using: 
  _35 = Lt(move _36, move _37)
  using: _36@Mir(bb13[0]), _37@Mir(bb13[1])
  switchInt(move _35) -> [0: bb23, otherwise: bb22]
  using: _35@Mir(bb13[2])
bb14:
  switchInt(move _23) -> [0: bb10, otherwise: bb9]
  using: _23@Phi(bb14)
bb15:
  _24 = const true
  using: 
  goto -> bb17
  using: 
bb16:
  _29 = _3
  using: _3@Entry
  _30 = const 1_i32
  using: 
  _28 = Lt(move _29, move _30)
  using: _29@Mir(bb16[0]), _30@Mir(bb16[1])
  switchInt(move _28) -> [0: bb20, otherwise: bb19]
  using: _28@Mir(bb16[2])
bb17:
  switchInt(move _24) -> [0: bb13, otherwise: bb12]
  using: _24@Phi(bb17)
bb18:
  switchInt(move _25) -> [0: bb16, otherwise: bb15]
  using: _25@Mir(bb8[1])
bb19:
  _27 = const true
  using: 
  goto -> bb21
  using: 
bb20:
  _32 = _3
  using: _3@Entry
  _33 = const 9_i32
  using: 
  _31 = Gt(move _32, move _33)
  using: _32@Mir(bb20[0]), _33@Mir(bb20[1])
  _27 = move _31
  using: _31@Mir(bb20[2])
  goto -> bb21
  using: 
bb21:
  _24 = move _27
  using: _27@Phi(bb21)
  goto -> bb17
  using: 
bb22:
  _34 = const true
  using: 
  goto -> bb24
  using: 
bb23:
  _39 = _5
  using: _5@Entry
  _40 = const 250_i32
  using: 
  _38 = Gt(move _39, move _40)
  using: _39@Mir(bb23[0]), _40@Mir(bb23[1])
  _34 = move _38
  using: _38@Mir(bb23[2])
  goto -> bb24
  using: 
bb24:
  _23 = move _34
  using: _34@Phi(bb24)
  goto -> bb14
  using: 
bb25:
  _41 = const true
  using: 
  goto -> bb27
  using: 
bb26:
  _46 = _4
  using: _4@Entry
  _47 = const 4_i32
  using: 
  _45 = Gt(move _46, move _47)
  using: _46@Mir(bb26[0]), _47@Mir(bb26[1])
  _41 = move _45
  using: _45@Mir(bb26[2])
  goto -> bb27
  using: 
bb27:
  _22 = move _41
  using: _41@Phi(bb27)
  goto -> bb11
  using: 
bb28:
  _50 = _1
  using: _1@Phi(bb4)
  _49 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _50) -> bb29
  using: _50@Mir(bb28[0])
bb29:
  _48 = Not(move _49)
  using: _49@Mir(bb28[1])
  switchInt(move _48) -> [0: bb31, otherwise: bb30]
  using: _48@Mir(bb29[0])
bb30:
  _51 = const 2_i32
  using: 
  (*_1) = Neg(move _51)
  using: _1@Phi(bb4), _51@Mir(bb30[0])
  goto -> bb32
  using: 
bb31:
  _54 = _1
  using: _1@Phi(bb4)
  _53 = move _54 as usize (PointerExposeAddress)
  using: _54@Mir(bb31[0])
  _52 = Eq(move _53, const 0_usize)
  using: _53@Mir(bb31[1])
  assume(move _52)
  using: _52@Mir(bb31[2])
  goto -> bb32
  using: 
bb32:
  _57 = _7
  using: _7@Phi(bb8)
  _56 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _57) -> bb33
  using: _57@Mir(bb32[0])
bb33:
  _55 = Not(move _56)
  using: _56@Mir(bb32[1])
  switchInt(move _55) -> [0: bb35, otherwise: bb34]
  using: _55@Mir(bb33[0])
bb34:
  _58 = const 2_i32
  using: 
  ((*_7).5: i32) = Neg(move _58)
  using: _7@Phi(bb8), _58@Mir(bb34[0])
  goto -> bb36
  using: 
bb35:
  _61 = _7
  using: _7@Phi(bb8)
  _60 = move _61 as usize (PointerExposeAddress)
  using: _61@Mir(bb35[0])
  _59 = Eq(move _60, const 0_usize)
  using: _60@Mir(bb35[1])
  assume(move _59)
  using: _59@Mir(bb35[2])
  goto -> bb36
  using: 
bb36:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb84
  using: 
bb37:
  _63 = _2
  using: _2@Entry
  _62 = bzlib::ferror(move _63) -> bb38
  using: _63@Mir(bb37[0])
bb38:
  switchInt(move _62) -> [0: bb48, otherwise: bb39]
  using: _62@Mir(bb37[1])
bb39:
  _66 = _1
  using: _1@Phi(bb32)
  _65 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _66) -> bb40
  using: _66@Mir(bb39[0])
bb40:
  _64 = Not(move _65)
  using: _65@Mir(bb39[1])
  switchInt(move _64) -> [0: bb42, otherwise: bb41]
  using: _64@Mir(bb40[0])
bb41:
  _67 = const 6_i32
  using: 
  (*_1) = Neg(move _67)
  using: _1@Phi(bb32), _67@Mir(bb41[0])
  goto -> bb43
  using: 
bb42:
  _70 = _1
  using: _1@Phi(bb32)
  _69 = move _70 as usize (PointerExposeAddress)
  using: _70@Mir(bb42[0])
  _68 = Eq(move _69, const 0_usize)
  using: _69@Mir(bb42[1])
  assume(move _68)
  using: _68@Mir(bb42[2])
  goto -> bb43
  using: 
bb43:
  _73 = _7
  using: _7@Phi(bb36)
  _72 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _73) -> bb44
  using: _73@Mir(bb43[0])
bb44:
  _71 = Not(move _72)
  using: _72@Mir(bb43[1])
  switchInt(move _71) -> [0: bb46, otherwise: bb45]
  using: _71@Mir(bb44[0])
bb45:
  _74 = const 6_i32
  using: 
  ((*_7).5: i32) = Neg(move _74)
  using: _7@Phi(bb36), _74@Mir(bb45[0])
  goto -> bb47
  using: 
bb46:
  _77 = _7
  using: _7@Phi(bb36)
  _76 = move _77 as usize (PointerExposeAddress)
  using: _77@Mir(bb46[0])
  _75 = Eq(move _76, const 0_usize)
  using: _76@Mir(bb46[1])
  assume(move _75)
  using: _75@Mir(bb46[2])
  goto -> bb47
  using: 
bb47:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb84
  using: 
bb48:
  _80 = std::mem::size_of::<bzlib::bzFile>() -> bb49
  using: 
bb49:
  _79 = move _80 as u64 (IntToInt)
  using: _80@Mir(bb48[0])
  _78 = bzlib::malloc(move _79) -> bb50
  using: _79@Mir(bb49[0])
bb50:
  _7 = move _78 as *mut bzlib::bzFile (PtrToPtr)
  using: _78@Mir(bb49[1])
  _82 = _7
  using: _7@Mir(bb50[0])
  _81 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _82) -> bb51
  using: _82@Mir(bb50[1])
bb51:
  switchInt(move _81) -> [0: bb61, otherwise: bb52]
  using: _81@Mir(bb50[2])
bb52:
  _85 = _7
  using: _7@Mir(bb50[0])
  _84 = move _85 as usize (PointerExposeAddress)
  using: _85@Mir(bb52[0])
  _83 = Eq(move _84, const 0_usize)
  using: _84@Mir(bb52[1])
  assume(move _83)
  using: _83@Mir(bb52[2])
  _88 = _1
  using: _1@Phi(bb43)
  _87 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _88) -> bb53
  using: _88@Mir(bb52[4])
bb53:
  _86 = Not(move _87)
  using: _87@Mir(bb52[5])
  switchInt(move _86) -> [0: bb55, otherwise: bb54]
  using: _86@Mir(bb53[0])
bb54:
  _89 = const 3_i32
  using: 
  (*_1) = Neg(move _89)
  using: _1@Phi(bb43), _89@Mir(bb54[0])
  goto -> bb56
  using: 
bb55:
  _92 = _1
  using: _1@Phi(bb43)
  _91 = move _92 as usize (PointerExposeAddress)
  using: _92@Mir(bb55[0])
  _90 = Eq(move _91, const 0_usize)
  using: _91@Mir(bb55[1])
  assume(move _90)
  using: _90@Mir(bb55[2])
  goto -> bb56
  using: 
bb56:
  _95 = _7
  using: _7@Mir(bb50[0])
  _94 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _95) -> bb57
  using: _95@Mir(bb56[0])
bb57:
  _93 = Not(move _94)
  using: _94@Mir(bb56[1])
  switchInt(move _93) -> [0: bb59, otherwise: bb58]
  using: _93@Mir(bb57[0])
bb58:
  _96 = const 3_i32
  using: 
  ((*_7).5: i32) = Neg(move _96)
  using: _7@Mir(bb50[0]), _96@Mir(bb58[0])
  goto -> bb60
  using: 
bb59:
  _99 = _7
  using: _7@Mir(bb50[0])
  _98 = move _99 as usize (PointerExposeAddress)
  using: _99@Mir(bb59[0])
  _97 = Eq(move _98, const 0_usize)
  using: _98@Mir(bb59[1])
  assume(move _97)
  using: _97@Mir(bb59[2])
  goto -> bb60
  using: 
bb60:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb84
  using: 
bb61:
  _102 = _1
  using: _1@Phi(bb56)
  _101 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _102) -> bb62
  using: _102@Mir(bb61[0])
bb62:
  _100 = Not(move _101)
  using: _101@Mir(bb61[1])
  switchInt(move _100) -> [0: bb64, otherwise: bb63]
  using: _100@Mir(bb62[0])
bb63:
  _103 = const 0_i32
  using: 
  (*_1) = move _103
  using: _1@Phi(bb56), _103@Mir(bb63[0])
  goto -> bb65
  using: 
bb64:
  _106 = _1
  using: _1@Phi(bb56)
  _105 = move _106 as usize (PointerExposeAddress)
  using: _106@Mir(bb64[0])
  _104 = Eq(move _105, const 0_usize)
  using: _105@Mir(bb64[1])
  assume(move _104)
  using: _104@Mir(bb64[2])
  goto -> bb65
  using: 
bb65:
  _109 = _7
  using: _7@Phi(bb60)
  _108 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _109) -> bb66
  using: _109@Mir(bb65[0])
bb66:
  _107 = Not(move _108)
  using: _108@Mir(bb65[1])
  switchInt(move _107) -> [0: bb68, otherwise: bb67]
  using: _107@Mir(bb66[0])
bb67:
  _110 = const 0_i32
  using: 
  ((*_7).5: i32) = move _110
  using: _7@Phi(bb60), _110@Mir(bb67[0])
  goto -> bb69
  using: 
bb68:
  _113 = _7
  using: _7@Phi(bb60)
  _112 = move _113 as usize (PointerExposeAddress)
  using: _113@Mir(bb68[0])
  _111 = Eq(move _112, const 0_usize)
  using: _112@Mir(bb68[1])
  assume(move _111)
  using: _111@Mir(bb68[2])
  goto -> bb69
  using: 
bb69:
  _114 = const 0_i32
  using: 
  ((*_7).6: u8) = move _114 as u8 (IntToInt)
  using: _7@Phi(bb69), _114@Mir(bb69[0])
  _115 = const 0_i32
  using: 
  ((*_7).2: i32) = move _115
  using: _7@Phi(bb69), _115@Mir(bb69[2])
  _116 = _2
  using: _2@Entry
  ((*_7).0: *mut blocksort::__sFILE) = move _116
  using: _7@Phi(bb69), _116@Mir(bb69[4])
  _117 = const 1_i32
  using: 
  ((*_7).3: u8) = move _117 as u8 (IntToInt)
  using: _7@Phi(bb69), _117@Mir(bb69[6])
  Deinit(_118)
  using: 
  discriminant(_118) = 0
  using: 
  (((*_7).4: blocksort::bz_stream).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _118
  using: _7@Phi(bb69), _118@Mir(bb69[8])
  Deinit(_119)
  using: 
  discriminant(_119) = 0
  using: 
  (((*_7).4: blocksort::bz_stream).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _119
  using: _7@Phi(bb69), _119@Mir(bb69[11])
  (((*_7).4: blocksort::bz_stream).11: *mut std::ffi::c_void) = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: _7@Phi(bb69)
  _121 = _5
  using: _5@Phi(bb14)
  _122 = const 0_i32
  using: 
  _120 = Eq(move _121, move _122)
  using: _121@Mir(bb69[15]), _122@Mir(bb69[16])
  switchInt(move _120) -> [0: bb71, otherwise: bb70]
  using: _120@Mir(bb69[17])
bb70:
  _5 = const 30_i32
  using: 
  goto -> bb71
  using: 
bb71:
  _125 = &mut ((*_7).4: blocksort::bz_stream)
  using: _7@Phi(bb69)
  _124 = &raw mut (*_125)
  using: _125@Mir(bb71[0])
  _126 = _3
  using: _3@Phi(bb17)
  _127 = _4
  using: _4@Phi(bb11)
  _128 = _5
  using: _5@Phi(bb71)
  _123 = bzlib::BZ2_bzCompressInit(move _124, move _126, move _127, move _128) -> bb72
  using: _124@Mir(bb71[1]), _126@Mir(bb71[2]), _127@Mir(bb71[3]), _128@Mir(bb71[4])
bb72:
  _6 = move _123
  using: _123@Mir(bb71[5])
  _130 = _6
  using: _6@Mir(bb72[0])
  _131 = const 0_i32
  using: 
  _129 = Ne(move _130, move _131)
  using: _130@Mir(bb72[1]), _131@Mir(bb72[2])
  switchInt(move _129) -> [0: bb83, otherwise: bb73]
  using: _129@Mir(bb72[3])
bb73:
  _134 = _1
  using: _1@Phi(bb65)
  _133 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _134) -> bb74
  using: _134@Mir(bb73[0])
bb74:
  _132 = Not(move _133)
  using: _133@Mir(bb73[1])
  switchInt(move _132) -> [0: bb76, otherwise: bb75]
  using: _132@Mir(bb74[0])
bb75:
  _135 = _6
  using: _6@Mir(bb72[0])
  (*_1) = move _135
  using: _1@Phi(bb65), _135@Mir(bb75[0])
  goto -> bb77
  using: 
bb76:
  _138 = _1
  using: _1@Phi(bb65)
  _137 = move _138 as usize (PointerExposeAddress)
  using: _138@Mir(bb76[0])
  _136 = Eq(move _137, const 0_usize)
  using: _137@Mir(bb76[1])
  assume(move _136)
  using: _136@Mir(bb76[2])
  goto -> bb77
  using: 
bb77:
  _141 = _7
  using: _7@Phi(bb69)
  _140 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _141) -> bb78
  using: _141@Mir(bb77[0])
bb78:
  _139 = Not(move _140)
  using: _140@Mir(bb77[1])
  switchInt(move _139) -> [0: bb80, otherwise: bb79]
  using: _139@Mir(bb78[0])
bb79:
  _142 = _6
  using: _6@Phi(bb77)
  ((*_7).5: i32) = move _142
  using: _7@Phi(bb69), _142@Mir(bb79[0])
  goto -> bb81
  using: 
bb80:
  _145 = _7
  using: _7@Phi(bb69)
  _144 = move _145 as usize (PointerExposeAddress)
  using: _145@Mir(bb80[0])
  _143 = Eq(move _144, const 0_usize)
  using: _144@Mir(bb80[1])
  assume(move _143)
  using: _143@Mir(bb80[2])
  goto -> bb81
  using: 
bb81:
  _148 = _7
  using: _7@Phi(bb81)
  _147 = move _148 as *mut std::ffi::c_void (PtrToPtr)
  using: _148@Mir(bb81[0])
  _146 = bzlib::free(move _147) -> bb82
  using: _147@Mir(bb81[1])
bb82:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb84
  using: 
bb83:
  _149 = const 0_i32
  using: 
  (((*_7).4: blocksort::bz_stream).1: u32) = move _149 as u32 (IntToInt)
  using: _7@Phi(bb81), _149@Mir(bb83[0])
  _150 = const 1_i32
  using: 
  ((*_7).6: u8) = move _150 as u8 (IntToInt)
  using: _7@Phi(bb81), _150@Mir(bb83[2])
  _151 = _7
  using: _7@Phi(bb81)
  _0 = move _151 as *mut std::ffi::c_void (PtrToPtr)
  using: _151@Mir(bb83[4])
  goto -> bb84
  using: 
bb84:
  return
  using: _0@Phi(bb84)
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1696:8: 1696:17 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:1702:16: 1702:47 (#0) by default
rewrite call bzlib::malloc @ workspace/bzip2/rust/bzlib.rs:1702:9: 1702:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_118) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_118) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_119) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_119) = 0 is ignored
@DefId(0:381 ~ c2rust_lib[1043]::bzlib::BZ2_bzWrite)
bb0:
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _9 = _2
  using: _2@Entry
  _8 = move _9 as *mut bzlib::bzFile (PtrToPtr)
  using: _9@Mir(bb0[3])
  _12 = _1
  using: _1@Entry
  _11 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _12) -> bb1
  using: _12@Mir(bb0[5])
bb1:
  _10 = Not(move _11)
  using: _11@Mir(bb0[6])
  switchInt(move _10) -> [0: bb3, otherwise: bb2]
  using: _10@Mir(bb1[0])
bb2:
  _13 = const 0_i32
  using: 
  (*_1) = move _13
  using: _1@Entry, _13@Mir(bb2[0])
  goto -> bb4
  using: 
bb3:
  _16 = _1
  using: _1@Entry
  _15 = move _16 as usize (PointerExposeAddress)
  using: _16@Mir(bb3[0])
  _14 = Eq(move _15, const 0_usize)
  using: _15@Mir(bb3[1])
  assume(move _14)
  using: _14@Mir(bb3[2])
  goto -> bb4
  using: 
bb4:
  _19 = _8
  using: _8@Mir(bb0[4])
  _18 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _19) -> bb5
  using: _19@Mir(bb4[0])
bb5:
  _17 = Not(move _18)
  using: _18@Mir(bb4[1])
  switchInt(move _17) -> [0: bb7, otherwise: bb6]
  using: _17@Mir(bb5[0])
bb6:
  _20 = const 0_i32
  using: 
  ((*_8).5: i32) = move _20
  using: _8@Mir(bb0[4]), _20@Mir(bb6[0])
  goto -> bb8
  using: 
bb7:
  _23 = _8
  using: _8@Mir(bb0[4])
  _22 = move _23 as usize (PointerExposeAddress)
  using: _23@Mir(bb7[0])
  _21 = Eq(move _22, const 0_usize)
  using: _22@Mir(bb7[1])
  assume(move _21)
  using: _21@Mir(bb7[2])
  goto -> bb8
  using: 
bb8:
  _27 = _8
  using: _8@Phi(bb8)
  _26 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _27) -> bb15
  using: _27@Mir(bb8[0])
bb9:
  _24 = const true
  using: 
  goto -> bb11
  using: 
bb10:
  _31 = _4
  using: _4@Entry
  _32 = const 0_i32
  using: 
  _30 = Lt(move _31, move _32)
  using: _31@Mir(bb10[0]), _32@Mir(bb10[1])
  _24 = move _30
  using: _30@Mir(bb10[2])
  goto -> bb11
  using: 
bb11:
  switchInt(move _24) -> [0: bb25, otherwise: bb17]
  using: _24@Phi(bb11)
bb12:
  _25 = const true
  using: 
  goto -> bb14
  using: 
bb13:
  _29 = _3
  using: _3@Entry
  _28 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _29) -> bb16
  using: _29@Mir(bb13[0])
bb14:
  switchInt(move _25) -> [0: bb10, otherwise: bb9]
  using: _25@Phi(bb14)
bb15:
  switchInt(move _26) -> [0: bb13, otherwise: bb12]
  using: _26@Mir(bb8[1])
bb16:
  _25 = move _28
  using: _28@Mir(bb13[1])
  goto -> bb14
  using: 
bb17:
  _35 = _1
  using: _1@Phi(bb4)
  _34 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _35) -> bb18
  using: _35@Mir(bb17[0])
bb18:
  _33 = Not(move _34)
  using: _34@Mir(bb17[1])
  switchInt(move _33) -> [0: bb20, otherwise: bb19]
  using: _33@Mir(bb18[0])
bb19:
  _36 = const 2_i32
  using: 
  (*_1) = Neg(move _36)
  using: _1@Phi(bb4), _36@Mir(bb19[0])
  goto -> bb21
  using: 
bb20:
  _39 = _1
  using: _1@Phi(bb4)
  _38 = move _39 as usize (PointerExposeAddress)
  using: _39@Mir(bb20[0])
  _37 = Eq(move _38, const 0_usize)
  using: _38@Mir(bb20[1])
  assume(move _37)
  using: _37@Mir(bb20[2])
  goto -> bb21
  using: 
bb21:
  _42 = _8
  using: _8@Phi(bb8)
  _41 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _42) -> bb22
  using: _42@Mir(bb21[0])
bb22:
  _40 = Not(move _41)
  using: _41@Mir(bb21[1])
  switchInt(move _40) -> [0: bb24, otherwise: bb23]
  using: _40@Mir(bb22[0])
bb23:
  _43 = const 2_i32
  using: 
  ((*_8).5: i32) = Neg(move _43)
  using: _8@Phi(bb8), _43@Mir(bb23[0])
  goto -> bb92
  using: 
bb24:
  _46 = _8
  using: _8@Phi(bb8)
  _45 = move _46 as usize (PointerExposeAddress)
  using: _46@Mir(bb24[0])
  _44 = Eq(move _45, const 0_usize)
  using: _45@Mir(bb24[1])
  assume(move _44)
  using: _44@Mir(bb24[2])
  goto -> bb92
  using: 
bb25:
  _47 = ((*_8).3: u8)
  using: _8@Phi(bb8)
  switchInt(move _47) -> [0: bb26, otherwise: bb27]
  using: _47@Mir(bb25[0])
bb26:
  _50 = _1
  using: _1@Phi(bb21)
  _49 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _50) -> bb28
  using: _50@Mir(bb26[0])
bb27:
  _63 = ((*_8).0: *mut blocksort::__sFILE)
  using: _8@Phi(bb8)
  _62 = bzlib::ferror(move _63) -> bb35
  using: _63@Mir(bb27[0])
bb28:
  _48 = Not(move _49)
  using: _49@Mir(bb26[1])
  switchInt(move _48) -> [0: bb30, otherwise: bb29]
  using: _48@Mir(bb28[0])
bb29:
  _51 = const 1_i32
  using: 
  (*_1) = Neg(move _51)
  using: _1@Phi(bb21), _51@Mir(bb29[0])
  goto -> bb31
  using: 
bb30:
  _54 = _1
  using: _1@Phi(bb21)
  _53 = move _54 as usize (PointerExposeAddress)
  using: _54@Mir(bb30[0])
  _52 = Eq(move _53, const 0_usize)
  using: _53@Mir(bb30[1])
  assume(move _52)
  using: _52@Mir(bb30[2])
  goto -> bb31
  using: 
bb31:
  _57 = _8
  using: _8@Phi(bb8)
  _56 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _57) -> bb32
  using: _57@Mir(bb31[0])
bb32:
  _55 = Not(move _56)
  using: _56@Mir(bb31[1])
  switchInt(move _55) -> [0: bb34, otherwise: bb33]
  using: _55@Mir(bb32[0])
bb33:
  _58 = const 1_i32
  using: 
  ((*_8).5: i32) = Neg(move _58)
  using: _8@Phi(bb8), _58@Mir(bb33[0])
  goto -> bb92
  using: 
bb34:
  _61 = _8
  using: _8@Phi(bb8)
  _60 = move _61 as usize (PointerExposeAddress)
  using: _61@Mir(bb34[0])
  _59 = Eq(move _60, const 0_usize)
  using: _60@Mir(bb34[1])
  assume(move _59)
  using: _59@Mir(bb34[2])
  goto -> bb92
  using: 
bb35:
  switchInt(move _62) -> [0: bb44, otherwise: bb36]
  using: _62@Mir(bb27[1])
bb36:
  _66 = _1
  using: _1@Phi(bb31)
  _65 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _66) -> bb37
  using: _66@Mir(bb36[0])
bb37:
  _64 = Not(move _65)
  using: _65@Mir(bb36[1])
  switchInt(move _64) -> [0: bb39, otherwise: bb38]
  using: _64@Mir(bb37[0])
bb38:
  _67 = const 6_i32
  using: 
  (*_1) = Neg(move _67)
  using: _1@Phi(bb31), _67@Mir(bb38[0])
  goto -> bb40
  using: 
bb39:
  _70 = _1
  using: _1@Phi(bb31)
  _69 = move _70 as usize (PointerExposeAddress)
  using: _70@Mir(bb39[0])
  _68 = Eq(move _69, const 0_usize)
  using: _69@Mir(bb39[1])
  assume(move _68)
  using: _68@Mir(bb39[2])
  goto -> bb40
  using: 
bb40:
  _73 = _8
  using: _8@Phi(bb8)
  _72 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _73) -> bb41
  using: _73@Mir(bb40[0])
bb41:
  _71 = Not(move _72)
  using: _72@Mir(bb40[1])
  switchInt(move _71) -> [0: bb43, otherwise: bb42]
  using: _71@Mir(bb41[0])
bb42:
  _74 = const 6_i32
  using: 
  ((*_8).5: i32) = Neg(move _74)
  using: _8@Phi(bb8), _74@Mir(bb42[0])
  goto -> bb92
  using: 
bb43:
  _77 = _8
  using: _8@Phi(bb8)
  _76 = move _77 as usize (PointerExposeAddress)
  using: _77@Mir(bb43[0])
  _75 = Eq(move _76, const 0_usize)
  using: _76@Mir(bb43[1])
  assume(move _75)
  using: _75@Mir(bb43[2])
  goto -> bb92
  using: 
bb44:
  _79 = _4
  using: _4@Phi(bb11)
  _80 = const 0_i32
  using: 
  _78 = Eq(move _79, move _80)
  using: _79@Mir(bb44[0]), _80@Mir(bb44[1])
  switchInt(move _78) -> [0: bb46, otherwise: bb45]
  using: _78@Mir(bb44[2])
bb45:
  _83 = _1
  using: _1@Phi(bb40)
  _82 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _83) -> bb47
  using: _83@Mir(bb45[0])
bb46:
  _95 = _4
  using: _4@Phi(bb11)
  (((*_8).4: blocksort::bz_stream).1: u32) = move _95 as u32 (IntToInt)
  using: _8@Phi(bb8), _95@Mir(bb46[0])
  _96 = _3
  using: _3@Phi(bb14)
  (((*_8).4: blocksort::bz_stream).0: *mut i8) = move _96 as *mut i8 (PtrToPtr)
  using: _8@Phi(bb8), _96@Mir(bb46[2])
  goto -> bb54
  using: 
bb47:
  _81 = Not(move _82)
  using: _82@Mir(bb45[1])
  switchInt(move _81) -> [0: bb49, otherwise: bb48]
  using: _81@Mir(bb47[0])
bb48:
  _84 = const 0_i32
  using: 
  (*_1) = move _84
  using: _1@Phi(bb40), _84@Mir(bb48[0])
  goto -> bb50
  using: 
bb49:
  _87 = _1
  using: _1@Phi(bb40)
  _86 = move _87 as usize (PointerExposeAddress)
  using: _87@Mir(bb49[0])
  _85 = Eq(move _86, const 0_usize)
  using: _86@Mir(bb49[1])
  assume(move _85)
  using: _85@Mir(bb49[2])
  goto -> bb50
  using: 
bb50:
  _90 = _8
  using: _8@Phi(bb8)
  _89 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _90) -> bb51
  using: _90@Mir(bb50[0])
bb51:
  _88 = Not(move _89)
  using: _89@Mir(bb50[1])
  switchInt(move _88) -> [0: bb53, otherwise: bb52]
  using: _88@Mir(bb51[0])
bb52:
  _91 = const 0_i32
  using: 
  ((*_8).5: i32) = move _91
  using: _8@Phi(bb8), _91@Mir(bb52[0])
  goto -> bb92
  using: 
bb53:
  _94 = _8
  using: _8@Phi(bb8)
  _93 = move _94 as usize (PointerExposeAddress)
  using: _94@Mir(bb53[0])
  _92 = Eq(move _93, const 0_usize)
  using: _93@Mir(bb53[1])
  assume(move _92)
  using: _92@Mir(bb53[2])
  goto -> bb92
  using: 
bb54:
  _97 = const 5000_i32
  using: 
  (((*_8).4: blocksort::bz_stream).5: u32) = move _97 as u32 (IntToInt)
  using: _8@Phi(bb54), _97@Mir(bb54[0])
  _100 = &mut ((*_8).1: [i8; 5000])
  using: _8@Phi(bb54)
  _99 = move _100 as &mut [i8] (Pointer(Unsize))
  using: _100@Mir(bb54[2])
  _98 = core::slice::<impl [i8]>::as_mut_ptr(move _99) -> bb55
  using: _99@Mir(bb54[3])
bb55:
  (((*_8).4: blocksort::bz_stream).4: *mut i8) = move _98
  using: _8@Phi(bb54), _98@Mir(bb54[4])
  _103 = &mut ((*_8).4: blocksort::bz_stream)
  using: _8@Phi(bb54)
  _102 = &raw mut (*_103)
  using: _103@Mir(bb55[1])
  _104 = const 0_i32
  using: 
  _101 = bzlib::BZ2_bzCompress(move _102, move _104) -> bb56
  using: _102@Mir(bb55[2]), _104@Mir(bb55[3])
bb56:
  _7 = move _101
  using: _101@Mir(bb55[4])
  _106 = _7
  using: _7@Mir(bb56[0])
  _107 = const 1_i32
  using: 
  _105 = Ne(move _106, move _107)
  using: _106@Mir(bb56[1]), _107@Mir(bb56[2])
  switchInt(move _105) -> [0: bb65, otherwise: bb57]
  using: _105@Mir(bb56[3])
bb57:
  _110 = _1
  using: _1@Phi(bb50)
  _109 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _110) -> bb58
  using: _110@Mir(bb57[0])
bb58:
  _108 = Not(move _109)
  using: _109@Mir(bb57[1])
  switchInt(move _108) -> [0: bb60, otherwise: bb59]
  using: _108@Mir(bb58[0])
bb59:
  _111 = _7
  using: _7@Mir(bb56[0])
  (*_1) = move _111
  using: _1@Phi(bb50), _111@Mir(bb59[0])
  goto -> bb61
  using: 
bb60:
  _114 = _1
  using: _1@Phi(bb50)
  _113 = move _114 as usize (PointerExposeAddress)
  using: _114@Mir(bb60[0])
  _112 = Eq(move _113, const 0_usize)
  using: _113@Mir(bb60[1])
  assume(move _112)
  using: _112@Mir(bb60[2])
  goto -> bb61
  using: 
bb61:
  _117 = _8
  using: _8@Phi(bb54)
  _116 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _117) -> bb62
  using: _117@Mir(bb61[0])
bb62:
  _115 = Not(move _116)
  using: _116@Mir(bb61[1])
  switchInt(move _115) -> [0: bb64, otherwise: bb63]
  using: _115@Mir(bb62[0])
bb63:
  _118 = _7
  using: _7@Phi(bb61)
  ((*_8).5: i32) = move _118
  using: _8@Phi(bb54), _118@Mir(bb63[0])
  goto -> bb92
  using: 
bb64:
  _121 = _8
  using: _8@Phi(bb54)
  _120 = move _121 as usize (PointerExposeAddress)
  using: _121@Mir(bb64[0])
  _119 = Eq(move _120, const 0_usize)
  using: _120@Mir(bb64[1])
  assume(move _119)
  using: _119@Mir(bb64[2])
  goto -> bb92
  using: 
bb65:
  _123 = (((*_8).4: blocksort::bz_stream).5: u32)
  using: _8@Phi(bb54)
  _124 = const 5000_u32
  using: 
  _122 = Lt(move _123, move _124)
  using: _123@Mir(bb65[0]), _124@Mir(bb65[1])
  switchInt(move _122) -> [0: bb83, otherwise: bb66]
  using: _122@Mir(bb65[2])
bb66:
  _126 = const 5000_u32
  using: 
  _127 = (((*_8).4: blocksort::bz_stream).5: u32)
  using: _8@Phi(bb54)
  _125 = core::num::<impl u32>::wrapping_sub(move _126, move _127) -> bb67
  using: _126@Mir(bb66[0]), _127@Mir(bb66[1])
bb67:
  _5 = move _125 as i32 (IntToInt)
  using: _125@Mir(bb66[2])
  _133 = &mut ((*_8).1: [i8; 5000])
  using: _8@Phi(bb54)
  _132 = move _133 as &mut [i8] (Pointer(Unsize))
  using: _133@Mir(bb67[1])
  _131 = core::slice::<impl [i8]>::as_mut_ptr(move _132) -> bb68
  using: _132@Mir(bb67[2])
bb68:
  _130 = move _131 as *mut std::ffi::c_void (PtrToPtr)
  using: _131@Mir(bb67[3])
  _129 = move _130 as *const std::ffi::c_void (Pointer(MutToConstPointer))
  using: _130@Mir(bb68[0])
  _135 = std::mem::size_of::<u8>() -> bb69
  using: 
bb69:
  _134 = move _135 as u64 (IntToInt)
  using: _135@Mir(bb68[2])
  _137 = _5
  using: _5@Mir(bb67[0])
  _136 = move _137 as u64 (IntToInt)
  using: _137@Mir(bb69[1])
  _138 = ((*_8).0: *mut blocksort::__sFILE)
  using: _8@Phi(bb54)
  _128 = bzlib::fwrite(move _129, move _134, move _136, move _138) -> bb70
  using: _129@Mir(bb68[1]), _134@Mir(bb69[0]), _136@Mir(bb69[2]), _138@Mir(bb69[3])
bb70:
  _6 = move _128 as i32 (IntToInt)
  using: _128@Mir(bb69[4])
  _141 = _5
  using: _5@Mir(bb67[0])
  _142 = _6
  using: _6@Mir(bb70[0])
  _140 = Ne(move _141, move _142)
  using: _141@Mir(bb70[1]), _142@Mir(bb70[2])
  switchInt(move _140) -> [0: bb72, otherwise: bb71]
  using: _140@Mir(bb70[3])
bb71:
  _139 = const true
  using: 
  goto -> bb73
  using: 
bb72:
  _145 = ((*_8).0: *mut blocksort::__sFILE)
  using: _8@Phi(bb54)
  _144 = bzlib::ferror(move _145) -> bb74
  using: _145@Mir(bb72[0])
bb73:
  switchInt(move _139) -> [0: bb83, otherwise: bb75]
  using: _139@Phi(bb73)
bb74:
  _143 = Ne(move _144, const 0_i32)
  using: _144@Mir(bb72[1])
  _139 = move _143
  using: _143@Mir(bb74[0])
  goto -> bb73
  using: 
bb75:
  _148 = _1
  using: _1@Phi(bb61)
  _147 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _148) -> bb76
  using: _148@Mir(bb75[0])
bb76:
  _146 = Not(move _147)
  using: _147@Mir(bb75[1])
  switchInt(move _146) -> [0: bb78, otherwise: bb77]
  using: _146@Mir(bb76[0])
bb77:
  _149 = const 6_i32
  using: 
  (*_1) = Neg(move _149)
  using: _1@Phi(bb61), _149@Mir(bb77[0])
  goto -> bb79
  using: 
bb78:
  _152 = _1
  using: _1@Phi(bb61)
  _151 = move _152 as usize (PointerExposeAddress)
  using: _152@Mir(bb78[0])
  _150 = Eq(move _151, const 0_usize)
  using: _151@Mir(bb78[1])
  assume(move _150)
  using: _150@Mir(bb78[2])
  goto -> bb79
  using: 
bb79:
  _155 = _8
  using: _8@Phi(bb73)
  _154 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _155) -> bb80
  using: _155@Mir(bb79[0])
bb80:
  _153 = Not(move _154)
  using: _154@Mir(bb79[1])
  switchInt(move _153) -> [0: bb82, otherwise: bb81]
  using: _153@Mir(bb80[0])
bb81:
  _156 = const 6_i32
  using: 
  ((*_8).5: i32) = Neg(move _156)
  using: _8@Phi(bb73), _156@Mir(bb81[0])
  goto -> bb92
  using: 
bb82:
  _159 = _8
  using: _8@Phi(bb73)
  _158 = move _159 as usize (PointerExposeAddress)
  using: _159@Mir(bb82[0])
  _157 = Eq(move _158, const 0_usize)
  using: _158@Mir(bb82[1])
  assume(move _157)
  using: _157@Mir(bb82[2])
  goto -> bb92
  using: 
bb83:
  _161 = (((*_8).4: blocksort::bz_stream).1: u32)
  using: _8@Phi(bb83)
  _162 = const 0_u32
  using: 
  _160 = Eq(move _161, move _162)
  using: _161@Mir(bb83[0]), _162@Mir(bb83[1])
  switchInt(move _160) -> [0: bb54, otherwise: bb84]
  using: _160@Mir(bb83[2])
bb84:
  _165 = _1
  using: _1@Phi(bb79)
  _164 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _165) -> bb85
  using: _165@Mir(bb84[0])
bb85:
  _163 = Not(move _164)
  using: _164@Mir(bb84[1])
  switchInt(move _163) -> [0: bb87, otherwise: bb86]
  using: _163@Mir(bb85[0])
bb86:
  _166 = const 0_i32
  using: 
  (*_1) = move _166
  using: _1@Phi(bb79), _166@Mir(bb86[0])
  goto -> bb88
  using: 
bb87:
  _169 = _1
  using: _1@Phi(bb79)
  _168 = move _169 as usize (PointerExposeAddress)
  using: _169@Mir(bb87[0])
  _167 = Eq(move _168, const 0_usize)
  using: _168@Mir(bb87[1])
  assume(move _167)
  using: _167@Mir(bb87[2])
  goto -> bb88
  using: 
bb88:
  _172 = _8
  using: _8@Phi(bb83)
  _171 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _172) -> bb89
  using: _172@Mir(bb88[0])
bb89:
  _170 = Not(move _171)
  using: _171@Mir(bb88[1])
  switchInt(move _170) -> [0: bb91, otherwise: bb90]
  using: _170@Mir(bb89[0])
bb90:
  _173 = const 0_i32
  using: 
  ((*_8).5: i32) = move _173
  using: _8@Phi(bb83), _173@Mir(bb90[0])
  goto -> bb92
  using: 
bb91:
  _176 = _8
  using: _8@Phi(bb83)
  _175 = move _176 as usize (PointerExposeAddress)
  using: _176@Mir(bb91[0])
  _174 = Eq(move _175, const 0_usize)
  using: _175@Mir(bb91[1])
  assume(move _174)
  using: _174@Mir(bb91[2])
  goto -> bb92
  using: 
bb92:
  return
  using: _0@Entry
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1754:8: 1754:29 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:1778:44: 1778:79 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:1782:24: 1782:54 (#0) by default
rewrite call bzlib::fwrite @ workspace/bzip2/rust/bzlib.rs:1781:17: 1783:66 (#0) by default
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1784:27: 1784:48 (#0) by default
@DefId(0:382 ~ c2rust_lib[1043]::bzlib::BZ2_bzWriteClose)
bb0:
  _7 = _1
  using: _1@Entry
  _8 = _2
  using: _2@Entry
  _9 = _3
  using: _3@Entry
  _10 = _4
  using: _4@Entry
  _11 = const {0x0 as *mut u32}
  using: 
  _12 = _5
  using: _5@Entry
  _13 = const {0x0 as *mut u32}
  using: 
  _6 = bzlib::BZ2_bzWriteClose64(move _7, move _8, move _9, move _10, move _11, move _12, move _13) -> bb1
  using: _7@Mir(bb0[0]), _8@Mir(bb0[1]), _9@Mir(bb0[2]), _10@Mir(bb0[3]), _11@Mir(bb0[4]), _12@Mir(bb0[5]), _13@Mir(bb0[6])
bb1:
  return
  using: _0@Entry
@DefId(0:383 ~ c2rust_lib[1043]::bzlib::BZ2_bzWriteClose64)
bb0:
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _12 = _2
  using: _2@Entry
  _11 = move _12 as *mut bzlib::bzFile (PtrToPtr)
  using: _12@Mir(bb0[3])
  _14 = _11
  using: _11@Mir(bb0[4])
  _13 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _14) -> bb1
  using: _14@Mir(bb0[5])
bb1:
  switchInt(move _13) -> [0: bb10, otherwise: bb2]
  using: _13@Mir(bb0[6])
bb2:
  _17 = _11
  using: _11@Mir(bb0[4])
  _16 = move _17 as usize (PointerExposeAddress)
  using: _17@Mir(bb2[0])
  _15 = Eq(move _16, const 0_usize)
  using: _16@Mir(bb2[1])
  assume(move _15)
  using: _15@Mir(bb2[2])
  _20 = _1
  using: _1@Entry
  _19 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _20) -> bb3
  using: _20@Mir(bb2[4])
bb3:
  _18 = Not(move _19)
  using: _19@Mir(bb2[5])
  switchInt(move _18) -> [0: bb5, otherwise: bb4]
  using: _18@Mir(bb3[0])
bb4:
  _21 = const 0_i32
  using: 
  (*_1) = move _21
  using: _1@Entry, _21@Mir(bb4[0])
  goto -> bb6
  using: 
bb5:
  _24 = _1
  using: _1@Entry
  _23 = move _24 as usize (PointerExposeAddress)
  using: _24@Mir(bb5[0])
  _22 = Eq(move _23, const 0_usize)
  using: _23@Mir(bb5[1])
  assume(move _22)
  using: _22@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  _27 = _11
  using: _11@Mir(bb0[4])
  _26 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _27) -> bb7
  using: _27@Mir(bb6[0])
bb7:
  _25 = Not(move _26)
  using: _26@Mir(bb6[1])
  switchInt(move _25) -> [0: bb9, otherwise: bb8]
  using: _25@Mir(bb7[0])
bb8:
  _28 = const 0_i32
  using: 
  ((*_11).5: i32) = move _28
  using: _11@Mir(bb0[4]), _28@Mir(bb8[0])
  goto -> bb124
  using: 
bb9:
  _31 = _11
  using: _11@Mir(bb0[4])
  _30 = move _31 as usize (PointerExposeAddress)
  using: _31@Mir(bb9[0])
  _29 = Eq(move _30, const 0_usize)
  using: _30@Mir(bb9[1])
  assume(move _29)
  using: _29@Mir(bb9[2])
  goto -> bb124
  using: 
bb10:
  _32 = ((*_11).3: u8)
  using: _11@Mir(bb0[4])
  switchInt(move _32) -> [0: bb11, otherwise: bb12]
  using: _32@Mir(bb10[0])
bb11:
  _35 = _1
  using: _1@Phi(bb6)
  _34 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _35) -> bb13
  using: _35@Mir(bb11[0])
bb12:
  _48 = ((*_11).0: *mut blocksort::__sFILE)
  using: _11@Mir(bb0[4])
  _47 = bzlib::ferror(move _48) -> bb20
  using: _48@Mir(bb12[0])
bb13:
  _33 = Not(move _34)
  using: _34@Mir(bb11[1])
  switchInt(move _33) -> [0: bb15, otherwise: bb14]
  using: _33@Mir(bb13[0])
bb14:
  _36 = const 1_i32
  using: 
  (*_1) = Neg(move _36)
  using: _1@Phi(bb6), _36@Mir(bb14[0])
  goto -> bb16
  using: 
bb15:
  _39 = _1
  using: _1@Phi(bb6)
  _38 = move _39 as usize (PointerExposeAddress)
  using: _39@Mir(bb15[0])
  _37 = Eq(move _38, const 0_usize)
  using: _38@Mir(bb15[1])
  assume(move _37)
  using: _37@Mir(bb15[2])
  goto -> bb16
  using: 
bb16:
  _42 = _11
  using: _11@Mir(bb0[4])
  _41 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _42) -> bb17
  using: _42@Mir(bb16[0])
bb17:
  _40 = Not(move _41)
  using: _41@Mir(bb16[1])
  switchInt(move _40) -> [0: bb19, otherwise: bb18]
  using: _40@Mir(bb17[0])
bb18:
  _43 = const 1_i32
  using: 
  ((*_11).5: i32) = Neg(move _43)
  using: _11@Mir(bb0[4]), _43@Mir(bb18[0])
  goto -> bb124
  using: 
bb19:
  _46 = _11
  using: _11@Mir(bb0[4])
  _45 = move _46 as usize (PointerExposeAddress)
  using: _46@Mir(bb19[0])
  _44 = Eq(move _45, const 0_usize)
  using: _45@Mir(bb19[1])
  assume(move _44)
  using: _44@Mir(bb19[2])
  goto -> bb124
  using: 
bb20:
  switchInt(move _47) -> [0: bb29, otherwise: bb21]
  using: _47@Mir(bb12[1])
bb21:
  _51 = _1
  using: _1@Phi(bb16)
  _50 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _51) -> bb22
  using: _51@Mir(bb21[0])
bb22:
  _49 = Not(move _50)
  using: _50@Mir(bb21[1])
  switchInt(move _49) -> [0: bb24, otherwise: bb23]
  using: _49@Mir(bb22[0])
bb23:
  _52 = const 6_i32
  using: 
  (*_1) = Neg(move _52)
  using: _1@Phi(bb16), _52@Mir(bb23[0])
  goto -> bb25
  using: 
bb24:
  _55 = _1
  using: _1@Phi(bb16)
  _54 = move _55 as usize (PointerExposeAddress)
  using: _55@Mir(bb24[0])
  _53 = Eq(move _54, const 0_usize)
  using: _54@Mir(bb24[1])
  assume(move _53)
  using: _53@Mir(bb24[2])
  goto -> bb25
  using: 
bb25:
  _58 = _11
  using: _11@Mir(bb0[4])
  _57 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _58) -> bb26
  using: _58@Mir(bb25[0])
bb26:
  _56 = Not(move _57)
  using: _57@Mir(bb25[1])
  switchInt(move _56) -> [0: bb28, otherwise: bb27]
  using: _56@Mir(bb26[0])
bb27:
  _59 = const 6_i32
  using: 
  ((*_11).5: i32) = Neg(move _59)
  using: _11@Mir(bb0[4]), _59@Mir(bb27[0])
  goto -> bb124
  using: 
bb28:
  _62 = _11
  using: _11@Mir(bb0[4])
  _61 = move _62 as usize (PointerExposeAddress)
  using: _62@Mir(bb28[0])
  _60 = Eq(move _61, const 0_usize)
  using: _61@Mir(bb28[1])
  assume(move _60)
  using: _60@Mir(bb28[2])
  goto -> bb124
  using: 
bb29:
  _65 = _4
  using: _4@Entry
  _64 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _65) -> bb30
  using: _65@Mir(bb29[0])
bb30:
  _63 = Not(move _64)
  using: _64@Mir(bb29[1])
  switchInt(move _63) -> [0: bb32, otherwise: bb31]
  using: _63@Mir(bb30[0])
bb31:
  _66 = const 0_i32
  using: 
  (*_4) = move _66 as u32 (IntToInt)
  using: _4@Entry, _66@Mir(bb31[0])
  goto -> bb33
  using: 
bb32:
  _69 = _4
  using: _4@Entry
  _68 = move _69 as usize (PointerExposeAddress)
  using: _69@Mir(bb32[0])
  _67 = Eq(move _68, const 0_usize)
  using: _68@Mir(bb32[1])
  assume(move _67)
  using: _67@Mir(bb32[2])
  goto -> bb33
  using: 
bb33:
  _72 = _5
  using: _5@Entry
  _71 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _72) -> bb34
  using: _72@Mir(bb33[0])
bb34:
  _70 = Not(move _71)
  using: _71@Mir(bb33[1])
  switchInt(move _70) -> [0: bb36, otherwise: bb35]
  using: _70@Mir(bb34[0])
bb35:
  _73 = const 0_i32
  using: 
  (*_5) = move _73 as u32 (IntToInt)
  using: _5@Entry, _73@Mir(bb35[0])
  goto -> bb37
  using: 
bb36:
  _76 = _5
  using: _5@Entry
  _75 = move _76 as usize (PointerExposeAddress)
  using: _76@Mir(bb36[0])
  _74 = Eq(move _75, const 0_usize)
  using: _75@Mir(bb36[1])
  assume(move _74)
  using: _74@Mir(bb36[2])
  goto -> bb37
  using: 
bb37:
  _79 = _6
  using: _6@Entry
  _78 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _79) -> bb38
  using: _79@Mir(bb37[0])
bb38:
  _77 = Not(move _78)
  using: _78@Mir(bb37[1])
  switchInt(move _77) -> [0: bb40, otherwise: bb39]
  using: _77@Mir(bb38[0])
bb39:
  _80 = const 0_i32
  using: 
  (*_6) = move _80 as u32 (IntToInt)
  using: _6@Entry, _80@Mir(bb39[0])
  goto -> bb41
  using: 
bb40:
  _83 = _6
  using: _6@Entry
  _82 = move _83 as usize (PointerExposeAddress)
  using: _83@Mir(bb40[0])
  _81 = Eq(move _82, const 0_usize)
  using: _82@Mir(bb40[1])
  assume(move _81)
  using: _81@Mir(bb40[2])
  goto -> bb41
  using: 
bb41:
  _86 = _7
  using: _7@Entry
  _85 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _86) -> bb42
  using: _86@Mir(bb41[0])
bb42:
  _84 = Not(move _85)
  using: _85@Mir(bb41[1])
  switchInt(move _84) -> [0: bb44, otherwise: bb43]
  using: _84@Mir(bb42[0])
bb43:
  _87 = const 0_i32
  using: 
  (*_7) = move _87 as u32 (IntToInt)
  using: _7@Entry, _87@Mir(bb43[0])
  goto -> bb45
  using: 
bb44:
  _90 = _7
  using: _7@Entry
  _89 = move _90 as usize (PointerExposeAddress)
  using: _90@Mir(bb44[0])
  _88 = Eq(move _89, const 0_usize)
  using: _89@Mir(bb44[1])
  assume(move _88)
  using: _88@Mir(bb44[2])
  goto -> bb45
  using: 
bb45:
  _92 = _3
  using: _3@Entry
  switchInt(move _92) -> [0: bb47, otherwise: bb46]
  using: _92@Mir(bb45[0])
bb46:
  _91 = const false
  using: 
  goto -> bb48
  using: 
bb47:
  _94 = ((*_11).5: i32)
  using: _11@Mir(bb0[4])
  _95 = const 0_i32
  using: 
  _93 = Eq(move _94, move _95)
  using: _94@Mir(bb47[0]), _95@Mir(bb47[1])
  _91 = move _93
  using: _93@Mir(bb47[2])
  goto -> bb48
  using: 
bb48:
  switchInt(move _91) -> [0: bb82, otherwise: bb49]
  using: _91@Phi(bb48)
bb49:
  _96 = const 5000_i32
  using: 
  (((*_11).4: blocksort::bz_stream).5: u32) = move _96 as u32 (IntToInt)
  using: _11@Phi(bb49), _96@Mir(bb49[0])
  _99 = &mut ((*_11).1: [i8; 5000])
  using: _11@Phi(bb49)
  _98 = move _99 as &mut [i8] (Pointer(Unsize))
  using: _99@Mir(bb49[2])
  _97 = core::slice::<impl [i8]>::as_mut_ptr(move _98) -> bb50
  using: _98@Mir(bb49[3])
bb50:
  (((*_11).4: blocksort::bz_stream).4: *mut i8) = move _97
  using: _11@Phi(bb49), _97@Mir(bb49[4])
  _102 = &mut ((*_11).4: blocksort::bz_stream)
  using: _11@Phi(bb49)
  _101 = &raw mut (*_102)
  using: _102@Mir(bb50[1])
  _103 = const 2_i32
  using: 
  _100 = bzlib::BZ2_bzCompress(move _101, move _103) -> bb51
  using: _101@Mir(bb50[2]), _103@Mir(bb50[3])
bb51:
  _10 = move _100
  using: _100@Mir(bb50[4])
  _106 = _10
  using: _10@Mir(bb51[0])
  _107 = const 3_i32
  using: 
  _105 = Ne(move _106, move _107)
  using: _106@Mir(bb51[1]), _107@Mir(bb51[2])
  switchInt(move _105) -> [0: bb52, otherwise: bb53]
  using: _105@Mir(bb51[3])
bb52:
  _104 = const false
  using: 
  goto -> bb54
  using: 
bb53:
  _109 = _10
  using: _10@Mir(bb51[0])
  _110 = const 4_i32
  using: 
  _108 = Ne(move _109, move _110)
  using: _109@Mir(bb53[0]), _110@Mir(bb53[1])
  _104 = move _108
  using: _108@Mir(bb53[2])
  goto -> bb54
  using: 
bb54:
  switchInt(move _104) -> [0: bb63, otherwise: bb55]
  using: _104@Phi(bb54)
bb55:
  _113 = _1
  using: _1@Phi(bb25)
  _112 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _113) -> bb56
  using: _113@Mir(bb55[0])
bb56:
  _111 = Not(move _112)
  using: _112@Mir(bb55[1])
  switchInt(move _111) -> [0: bb58, otherwise: bb57]
  using: _111@Mir(bb56[0])
bb57:
  _114 = _10
  using: _10@Phi(bb54)
  (*_1) = move _114
  using: _1@Phi(bb25), _114@Mir(bb57[0])
  goto -> bb59
  using: 
bb58:
  _117 = _1
  using: _1@Phi(bb25)
  _116 = move _117 as usize (PointerExposeAddress)
  using: _117@Mir(bb58[0])
  _115 = Eq(move _116, const 0_usize)
  using: _116@Mir(bb58[1])
  assume(move _115)
  using: _115@Mir(bb58[2])
  goto -> bb59
  using: 
bb59:
  _120 = _11
  using: _11@Phi(bb49)
  _119 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _120) -> bb60
  using: _120@Mir(bb59[0])
bb60:
  _118 = Not(move _119)
  using: _119@Mir(bb59[1])
  switchInt(move _118) -> [0: bb62, otherwise: bb61]
  using: _118@Mir(bb60[0])
bb61:
  _121 = _10
  using: _10@Phi(bb59)
  ((*_11).5: i32) = move _121
  using: _11@Phi(bb49), _121@Mir(bb61[0])
  goto -> bb124
  using: 
bb62:
  _124 = _11
  using: _11@Phi(bb49)
  _123 = move _124 as usize (PointerExposeAddress)
  using: _124@Mir(bb62[0])
  _122 = Eq(move _123, const 0_usize)
  using: _123@Mir(bb62[1])
  assume(move _122)
  using: _122@Mir(bb62[2])
  goto -> bb124
  using: 
bb63:
  _126 = (((*_11).4: blocksort::bz_stream).5: u32)
  using: _11@Phi(bb49)
  _127 = const 5000_u32
  using: 
  _125 = Lt(move _126, move _127)
  using: _126@Mir(bb63[0]), _127@Mir(bb63[1])
  switchInt(move _125) -> [0: bb81, otherwise: bb64]
  using: _125@Mir(bb63[2])
bb64:
  _129 = const 5000_u32
  using: 
  _130 = (((*_11).4: blocksort::bz_stream).5: u32)
  using: _11@Phi(bb49)
  _128 = core::num::<impl u32>::wrapping_sub(move _129, move _130) -> bb65
  using: _129@Mir(bb64[0]), _130@Mir(bb64[1])
bb65:
  _8 = move _128 as i32 (IntToInt)
  using: _128@Mir(bb64[2])
  _136 = &mut ((*_11).1: [i8; 5000])
  using: _11@Phi(bb49)
  _135 = move _136 as &mut [i8] (Pointer(Unsize))
  using: _136@Mir(bb65[1])
  _134 = core::slice::<impl [i8]>::as_mut_ptr(move _135) -> bb66
  using: _135@Mir(bb65[2])
bb66:
  _133 = move _134 as *mut std::ffi::c_void (PtrToPtr)
  using: _134@Mir(bb65[3])
  _132 = move _133 as *const std::ffi::c_void (Pointer(MutToConstPointer))
  using: _133@Mir(bb66[0])
  _138 = std::mem::size_of::<u8>() -> bb67
  using: 
bb67:
  _137 = move _138 as u64 (IntToInt)
  using: _138@Mir(bb66[2])
  _140 = _8
  using: _8@Mir(bb65[0])
  _139 = move _140 as u64 (IntToInt)
  using: _140@Mir(bb67[1])
  _141 = ((*_11).0: *mut blocksort::__sFILE)
  using: _11@Phi(bb49)
  _131 = bzlib::fwrite(move _132, move _137, move _139, move _141) -> bb68
  using: _132@Mir(bb66[1]), _137@Mir(bb67[0]), _139@Mir(bb67[2]), _141@Mir(bb67[3])
bb68:
  _9 = move _131 as i32 (IntToInt)
  using: _131@Mir(bb67[4])
  _144 = _8
  using: _8@Mir(bb65[0])
  _145 = _9
  using: _9@Mir(bb68[0])
  _143 = Ne(move _144, move _145)
  using: _144@Mir(bb68[1]), _145@Mir(bb68[2])
  switchInt(move _143) -> [0: bb70, otherwise: bb69]
  using: _143@Mir(bb68[3])
bb69:
  _142 = const true
  using: 
  goto -> bb71
  using: 
bb70:
  _148 = ((*_11).0: *mut blocksort::__sFILE)
  using: _11@Phi(bb49)
  _147 = bzlib::ferror(move _148) -> bb72
  using: _148@Mir(bb70[0])
bb71:
  switchInt(move _142) -> [0: bb81, otherwise: bb73]
  using: _142@Phi(bb71)
bb72:
  _146 = Ne(move _147, const 0_i32)
  using: _147@Mir(bb70[1])
  _142 = move _146
  using: _146@Mir(bb72[0])
  goto -> bb71
  using: 
bb73:
  _151 = _1
  using: _1@Phi(bb59)
  _150 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _151) -> bb74
  using: _151@Mir(bb73[0])
bb74:
  _149 = Not(move _150)
  using: _150@Mir(bb73[1])
  switchInt(move _149) -> [0: bb76, otherwise: bb75]
  using: _149@Mir(bb74[0])
bb75:
  _152 = const 6_i32
  using: 
  (*_1) = Neg(move _152)
  using: _1@Phi(bb59), _152@Mir(bb75[0])
  goto -> bb77
  using: 
bb76:
  _155 = _1
  using: _1@Phi(bb59)
  _154 = move _155 as usize (PointerExposeAddress)
  using: _155@Mir(bb76[0])
  _153 = Eq(move _154, const 0_usize)
  using: _154@Mir(bb76[1])
  assume(move _153)
  using: _153@Mir(bb76[2])
  goto -> bb77
  using: 
bb77:
  _158 = _11
  using: _11@Phi(bb71)
  _157 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _158) -> bb78
  using: _158@Mir(bb77[0])
bb78:
  _156 = Not(move _157)
  using: _157@Mir(bb77[1])
  switchInt(move _156) -> [0: bb80, otherwise: bb79]
  using: _156@Mir(bb78[0])
bb79:
  _159 = const 6_i32
  using: 
  ((*_11).5: i32) = Neg(move _159)
  using: _11@Phi(bb71), _159@Mir(bb79[0])
  goto -> bb124
  using: 
bb80:
  _162 = _11
  using: _11@Phi(bb71)
  _161 = move _162 as usize (PointerExposeAddress)
  using: _162@Mir(bb80[0])
  _160 = Eq(move _161, const 0_usize)
  using: _161@Mir(bb80[1])
  assume(move _160)
  using: _160@Mir(bb80[2])
  goto -> bb124
  using: 
bb81:
  _164 = _10
  using: _10@Phi(bb59)
  _165 = const 4_i32
  using: 
  _163 = Eq(move _164, move _165)
  using: _164@Mir(bb81[0]), _165@Mir(bb81[1])
  switchInt(move _163) -> [0: bb49, otherwise: bb82]
  using: _163@Mir(bb81[2])
bb82:
  _167 = _3
  using: _3@Entry
  switchInt(move _167) -> [0: bb84, otherwise: bb83]
  using: _167@Mir(bb82[0])
bb83:
  _166 = const false
  using: 
  goto -> bb85
  using: 
bb84:
  _170 = ((*_11).0: *mut blocksort::__sFILE)
  using: _11@Phi(bb82)
  _169 = bzlib::ferror(move _170) -> bb86
  using: _170@Mir(bb84[0])
bb85:
  switchInt(move _166) -> [0: bb98, otherwise: bb87]
  using: _166@Phi(bb85)
bb86:
  _168 = Eq(move _169, const 0_i32)
  using: _169@Mir(bb84[1])
  _166 = move _168
  using: _168@Mir(bb86[0])
  goto -> bb85
  using: 
bb87:
  _172 = ((*_11).0: *mut blocksort::__sFILE)
  using: _11@Phi(bb85)
  _171 = bzlib::fflush(move _172) -> bb88
  using: _172@Mir(bb87[0])
bb88:
  _174 = ((*_11).0: *mut blocksort::__sFILE)
  using: _11@Phi(bb85)
  _173 = bzlib::ferror(move _174) -> bb89
  using: _174@Mir(bb88[0])
bb89:
  switchInt(move _173) -> [0: bb98, otherwise: bb90]
  using: _173@Mir(bb88[1])
bb90:
  _177 = _1
  using: _1@Phi(bb77)
  _176 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _177) -> bb91
  using: _177@Mir(bb90[0])
bb91:
  _175 = Not(move _176)
  using: _176@Mir(bb90[1])
  switchInt(move _175) -> [0: bb93, otherwise: bb92]
  using: _175@Mir(bb91[0])
bb92:
  _178 = const 6_i32
  using: 
  (*_1) = Neg(move _178)
  using: _1@Phi(bb77), _178@Mir(bb92[0])
  goto -> bb94
  using: 
bb93:
  _181 = _1
  using: _1@Phi(bb77)
  _180 = move _181 as usize (PointerExposeAddress)
  using: _181@Mir(bb93[0])
  _179 = Eq(move _180, const 0_usize)
  using: _180@Mir(bb93[1])
  assume(move _179)
  using: _179@Mir(bb93[2])
  goto -> bb94
  using: 
bb94:
  _184 = _11
  using: _11@Phi(bb85)
  _183 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _184) -> bb95
  using: _184@Mir(bb94[0])
bb95:
  _182 = Not(move _183)
  using: _183@Mir(bb94[1])
  switchInt(move _182) -> [0: bb97, otherwise: bb96]
  using: _182@Mir(bb95[0])
bb96:
  _185 = const 6_i32
  using: 
  ((*_11).5: i32) = Neg(move _185)
  using: _11@Phi(bb85), _185@Mir(bb96[0])
  goto -> bb124
  using: 
bb97:
  _188 = _11
  using: _11@Phi(bb85)
  _187 = move _188 as usize (PointerExposeAddress)
  using: _188@Mir(bb97[0])
  _186 = Eq(move _187, const 0_usize)
  using: _187@Mir(bb97[1])
  assume(move _186)
  using: _186@Mir(bb97[2])
  goto -> bb124
  using: 
bb98:
  _191 = _4
  using: _4@Phi(bb33)
  _190 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _191) -> bb99
  using: _191@Mir(bb98[0])
bb99:
  _189 = Not(move _190)
  using: _190@Mir(bb98[1])
  switchInt(move _189) -> [0: bb101, otherwise: bb100]
  using: _189@Mir(bb99[0])
bb100:
  _192 = (((*_11).4: blocksort::bz_stream).2: u32)
  using: _11@Phi(bb98)
  (*_4) = move _192
  using: _4@Phi(bb33), _192@Mir(bb100[0])
  goto -> bb102
  using: 
bb101:
  _195 = _4
  using: _4@Phi(bb33)
  _194 = move _195 as usize (PointerExposeAddress)
  using: _195@Mir(bb101[0])
  _193 = Eq(move _194, const 0_usize)
  using: _194@Mir(bb101[1])
  assume(move _193)
  using: _193@Mir(bb101[2])
  goto -> bb102
  using: 
bb102:
  _198 = _5
  using: _5@Phi(bb37)
  _197 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _198) -> bb103
  using: _198@Mir(bb102[0])
bb103:
  _196 = Not(move _197)
  using: _197@Mir(bb102[1])
  switchInt(move _196) -> [0: bb105, otherwise: bb104]
  using: _196@Mir(bb103[0])
bb104:
  _199 = (((*_11).4: blocksort::bz_stream).3: u32)
  using: _11@Phi(bb102)
  (*_5) = move _199
  using: _5@Phi(bb37), _199@Mir(bb104[0])
  goto -> bb106
  using: 
bb105:
  _202 = _5
  using: _5@Phi(bb37)
  _201 = move _202 as usize (PointerExposeAddress)
  using: _202@Mir(bb105[0])
  _200 = Eq(move _201, const 0_usize)
  using: _201@Mir(bb105[1])
  assume(move _200)
  using: _200@Mir(bb105[2])
  goto -> bb106
  using: 
bb106:
  _205 = _6
  using: _6@Phi(bb41)
  _204 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _205) -> bb107
  using: _205@Mir(bb106[0])
bb107:
  _203 = Not(move _204)
  using: _204@Mir(bb106[1])
  switchInt(move _203) -> [0: bb109, otherwise: bb108]
  using: _203@Mir(bb107[0])
bb108:
  _206 = (((*_11).4: blocksort::bz_stream).6: u32)
  using: _11@Phi(bb106)
  (*_6) = move _206
  using: _6@Phi(bb41), _206@Mir(bb108[0])
  goto -> bb110
  using: 
bb109:
  _209 = _6
  using: _6@Phi(bb41)
  _208 = move _209 as usize (PointerExposeAddress)
  using: _209@Mir(bb109[0])
  _207 = Eq(move _208, const 0_usize)
  using: _208@Mir(bb109[1])
  assume(move _207)
  using: _207@Mir(bb109[2])
  goto -> bb110
  using: 
bb110:
  _212 = _7
  using: _7@Phi(bb45)
  _211 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _212) -> bb111
  using: _212@Mir(bb110[0])
bb111:
  _210 = Not(move _211)
  using: _211@Mir(bb110[1])
  switchInt(move _210) -> [0: bb113, otherwise: bb112]
  using: _210@Mir(bb111[0])
bb112:
  _213 = (((*_11).4: blocksort::bz_stream).7: u32)
  using: _11@Phi(bb110)
  (*_7) = move _213
  using: _7@Phi(bb45), _213@Mir(bb112[0])
  goto -> bb114
  using: 
bb113:
  _216 = _7
  using: _7@Phi(bb45)
  _215 = move _216 as usize (PointerExposeAddress)
  using: _216@Mir(bb113[0])
  _214 = Eq(move _215, const 0_usize)
  using: _215@Mir(bb113[1])
  assume(move _214)
  using: _214@Mir(bb113[2])
  goto -> bb114
  using: 
bb114:
  _219 = _1
  using: _1@Phi(bb94)
  _218 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _219) -> bb115
  using: _219@Mir(bb114[0])
bb115:
  _217 = Not(move _218)
  using: _218@Mir(bb114[1])
  switchInt(move _217) -> [0: bb117, otherwise: bb116]
  using: _217@Mir(bb115[0])
bb116:
  _220 = const 0_i32
  using: 
  (*_1) = move _220
  using: _1@Phi(bb94), _220@Mir(bb116[0])
  goto -> bb118
  using: 
bb117:
  _223 = _1
  using: _1@Phi(bb94)
  _222 = move _223 as usize (PointerExposeAddress)
  using: _223@Mir(bb117[0])
  _221 = Eq(move _222, const 0_usize)
  using: _222@Mir(bb117[1])
  assume(move _221)
  using: _221@Mir(bb117[2])
  goto -> bb118
  using: 
bb118:
  _226 = _11
  using: _11@Phi(bb114)
  _225 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _226) -> bb119
  using: _226@Mir(bb118[0])
bb119:
  _224 = Not(move _225)
  using: _225@Mir(bb118[1])
  switchInt(move _224) -> [0: bb121, otherwise: bb120]
  using: _224@Mir(bb119[0])
bb120:
  _227 = const 0_i32
  using: 
  ((*_11).5: i32) = move _227
  using: _11@Phi(bb114), _227@Mir(bb120[0])
  goto -> bb122
  using: 
bb121:
  _230 = _11
  using: _11@Phi(bb114)
  _229 = move _230 as usize (PointerExposeAddress)
  using: _230@Mir(bb121[0])
  _228 = Eq(move _229, const 0_usize)
  using: _229@Mir(bb121[1])
  assume(move _228)
  using: _228@Mir(bb121[2])
  goto -> bb122
  using: 
bb122:
  _233 = &mut ((*_11).4: blocksort::bz_stream)
  using: _11@Phi(bb122)
  _232 = &raw mut (*_233)
  using: _233@Mir(bb122[0])
  _231 = bzlib::BZ2_bzCompressEnd(move _232) -> bb123
  using: _232@Mir(bb122[1])
bb123:
  _236 = _11
  using: _11@Phi(bb122)
  _235 = move _236 as *mut std::ffi::c_void (PtrToPtr)
  using: _236@Mir(bb123[0])
  _234 = bzlib::free(move _235) -> bb124
  using: _235@Mir(bb123[1])
bb124:
  return
  using: _0@Entry
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1833:8: 1833:29 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:1863:48: 1863:83 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:1867:28: 1867:58 (#0) by default
rewrite call bzlib::fwrite @ workspace/bzip2/rust/bzlib.rs:1866:21: 1868:70 (#0) by default
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1869:31: 1869:52 (#0) by default
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1878:24: 1878:45 (#0) by default
rewrite call bzlib::fflush @ workspace/bzip2/rust/bzlib.rs:1879:9: 1879:30 (#0) by default
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1880:12: 1880:33 (#0) by default
@DefId(0:384 ~ c2rust_lib[1043]::bzlib::BZ2_bzReadOpen)
bb0:
  _7 = const {0x0 as *mut bzlib::bzFile}
  using: 
  _8 = const 0_i32
  using: 
  _11 = _1
  using: _1@Entry
  _10 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _11) -> bb1
  using: _11@Mir(bb0[2])
bb1:
  _9 = Not(move _10)
  using: _10@Mir(bb0[3])
  switchInt(move _9) -> [0: bb3, otherwise: bb2]
  using: _9@Mir(bb1[0])
bb2:
  _12 = const 0_i32
  using: 
  (*_1) = move _12
  using: _1@Entry, _12@Mir(bb2[0])
  goto -> bb4
  using: 
bb3:
  _15 = _1
  using: _1@Entry
  _14 = move _15 as usize (PointerExposeAddress)
  using: _15@Mir(bb3[0])
  _13 = Eq(move _14, const 0_usize)
  using: _14@Mir(bb3[1])
  assume(move _13)
  using: _13@Mir(bb3[2])
  goto -> bb4
  using: 
bb4:
  _18 = _7
  using: _7@Mir(bb0[0])
  _17 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _18) -> bb5
  using: _18@Mir(bb4[0])
bb5:
  _16 = Not(move _17)
  using: _17@Mir(bb4[1])
  switchInt(move _16) -> [0: bb7, otherwise: bb6]
  using: _16@Mir(bb5[0])
bb6:
  _19 = const 0_i32
  using: 
  ((*_7).5: i32) = move _19
  using: _7@Mir(bb0[0]), _19@Mir(bb6[0])
  goto -> bb8
  using: 
bb7:
  _22 = _7
  using: _7@Mir(bb0[0])
  _21 = move _22 as usize (PointerExposeAddress)
  using: _22@Mir(bb7[0])
  _20 = Eq(move _21, const 0_usize)
  using: _21@Mir(bb7[1])
  assume(move _20)
  using: _20@Mir(bb7[2])
  goto -> bb8
  using: 
bb8:
  _28 = _2
  using: _2@Entry
  _27 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _28) -> bb21
  using: _28@Mir(bb8[0])
bb9:
  _23 = const true
  using: 
  goto -> bb11
  using: 
bb10:
  _52 = _5
  using: _5@Phi(bb14)
  _51 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _52) -> bb35
  using: _52@Mir(bb10[0])
bb11:
  switchInt(move _23) -> [0: bb48, otherwise: bb39]
  using: _23@Phi(bb11)
bb12:
  _24 = const true
  using: 
  goto -> bb14
  using: 
bb13:
  _45 = _5
  using: _5@Entry
  _44 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _45) -> bb31
  using: _45@Mir(bb13[0])
bb14:
  switchInt(move _24) -> [0: bb10, otherwise: bb9]
  using: _24@Phi(bb14)
bb15:
  _25 = const true
  using: 
  goto -> bb17
  using: 
bb16:
  _38 = _3
  using: _3@Entry
  _39 = const 0_i32
  using: 
  _37 = Lt(move _38, move _39)
  using: _38@Mir(bb16[0]), _39@Mir(bb16[1])
  switchInt(move _37) -> [0: bb26, otherwise: bb25]
  using: _37@Mir(bb16[2])
bb17:
  switchInt(move _25) -> [0: bb13, otherwise: bb12]
  using: _25@Phi(bb17)
bb18:
  _26 = const true
  using: 
  goto -> bb20
  using: 
bb19:
  _31 = _4
  using: _4@Entry
  _32 = const 0_i32
  using: 
  _30 = Ne(move _31, move _32)
  using: _31@Mir(bb19[0]), _32@Mir(bb19[1])
  switchInt(move _30) -> [0: bb22, otherwise: bb23]
  using: _30@Mir(bb19[2])
bb20:
  switchInt(move _26) -> [0: bb16, otherwise: bb15]
  using: _26@Phi(bb20)
bb21:
  switchInt(move _27) -> [0: bb19, otherwise: bb18]
  using: _27@Mir(bb8[1])
bb22:
  _29 = const false
  using: 
  goto -> bb24
  using: 
bb23:
  _34 = _4
  using: _4@Entry
  _35 = const 1_i32
  using: 
  _33 = Ne(move _34, move _35)
  using: _34@Mir(bb23[0]), _35@Mir(bb23[1])
  _29 = move _33
  using: _33@Mir(bb23[2])
  goto -> bb24
  using: 
bb24:
  _26 = move _29
  using: _29@Phi(bb24)
  goto -> bb20
  using: 
bb25:
  _36 = const true
  using: 
  goto -> bb27
  using: 
bb26:
  _41 = _3
  using: _3@Entry
  _42 = const 4_i32
  using: 
  _40 = Gt(move _41, move _42)
  using: _41@Mir(bb26[0]), _42@Mir(bb26[1])
  _36 = move _40
  using: _40@Mir(bb26[2])
  goto -> bb27
  using: 
bb27:
  _25 = move _36
  using: _36@Phi(bb27)
  goto -> bb17
  using: 
bb28:
  _43 = const false
  using: 
  goto -> bb30
  using: 
bb29:
  _47 = _6
  using: _6@Entry
  _48 = const 0_i32
  using: 
  _46 = Ne(move _47, move _48)
  using: _47@Mir(bb29[0]), _48@Mir(bb29[1])
  _43 = move _46
  using: _46@Mir(bb29[2])
  goto -> bb30
  using: 
bb30:
  _24 = move _43
  using: _43@Phi(bb30)
  goto -> bb14
  using: 
bb31:
  switchInt(move _44) -> [0: bb28, otherwise: bb29]
  using: _44@Mir(bb13[1])
bb32:
  _49 = const false
  using: 
  goto -> bb34
  using: 
bb33:
  _55 = _6
  using: _6@Phi(bb14)
  _56 = const 0_i32
  using: 
  _54 = Lt(move _55, move _56)
  using: _55@Mir(bb33[0]), _56@Mir(bb33[1])
  switchInt(move _54) -> [0: bb37, otherwise: bb36]
  using: _54@Mir(bb33[2])
bb34:
  _23 = move _49
  using: _49@Phi(bb34)
  goto -> bb11
  using: 
bb35:
  _50 = Not(move _51)
  using: _51@Mir(bb10[1])
  switchInt(move _50) -> [0: bb32, otherwise: bb33]
  using: _50@Mir(bb35[0])
bb36:
  _53 = const true
  using: 
  goto -> bb38
  using: 
bb37:
  _58 = _6
  using: _6@Phi(bb14)
  _59 = const 5000_i32
  using: 
  _57 = Gt(move _58, move _59)
  using: _58@Mir(bb37[0]), _59@Mir(bb37[1])
  _53 = move _57
  using: _57@Mir(bb37[2])
  goto -> bb38
  using: 
bb38:
  _49 = move _53
  using: _53@Phi(bb38)
  goto -> bb34
  using: 
bb39:
  _62 = _1
  using: _1@Phi(bb4)
  _61 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _62) -> bb40
  using: _62@Mir(bb39[0])
bb40:
  _60 = Not(move _61)
  using: _61@Mir(bb39[1])
  switchInt(move _60) -> [0: bb42, otherwise: bb41]
  using: _60@Mir(bb40[0])
bb41:
  _63 = const 2_i32
  using: 
  (*_1) = Neg(move _63)
  using: _1@Phi(bb4), _63@Mir(bb41[0])
  goto -> bb43
  using: 
bb42:
  _66 = _1
  using: _1@Phi(bb4)
  _65 = move _66 as usize (PointerExposeAddress)
  using: _66@Mir(bb42[0])
  _64 = Eq(move _65, const 0_usize)
  using: _65@Mir(bb42[1])
  assume(move _64)
  using: _64@Mir(bb42[2])
  goto -> bb43
  using: 
bb43:
  _69 = _7
  using: _7@Phi(bb8)
  _68 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _69) -> bb44
  using: _69@Mir(bb43[0])
bb44:
  _67 = Not(move _68)
  using: _68@Mir(bb43[1])
  switchInt(move _67) -> [0: bb46, otherwise: bb45]
  using: _67@Mir(bb44[0])
bb45:
  _70 = const 2_i32
  using: 
  ((*_7).5: i32) = Neg(move _70)
  using: _7@Phi(bb8), _70@Mir(bb45[0])
  goto -> bb47
  using: 
bb46:
  _73 = _7
  using: _7@Phi(bb8)
  _72 = move _73 as usize (PointerExposeAddress)
  using: _73@Mir(bb46[0])
  _71 = Eq(move _72, const 0_usize)
  using: _72@Mir(bb46[1])
  assume(move _71)
  using: _71@Mir(bb46[2])
  goto -> bb47
  using: 
bb47:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb101
  using: 
bb48:
  _75 = _2
  using: _2@Entry
  _74 = bzlib::ferror(move _75) -> bb49
  using: _75@Mir(bb48[0])
bb49:
  switchInt(move _74) -> [0: bb59, otherwise: bb50]
  using: _74@Mir(bb48[1])
bb50:
  _78 = _1
  using: _1@Phi(bb43)
  _77 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _78) -> bb51
  using: _78@Mir(bb50[0])
bb51:
  _76 = Not(move _77)
  using: _77@Mir(bb50[1])
  switchInt(move _76) -> [0: bb53, otherwise: bb52]
  using: _76@Mir(bb51[0])
bb52:
  _79 = const 6_i32
  using: 
  (*_1) = Neg(move _79)
  using: _1@Phi(bb43), _79@Mir(bb52[0])
  goto -> bb54
  using: 
bb53:
  _82 = _1
  using: _1@Phi(bb43)
  _81 = move _82 as usize (PointerExposeAddress)
  using: _82@Mir(bb53[0])
  _80 = Eq(move _81, const 0_usize)
  using: _81@Mir(bb53[1])
  assume(move _80)
  using: _80@Mir(bb53[2])
  goto -> bb54
  using: 
bb54:
  _85 = _7
  using: _7@Phi(bb47)
  _84 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _85) -> bb55
  using: _85@Mir(bb54[0])
bb55:
  _83 = Not(move _84)
  using: _84@Mir(bb54[1])
  switchInt(move _83) -> [0: bb57, otherwise: bb56]
  using: _83@Mir(bb55[0])
bb56:
  _86 = const 6_i32
  using: 
  ((*_7).5: i32) = Neg(move _86)
  using: _7@Phi(bb47), _86@Mir(bb56[0])
  goto -> bb58
  using: 
bb57:
  _89 = _7
  using: _7@Phi(bb47)
  _88 = move _89 as usize (PointerExposeAddress)
  using: _89@Mir(bb57[0])
  _87 = Eq(move _88, const 0_usize)
  using: _88@Mir(bb57[1])
  assume(move _87)
  using: _87@Mir(bb57[2])
  goto -> bb58
  using: 
bb58:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb101
  using: 
bb59:
  _92 = std::mem::size_of::<bzlib::bzFile>() -> bb60
  using: 
bb60:
  _91 = move _92 as u64 (IntToInt)
  using: _92@Mir(bb59[0])
  _90 = bzlib::malloc(move _91) -> bb61
  using: _91@Mir(bb60[0])
bb61:
  _7 = move _90 as *mut bzlib::bzFile (PtrToPtr)
  using: _90@Mir(bb60[1])
  _94 = _7
  using: _7@Mir(bb61[0])
  _93 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _94) -> bb62
  using: _94@Mir(bb61[1])
bb62:
  switchInt(move _93) -> [0: bb72, otherwise: bb63]
  using: _93@Mir(bb61[2])
bb63:
  _97 = _7
  using: _7@Mir(bb61[0])
  _96 = move _97 as usize (PointerExposeAddress)
  using: _97@Mir(bb63[0])
  _95 = Eq(move _96, const 0_usize)
  using: _96@Mir(bb63[1])
  assume(move _95)
  using: _95@Mir(bb63[2])
  _100 = _1
  using: _1@Phi(bb54)
  _99 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _100) -> bb64
  using: _100@Mir(bb63[4])
bb64:
  _98 = Not(move _99)
  using: _99@Mir(bb63[5])
  switchInt(move _98) -> [0: bb66, otherwise: bb65]
  using: _98@Mir(bb64[0])
bb65:
  _101 = const 3_i32
  using: 
  (*_1) = Neg(move _101)
  using: _1@Phi(bb54), _101@Mir(bb65[0])
  goto -> bb67
  using: 
bb66:
  _104 = _1
  using: _1@Phi(bb54)
  _103 = move _104 as usize (PointerExposeAddress)
  using: _104@Mir(bb66[0])
  _102 = Eq(move _103, const 0_usize)
  using: _103@Mir(bb66[1])
  assume(move _102)
  using: _102@Mir(bb66[2])
  goto -> bb67
  using: 
bb67:
  _107 = _7
  using: _7@Mir(bb61[0])
  _106 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _107) -> bb68
  using: _107@Mir(bb67[0])
bb68:
  _105 = Not(move _106)
  using: _106@Mir(bb67[1])
  switchInt(move _105) -> [0: bb70, otherwise: bb69]
  using: _105@Mir(bb68[0])
bb69:
  _108 = const 3_i32
  using: 
  ((*_7).5: i32) = Neg(move _108)
  using: _7@Mir(bb61[0]), _108@Mir(bb69[0])
  goto -> bb71
  using: 
bb70:
  _111 = _7
  using: _7@Mir(bb61[0])
  _110 = move _111 as usize (PointerExposeAddress)
  using: _111@Mir(bb70[0])
  _109 = Eq(move _110, const 0_usize)
  using: _110@Mir(bb70[1])
  assume(move _109)
  using: _109@Mir(bb70[2])
  goto -> bb71
  using: 
bb71:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb101
  using: 
bb72:
  _114 = _1
  using: _1@Phi(bb67)
  _113 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _114) -> bb73
  using: _114@Mir(bb72[0])
bb73:
  _112 = Not(move _113)
  using: _113@Mir(bb72[1])
  switchInt(move _112) -> [0: bb75, otherwise: bb74]
  using: _112@Mir(bb73[0])
bb74:
  _115 = const 0_i32
  using: 
  (*_1) = move _115
  using: _1@Phi(bb67), _115@Mir(bb74[0])
  goto -> bb76
  using: 
bb75:
  _118 = _1
  using: _1@Phi(bb67)
  _117 = move _118 as usize (PointerExposeAddress)
  using: _118@Mir(bb75[0])
  _116 = Eq(move _117, const 0_usize)
  using: _117@Mir(bb75[1])
  assume(move _116)
  using: _116@Mir(bb75[2])
  goto -> bb76
  using: 
bb76:
  _121 = _7
  using: _7@Phi(bb71)
  _120 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _121) -> bb77
  using: _121@Mir(bb76[0])
bb77:
  _119 = Not(move _120)
  using: _120@Mir(bb76[1])
  switchInt(move _119) -> [0: bb79, otherwise: bb78]
  using: _119@Mir(bb77[0])
bb78:
  _122 = const 0_i32
  using: 
  ((*_7).5: i32) = move _122
  using: _7@Phi(bb71), _122@Mir(bb78[0])
  goto -> bb80
  using: 
bb79:
  _125 = _7
  using: _7@Phi(bb71)
  _124 = move _125 as usize (PointerExposeAddress)
  using: _125@Mir(bb79[0])
  _123 = Eq(move _124, const 0_usize)
  using: _124@Mir(bb79[1])
  assume(move _123)
  using: _123@Mir(bb79[2])
  goto -> bb80
  using: 
bb80:
  _126 = const 0_i32
  using: 
  ((*_7).6: u8) = move _126 as u8 (IntToInt)
  using: _7@Phi(bb80), _126@Mir(bb80[0])
  _127 = _2
  using: _2@Entry
  ((*_7).0: *mut blocksort::__sFILE) = move _127
  using: _7@Phi(bb80), _127@Mir(bb80[2])
  _128 = const 0_i32
  using: 
  ((*_7).2: i32) = move _128
  using: _7@Phi(bb80), _128@Mir(bb80[4])
  _129 = const 0_i32
  using: 
  ((*_7).3: u8) = move _129 as u8 (IntToInt)
  using: _7@Phi(bb80), _129@Mir(bb80[6])
  Deinit(_130)
  using: 
  discriminant(_130) = 0
  using: 
  (((*_7).4: blocksort::bz_stream).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _130
  using: _7@Phi(bb80), _130@Mir(bb80[8])
  Deinit(_131)
  using: 
  discriminant(_131) = 0
  using: 
  (((*_7).4: blocksort::bz_stream).10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _131
  using: _7@Phi(bb80), _131@Mir(bb80[11])
  (((*_7).4: blocksort::bz_stream).11: *mut std::ffi::c_void) = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: _7@Phi(bb80)
  goto -> bb81
  using: 
bb81:
  _133 = _6
  using: _6@Phi(bb81)
  _134 = const 0_i32
  using: 
  _132 = Gt(move _133, move _134)
  using: _133@Mir(bb81[0]), _134@Mir(bb81[1])
  switchInt(move _132) -> [0: bb87, otherwise: bb82]
  using: _132@Mir(bb81[2])
bb82:
  _137 = _5
  using: _5@Phi(bb81)
  _136 = move _137 as *mut u8 (PtrToPtr)
  using: _137@Mir(bb82[0])
  _135 = (*_136)
  using: _136@Mir(bb82[1])
  _139 = ((*_7).2: i32)
  using: _7@Phi(bb81)
  _138 = move _139 as usize (IntToInt)
  using: _139@Mir(bb82[3])
  _140 = const 5000_usize
  using: 
  _141 = Lt(_138, _140)
  using: _138@Mir(bb82[4]), _140@Mir(bb82[5])
  assert(move _141, "index out of bounds: the length is {} but the index is {}", move _140, _138) -> bb83
  using: _141@Entry, _140@Entry, _138@Entry
bb83:
  ((*_7).1: [i8; 5000])[_138] = move _135 as i8 (IntToInt)
  using: _7@Phi(bb81), _138@Mir(bb82[4]), _135@Mir(bb82[2])
  _142 = CheckedAdd(((*_7).2: i32), const 1_i32)
  using: _7@Phi(bb81)
  assert(!move (_142.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_7).2: i32), const 1_i32) -> bb84
  using: _142@Entry, _7@Entry
bb84:
  ((*_7).2: i32) = move (_142.0: i32)
  using: _7@Phi(bb81), _142@Mir(bb83[1])
  _145 = _5
  using: _5@Phi(bb81)
  _144 = move _145 as *mut u8 (PtrToPtr)
  using: _145@Mir(bb84[1])
  _146 = const 1_isize
  using: 
  _143 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _144, move _146) -> bb85
  using: _144@Mir(bb84[2]), _146@Mir(bb84[3])
bb85:
  _5 = move _143 as *mut std::ffi::c_void (PtrToPtr)
  using: _143@Mir(bb84[4])
  _147 = CheckedSub(_6, const 1_i32)
  using: _6@Phi(bb81)
  assert(!move (_147.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> bb86
  using: _147@Entry, _6@Entry
bb86:
  _6 = move (_147.0: i32)
  using: _147@Mir(bb85[1])
  goto -> bb81
  using: 
bb87:
  _150 = &mut ((*_7).4: blocksort::bz_stream)
  using: _7@Phi(bb81)
  _149 = &raw mut (*_150)
  using: _150@Mir(bb87[0])
  _151 = _3
  using: _3@Phi(bb17)
  _152 = _4
  using: _4@Phi(bb20)
  _148 = bzlib::BZ2_bzDecompressInit(move _149, move _151, move _152) -> bb88
  using: _149@Mir(bb87[1]), _151@Mir(bb87[2]), _152@Mir(bb87[3])
bb88:
  _8 = move _148
  using: _148@Mir(bb87[4])
  _154 = _8
  using: _8@Mir(bb88[0])
  _155 = const 0_i32
  using: 
  _153 = Ne(move _154, move _155)
  using: _154@Mir(bb88[1]), _155@Mir(bb88[2])
  switchInt(move _153) -> [0: bb99, otherwise: bb89]
  using: _153@Mir(bb88[3])
bb89:
  _158 = _1
  using: _1@Phi(bb76)
  _157 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _158) -> bb90
  using: _158@Mir(bb89[0])
bb90:
  _156 = Not(move _157)
  using: _157@Mir(bb89[1])
  switchInt(move _156) -> [0: bb92, otherwise: bb91]
  using: _156@Mir(bb90[0])
bb91:
  _159 = _8
  using: _8@Mir(bb88[0])
  (*_1) = move _159
  using: _1@Phi(bb76), _159@Mir(bb91[0])
  goto -> bb93
  using: 
bb92:
  _162 = _1
  using: _1@Phi(bb76)
  _161 = move _162 as usize (PointerExposeAddress)
  using: _162@Mir(bb92[0])
  _160 = Eq(move _161, const 0_usize)
  using: _161@Mir(bb92[1])
  assume(move _160)
  using: _160@Mir(bb92[2])
  goto -> bb93
  using: 
bb93:
  _165 = _7
  using: _7@Phi(bb81)
  _164 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _165) -> bb94
  using: _165@Mir(bb93[0])
bb94:
  _163 = Not(move _164)
  using: _164@Mir(bb93[1])
  switchInt(move _163) -> [0: bb96, otherwise: bb95]
  using: _163@Mir(bb94[0])
bb95:
  _166 = _8
  using: _8@Phi(bb93)
  ((*_7).5: i32) = move _166
  using: _7@Phi(bb81), _166@Mir(bb95[0])
  goto -> bb97
  using: 
bb96:
  _169 = _7
  using: _7@Phi(bb81)
  _168 = move _169 as usize (PointerExposeAddress)
  using: _169@Mir(bb96[0])
  _167 = Eq(move _168, const 0_usize)
  using: _168@Mir(bb96[1])
  assume(move _167)
  using: _167@Mir(bb96[2])
  goto -> bb97
  using: 
bb97:
  _172 = _7
  using: _7@Phi(bb97)
  _171 = move _172 as *mut std::ffi::c_void (PtrToPtr)
  using: _172@Mir(bb97[0])
  _170 = bzlib::free(move _171) -> bb98
  using: _171@Mir(bb97[1])
bb98:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb101
  using: 
bb99:
  _173 = ((*_7).2: i32)
  using: _7@Phi(bb97)
  (((*_7).4: blocksort::bz_stream).1: u32) = move _173 as u32 (IntToInt)
  using: _7@Phi(bb97), _173@Mir(bb99[0])
  _176 = &mut ((*_7).1: [i8; 5000])
  using: _7@Phi(bb97)
  _175 = move _176 as &mut [i8] (Pointer(Unsize))
  using: _176@Mir(bb99[2])
  _174 = core::slice::<impl [i8]>::as_mut_ptr(move _175) -> bb100
  using: _175@Mir(bb99[3])
bb100:
  (((*_7).4: blocksort::bz_stream).0: *mut i8) = move _174
  using: _7@Phi(bb97), _174@Mir(bb99[4])
  _177 = const 1_i32
  using: 
  ((*_7).6: u8) = move _177 as u8 (IntToInt)
  using: _7@Phi(bb97), _177@Mir(bb100[1])
  _178 = _7
  using: _7@Phi(bb97)
  _0 = move _178 as *mut std::ffi::c_void (PtrToPtr)
  using: _178@Mir(bb100[3])
  goto -> bb101
  using: 
bb101:
  return
  using: _0@Phi(bb101)
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:1925:8: 1925:17 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:1931:16: 1931:47 (#0) by default
rewrite call bzlib::malloc @ workspace/bzip2/rust/bzlib.rs:1931:9: 1931:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_130) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_130) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_131) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_131) = 0 is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/bzlib.rs:1951:36: 1951:77 (#0) by default
@DefId(0:385 ~ c2rust_lib[1043]::bzlib::BZ2_bzReadClose)
bb0:
  _4 = _2
  using: _2@Entry
  _3 = move _4 as *mut bzlib::bzFile (PtrToPtr)
  using: _4@Mir(bb0[0])
  _7 = _1
  using: _1@Entry
  _6 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _7) -> bb1
  using: _7@Mir(bb0[2])
bb1:
  _5 = Not(move _6)
  using: _6@Mir(bb0[3])
  switchInt(move _5) -> [0: bb3, otherwise: bb2]
  using: _5@Mir(bb1[0])
bb2:
  _8 = const 0_i32
  using: 
  (*_1) = move _8
  using: _1@Entry, _8@Mir(bb2[0])
  goto -> bb4
  using: 
bb3:
  _11 = _1
  using: _1@Entry
  _10 = move _11 as usize (PointerExposeAddress)
  using: _11@Mir(bb3[0])
  _9 = Eq(move _10, const 0_usize)
  using: _10@Mir(bb3[1])
  assume(move _9)
  using: _9@Mir(bb3[2])
  goto -> bb4
  using: 
bb4:
  _14 = _3
  using: _3@Mir(bb0[1])
  _13 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _14) -> bb5
  using: _14@Mir(bb4[0])
bb5:
  _12 = Not(move _13)
  using: _13@Mir(bb4[1])
  switchInt(move _12) -> [0: bb7, otherwise: bb6]
  using: _12@Mir(bb5[0])
bb6:
  _15 = const 0_i32
  using: 
  ((*_3).5: i32) = move _15
  using: _3@Mir(bb0[1]), _15@Mir(bb6[0])
  goto -> bb8
  using: 
bb7:
  _18 = _3
  using: _3@Mir(bb0[1])
  _17 = move _18 as usize (PointerExposeAddress)
  using: _18@Mir(bb7[0])
  _16 = Eq(move _17, const 0_usize)
  using: _17@Mir(bb7[1])
  assume(move _16)
  using: _16@Mir(bb7[2])
  goto -> bb8
  using: 
bb8:
  _20 = _3
  using: _3@Phi(bb8)
  _19 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _20) -> bb9
  using: _20@Mir(bb8[0])
bb9:
  switchInt(move _19) -> [0: bb18, otherwise: bb10]
  using: _19@Mir(bb8[1])
bb10:
  _23 = _3
  using: _3@Phi(bb8)
  _22 = move _23 as usize (PointerExposeAddress)
  using: _23@Mir(bb10[0])
  _21 = Eq(move _22, const 0_usize)
  using: _22@Mir(bb10[1])
  assume(move _21)
  using: _21@Mir(bb10[2])
  _26 = _1
  using: _1@Phi(bb4)
  _25 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _26) -> bb11
  using: _26@Mir(bb10[4])
bb11:
  _24 = Not(move _25)
  using: _25@Mir(bb10[5])
  switchInt(move _24) -> [0: bb13, otherwise: bb12]
  using: _24@Mir(bb11[0])
bb12:
  _27 = const 0_i32
  using: 
  (*_1) = move _27
  using: _1@Phi(bb4), _27@Mir(bb12[0])
  goto -> bb14
  using: 
bb13:
  _30 = _1
  using: _1@Phi(bb4)
  _29 = move _30 as usize (PointerExposeAddress)
  using: _30@Mir(bb13[0])
  _28 = Eq(move _29, const 0_usize)
  using: _29@Mir(bb13[1])
  assume(move _28)
  using: _28@Mir(bb13[2])
  goto -> bb14
  using: 
bb14:
  _33 = _3
  using: _3@Phi(bb8)
  _32 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _33) -> bb15
  using: _33@Mir(bb14[0])
bb15:
  _31 = Not(move _32)
  using: _32@Mir(bb14[1])
  switchInt(move _31) -> [0: bb17, otherwise: bb16]
  using: _31@Mir(bb15[0])
bb16:
  _34 = const 0_i32
  using: 
  ((*_3).5: i32) = move _34
  using: _3@Phi(bb8), _34@Mir(bb16[0])
  goto -> bb30
  using: 
bb17:
  _37 = _3
  using: _3@Phi(bb8)
  _36 = move _37 as usize (PointerExposeAddress)
  using: _37@Mir(bb17[0])
  _35 = Eq(move _36, const 0_usize)
  using: _36@Mir(bb17[1])
  assume(move _35)
  using: _35@Mir(bb17[2])
  goto -> bb30
  using: 
bb18:
  _38 = ((*_3).3: u8)
  using: _3@Phi(bb8)
  switchInt(move _38) -> [0: bb20, otherwise: bb19]
  using: _38@Mir(bb18[0])
bb19:
  _41 = _1
  using: _1@Phi(bb14)
  _40 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _41) -> bb21
  using: _41@Mir(bb19[0])
bb20:
  _53 = ((*_3).6: u8)
  using: _3@Phi(bb8)
  switchInt(move _53) -> [0: bb29, otherwise: bb28]
  using: _53@Mir(bb20[0])
bb21:
  _39 = Not(move _40)
  using: _40@Mir(bb19[1])
  switchInt(move _39) -> [0: bb23, otherwise: bb22]
  using: _39@Mir(bb21[0])
bb22:
  _42 = const 1_i32
  using: 
  (*_1) = Neg(move _42)
  using: _1@Phi(bb14), _42@Mir(bb22[0])
  goto -> bb24
  using: 
bb23:
  _45 = _1
  using: _1@Phi(bb14)
  _44 = move _45 as usize (PointerExposeAddress)
  using: _45@Mir(bb23[0])
  _43 = Eq(move _44, const 0_usize)
  using: _44@Mir(bb23[1])
  assume(move _43)
  using: _43@Mir(bb23[2])
  goto -> bb24
  using: 
bb24:
  _48 = _3
  using: _3@Phi(bb8)
  _47 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _48) -> bb25
  using: _48@Mir(bb24[0])
bb25:
  _46 = Not(move _47)
  using: _47@Mir(bb24[1])
  switchInt(move _46) -> [0: bb27, otherwise: bb26]
  using: _46@Mir(bb25[0])
bb26:
  _49 = const 1_i32
  using: 
  ((*_3).5: i32) = Neg(move _49)
  using: _3@Phi(bb8), _49@Mir(bb26[0])
  goto -> bb30
  using: 
bb27:
  _52 = _3
  using: _3@Phi(bb8)
  _51 = move _52 as usize (PointerExposeAddress)
  using: _52@Mir(bb27[0])
  _50 = Eq(move _51, const 0_usize)
  using: _51@Mir(bb27[1])
  assume(move _50)
  using: _50@Mir(bb27[2])
  goto -> bb30
  using: 
bb28:
  _56 = &mut ((*_3).4: blocksort::bz_stream)
  using: _3@Phi(bb8)
  _55 = &raw mut (*_56)
  using: _56@Mir(bb28[0])
  _54 = bzlib::BZ2_bzDecompressEnd(move _55) -> bb29
  using: _55@Mir(bb28[1])
bb29:
  _59 = _3
  using: _3@Phi(bb29)
  _58 = move _59 as *mut std::ffi::c_void (PtrToPtr)
  using: _59@Mir(bb29[0])
  _57 = bzlib::free(move _58) -> bb30
  using: _58@Mir(bb29[1])
bb30:
  return
  using: _0@Entry
@DefId(0:386 ~ c2rust_lib[1043]::bzlib::BZ2_bzRead)
bb0:
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _8 = _2
  using: _2@Entry
  _7 = move _8 as *mut bzlib::bzFile (PtrToPtr)
  using: _8@Mir(bb0[2])
  _11 = _1
  using: _1@Entry
  _10 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _11) -> bb1
  using: _11@Mir(bb0[4])
bb1:
  _9 = Not(move _10)
  using: _10@Mir(bb0[5])
  switchInt(move _9) -> [0: bb3, otherwise: bb2]
  using: _9@Mir(bb1[0])
bb2:
  _12 = const 0_i32
  using: 
  (*_1) = move _12
  using: _1@Entry, _12@Mir(bb2[0])
  goto -> bb4
  using: 
bb3:
  _15 = _1
  using: _1@Entry
  _14 = move _15 as usize (PointerExposeAddress)
  using: _15@Mir(bb3[0])
  _13 = Eq(move _14, const 0_usize)
  using: _14@Mir(bb3[1])
  assume(move _13)
  using: _13@Mir(bb3[2])
  goto -> bb4
  using: 
bb4:
  _18 = _7
  using: _7@Mir(bb0[3])
  _17 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _18) -> bb5
  using: _18@Mir(bb4[0])
bb5:
  _16 = Not(move _17)
  using: _17@Mir(bb4[1])
  switchInt(move _16) -> [0: bb7, otherwise: bb6]
  using: _16@Mir(bb5[0])
bb6:
  _19 = const 0_i32
  using: 
  ((*_7).5: i32) = move _19
  using: _7@Mir(bb0[3]), _19@Mir(bb6[0])
  goto -> bb8
  using: 
bb7:
  _22 = _7
  using: _7@Mir(bb0[3])
  _21 = move _22 as usize (PointerExposeAddress)
  using: _22@Mir(bb7[0])
  _20 = Eq(move _21, const 0_usize)
  using: _21@Mir(bb7[1])
  assume(move _20)
  using: _20@Mir(bb7[2])
  goto -> bb8
  using: 
bb8:
  _26 = _7
  using: _7@Phi(bb8)
  _25 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _26) -> bb15
  using: _26@Mir(bb8[0])
bb9:
  _23 = const true
  using: 
  goto -> bb11
  using: 
bb10:
  _30 = _4
  using: _4@Entry
  _31 = const 0_i32
  using: 
  _29 = Lt(move _30, move _31)
  using: _30@Mir(bb10[0]), _31@Mir(bb10[1])
  _23 = move _29
  using: _29@Mir(bb10[2])
  goto -> bb11
  using: 
bb11:
  switchInt(move _23) -> [0: bb26, otherwise: bb17]
  using: _23@Phi(bb11)
bb12:
  _24 = const true
  using: 
  goto -> bb14
  using: 
bb13:
  _28 = _3
  using: _3@Entry
  _27 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _28) -> bb16
  using: _28@Mir(bb13[0])
bb14:
  switchInt(move _24) -> [0: bb10, otherwise: bb9]
  using: _24@Phi(bb14)
bb15:
  switchInt(move _25) -> [0: bb13, otherwise: bb12]
  using: _25@Mir(bb8[1])
bb16:
  _24 = move _27
  using: _27@Mir(bb13[1])
  goto -> bb14
  using: 
bb17:
  _34 = _1
  using: _1@Phi(bb4)
  _33 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _34) -> bb18
  using: _34@Mir(bb17[0])
bb18:
  _32 = Not(move _33)
  using: _33@Mir(bb17[1])
  switchInt(move _32) -> [0: bb20, otherwise: bb19]
  using: _32@Mir(bb18[0])
bb19:
  _35 = const 2_i32
  using: 
  (*_1) = Neg(move _35)
  using: _1@Phi(bb4), _35@Mir(bb19[0])
  goto -> bb21
  using: 
bb20:
  _38 = _1
  using: _1@Phi(bb4)
  _37 = move _38 as usize (PointerExposeAddress)
  using: _38@Mir(bb20[0])
  _36 = Eq(move _37, const 0_usize)
  using: _37@Mir(bb20[1])
  assume(move _36)
  using: _36@Mir(bb20[2])
  goto -> bb21
  using: 
bb21:
  _41 = _7
  using: _7@Phi(bb8)
  _40 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _41) -> bb22
  using: _41@Mir(bb21[0])
bb22:
  _39 = Not(move _40)
  using: _40@Mir(bb21[1])
  switchInt(move _39) -> [0: bb24, otherwise: bb23]
  using: _39@Mir(bb22[0])
bb23:
  _42 = const 2_i32
  using: 
  ((*_7).5: i32) = Neg(move _42)
  using: _7@Phi(bb8), _42@Mir(bb23[0])
  goto -> bb25
  using: 
bb24:
  _45 = _7
  using: _7@Phi(bb8)
  _44 = move _45 as usize (PointerExposeAddress)
  using: _45@Mir(bb24[0])
  _43 = Eq(move _44, const 0_usize)
  using: _44@Mir(bb24[1])
  assume(move _43)
  using: _43@Mir(bb24[2])
  goto -> bb25
  using: 
bb25:
  _0 = const 0_i32
  using: 
  goto -> bb134
  using: 
bb26:
  _46 = ((*_7).3: u8)
  using: _7@Phi(bb25)
  switchInt(move _46) -> [0: bb28, otherwise: bb27]
  using: _46@Mir(bb26[0])
bb27:
  _49 = _1
  using: _1@Phi(bb21)
  _48 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _49) -> bb29
  using: _49@Mir(bb27[0])
bb28:
  _62 = _4
  using: _4@Phi(bb11)
  _63 = const 0_i32
  using: 
  _61 = Eq(move _62, move _63)
  using: _62@Mir(bb28[0]), _63@Mir(bb28[1])
  switchInt(move _61) -> [0: bb38, otherwise: bb37]
  using: _61@Mir(bb28[2])
bb29:
  _47 = Not(move _48)
  using: _48@Mir(bb27[1])
  switchInt(move _47) -> [0: bb31, otherwise: bb30]
  using: _47@Mir(bb29[0])
bb30:
  _50 = const 1_i32
  using: 
  (*_1) = Neg(move _50)
  using: _1@Phi(bb21), _50@Mir(bb30[0])
  goto -> bb32
  using: 
bb31:
  _53 = _1
  using: _1@Phi(bb21)
  _52 = move _53 as usize (PointerExposeAddress)
  using: _53@Mir(bb31[0])
  _51 = Eq(move _52, const 0_usize)
  using: _52@Mir(bb31[1])
  assume(move _51)
  using: _51@Mir(bb31[2])
  goto -> bb32
  using: 
bb32:
  _56 = _7
  using: _7@Phi(bb25)
  _55 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _56) -> bb33
  using: _56@Mir(bb32[0])
bb33:
  _54 = Not(move _55)
  using: _55@Mir(bb32[1])
  switchInt(move _54) -> [0: bb35, otherwise: bb34]
  using: _54@Mir(bb33[0])
bb34:
  _57 = const 1_i32
  using: 
  ((*_7).5: i32) = Neg(move _57)
  using: _7@Phi(bb25), _57@Mir(bb34[0])
  goto -> bb36
  using: 
bb35:
  _60 = _7
  using: _7@Phi(bb25)
  _59 = move _60 as usize (PointerExposeAddress)
  using: _60@Mir(bb35[0])
  _58 = Eq(move _59, const 0_usize)
  using: _59@Mir(bb35[1])
  assume(move _58)
  using: _58@Mir(bb35[2])
  goto -> bb36
  using: 
bb36:
  _0 = const 0_i32
  using: 
  goto -> bb134
  using: 
bb37:
  _66 = _1
  using: _1@Phi(bb32)
  _65 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _66) -> bb39
  using: _66@Mir(bb37[0])
bb38:
  _78 = _4
  using: _4@Phi(bb11)
  (((*_7).4: blocksort::bz_stream).5: u32) = move _78 as u32 (IntToInt)
  using: _7@Phi(bb46), _78@Mir(bb38[0])
  _79 = _3
  using: _3@Phi(bb14)
  (((*_7).4: blocksort::bz_stream).4: *mut i8) = move _79 as *mut i8 (PtrToPtr)
  using: _7@Phi(bb46), _79@Mir(bb38[2])
  goto -> bb47
  using: 
bb39:
  _64 = Not(move _65)
  using: _65@Mir(bb37[1])
  switchInt(move _64) -> [0: bb41, otherwise: bb40]
  using: _64@Mir(bb39[0])
bb40:
  _67 = const 0_i32
  using: 
  (*_1) = move _67
  using: _1@Phi(bb32), _67@Mir(bb40[0])
  goto -> bb42
  using: 
bb41:
  _70 = _1
  using: _1@Phi(bb32)
  _69 = move _70 as usize (PointerExposeAddress)
  using: _70@Mir(bb41[0])
  _68 = Eq(move _69, const 0_usize)
  using: _69@Mir(bb41[1])
  assume(move _68)
  using: _68@Mir(bb41[2])
  goto -> bb42
  using: 
bb42:
  _73 = _7
  using: _7@Phi(bb36)
  _72 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _73) -> bb43
  using: _73@Mir(bb42[0])
bb43:
  _71 = Not(move _72)
  using: _72@Mir(bb42[1])
  switchInt(move _71) -> [0: bb45, otherwise: bb44]
  using: _71@Mir(bb43[0])
bb44:
  _74 = const 0_i32
  using: 
  ((*_7).5: i32) = move _74
  using: _7@Phi(bb36), _74@Mir(bb44[0])
  goto -> bb46
  using: 
bb45:
  _77 = _7
  using: _7@Phi(bb36)
  _76 = move _77 as usize (PointerExposeAddress)
  using: _77@Mir(bb45[0])
  _75 = Eq(move _76, const 0_usize)
  using: _76@Mir(bb45[1])
  assume(move _75)
  using: _75@Mir(bb45[2])
  goto -> bb46
  using: 
bb46:
  _0 = const 0_i32
  using: 
  goto -> bb134
  using: 
bb47:
  _81 = ((*_7).0: *mut blocksort::__sFILE)
  using: _7@Phi(bb47)
  _80 = bzlib::ferror(move _81) -> bb48
  using: _81@Mir(bb47[0])
bb48:
  switchInt(move _80) -> [0: bb58, otherwise: bb49]
  using: _80@Mir(bb47[1])
bb49:
  _84 = _1
  using: _1@Phi(bb42)
  _83 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _84) -> bb50
  using: _84@Mir(bb49[0])
bb50:
  _82 = Not(move _83)
  using: _83@Mir(bb49[1])
  switchInt(move _82) -> [0: bb52, otherwise: bb51]
  using: _82@Mir(bb50[0])
bb51:
  _85 = const 6_i32
  using: 
  (*_1) = Neg(move _85)
  using: _1@Phi(bb42), _85@Mir(bb51[0])
  goto -> bb53
  using: 
bb52:
  _88 = _1
  using: _1@Phi(bb42)
  _87 = move _88 as usize (PointerExposeAddress)
  using: _88@Mir(bb52[0])
  _86 = Eq(move _87, const 0_usize)
  using: _87@Mir(bb52[1])
  assume(move _86)
  using: _86@Mir(bb52[2])
  goto -> bb53
  using: 
bb53:
  _91 = _7
  using: _7@Phi(bb47)
  _90 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _91) -> bb54
  using: _91@Mir(bb53[0])
bb54:
  _89 = Not(move _90)
  using: _90@Mir(bb53[1])
  switchInt(move _89) -> [0: bb56, otherwise: bb55]
  using: _89@Mir(bb54[0])
bb55:
  _92 = const 6_i32
  using: 
  ((*_7).5: i32) = Neg(move _92)
  using: _7@Phi(bb47), _92@Mir(bb55[0])
  goto -> bb57
  using: 
bb56:
  _95 = _7
  using: _7@Phi(bb47)
  _94 = move _95 as usize (PointerExposeAddress)
  using: _95@Mir(bb56[0])
  _93 = Eq(move _94, const 0_usize)
  using: _94@Mir(bb56[1])
  assume(move _93)
  using: _93@Mir(bb56[2])
  goto -> bb57
  using: 
bb57:
  _0 = const 0_i32
  using: 
  goto -> bb134
  using: 
bb58:
  _98 = (((*_7).4: blocksort::bz_stream).1: u32)
  using: _7@Phi(bb57)
  _99 = const 0_u32
  using: 
  _97 = Eq(move _98, move _99)
  using: _98@Mir(bb58[0]), _99@Mir(bb58[1])
  switchInt(move _97) -> [0: bb59, otherwise: bb60]
  using: _97@Mir(bb58[2])
bb59:
  _96 = const false
  using: 
  goto -> bb61
  using: 
bb60:
  _102 = ((*_7).0: *mut blocksort::__sFILE)
  using: _7@Phi(bb57)
  _101 = bzlib::myfeof(move _102) -> bb62
  using: _102@Mir(bb60[0])
bb61:
  switchInt(move _96) -> [0: bb79, otherwise: bb63]
  using: _96@Phi(bb61)
bb62:
  _100 = Eq(move _101, const 0_u8)
  using: _101@Mir(bb60[1])
  _96 = move _100
  using: _100@Mir(bb62[0])
  goto -> bb61
  using: 
bb63:
  _107 = &mut ((*_7).1: [i8; 5000])
  using: _7@Phi(bb61)
  _106 = move _107 as &mut [i8] (Pointer(Unsize))
  using: _107@Mir(bb63[0])
  _105 = core::slice::<impl [i8]>::as_mut_ptr(move _106) -> bb64
  using: _106@Mir(bb63[1])
bb64:
  _104 = move _105 as *mut std::ffi::c_void (PtrToPtr)
  using: _105@Mir(bb63[2])
  _109 = std::mem::size_of::<u8>() -> bb65
  using: 
bb65:
  _108 = move _109 as u64 (IntToInt)
  using: _109@Mir(bb64[1])
  _110 = const 5000_u64
  using: 
  _111 = ((*_7).0: *mut blocksort::__sFILE)
  using: _7@Phi(bb61)
  _103 = bzlib::fread(move _104, move _108, move _110, move _111) -> bb66
  using: _104@Mir(bb64[0]), _108@Mir(bb65[0]), _110@Mir(bb65[1]), _111@Mir(bb65[2])
bb66:
  _5 = move _103 as i32 (IntToInt)
  using: _103@Mir(bb65[3])
  _113 = ((*_7).0: *mut blocksort::__sFILE)
  using: _7@Phi(bb61)
  _112 = bzlib::ferror(move _113) -> bb67
  using: _113@Mir(bb66[1])
bb67:
  switchInt(move _112) -> [0: bb77, otherwise: bb68]
  using: _112@Mir(bb66[2])
bb68:
  _116 = _1
  using: _1@Phi(bb53)
  _115 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _116) -> bb69
  using: _116@Mir(bb68[0])
bb69:
  _114 = Not(move _115)
  using: _115@Mir(bb68[1])
  switchInt(move _114) -> [0: bb71, otherwise: bb70]
  using: _114@Mir(bb69[0])
bb70:
  _117 = const 6_i32
  using: 
  (*_1) = Neg(move _117)
  using: _1@Phi(bb53), _117@Mir(bb70[0])
  goto -> bb72
  using: 
bb71:
  _120 = _1
  using: _1@Phi(bb53)
  _119 = move _120 as usize (PointerExposeAddress)
  using: _120@Mir(bb71[0])
  _118 = Eq(move _119, const 0_usize)
  using: _119@Mir(bb71[1])
  assume(move _118)
  using: _118@Mir(bb71[2])
  goto -> bb72
  using: 
bb72:
  _123 = _7
  using: _7@Phi(bb61)
  _122 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _123) -> bb73
  using: _123@Mir(bb72[0])
bb73:
  _121 = Not(move _122)
  using: _122@Mir(bb72[1])
  switchInt(move _121) -> [0: bb75, otherwise: bb74]
  using: _121@Mir(bb73[0])
bb74:
  _124 = const 6_i32
  using: 
  ((*_7).5: i32) = Neg(move _124)
  using: _7@Phi(bb61), _124@Mir(bb74[0])
  goto -> bb76
  using: 
bb75:
  _127 = _7
  using: _7@Phi(bb61)
  _126 = move _127 as usize (PointerExposeAddress)
  using: _127@Mir(bb75[0])
  _125 = Eq(move _126, const 0_usize)
  using: _126@Mir(bb75[1])
  assume(move _125)
  using: _125@Mir(bb75[2])
  goto -> bb76
  using: 
bb76:
  _0 = const 0_i32
  using: 
  goto -> bb134
  using: 
bb77:
  _128 = _5
  using: _5@Mir(bb66[0])
  ((*_7).2: i32) = move _128
  using: _7@Phi(bb76), _128@Mir(bb77[0])
  _129 = ((*_7).2: i32)
  using: _7@Phi(bb76)
  (((*_7).4: blocksort::bz_stream).1: u32) = move _129 as u32 (IntToInt)
  using: _7@Phi(bb76), _129@Mir(bb77[2])
  _132 = &mut ((*_7).1: [i8; 5000])
  using: _7@Phi(bb76)
  _131 = move _132 as &mut [i8] (Pointer(Unsize))
  using: _132@Mir(bb77[4])
  _130 = core::slice::<impl [i8]>::as_mut_ptr(move _131) -> bb78
  using: _131@Mir(bb77[5])
bb78:
  (((*_7).4: blocksort::bz_stream).0: *mut i8) = move _130
  using: _7@Phi(bb76), _130@Mir(bb77[6])
  goto -> bb79
  using: 
bb79:
  _135 = &mut ((*_7).4: blocksort::bz_stream)
  using: _7@Phi(bb79)
  _134 = &raw mut (*_135)
  using: _135@Mir(bb79[0])
  _133 = bzlib::BZ2_bzDecompress(move _134) -> bb80
  using: _134@Mir(bb79[1])
bb80:
  _6 = move _133
  using: _133@Mir(bb79[2])
  _138 = _6
  using: _6@Mir(bb80[0])
  _139 = const 0_i32
  using: 
  _137 = Ne(move _138, move _139)
  using: _138@Mir(bb80[1]), _139@Mir(bb80[2])
  switchInt(move _137) -> [0: bb81, otherwise: bb82]
  using: _137@Mir(bb80[3])
bb81:
  _136 = const false
  using: 
  goto -> bb83
  using: 
bb82:
  _141 = _6
  using: _6@Mir(bb80[0])
  _142 = const 4_i32
  using: 
  _140 = Ne(move _141, move _142)
  using: _141@Mir(bb82[0]), _142@Mir(bb82[1])
  _136 = move _140
  using: _140@Mir(bb82[2])
  goto -> bb83
  using: 
bb83:
  switchInt(move _136) -> [0: bb93, otherwise: bb84]
  using: _136@Phi(bb83)
bb84:
  _145 = _1
  using: _1@Phi(bb72)
  _144 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _145) -> bb85
  using: _145@Mir(bb84[0])
bb85:
  _143 = Not(move _144)
  using: _144@Mir(bb84[1])
  switchInt(move _143) -> [0: bb87, otherwise: bb86]
  using: _143@Mir(bb85[0])
bb86:
  _146 = _6
  using: _6@Phi(bb83)
  (*_1) = move _146
  using: _1@Phi(bb72), _146@Mir(bb86[0])
  goto -> bb88
  using: 
bb87:
  _149 = _1
  using: _1@Phi(bb72)
  _148 = move _149 as usize (PointerExposeAddress)
  using: _149@Mir(bb87[0])
  _147 = Eq(move _148, const 0_usize)
  using: _148@Mir(bb87[1])
  assume(move _147)
  using: _147@Mir(bb87[2])
  goto -> bb88
  using: 
bb88:
  _152 = _7
  using: _7@Phi(bb79)
  _151 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _152) -> bb89
  using: _152@Mir(bb88[0])
bb89:
  _150 = Not(move _151)
  using: _151@Mir(bb88[1])
  switchInt(move _150) -> [0: bb91, otherwise: bb90]
  using: _150@Mir(bb89[0])
bb90:
  _153 = _6
  using: _6@Phi(bb88)
  ((*_7).5: i32) = move _153
  using: _7@Phi(bb79), _153@Mir(bb90[0])
  goto -> bb92
  using: 
bb91:
  _156 = _7
  using: _7@Phi(bb79)
  _155 = move _156 as usize (PointerExposeAddress)
  using: _156@Mir(bb91[0])
  _154 = Eq(move _155, const 0_usize)
  using: _155@Mir(bb91[1])
  assume(move _154)
  using: _154@Mir(bb91[2])
  goto -> bb92
  using: 
bb92:
  _0 = const 0_i32
  using: 
  goto -> bb134
  using: 
bb93:
  _161 = _6
  using: _6@Phi(bb92)
  _162 = const 0_i32
  using: 
  _160 = Eq(move _161, move _162)
  using: _161@Mir(bb93[0]), _162@Mir(bb93[1])
  switchInt(move _160) -> [0: bb100, otherwise: bb101]
  using: _160@Mir(bb93[2])
bb94:
  _157 = const false
  using: 
  goto -> bb96
  using: 
bb95:
  _171 = (((*_7).4: blocksort::bz_stream).5: u32)
  using: _7@Phi(bb99)
  _172 = const 0_u32
  using: 
  _170 = Gt(move _171, move _172)
  using: _171@Mir(bb95[0]), _172@Mir(bb95[1])
  _157 = move _170
  using: _170@Mir(bb95[2])
  goto -> bb96
  using: 
bb96:
  switchInt(move _157) -> [0: bb113, otherwise: bb104]
  using: _157@Phi(bb96)
bb97:
  _158 = const false
  using: 
  goto -> bb99
  using: 
bb98:
  _168 = (((*_7).4: blocksort::bz_stream).1: u32)
  using: _7@Phi(bb102)
  _169 = const 0_u32
  using: 
  _167 = Eq(move _168, move _169)
  using: _168@Mir(bb98[0]), _169@Mir(bb98[1])
  _158 = move _167
  using: _167@Mir(bb98[2])
  goto -> bb99
  using: 
bb99:
  switchInt(move _158) -> [0: bb94, otherwise: bb95]
  using: _158@Phi(bb99)
bb100:
  _159 = const false
  using: 
  goto -> bb102
  using: 
bb101:
  _166 = ((*_7).0: *mut blocksort::__sFILE)
  using: _7@Phi(bb92)
  _165 = bzlib::myfeof(move _166) -> bb103
  using: _166@Mir(bb101[0])
bb102:
  switchInt(move _159) -> [0: bb97, otherwise: bb98]
  using: _159@Phi(bb102)
bb103:
  _164 = move _165 as i32 (IntToInt)
  using: _165@Mir(bb101[1])
  _163 = Ne(move _164, const 0_i32)
  using: _164@Mir(bb103[0])
  _159 = move _163
  using: _163@Mir(bb103[1])
  goto -> bb102
  using: 
bb104:
  _175 = _1
  using: _1@Phi(bb88)
  _174 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _175) -> bb105
  using: _175@Mir(bb104[0])
bb105:
  _173 = Not(move _174)
  using: _174@Mir(bb104[1])
  switchInt(move _173) -> [0: bb107, otherwise: bb106]
  using: _173@Mir(bb105[0])
bb106:
  _176 = const 7_i32
  using: 
  (*_1) = Neg(move _176)
  using: _1@Phi(bb88), _176@Mir(bb106[0])
  goto -> bb108
  using: 
bb107:
  _179 = _1
  using: _1@Phi(bb88)
  _178 = move _179 as usize (PointerExposeAddress)
  using: _179@Mir(bb107[0])
  _177 = Eq(move _178, const 0_usize)
  using: _178@Mir(bb107[1])
  assume(move _177)
  using: _177@Mir(bb107[2])
  goto -> bb108
  using: 
bb108:
  _182 = _7
  using: _7@Phi(bb96)
  _181 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _182) -> bb109
  using: _182@Mir(bb108[0])
bb109:
  _180 = Not(move _181)
  using: _181@Mir(bb108[1])
  switchInt(move _180) -> [0: bb111, otherwise: bb110]
  using: _180@Mir(bb109[0])
bb110:
  _183 = const 7_i32
  using: 
  ((*_7).5: i32) = Neg(move _183)
  using: _7@Phi(bb96), _183@Mir(bb110[0])
  goto -> bb112
  using: 
bb111:
  _186 = _7
  using: _7@Phi(bb96)
  _185 = move _186 as usize (PointerExposeAddress)
  using: _186@Mir(bb111[0])
  _184 = Eq(move _185, const 0_usize)
  using: _185@Mir(bb111[1])
  assume(move _184)
  using: _184@Mir(bb111[2])
  goto -> bb112
  using: 
bb112:
  _0 = const 0_i32
  using: 
  goto -> bb134
  using: 
bb113:
  _188 = _6
  using: _6@Phi(bb92)
  _189 = const 4_i32
  using: 
  _187 = Eq(move _188, move _189)
  using: _188@Mir(bb113[0]), _189@Mir(bb113[1])
  switchInt(move _187) -> [0: bb115, otherwise: bb114]
  using: _187@Mir(bb113[2])
bb114:
  _192 = _1
  using: _1@Phi(bb108)
  _191 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _192) -> bb116
  using: _192@Mir(bb114[0])
bb115:
  _209 = (((*_7).4: blocksort::bz_stream).5: u32)
  using: _7@Phi(bb123)
  _210 = const 0_u32
  using: 
  _208 = Eq(move _209, move _210)
  using: _209@Mir(bb115[0]), _210@Mir(bb115[1])
  switchInt(move _208) -> [0: bb47, otherwise: bb125]
  using: _208@Mir(bb115[2])
bb116:
  _190 = Not(move _191)
  using: _191@Mir(bb114[1])
  switchInt(move _190) -> [0: bb118, otherwise: bb117]
  using: _190@Mir(bb116[0])
bb117:
  _193 = const 4_i32
  using: 
  (*_1) = move _193
  using: _1@Phi(bb108), _193@Mir(bb117[0])
  goto -> bb119
  using: 
bb118:
  _196 = _1
  using: _1@Phi(bb108)
  _195 = move _196 as usize (PointerExposeAddress)
  using: _196@Mir(bb118[0])
  _194 = Eq(move _195, const 0_usize)
  using: _195@Mir(bb118[1])
  assume(move _194)
  using: _194@Mir(bb118[2])
  goto -> bb119
  using: 
bb119:
  _199 = _7
  using: _7@Phi(bb112)
  _198 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _199) -> bb120
  using: _199@Mir(bb119[0])
bb120:
  _197 = Not(move _198)
  using: _198@Mir(bb119[1])
  switchInt(move _197) -> [0: bb122, otherwise: bb121]
  using: _197@Mir(bb120[0])
bb121:
  _200 = const 4_i32
  using: 
  ((*_7).5: i32) = move _200
  using: _7@Phi(bb112), _200@Mir(bb121[0])
  goto -> bb123
  using: 
bb122:
  _203 = _7
  using: _7@Phi(bb112)
  _202 = move _203 as usize (PointerExposeAddress)
  using: _203@Mir(bb122[0])
  _201 = Eq(move _202, const 0_usize)
  using: _202@Mir(bb122[1])
  assume(move _201)
  using: _201@Mir(bb122[2])
  goto -> bb123
  using: 
bb123:
  _206 = _4
  using: _4@Phi(bb11)
  _205 = move _206 as u32 (IntToInt)
  using: _206@Mir(bb123[0])
  _207 = (((*_7).4: blocksort::bz_stream).5: u32)
  using: _7@Phi(bb123)
  _204 = core::num::<impl u32>::wrapping_sub(move _205, move _207) -> bb124
  using: _205@Mir(bb123[1]), _207@Mir(bb123[2])
bb124:
  _0 = move _204 as i32 (IntToInt)
  using: _204@Mir(bb123[3])
  goto -> bb134
  using: 
bb125:
  _213 = _1
  using: _1@Phi(bb119)
  _212 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _213) -> bb126
  using: _213@Mir(bb125[0])
bb126:
  _211 = Not(move _212)
  using: _212@Mir(bb125[1])
  switchInt(move _211) -> [0: bb128, otherwise: bb127]
  using: _211@Mir(bb126[0])
bb127:
  _214 = const 0_i32
  using: 
  (*_1) = move _214
  using: _1@Phi(bb119), _214@Mir(bb127[0])
  goto -> bb129
  using: 
bb128:
  _217 = _1
  using: _1@Phi(bb119)
  _216 = move _217 as usize (PointerExposeAddress)
  using: _217@Mir(bb128[0])
  _215 = Eq(move _216, const 0_usize)
  using: _216@Mir(bb128[1])
  assume(move _215)
  using: _215@Mir(bb128[2])
  goto -> bb129
  using: 
bb129:
  _220 = _7
  using: _7@Phi(bb123)
  _219 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _220) -> bb130
  using: _220@Mir(bb129[0])
bb130:
  _218 = Not(move _219)
  using: _219@Mir(bb129[1])
  switchInt(move _218) -> [0: bb132, otherwise: bb131]
  using: _218@Mir(bb130[0])
bb131:
  _221 = const 0_i32
  using: 
  ((*_7).5: i32) = move _221
  using: _7@Phi(bb123), _221@Mir(bb131[0])
  goto -> bb133
  using: 
bb132:
  _224 = _7
  using: _7@Phi(bb123)
  _223 = move _224 as usize (PointerExposeAddress)
  using: _224@Mir(bb132[0])
  _222 = Eq(move _223, const 0_usize)
  using: _223@Mir(bb132[1])
  assume(move _222)
  using: _222@Mir(bb132[2])
  goto -> bb133
  using: 
bb133:
  _0 = _4
  using: _4@Phi(bb11)
  goto -> bb134
  using: 
bb134:
  return
  using: _0@Phi(bb134)
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:2016:12: 2016:33 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/bzlib.rs:2025:23: 2025:53 (#0) by default
rewrite call bzlib::fread @ workspace/bzip2/rust/bzlib.rs:2024:17: 2026:91 (#0) by default
rewrite call bzlib::ferror @ workspace/bzip2/rust/bzlib.rs:2028:16: 2028:37 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:2054:50: 2054:85 (#0) by default
@DefId(0:387 ~ c2rust_lib[1043]::bzlib::BZ2_bzReadGetUnused)
bb0:
  _6 = _2
  using: _2@Entry
  _5 = move _6 as *mut bzlib::bzFile (PtrToPtr)
  using: _6@Mir(bb0[0])
  _8 = _5
  using: _5@Mir(bb0[1])
  _7 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _8) -> bb1
  using: _8@Mir(bb0[2])
bb1:
  switchInt(move _7) -> [0: bb10, otherwise: bb2]
  using: _7@Mir(bb0[3])
bb2:
  _11 = _5
  using: _5@Mir(bb0[1])
  _10 = move _11 as usize (PointerExposeAddress)
  using: _11@Mir(bb2[0])
  _9 = Eq(move _10, const 0_usize)
  using: _10@Mir(bb2[1])
  assume(move _9)
  using: _9@Mir(bb2[2])
  _14 = _1
  using: _1@Entry
  _13 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _14) -> bb3
  using: _14@Mir(bb2[4])
bb3:
  _12 = Not(move _13)
  using: _13@Mir(bb2[5])
  switchInt(move _12) -> [0: bb5, otherwise: bb4]
  using: _12@Mir(bb3[0])
bb4:
  _15 = const 2_i32
  using: 
  (*_1) = Neg(move _15)
  using: _1@Entry, _15@Mir(bb4[0])
  goto -> bb6
  using: 
bb5:
  _18 = _1
  using: _1@Entry
  _17 = move _18 as usize (PointerExposeAddress)
  using: _18@Mir(bb5[0])
  _16 = Eq(move _17, const 0_usize)
  using: _17@Mir(bb5[1])
  assume(move _16)
  using: _16@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  _21 = _5
  using: _5@Mir(bb0[1])
  _20 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _21) -> bb7
  using: _21@Mir(bb6[0])
bb7:
  _19 = Not(move _20)
  using: _20@Mir(bb6[1])
  switchInt(move _19) -> [0: bb9, otherwise: bb8]
  using: _19@Mir(bb7[0])
bb8:
  _22 = const 2_i32
  using: 
  ((*_5).5: i32) = Neg(move _22)
  using: _5@Mir(bb0[1]), _22@Mir(bb8[0])
  goto -> bb42
  using: 
bb9:
  _25 = _5
  using: _5@Mir(bb0[1])
  _24 = move _25 as usize (PointerExposeAddress)
  using: _25@Mir(bb9[0])
  _23 = Eq(move _24, const 0_usize)
  using: _24@Mir(bb9[1])
  assume(move _23)
  using: _23@Mir(bb9[2])
  goto -> bb42
  using: 
bb10:
  _27 = ((*_5).5: i32)
  using: _5@Mir(bb0[1])
  _28 = const 4_i32
  using: 
  _26 = Ne(move _27, move _28)
  using: _27@Mir(bb10[0]), _28@Mir(bb10[1])
  switchInt(move _26) -> [0: bb12, otherwise: bb11]
  using: _26@Mir(bb10[2])
bb11:
  _31 = _1
  using: _1@Phi(bb6)
  _30 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _31) -> bb13
  using: _31@Mir(bb11[0])
bb12:
  _45 = _3
  using: _3@Entry
  _44 = std::ptr::mut_ptr::<impl *mut *mut std::ffi::c_void>::is_null(move _45) -> bb23
  using: _45@Mir(bb12[0])
bb13:
  _29 = Not(move _30)
  using: _30@Mir(bb11[1])
  switchInt(move _29) -> [0: bb15, otherwise: bb14]
  using: _29@Mir(bb13[0])
bb14:
  _32 = const 1_i32
  using: 
  (*_1) = Neg(move _32)
  using: _1@Phi(bb6), _32@Mir(bb14[0])
  goto -> bb16
  using: 
bb15:
  _35 = _1
  using: _1@Phi(bb6)
  _34 = move _35 as usize (PointerExposeAddress)
  using: _35@Mir(bb15[0])
  _33 = Eq(move _34, const 0_usize)
  using: _34@Mir(bb15[1])
  assume(move _33)
  using: _33@Mir(bb15[2])
  goto -> bb16
  using: 
bb16:
  _38 = _5
  using: _5@Mir(bb0[1])
  _37 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _38) -> bb17
  using: _38@Mir(bb16[0])
bb17:
  _36 = Not(move _37)
  using: _37@Mir(bb16[1])
  switchInt(move _36) -> [0: bb19, otherwise: bb18]
  using: _36@Mir(bb17[0])
bb18:
  _39 = const 1_i32
  using: 
  ((*_5).5: i32) = Neg(move _39)
  using: _5@Mir(bb0[1]), _39@Mir(bb18[0])
  goto -> bb42
  using: 
bb19:
  _42 = _5
  using: _5@Mir(bb0[1])
  _41 = move _42 as usize (PointerExposeAddress)
  using: _42@Mir(bb19[0])
  _40 = Eq(move _41, const 0_usize)
  using: _41@Mir(bb19[1])
  assume(move _40)
  using: _40@Mir(bb19[2])
  goto -> bb42
  using: 
bb20:
  _43 = const true
  using: 
  goto -> bb22
  using: 
bb21:
  _47 = _4
  using: _4@Entry
  _46 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _47) -> bb24
  using: _47@Mir(bb21[0])
bb22:
  switchInt(move _43) -> [0: bb33, otherwise: bb25]
  using: _43@Phi(bb22)
bb23:
  switchInt(move _44) -> [0: bb21, otherwise: bb20]
  using: _44@Mir(bb12[1])
bb24:
  _43 = move _46
  using: _46@Mir(bb21[1])
  goto -> bb22
  using: 
bb25:
  _50 = _1
  using: _1@Phi(bb16)
  _49 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _50) -> bb26
  using: _50@Mir(bb25[0])
bb26:
  _48 = Not(move _49)
  using: _49@Mir(bb25[1])
  switchInt(move _48) -> [0: bb28, otherwise: bb27]
  using: _48@Mir(bb26[0])
bb27:
  _51 = const 2_i32
  using: 
  (*_1) = Neg(move _51)
  using: _1@Phi(bb16), _51@Mir(bb27[0])
  goto -> bb29
  using: 
bb28:
  _54 = _1
  using: _1@Phi(bb16)
  _53 = move _54 as usize (PointerExposeAddress)
  using: _54@Mir(bb28[0])
  _52 = Eq(move _53, const 0_usize)
  using: _53@Mir(bb28[1])
  assume(move _52)
  using: _52@Mir(bb28[2])
  goto -> bb29
  using: 
bb29:
  _57 = _5
  using: _5@Mir(bb0[1])
  _56 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _57) -> bb30
  using: _57@Mir(bb29[0])
bb30:
  _55 = Not(move _56)
  using: _56@Mir(bb29[1])
  switchInt(move _55) -> [0: bb32, otherwise: bb31]
  using: _55@Mir(bb30[0])
bb31:
  _58 = const 2_i32
  using: 
  ((*_5).5: i32) = Neg(move _58)
  using: _5@Mir(bb0[1]), _58@Mir(bb31[0])
  goto -> bb42
  using: 
bb32:
  _61 = _5
  using: _5@Mir(bb0[1])
  _60 = move _61 as usize (PointerExposeAddress)
  using: _61@Mir(bb32[0])
  _59 = Eq(move _60, const 0_usize)
  using: _60@Mir(bb32[1])
  assume(move _59)
  using: _59@Mir(bb32[2])
  goto -> bb42
  using: 
bb33:
  _64 = _1
  using: _1@Phi(bb29)
  _63 = std::ptr::mut_ptr::<impl *mut i32>::is_null(move _64) -> bb34
  using: _64@Mir(bb33[0])
bb34:
  _62 = Not(move _63)
  using: _63@Mir(bb33[1])
  switchInt(move _62) -> [0: bb36, otherwise: bb35]
  using: _62@Mir(bb34[0])
bb35:
  _65 = const 0_i32
  using: 
  (*_1) = move _65
  using: _1@Phi(bb29), _65@Mir(bb35[0])
  goto -> bb37
  using: 
bb36:
  _68 = _1
  using: _1@Phi(bb29)
  _67 = move _68 as usize (PointerExposeAddress)
  using: _68@Mir(bb36[0])
  _66 = Eq(move _67, const 0_usize)
  using: _67@Mir(bb36[1])
  assume(move _66)
  using: _66@Mir(bb36[2])
  goto -> bb37
  using: 
bb37:
  _71 = _5
  using: _5@Mir(bb0[1])
  _70 = std::ptr::mut_ptr::<impl *mut bzlib::bzFile>::is_null(move _71) -> bb38
  using: _71@Mir(bb37[0])
bb38:
  _69 = Not(move _70)
  using: _70@Mir(bb37[1])
  switchInt(move _69) -> [0: bb40, otherwise: bb39]
  using: _69@Mir(bb38[0])
bb39:
  _72 = const 0_i32
  using: 
  ((*_5).5: i32) = move _72
  using: _5@Mir(bb0[1]), _72@Mir(bb39[0])
  goto -> bb41
  using: 
bb40:
  _75 = _5
  using: _5@Mir(bb0[1])
  _74 = move _75 as usize (PointerExposeAddress)
  using: _75@Mir(bb40[0])
  _73 = Eq(move _74, const 0_usize)
  using: _74@Mir(bb40[1])
  assume(move _73)
  using: _73@Mir(bb40[2])
  goto -> bb41
  using: 
bb41:
  _76 = (((*_5).4: blocksort::bz_stream).1: u32)
  using: _5@Phi(bb41)
  (*_4) = move _76 as i32 (IntToInt)
  using: _4@Phi(bb22), _76@Mir(bb41[0])
  _77 = (((*_5).4: blocksort::bz_stream).0: *mut i8)
  using: _5@Phi(bb41)
  (*_3) = move _77 as *mut std::ffi::c_void (PtrToPtr)
  using: _3@Entry, _77@Mir(bb41[2])
  goto -> bb42
  using: 
bb42:
  return
  using: _0@Entry
@DefId(0:388 ~ c2rust_lib[1043]::bzlib::BZ2_bzBuffToBuffCompress)
bb0:
  _9 = const {0x0 as *mut i8}
  using: 
  _10 = const {0x0 as *mut i8}
  using: 
  _11 = const {0x0 as *mut std::ffi::c_void}
  using: 
  Deinit(_12)
  using: 
  discriminant(_12) = 0
  using: 
  Deinit(_13)
  using: 
  discriminant(_13) = 0
  using: 
  _14 = const {0x0 as *mut std::ffi::c_void}
  using: 
  Deinit(_8)
  using: 
  (_8.0: *mut i8) = move _9
  using: _9@Mir(bb0[0])
  (_8.1: u32) = const 0_u32
  using: 
  (_8.2: u32) = const 0_u32
  using: 
  (_8.3: u32) = const 0_u32
  using: 
  (_8.4: *mut i8) = move _10
  using: _10@Mir(bb0[1])
  (_8.5: u32) = const 0_u32
  using: 
  (_8.6: u32) = const 0_u32
  using: 
  (_8.7: u32) = const 0_u32
  using: 
  (_8.8: *mut std::ffi::c_void) = move _11
  using: _11@Mir(bb0[2])
  (_8.9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _12
  using: _12@Mir(bb0[3])
  (_8.10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _13
  using: _13@Mir(bb0[5])
  (_8.11: *mut std::ffi::c_void) = move _14
  using: _14@Mir(bb0[7])
  _15 = const 0_i32
  using: 
  _25 = _1
  using: _1@Entry
  _24 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _25) -> bb25
  using: _25@Mir(bb0[22])
bb1:
  _16 = const true
  using: 
  goto -> bb3
  using: 
bb2:
  _46 = _7
  using: _7@Phi(bb6)
  _47 = const 250_i32
  using: 
  _45 = Gt(move _46, move _47)
  using: _46@Mir(bb2[0]), _47@Mir(bb2[1])
  _16 = move _45
  using: _45@Mir(bb2[2])
  goto -> bb3
  using: 
bb3:
  switchInt(move _16) -> [0: bb29, otherwise: bb28]
  using: _16@Phi(bb3)
bb4:
  _17 = const true
  using: 
  goto -> bb6
  using: 
bb5:
  _43 = _7
  using: _7@Entry
  _44 = const 0_i32
  using: 
  _42 = Lt(move _43, move _44)
  using: _43@Mir(bb5[0]), _44@Mir(bb5[1])
  _17 = move _42
  using: _42@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  switchInt(move _17) -> [0: bb2, otherwise: bb1]
  using: _17@Phi(bb6)
bb7:
  _18 = const true
  using: 
  goto -> bb9
  using: 
bb8:
  _40 = _6
  using: _6@Phi(bb12)
  _41 = const 4_i32
  using: 
  _39 = Gt(move _40, move _41)
  using: _40@Mir(bb8[0]), _41@Mir(bb8[1])
  _18 = move _39
  using: _39@Mir(bb8[2])
  goto -> bb9
  using: 
bb9:
  switchInt(move _18) -> [0: bb5, otherwise: bb4]
  using: _18@Phi(bb9)
bb10:
  _19 = const true
  using: 
  goto -> bb12
  using: 
bb11:
  _37 = _6
  using: _6@Entry
  _38 = const 0_i32
  using: 
  _36 = Lt(move _37, move _38)
  using: _37@Mir(bb11[0]), _38@Mir(bb11[1])
  _19 = move _36
  using: _36@Mir(bb11[2])
  goto -> bb12
  using: 
bb12:
  switchInt(move _19) -> [0: bb8, otherwise: bb7]
  using: _19@Phi(bb12)
bb13:
  _20 = const true
  using: 
  goto -> bb15
  using: 
bb14:
  _34 = _5
  using: _5@Phi(bb18)
  _35 = const 9_i32
  using: 
  _33 = Gt(move _34, move _35)
  using: _34@Mir(bb14[0]), _35@Mir(bb14[1])
  _20 = move _33
  using: _33@Mir(bb14[2])
  goto -> bb15
  using: 
bb15:
  switchInt(move _20) -> [0: bb11, otherwise: bb10]
  using: _20@Phi(bb15)
bb16:
  _21 = const true
  using: 
  goto -> bb18
  using: 
bb17:
  _31 = _5
  using: _5@Entry
  _32 = const 1_i32
  using: 
  _30 = Lt(move _31, move _32)
  using: _31@Mir(bb17[0]), _32@Mir(bb17[1])
  _21 = move _30
  using: _30@Mir(bb17[2])
  goto -> bb18
  using: 
bb18:
  switchInt(move _21) -> [0: bb14, otherwise: bb13]
  using: _21@Phi(bb18)
bb19:
  _22 = const true
  using: 
  goto -> bb21
  using: 
bb20:
  _29 = _3
  using: _3@Entry
  _28 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _29) -> bb27
  using: _29@Mir(bb20[0])
bb21:
  switchInt(move _22) -> [0: bb17, otherwise: bb16]
  using: _22@Phi(bb21)
bb22:
  _23 = const true
  using: 
  goto -> bb24
  using: 
bb23:
  _27 = _2
  using: _2@Entry
  _26 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _27) -> bb26
  using: _27@Mir(bb23[0])
bb24:
  switchInt(move _23) -> [0: bb20, otherwise: bb19]
  using: _23@Phi(bb24)
bb25:
  switchInt(move _24) -> [0: bb23, otherwise: bb22]
  using: _24@Mir(bb0[23])
bb26:
  _23 = move _26
  using: _26@Mir(bb23[1])
  goto -> bb24
  using: 
bb27:
  _22 = move _28
  using: _28@Mir(bb20[1])
  goto -> bb21
  using: 
bb28:
  _0 = const -2_i32
  using: 
  goto -> bb44
  using: 
bb29:
  _49 = _7
  using: _7@Phi(bb3)
  _50 = const 0_i32
  using: 
  _48 = Eq(move _49, move _50)
  using: _49@Mir(bb29[0]), _50@Mir(bb29[1])
  switchInt(move _48) -> [0: bb31, otherwise: bb30]
  using: _48@Mir(bb29[2])
bb30:
  _7 = const 30_i32
  using: 
  goto -> bb31
  using: 
bb31:
  Deinit(_51)
  using: 
  discriminant(_51) = 0
  using: 
  (_8.9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _51
  using: _51@Mir(bb31[0])
  Deinit(_52)
  using: 
  discriminant(_52) = 0
  using: 
  (_8.10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _52
  using: _52@Mir(bb31[3])
  (_8.11: *mut std::ffi::c_void) = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: 
  _55 = &mut _8
  using: _8@Mir(bb0[8])
  _54 = &raw mut (*_55)
  using: _55@Mir(bb31[7])
  _56 = _5
  using: _5@Phi(bb15)
  _57 = _6
  using: _6@Phi(bb9)
  _58 = _7
  using: _7@Phi(bb31)
  _53 = bzlib::BZ2_bzCompressInit(move _54, move _56, move _57, move _58) -> bb32
  using: _54@Mir(bb31[8]), _56@Mir(bb31[9]), _57@Mir(bb31[10]), _58@Mir(bb31[11])
bb32:
  _15 = move _53
  using: _53@Mir(bb31[12])
  _60 = _15
  using: _15@Mir(bb32[0])
  _61 = const 0_i32
  using: 
  _59 = Ne(move _60, move _61)
  using: _60@Mir(bb32[1]), _61@Mir(bb32[2])
  switchInt(move _59) -> [0: bb34, otherwise: bb33]
  using: _59@Mir(bb32[3])
bb33:
  _0 = _15
  using: _15@Mir(bb32[0])
  goto -> bb44
  using: 
bb34:
  _62 = _3
  using: _3@Phi(bb21)
  (_8.0: *mut i8) = move _62
  using: _62@Mir(bb34[0])
  _63 = _1
  using: _1@Entry
  (_8.4: *mut i8) = move _63
  using: _63@Mir(bb34[2])
  _64 = _4
  using: _4@Entry
  (_8.1: u32) = move _64
  using: _64@Mir(bb34[4])
  _65 = (*_2)
  using: _2@Phi(bb24)
  (_8.5: u32) = move _65
  using: _65@Mir(bb34[6])
  _68 = &mut _8
  using: _8@Mir(bb0[8])
  _67 = &raw mut (*_68)
  using: _68@Mir(bb34[8])
  _69 = const 2_i32
  using: 
  _66 = bzlib::BZ2_bzCompress(move _67, move _69) -> bb35
  using: _67@Mir(bb34[9]), _69@Mir(bb34[10])
bb35:
  _15 = move _66
  using: _66@Mir(bb34[11])
  _71 = _15
  using: _15@Mir(bb35[0])
  _72 = const 3_i32
  using: 
  _70 = Eq(move _71, move _72)
  using: _71@Mir(bb35[1]), _72@Mir(bb35[2])
  switchInt(move _70) -> [0: bb38, otherwise: bb36]
  using: _70@Mir(bb35[3])
bb36:
  _75 = &mut _8
  using: _8@Mir(bb0[8])
  _74 = &raw mut (*_75)
  using: _75@Mir(bb36[0])
  _73 = bzlib::BZ2_bzCompressEnd(move _74) -> bb37
  using: _74@Mir(bb36[1])
bb37:
  _0 = const -8_i32
  using: 
  goto -> bb44
  using: 
bb38:
  _77 = _15
  using: _15@Mir(bb35[0])
  _78 = const 4_i32
  using: 
  _76 = Ne(move _77, move _78)
  using: _77@Mir(bb38[0]), _78@Mir(bb38[1])
  switchInt(move _76) -> [0: bb41, otherwise: bb39]
  using: _76@Mir(bb38[2])
bb39:
  _81 = &mut _8
  using: _8@Mir(bb0[8])
  _80 = &raw mut (*_81)
  using: _81@Mir(bb39[0])
  _79 = bzlib::BZ2_bzCompressEnd(move _80) -> bb40
  using: _80@Mir(bb39[1])
bb40:
  _0 = _15
  using: _15@Mir(bb35[0])
  goto -> bb44
  using: 
bb41:
  _83 = (*_2)
  using: _2@Phi(bb24)
  _84 = (_8.5: u32)
  using: _8@Mir(bb0[8])
  _82 = core::num::<impl u32>::wrapping_sub(move _83, move _84) -> bb42
  using: _83@Mir(bb41[0]), _84@Mir(bb41[1])
bb42:
  (*_2) = move _82
  using: _2@Phi(bb24), _82@Mir(bb41[2])
  _87 = &mut _8
  using: _8@Mir(bb0[8])
  _86 = &raw mut (*_87)
  using: _87@Mir(bb42[1])
  _85 = bzlib::BZ2_bzCompressEnd(move _86) -> bb43
  using: _86@Mir(bb42[2])
bb43:
  _0 = const 0_i32
  using: 
  goto -> bb44
  using: 
bb44:
  return
  using: _0@Phi(bb44)
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_12) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_12) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_13) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_13) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_8) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_51) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_51) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_52) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_52) = 0 is ignored
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:2150:31: 2150:59 (#0) by default
@DefId(0:389 ~ c2rust_lib[1043]::bzlib::BZ2_bzBuffToBuffDecompress)
bb0:
  _8 = const {0x0 as *mut i8}
  using: 
  _9 = const {0x0 as *mut i8}
  using: 
  _10 = const {0x0 as *mut std::ffi::c_void}
  using: 
  Deinit(_11)
  using: 
  discriminant(_11) = 0
  using: 
  Deinit(_12)
  using: 
  discriminant(_12) = 0
  using: 
  _13 = const {0x0 as *mut std::ffi::c_void}
  using: 
  Deinit(_7)
  using: 
  (_7.0: *mut i8) = move _8
  using: _8@Mir(bb0[0])
  (_7.1: u32) = const 0_u32
  using: 
  (_7.2: u32) = const 0_u32
  using: 
  (_7.3: u32) = const 0_u32
  using: 
  (_7.4: *mut i8) = move _9
  using: _9@Mir(bb0[1])
  (_7.5: u32) = const 0_u32
  using: 
  (_7.6: u32) = const 0_u32
  using: 
  (_7.7: u32) = const 0_u32
  using: 
  (_7.8: *mut std::ffi::c_void) = move _10
  using: _10@Mir(bb0[2])
  (_7.9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _11
  using: _11@Mir(bb0[3])
  (_7.10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _12
  using: _12@Mir(bb0[5])
  (_7.11: *mut std::ffi::c_void) = move _13
  using: _13@Mir(bb0[7])
  _14 = const 0_i32
  using: 
  _21 = _1
  using: _1@Entry
  _20 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _21) -> bb16
  using: _21@Mir(bb0[22])
bb1:
  _15 = const true
  using: 
  goto -> bb3
  using: 
bb2:
  _37 = _6
  using: _6@Phi(bb6)
  _38 = const 4_i32
  using: 
  _36 = Gt(move _37, move _38)
  using: _37@Mir(bb2[0]), _38@Mir(bb2[1])
  _15 = move _36
  using: _36@Mir(bb2[2])
  goto -> bb3
  using: 
bb3:
  switchInt(move _15) -> [0: bb23, otherwise: bb22]
  using: _15@Phi(bb3)
bb4:
  _16 = const true
  using: 
  goto -> bb6
  using: 
bb5:
  _34 = _6
  using: _6@Entry
  _35 = const 0_i32
  using: 
  _33 = Lt(move _34, move _35)
  using: _34@Mir(bb5[0]), _35@Mir(bb5[1])
  _16 = move _33
  using: _33@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  switchInt(move _16) -> [0: bb2, otherwise: bb1]
  using: _16@Phi(bb6)
bb7:
  _17 = const true
  using: 
  goto -> bb9
  using: 
bb8:
  _28 = _5
  using: _5@Entry
  _29 = const 0_i32
  using: 
  _27 = Ne(move _28, move _29)
  using: _28@Mir(bb8[0]), _29@Mir(bb8[1])
  switchInt(move _27) -> [0: bb19, otherwise: bb20]
  using: _27@Mir(bb8[2])
bb9:
  switchInt(move _17) -> [0: bb5, otherwise: bb4]
  using: _17@Phi(bb9)
bb10:
  _18 = const true
  using: 
  goto -> bb12
  using: 
bb11:
  _25 = _3
  using: _3@Entry
  _24 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _25) -> bb18
  using: _25@Mir(bb11[0])
bb12:
  switchInt(move _18) -> [0: bb8, otherwise: bb7]
  using: _18@Phi(bb12)
bb13:
  _19 = const true
  using: 
  goto -> bb15
  using: 
bb14:
  _23 = _2
  using: _2@Entry
  _22 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _23) -> bb17
  using: _23@Mir(bb14[0])
bb15:
  switchInt(move _19) -> [0: bb11, otherwise: bb10]
  using: _19@Phi(bb15)
bb16:
  switchInt(move _20) -> [0: bb14, otherwise: bb13]
  using: _20@Mir(bb0[23])
bb17:
  _19 = move _22
  using: _22@Mir(bb14[1])
  goto -> bb15
  using: 
bb18:
  _18 = move _24
  using: _24@Mir(bb11[1])
  goto -> bb12
  using: 
bb19:
  _26 = const false
  using: 
  goto -> bb21
  using: 
bb20:
  _31 = _5
  using: _5@Entry
  _32 = const 1_i32
  using: 
  _30 = Ne(move _31, move _32)
  using: _31@Mir(bb20[0]), _32@Mir(bb20[1])
  _26 = move _30
  using: _30@Mir(bb20[2])
  goto -> bb21
  using: 
bb21:
  _17 = move _26
  using: _26@Phi(bb21)
  goto -> bb9
  using: 
bb22:
  _0 = const -2_i32
  using: 
  goto -> bb39
  using: 
bb23:
  Deinit(_39)
  using: 
  discriminant(_39) = 0
  using: 
  (_7.9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>) = move _39
  using: _39@Mir(bb23[0])
  Deinit(_40)
  using: 
  discriminant(_40) = 0
  using: 
  (_7.10: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, *mut std::ffi::c_void)>) = move _40
  using: _40@Mir(bb23[3])
  (_7.11: *mut std::ffi::c_void) = const 0_usize as *mut std::ffi::c_void (PointerFromExposedAddress)
  using: 
  _43 = &mut _7
  using: _7@Mir(bb0[8])
  _42 = &raw mut (*_43)
  using: _43@Mir(bb23[7])
  _44 = _6
  using: _6@Phi(bb3)
  _45 = _5
  using: _5@Phi(bb9)
  _41 = bzlib::BZ2_bzDecompressInit(move _42, move _44, move _45) -> bb24
  using: _42@Mir(bb23[8]), _44@Mir(bb23[9]), _45@Mir(bb23[10])
bb24:
  _14 = move _41
  using: _41@Mir(bb23[11])
  _47 = _14
  using: _14@Mir(bb24[0])
  _48 = const 0_i32
  using: 
  _46 = Ne(move _47, move _48)
  using: _47@Mir(bb24[1]), _48@Mir(bb24[2])
  switchInt(move _46) -> [0: bb26, otherwise: bb25]
  using: _46@Mir(bb24[3])
bb25:
  _0 = _14
  using: _14@Mir(bb24[0])
  goto -> bb39
  using: 
bb26:
  _49 = _3
  using: _3@Phi(bb12)
  (_7.0: *mut i8) = move _49
  using: _49@Mir(bb26[0])
  _50 = _1
  using: _1@Entry
  (_7.4: *mut i8) = move _50
  using: _50@Mir(bb26[2])
  _51 = _4
  using: _4@Entry
  (_7.1: u32) = move _51
  using: _51@Mir(bb26[4])
  _52 = (*_2)
  using: _2@Phi(bb15)
  (_7.5: u32) = move _52
  using: _52@Mir(bb26[6])
  _55 = &mut _7
  using: _7@Mir(bb0[8])
  _54 = &raw mut (*_55)
  using: _55@Mir(bb26[8])
  _53 = bzlib::BZ2_bzDecompress(move _54) -> bb27
  using: _54@Mir(bb26[9])
bb27:
  _14 = move _53
  using: _53@Mir(bb26[10])
  _57 = _14
  using: _14@Mir(bb27[0])
  _58 = const 0_i32
  using: 
  _56 = Eq(move _57, move _58)
  using: _57@Mir(bb27[1]), _58@Mir(bb27[2])
  switchInt(move _56) -> [0: bb33, otherwise: bb28]
  using: _56@Mir(bb27[3])
bb28:
  _60 = (_7.5: u32)
  using: _7@Mir(bb0[8])
  _61 = const 0_u32
  using: 
  _59 = Gt(move _60, move _61)
  using: _60@Mir(bb28[0]), _61@Mir(bb28[1])
  switchInt(move _59) -> [0: bb31, otherwise: bb29]
  using: _59@Mir(bb28[2])
bb29:
  _64 = &mut _7
  using: _7@Mir(bb0[8])
  _63 = &raw mut (*_64)
  using: _64@Mir(bb29[0])
  _62 = bzlib::BZ2_bzDecompressEnd(move _63) -> bb30
  using: _63@Mir(bb29[1])
bb30:
  _0 = const -7_i32
  using: 
  goto -> bb39
  using: 
bb31:
  _67 = &mut _7
  using: _7@Mir(bb0[8])
  _66 = &raw mut (*_67)
  using: _67@Mir(bb31[0])
  _65 = bzlib::BZ2_bzDecompressEnd(move _66) -> bb32
  using: _66@Mir(bb31[1])
bb32:
  _0 = const -8_i32
  using: 
  goto -> bb39
  using: 
bb33:
  _69 = _14
  using: _14@Mir(bb27[0])
  _70 = const 4_i32
  using: 
  _68 = Ne(move _69, move _70)
  using: _69@Mir(bb33[0]), _70@Mir(bb33[1])
  switchInt(move _68) -> [0: bb36, otherwise: bb34]
  using: _68@Mir(bb33[2])
bb34:
  _73 = &mut _7
  using: _7@Mir(bb0[8])
  _72 = &raw mut (*_73)
  using: _73@Mir(bb34[0])
  _71 = bzlib::BZ2_bzDecompressEnd(move _72) -> bb35
  using: _72@Mir(bb34[1])
bb35:
  _0 = _14
  using: _14@Mir(bb27[0])
  goto -> bb39
  using: 
bb36:
  _75 = (*_2)
  using: _2@Phi(bb15)
  _76 = (_7.5: u32)
  using: _7@Mir(bb0[8])
  _74 = core::num::<impl u32>::wrapping_sub(move _75, move _76) -> bb37
  using: _75@Mir(bb36[0]), _76@Mir(bb36[1])
bb37:
  (*_2) = move _74
  using: _2@Phi(bb15), _74@Mir(bb36[2])
  _79 = &mut _7
  using: _7@Mir(bb0[8])
  _78 = &raw mut (*_79)
  using: _79@Mir(bb37[1])
  _77 = bzlib::BZ2_bzDecompressEnd(move _78) -> bb38
  using: _78@Mir(bb37[2])
bb38:
  _0 = const 0_i32
  using: 
  goto -> bb39
  using: 
bb39:
  return
  using: _0@Phi(bb39)
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_11) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_11) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_12) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_12) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_7) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_39) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_39) = 0 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_40) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_40) = 0 is ignored
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/bzlib.rs:2208:31: 2208:59 (#0) by default
@DefId(0:390 ~ c2rust_lib[1043]::bzlib::BZ2_bzlibVersion)
bb0:
  _3 = const b"1.0.8, 13-Jul-2019\x00"
  using: 
  _2 = &raw const (*_3)
  using: _3@Mir(bb0[0])
  _1 = move _2 as *const u8 (Pointer(ArrayToPointer))
  using: _2@Mir(bb0[1])
  _0 = move _1 as *const i8 (PtrToPtr)
  using: _1@Mir(bb0[2])
  return
  using: _0@Mir(bb0[3])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:391 ~ c2rust_lib[1043]::bzlib::bzopen_or_bzdopen)
bb0:
  _5 = const 0_i32
  using: 
  _6 = [const 0_i8; 5000]
  using: 
  _7 = const 9_i32
  using: 
  _8 = const 0_i32
  using: 
  _9 = [const 0_i8; 10]
  using: 
  _10 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _11 = const {0x0 as *mut std::ffi::c_void}
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 30_i32
  using: 
  _14 = const 0_i32
  using: 
  _15 = const 0_i32
  using: 
  _17 = _3
  using: _3@Entry
  _16 = std::ptr::const_ptr::<impl *const i8>::is_null(move _17) -> bb1
  using: _17@Mir(bb0[11])
bb1:
  switchInt(move _16) -> [0: bb3, otherwise: bb2]
  using: _16@Mir(bb0[12])
bb2:
  _20 = _3
  using: _3@Entry
  _19 = move _20 as usize (PointerExposeAddress)
  using: _20@Mir(bb2[0])
  _18 = Eq(move _19, const 0_usize)
  using: _19@Mir(bb2[1])
  assume(move _18)
  using: _18@Mir(bb2[2])
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb60
  using: 
bb3:
  _21 = (*_3)
  using: _3@Phi(bb3)
  switchInt(move _21) -> [0: bb14, otherwise: bb4]
  using: _21@Mir(bb3[0])
bb4:
  _23 = (*_3)
  using: _3@Phi(bb3)
  _22 = move _23 as i32 (IntToInt)
  using: _23@Mir(bb4[0])
  switchInt(_22) -> [114: bb6, 119: bb7, 115: bb8, otherwise: bb5]
  using: _22@Mir(bb4[1])
bb5:
  _26 = (*_3)
  using: _3@Phi(bb3)
  _25 = move _26 as i32 (IntToInt)
  using: _26@Mir(bb5[0])
  _24 = bzlib::isdigit(move _25) -> bb9
  using: _25@Mir(bb5[1])
bb6:
  _8 = const 0_i32
  using: 
  goto -> bb12
  using: 
bb7:
  _8 = const 1_i32
  using: 
  goto -> bb12
  using: 
bb8:
  _14 = const 1_i32
  using: 
  goto -> bb12
  using: 
bb9:
  switchInt(move _24) -> [0: bb12, otherwise: bb10]
  using: _24@Mir(bb5[2])
bb10:
  _28 = (*_3)
  using: _3@Phi(bb3)
  _27 = move _28 as i32 (IntToInt)
  using: _28@Mir(bb10[0])
  _29 = const 48_i32
  using: 
  _30 = CheckedSub(_27, _29)
  using: _27@Mir(bb10[1]), _29@Mir(bb10[2])
  assert(!move (_30.1: bool), "attempt to compute `{} - {}`, which would overflow", move _27, move _29) -> bb11
  using: _30@Entry, _27@Entry, _29@Entry
bb11:
  _7 = move (_30.0: i32)
  using: _30@Mir(bb10[3])
  goto -> bb12
  using: 
bb12:
  _32 = _3
  using: _3@Phi(bb12)
  _31 = std::ptr::const_ptr::<impl *const i8>::offset(move _32, const 1_isize) -> bb13
  using: _32@Mir(bb12[0])
bb13:
  _3 = move _31
  using: _31@Mir(bb12[1])
  goto -> bb3
  using: 
bb14:
  _36 = &mut _9
  using: _9@Mir(bb0[4])
  _35 = move _36 as &mut [i8] (Pointer(Unsize))
  using: _36@Mir(bb14[0])
  _34 = core::slice::<impl [i8]>::as_mut_ptr(move _35) -> bb15
  using: _35@Mir(bb14[1])
bb15:
  _38 = _8
  using: _8@Phi(bb12)
  switchInt(move _38) -> [0: bb17, otherwise: bb16]
  using: _38@Mir(bb15[0])
bb16:
  _41 = const b"w\x00"
  using: 
  _40 = &raw const (*_41)
  using: _41@Mir(bb16[0])
  _39 = move _40 as *const u8 (Pointer(ArrayToPointer))
  using: _40@Mir(bb16[1])
  _37 = move _39 as *const i8 (PtrToPtr)
  using: _39@Mir(bb16[2])
  goto -> bb18
  using: 
bb17:
  _44 = const b"r\x00"
  using: 
  _43 = &raw const (*_44)
  using: _44@Mir(bb17[0])
  _42 = move _43 as *const u8 (Pointer(ArrayToPointer))
  using: _43@Mir(bb17[1])
  _37 = move _42 as *const i8 (PtrToPtr)
  using: _42@Mir(bb17[2])
  goto -> bb18
  using: 
bb18:
  _33 = bzlib::strcat(move _34, move _37) -> bb19
  using: _34@Mir(bb14[2]), _37@Phi(bb18)
bb19:
  _48 = &mut _9
  using: _9@Mir(bb0[4])
  _47 = move _48 as &mut [i8] (Pointer(Unsize))
  using: _48@Mir(bb19[0])
  _46 = core::slice::<impl [i8]>::as_mut_ptr(move _47) -> bb20
  using: _47@Mir(bb19[1])
bb20:
  _52 = const b"b\x00"
  using: 
  _51 = &raw const (*_52)
  using: _52@Mir(bb20[0])
  _50 = move _51 as *const u8 (Pointer(ArrayToPointer))
  using: _51@Mir(bb20[1])
  _49 = move _50 as *const i8 (PtrToPtr)
  using: _50@Mir(bb20[2])
  _45 = bzlib::strcat(move _46, move _49) -> bb21
  using: _46@Mir(bb19[2]), _49@Mir(bb20[3])
bb21:
  _54 = _4
  using: _4@Entry
  _55 = const 0_i32
  using: 
  _53 = Eq(move _54, move _55)
  using: _54@Mir(bb21[0]), _55@Mir(bb21[1])
  switchInt(move _53) -> [0: bb35, otherwise: bb22]
  using: _53@Mir(bb21[2])
bb22:
  _58 = _1
  using: _1@Entry
  _57 = std::ptr::const_ptr::<impl *const i8>::is_null(move _58) -> bb26
  using: _58@Mir(bb22[0])
bb23:
  _56 = const true
  using: 
  goto -> bb25
  using: 
bb24:
  _61 = _1
  using: _1@Entry
  _65 = const b"\x00"
  using: 
  _64 = &raw const (*_65)
  using: _65@Mir(bb24[1])
  _63 = move _64 as *const u8 (Pointer(ArrayToPointer))
  using: _64@Mir(bb24[2])
  _62 = move _63 as *const i8 (PtrToPtr)
  using: _63@Mir(bb24[3])
  _60 = bzlib::strcmp(move _61, move _62) -> bb27
  using: _61@Mir(bb24[0]), _62@Mir(bb24[4])
bb25:
  switchInt(move _56) -> [0: bb32, otherwise: bb28]
  using: _56@Phi(bb25)
bb26:
  switchInt(move _57) -> [0: bb24, otherwise: bb23]
  using: _57@Mir(bb22[1])
bb27:
  _66 = const 0_i32
  using: 
  _59 = Eq(move _60, move _66)
  using: _60@Mir(bb24[5]), _66@Mir(bb27[0])
  _56 = move _59
  using: _59@Mir(bb27[1])
  goto -> bb25
  using: 
bb28:
  _68 = _8
  using: _8@Phi(bb12)
  switchInt(move _68) -> [0: bb30, otherwise: bb29]
  using: _68@Mir(bb28[0])
bb29:
  _69 = const {alloc845: *mut *mut blocksort::__sFILE}
  using: 
  _67 = (*_69)
  using: _69@Mir(bb29[0])
  goto -> bb31
  using: 
bb30:
  _70 = const {alloc846: *mut *mut blocksort::__sFILE}
  using: 
  _67 = (*_70)
  using: _70@Mir(bb30[0])
  goto -> bb31
  using: 
bb31:
  _10 = move _67
  using: _67@Phi(bb31)
  goto -> bb38
  using: 
bb32:
  _72 = _1
  using: _1@Phi(bb25)
  _76 = &mut _9
  using: _9@Mir(bb0[4])
  _75 = move _76 as &mut [i8] (Pointer(Unsize))
  using: _76@Mir(bb32[1])
  _74 = core::slice::<impl [i8]>::as_mut_ptr(move _75) -> bb33
  using: _75@Mir(bb32[2])
bb33:
  _73 = move _74 as *const i8 (Pointer(MutToConstPointer))
  using: _74@Mir(bb32[3])
  _71 = bzlib::fopen(move _72, move _73) -> bb34
  using: _72@Mir(bb32[0]), _73@Mir(bb33[0])
bb34:
  _10 = move _71
  using: _71@Mir(bb33[1])
  goto -> bb38
  using: 
bb35:
  _78 = _2
  using: _2@Entry
  _82 = &mut _9
  using: _9@Mir(bb0[4])
  _81 = move _82 as &mut [i8] (Pointer(Unsize))
  using: _82@Mir(bb35[1])
  _80 = core::slice::<impl [i8]>::as_mut_ptr(move _81) -> bb36
  using: _81@Mir(bb35[2])
bb36:
  _79 = move _80 as *const i8 (Pointer(MutToConstPointer))
  using: _80@Mir(bb35[3])
  _77 = bzlib::fdopen(move _78, move _79) -> bb37
  using: _78@Mir(bb35[0]), _79@Mir(bb36[0])
bb37:
  _10 = move _77
  using: _77@Mir(bb36[1])
  goto -> bb38
  using: 
bb38:
  _84 = _10
  using: _10@Phi(bb38)
  _83 = std::ptr::mut_ptr::<impl *mut blocksort::__sFILE>::is_null(move _84) -> bb39
  using: _84@Mir(bb38[0])
bb39:
  switchInt(move _83) -> [0: bb41, otherwise: bb40]
  using: _83@Mir(bb38[1])
bb40:
  _87 = _10
  using: _10@Phi(bb38)
  _86 = move _87 as usize (PointerExposeAddress)
  using: _87@Mir(bb40[0])
  _85 = Eq(move _86, const 0_usize)
  using: _86@Mir(bb40[1])
  assume(move _85)
  using: _85@Mir(bb40[2])
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb60
  using: 
bb41:
  _88 = _8
  using: _8@Phi(bb38)
  switchInt(move _88) -> [0: bb43, otherwise: bb42]
  using: _88@Mir(bb41[0])
bb42:
  _90 = _7
  using: _7@Phi(bb12)
  _91 = const 1_i32
  using: 
  _89 = Lt(move _90, move _91)
  using: _90@Mir(bb42[0]), _91@Mir(bb42[1])
  switchInt(move _89) -> [0: bb45, otherwise: bb44]
  using: _89@Mir(bb42[2])
bb43:
  _104 = &mut _5
  using: _5@Mir(bb0[0])
  _103 = &raw mut (*_104)
  using: _104@Mir(bb43[0])
  _105 = _10
  using: _10@Phi(bb38)
  _106 = _12
  using: _12@Mir(bb0[7])
  _107 = _14
  using: _14@Phi(bb12)
  _111 = &mut _6
  using: _6@Mir(bb0[1])
  _110 = move _111 as &mut [i8] (Pointer(Unsize))
  using: _111@Mir(bb43[5])
  _109 = core::slice::<impl [i8]>::as_mut_ptr(move _110) -> bb49
  using: _110@Mir(bb43[6])
bb44:
  _7 = const 1_i32
  using: 
  goto -> bb45
  using: 
bb45:
  _93 = _7
  using: _7@Phi(bb45)
  _94 = const 9_i32
  using: 
  _92 = Gt(move _93, move _94)
  using: _93@Mir(bb45[0]), _94@Mir(bb45[1])
  switchInt(move _92) -> [0: bb47, otherwise: bb46]
  using: _92@Mir(bb45[2])
bb46:
  _7 = const 9_i32
  using: 
  goto -> bb47
  using: 
bb47:
  _97 = &mut _5
  using: _5@Mir(bb0[0])
  _96 = &raw mut (*_97)
  using: _97@Mir(bb47[0])
  _98 = _10
  using: _10@Phi(bb38)
  _99 = _7
  using: _7@Phi(bb47)
  _100 = _12
  using: _12@Mir(bb0[7])
  _101 = _13
  using: _13@Mir(bb0[8])
  _95 = bzlib::BZ2_bzWriteOpen(move _96, move _98, move _99, move _100, move _101) -> bb48
  using: _96@Mir(bb47[1]), _98@Mir(bb47[2]), _99@Mir(bb47[3]), _100@Mir(bb47[4]), _101@Mir(bb47[5])
bb48:
  _11 = move _95
  using: _95@Mir(bb47[6])
  goto -> bb51
  using: 
bb49:
  _108 = move _109 as *mut std::ffi::c_void (PtrToPtr)
  using: _109@Mir(bb43[7])
  _112 = _15
  using: _15@Mir(bb0[10])
  _102 = bzlib::BZ2_bzReadOpen(move _103, move _105, move _106, move _107, move _108, move _112) -> bb50
  using: _103@Mir(bb43[1]), _105@Mir(bb43[2]), _106@Mir(bb43[3]), _107@Mir(bb43[4]), _108@Mir(bb49[0]), _112@Mir(bb49[1])
bb50:
  _11 = move _102
  using: _102@Mir(bb49[2])
  goto -> bb51
  using: 
bb51:
  _114 = _11
  using: _11@Phi(bb51)
  _113 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _114) -> bb52
  using: _114@Mir(bb51[0])
bb52:
  switchInt(move _113) -> [0: bb59, otherwise: bb53]
  using: _113@Mir(bb51[1])
bb53:
  _117 = _11
  using: _11@Phi(bb51)
  _116 = move _117 as usize (PointerExposeAddress)
  using: _117@Mir(bb53[0])
  _115 = Eq(move _116, const 0_usize)
  using: _116@Mir(bb53[1])
  assume(move _115)
  using: _115@Mir(bb53[2])
  _120 = _10
  using: _10@Phi(bb51)
  _122 = const {alloc846: *mut *mut blocksort::__sFILE}
  using: 
  _121 = (*_122)
  using: _122@Mir(bb53[5])
  _119 = Ne(move _120, move _121)
  using: _120@Mir(bb53[4]), _121@Mir(bb53[6])
  switchInt(move _119) -> [0: bb54, otherwise: bb55]
  using: _119@Mir(bb53[7])
bb54:
  _118 = const false
  using: 
  goto -> bb56
  using: 
bb55:
  _124 = _10
  using: _10@Phi(bb51)
  _126 = const {alloc845: *mut *mut blocksort::__sFILE}
  using: 
  _125 = (*_126)
  using: _126@Mir(bb55[1])
  _123 = Ne(move _124, move _125)
  using: _124@Mir(bb55[0]), _125@Mir(bb55[2])
  _118 = move _123
  using: _123@Mir(bb55[3])
  goto -> bb56
  using: 
bb56:
  switchInt(move _118) -> [0: bb58, otherwise: bb57]
  using: _118@Phi(bb56)
bb57:
  _128 = _10
  using: _10@Phi(bb56)
  _127 = bzlib::fclose(move _128) -> bb58
  using: _128@Mir(bb57[0])
bb58:
  _0 = const {0x0 as *mut std::ffi::c_void}
  using: 
  goto -> bb60
  using: 
bb59:
  _0 = _11
  using: _11@Phi(bb51)
  goto -> bb60
  using: 
bb60:
  return
  using: _0@Phi(bb60)
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i8; 5000] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i8; 10] is not supported
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/bzip2/rust/bzlib.rs:2262:21: 2262:30 (#0) by default
rewrite call bzlib::strcat @ workspace/bzip2/rust/bzlib.rs:2264:5: 2267:76 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzlib::strcat @ workspace/bzip2/rust/bzlib.rs:2268:5: 2268:85 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzlib::strcmp @ workspace/bzip2/rust/bzlib.rs:2271:16: 2271:81 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call bzlib::fopen @ workspace/bzip2/rust/bzlib.rs:2274:23: 2274:54 (#0) by default
rewrite call bzlib::fdopen @ workspace/bzip2/rust/bzlib.rs:2275:19: 2275:49 (#0) by default
rewrite call bzlib::fclose @ workspace/bzip2/rust/bzlib.rs:2294:48: 2294:58 (#0) by default
@DefId(0:396 ~ c2rust_lib[1043]::bzlib::BZ2_bzopen)
bb0:
  _3 = _1
  using: _1@Entry
  _4 = const -1_i32
  using: 
  _5 = _2
  using: _2@Entry
  _6 = const 0_i32
  using: 
  _0 = bzlib::bzopen_or_bzdopen(move _3, move _4, move _5, move _6) -> bb1
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1]), _5@Mir(bb0[2]), _6@Mir(bb0[3])
bb1:
  return
  using: _0@Mir(bb0[4])
@DefId(0:397 ~ c2rust_lib[1043]::bzlib::BZ2_bzdopen)
bb0:
  _3 = const {0x0 as *const i8}
  using: 
  _4 = _1
  using: _1@Entry
  _5 = _2
  using: _2@Entry
  _6 = const 1_i32
  using: 
  _0 = bzlib::bzopen_or_bzdopen(move _3, move _4, move _5, move _6) -> bb1
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1]), _5@Mir(bb0[2]), _6@Mir(bb0[3])
bb1:
  return
  using: _0@Mir(bb0[4])
@DefId(0:398 ~ c2rust_lib[1043]::bzlib::BZ2_bzread)
bb0:
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _9 = _1
  using: _1@Entry
  _8 = move _9 as *mut bzlib::bzFile (PtrToPtr)
  using: _9@Mir(bb0[2])
  _7 = ((*_8).5: i32)
  using: _8@Mir(bb0[3])
  _10 = const 4_i32
  using: 
  _6 = Eq(move _7, move _10)
  using: _7@Mir(bb0[4]), _10@Mir(bb0[5])
  switchInt(move _6) -> [0: bb2, otherwise: bb1]
  using: _6@Mir(bb0[6])
bb1:
  _0 = const 0_i32
  using: 
  goto -> bb9
  using: 
bb2:
  _13 = &mut _4
  using: _4@Mir(bb0[0])
  _12 = &raw mut (*_13)
  using: _13@Mir(bb2[0])
  _14 = _1
  using: _1@Entry
  _15 = _2
  using: _2@Entry
  _16 = _3
  using: _3@Entry
  _11 = bzlib::BZ2_bzRead(move _12, move _14, move _15, move _16) -> bb3
  using: _12@Mir(bb2[1]), _14@Mir(bb2[2]), _15@Mir(bb2[3]), _16@Mir(bb2[4])
bb3:
  _5 = move _11
  using: _11@Mir(bb2[5])
  _19 = _4
  using: _4@Mir(bb0[0])
  _20 = const 0_i32
  using: 
  _18 = Eq(move _19, move _20)
  using: _19@Mir(bb3[1]), _20@Mir(bb3[2])
  switchInt(move _18) -> [0: bb5, otherwise: bb4]
  using: _18@Mir(bb3[3])
bb4:
  _17 = const true
  using: 
  goto -> bb6
  using: 
bb5:
  _22 = _4
  using: _4@Mir(bb0[0])
  _23 = const 4_i32
  using: 
  _21 = Eq(move _22, move _23)
  using: _22@Mir(bb5[0]), _23@Mir(bb5[1])
  _17 = move _21
  using: _21@Mir(bb5[2])
  goto -> bb6
  using: 
bb6:
  switchInt(move _17) -> [0: bb8, otherwise: bb7]
  using: _17@Phi(bb6)
bb7:
  _0 = _5
  using: _5@Mir(bb3[0])
  goto -> bb9
  using: 
bb8:
  _0 = const -1_i32
  using: 
  goto -> bb9
  using: 
bb9:
  return
  using: _0@Phi(bb9)
@DefId(0:399 ~ c2rust_lib[1043]::bzlib::BZ2_bzwrite)
bb0:
  _4 = const 0_i32
  using: 
  _7 = &mut _4
  using: _4@Mir(bb0[0])
  _6 = &raw mut (*_7)
  using: _7@Mir(bb0[1])
  _8 = _1
  using: _1@Entry
  _9 = _2
  using: _2@Entry
  _10 = _3
  using: _3@Entry
  _5 = bzlib::BZ2_bzWrite(move _6, move _8, move _9, move _10) -> bb1
  using: _6@Mir(bb0[2]), _8@Mir(bb0[3]), _9@Mir(bb0[4]), _10@Mir(bb0[5])
bb1:
  _12 = _4
  using: _4@Mir(bb0[0])
  _13 = const 0_i32
  using: 
  _11 = Eq(move _12, move _13)
  using: _12@Mir(bb1[0]), _13@Mir(bb1[1])
  switchInt(move _11) -> [0: bb3, otherwise: bb2]
  using: _11@Mir(bb1[2])
bb2:
  _0 = _3
  using: _3@Entry
  goto -> bb4
  using: 
bb3:
  _0 = const -1_i32
  using: 
  goto -> bb4
  using: 
bb4:
  return
  using: _0@Phi(bb4)
@DefId(0:400 ~ c2rust_lib[1043]::bzlib::BZ2_bzflush)
bb0:
  _0 = const 0_i32
  using: 
  return
  using: _0@Mir(bb0[0])
@DefId(0:401 ~ c2rust_lib[1043]::bzlib::BZ2_bzclose)
bb0:
  _2 = const 0_i32
  using: 
  _3 = const {0x0 as *mut blocksort::__sFILE}
  using: 
  _5 = _1
  using: _1@Entry
  _4 = std::ptr::mut_ptr::<impl *mut std::ffi::c_void>::is_null(move _5) -> bb1
  using: _5@Mir(bb0[2])
bb1:
  switchInt(move _4) -> [0: bb3, otherwise: bb2]
  using: _4@Mir(bb0[3])
bb2:
  _8 = _1
  using: _1@Entry
  _7 = move _8 as usize (PointerExposeAddress)
  using: _8@Mir(bb2[0])
  _6 = Eq(move _7, const 0_usize)
  using: _7@Mir(bb2[1])
  assume(move _6)
  using: _6@Mir(bb2[2])
  goto -> bb13
  using: 
bb3:
  _11 = _1
  using: _1@Entry
  _10 = move _11 as *mut bzlib::bzFile (PtrToPtr)
  using: _11@Mir(bb3[0])
  _9 = ((*_10).0: *mut blocksort::__sFILE)
  using: _10@Mir(bb3[1])
  _3 = move _9
  using: _9@Mir(bb3[2])
  _14 = _1
  using: _1@Entry
  _13 = move _14 as *mut bzlib::bzFile (PtrToPtr)
  using: _14@Mir(bb3[4])
  _12 = ((*_13).3: u8)
  using: _13@Mir(bb3[5])
  switchInt(move _12) -> [0: bb5, otherwise: bb4]
  using: _12@Mir(bb3[6])
bb4:
  _17 = &mut _2
  using: _2@Mir(bb0[0])
  _16 = &raw mut (*_17)
  using: _17@Mir(bb4[0])
  _18 = _1
  using: _1@Entry
  _19 = const 0_i32
  using: 
  _20 = const {0x0 as *mut u32}
  using: 
  _21 = const {0x0 as *mut u32}
  using: 
  _15 = bzlib::BZ2_bzWriteClose(move _16, move _18, move _19, move _20, move _21) -> bb6
  using: _16@Mir(bb4[1]), _18@Mir(bb4[2]), _19@Mir(bb4[3]), _20@Mir(bb4[4]), _21@Mir(bb4[5])
bb5:
  _33 = &mut _2
  using: _2@Mir(bb0[0])
  _32 = &raw mut (*_33)
  using: _33@Mir(bb5[0])
  _34 = _1
  using: _1@Entry
  _31 = bzlib::BZ2_bzReadClose(move _32, move _34) -> bb8
  using: _32@Mir(bb5[1]), _34@Mir(bb5[2])
bb6:
  _23 = _2
  using: _2@Mir(bb0[0])
  _24 = const 0_i32
  using: 
  _22 = Ne(move _23, move _24)
  using: _23@Mir(bb6[0]), _24@Mir(bb6[1])
  switchInt(move _22) -> [0: bb8, otherwise: bb7]
  using: _22@Mir(bb6[2])
bb7:
  _26 = const {0x0 as *mut i32}
  using: 
  _27 = _1
  using: _1@Entry
  _28 = const 1_i32
  using: 
  _29 = const {0x0 as *mut u32}
  using: 
  _30 = const {0x0 as *mut u32}
  using: 
  _25 = bzlib::BZ2_bzWriteClose(move _26, move _27, move _28, move _29, move _30) -> bb8
  using: _26@Mir(bb7[0]), _27@Mir(bb7[1]), _28@Mir(bb7[2]), _29@Mir(bb7[3]), _30@Mir(bb7[4])
bb8:
  _37 = _3
  using: _3@Mir(bb3[3])
  _39 = const {alloc846: *mut *mut blocksort::__sFILE}
  using: 
  _38 = (*_39)
  using: _39@Mir(bb8[1])
  _36 = Ne(move _37, move _38)
  using: _37@Mir(bb8[0]), _38@Mir(bb8[2])
  switchInt(move _36) -> [0: bb9, otherwise: bb10]
  using: _36@Mir(bb8[3])
bb9:
  _35 = const false
  using: 
  goto -> bb11
  using: 
bb10:
  _41 = _3
  using: _3@Mir(bb3[3])
  _43 = const {alloc845: *mut *mut blocksort::__sFILE}
  using: 
  _42 = (*_43)
  using: _43@Mir(bb10[1])
  _40 = Ne(move _41, move _42)
  using: _41@Mir(bb10[0]), _42@Mir(bb10[2])
  _35 = move _40
  using: _40@Mir(bb10[3])
  goto -> bb11
  using: 
bb11:
  switchInt(move _35) -> [0: bb13, otherwise: bb12]
  using: _35@Phi(bb11)
bb12:
  _45 = _3
  using: _3@Phi(bb11)
  _44 = bzlib::fclose(move _45) -> bb13
  using: _45@Mir(bb12[0])
bb13:
  return
  using: _0@Entry
rewrite call bzlib::fclose @ workspace/bzip2/rust/bzlib.rs:2368:44: 2368:54 (#0) by default
@DefId(0:404 ~ c2rust_lib[1043]::bzlib::BZ2_bzerror)
bb0:
  _5 = _1
  using: _1@Entry
  _4 = move _5 as *mut bzlib::bzFile (PtrToPtr)
  using: _5@Mir(bb0[0])
  _3 = ((*_4).5: i32)
  using: _4@Mir(bb0[1])
  _7 = _3
  using: _3@Mir(bb0[2])
  _8 = const 0_i32
  using: 
  _6 = Gt(move _7, move _8)
  using: _7@Mir(bb0[3]), _8@Mir(bb0[4])
  switchInt(move _6) -> [0: bb2, otherwise: bb1]
  using: _6@Mir(bb0[5])
bb1:
  _3 = const 0_i32
  using: 
  goto -> bb2
  using: 
bb2:
  _9 = _3
  using: _3@Phi(bb2)
  (*_2) = move _9
  using: _2@Entry, _9@Mir(bb2[0])
  _10 = const {alloc865: *mut [*const i8; 16]}
  using: 
  _13 = _3
  using: _3@Phi(bb2)
  _14 = const -1_i32
  using: 
  _15 = CheckedMul(_13, _14)
  using: _13@Mir(bb2[3]), _14@Mir(bb2[4])
  assert(!move (_15.1: bool), "attempt to compute `{} * {}`, which would overflow", move _13, move _14) -> bb3
  using: _15@Entry, _13@Entry, _14@Entry
bb3:
  _12 = move (_15.0: i32)
  using: _15@Mir(bb2[5])
  _11 = move _12 as usize (IntToInt)
  using: _12@Mir(bb3[0])
  _16 = const 16_usize
  using: 
  _17 = Lt(_11, _16)
  using: _11@Mir(bb3[1]), _16@Mir(bb3[2])
  assert(move _17, "index out of bounds: the length is {} but the index is {}", move _16, _11) -> bb4
  using: _17@Entry, _16@Entry, _11@Entry
bb4:
  _0 = (*_10)[_11]
  using: _10@Mir(bb2[2]), _11@Mir(bb3[1])
  return
  using: _0@Mir(bb4[0])
@DefId(0:418 ~ c2rust_lib[1043]::compress::BZ2_bsInitWrite)
bb0:
  _2 = const 0_i32
  using: 
  ((*_1).25: i32) = move _2
  using: _1@Entry, _2@Mir(bb0[0])
  _3 = const 0_i32
  using: 
  ((*_1).24: u32) = move _3 as u32 (IntToInt)
  using: _1@Entry, _3@Mir(bb0[2])
  return
  using: _0@Entry
@DefId(0:419 ~ c2rust_lib[1043]::compress::bsFinishWrite)
bb0:
  goto -> bb1
  using: 
bb1:
  _3 = ((*_1).25: i32)
  using: _1@Phi(bb1)
  _4 = const 0_i32
  using: 
  _2 = Gt(move _3, move _4)
  using: _3@Mir(bb1[0]), _4@Mir(bb1[1])
  switchInt(move _2) -> [0: bb8, otherwise: bb2]
  using: _2@Mir(bb1[2])
bb2:
  _6 = ((*_1).24: u32)
  using: _1@Phi(bb1)
  _7 = const 24_i32
  using: 
  _8 = CheckedShr(_6, _7)
  using: _6@Mir(bb2[0]), _7@Mir(bb2[1])
  assert(!move (_8.1: bool), "attempt to shift right by `{}`, which would overflow", move _7) -> bb3
  using: _8@Entry, _6@Entry, _7@Entry
bb3:
  _5 = move (_8.0: u32)
  using: _8@Mir(bb2[2])
  _10 = ((*_1).11: *mut u8)
  using: _1@Phi(bb1)
  _12 = ((*_1).19: i32)
  using: _1@Phi(bb1)
  _11 = move _12 as isize (IntToInt)
  using: _12@Mir(bb3[2])
  _9 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _10, move _11) -> bb4
  using: _10@Mir(bb3[1]), _11@Mir(bb3[3])
bb4:
  (*_9) = move _5 as u8 (IntToInt)
  using: _9@Mir(bb3[4]), _5@Mir(bb3[0])
  _13 = CheckedAdd(((*_1).19: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).19: i32), const 1_i32) -> bb5
  using: _13@Entry, _1@Entry
bb5:
  ((*_1).19: i32) = move (_13.0: i32)
  using: _1@Phi(bb1), _13@Mir(bb4[1])
  _14 = const 8_i32
  using: 
  _15 = CheckedShl(((*_1).24: u32), _14)
  using: _1@Phi(bb1), _14@Mir(bb5[1])
  assert(!move (_15.1: bool), "attempt to shift left by `{}`, which would overflow", move _14) -> bb6
  using: _15@Entry, _1@Entry, _14@Entry
bb6:
  ((*_1).24: u32) = move (_15.0: u32)
  using: _1@Phi(bb1), _15@Mir(bb5[2])
  _16 = const 8_i32
  using: 
  _17 = CheckedSub(((*_1).25: i32), _16)
  using: _1@Phi(bb1), _16@Mir(bb6[1])
  assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).25: i32), move _16) -> bb7
  using: _17@Entry, _1@Entry, _16@Entry
bb7:
  ((*_1).25: i32) = move (_17.0: i32)
  using: _1@Phi(bb1), _17@Mir(bb6[2])
  goto -> bb1
  using: 
bb8:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:73:21: 73:47 (#0) by default
@DefId(0:420 ~ c2rust_lib[1043]::compress::bsW)
bb0:
  goto -> bb1
  using: 
bb1:
  _5 = ((*_1).25: i32)
  using: _1@Phi(bb1)
  _6 = const 8_i32
  using: 
  _4 = Ge(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb8, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _8 = ((*_1).24: u32)
  using: _1@Phi(bb1)
  _9 = const 24_i32
  using: 
  _10 = CheckedShr(_8, _9)
  using: _8@Mir(bb2[0]), _9@Mir(bb2[1])
  assert(!move (_10.1: bool), "attempt to shift right by `{}`, which would overflow", move _9) -> bb3
  using: _10@Entry, _8@Entry, _9@Entry
bb3:
  _7 = move (_10.0: u32)
  using: _10@Mir(bb2[2])
  _12 = ((*_1).11: *mut u8)
  using: _1@Phi(bb1)
  _14 = ((*_1).19: i32)
  using: _1@Phi(bb1)
  _13 = move _14 as isize (IntToInt)
  using: _14@Mir(bb3[2])
  _11 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _12, move _13) -> bb4
  using: _12@Mir(bb3[1]), _13@Mir(bb3[3])
bb4:
  (*_11) = move _7 as u8 (IntToInt)
  using: _11@Mir(bb3[4]), _7@Mir(bb3[0])
  _15 = CheckedAdd(((*_1).19: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).19: i32), const 1_i32) -> bb5
  using: _15@Entry, _1@Entry
bb5:
  ((*_1).19: i32) = move (_15.0: i32)
  using: _1@Phi(bb1), _15@Mir(bb4[1])
  _16 = const 8_i32
  using: 
  _17 = CheckedShl(((*_1).24: u32), _16)
  using: _1@Phi(bb1), _16@Mir(bb5[1])
  assert(!move (_17.1: bool), "attempt to shift left by `{}`, which would overflow", move _16) -> bb6
  using: _17@Entry, _1@Entry, _16@Entry
bb6:
  ((*_1).24: u32) = move (_17.0: u32)
  using: _1@Phi(bb1), _17@Mir(bb5[2])
  _18 = const 8_i32
  using: 
  _19 = CheckedSub(((*_1).25: i32), _18)
  using: _1@Phi(bb1), _18@Mir(bb6[1])
  assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).25: i32), move _18) -> bb7
  using: _19@Entry, _1@Entry, _18@Entry
bb7:
  ((*_1).25: i32) = move (_19.0: i32)
  using: _1@Phi(bb1), _19@Mir(bb6[2])
  goto -> bb1
  using: 
bb8:
  _21 = _3
  using: _3@Entry
  _24 = const 32_i32
  using: 
  _25 = ((*_1).25: i32)
  using: _1@Phi(bb1)
  _26 = CheckedSub(_24, _25)
  using: _24@Mir(bb8[1]), _25@Mir(bb8[2])
  assert(!move (_26.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, move _25) -> bb9
  using: _26@Entry, _24@Entry, _25@Entry
bb9:
  _23 = move (_26.0: i32)
  using: _26@Mir(bb8[3])
  _27 = _2
  using: _2@Entry
  _28 = CheckedSub(_23, _27)
  using: _23@Mir(bb9[0]), _27@Mir(bb9[1])
  assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", move _23, move _27) -> bb10
  using: _28@Entry, _23@Entry, _27@Entry
bb10:
  _22 = move (_28.0: i32)
  using: _28@Mir(bb9[2])
  _29 = CheckedShl(_21, _22)
  using: _21@Mir(bb8[0]), _22@Mir(bb10[0])
  assert(!move (_29.1: bool), "attempt to shift left by `{}`, which would overflow", move _22) -> bb11
  using: _29@Entry, _21@Entry, _22@Entry
bb11:
  _20 = move (_29.0: u32)
  using: _29@Mir(bb10[1])
  ((*_1).24: u32) = BitOr(((*_1).24: u32), move _20)
  using: _1@Phi(bb1), _1@Phi(bb1), _20@Mir(bb11[0])
  _30 = _2
  using: _2@Entry
  _31 = CheckedAdd(((*_1).25: i32), _30)
  using: _1@Phi(bb1), _30@Mir(bb11[2])
  assert(!move (_31.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).25: i32), move _30) -> bb12
  using: _31@Entry, _1@Entry, _30@Entry
bb12:
  ((*_1).25: i32) = move (_31.0: i32)
  using: _1@Phi(bb1), _31@Mir(bb11[3])
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:85:21: 85:47 (#0) by default
@DefId(0:421 ~ c2rust_lib[1043]::compress::bsPutUInt32)
bb0:
  _4 = _1
  using: _1@Entry
  _5 = const 8_i32
  using: 
  _10 = _2
  using: _2@Entry
  _11 = const 24_i32
  using: 
  _12 = CheckedShr(_10, _11)
  using: _10@Mir(bb0[2]), _11@Mir(bb0[3])
  assert(!move (_12.1: bool), "attempt to shift right by `{}`, which would overflow", move _11) -> bb1
  using: _12@Entry, _10@Entry, _11@Entry
bb1:
  _9 = move (_12.0: u32)
  using: _12@Mir(bb0[4])
  _8 = move _9 as i64 (IntToInt)
  using: _9@Mir(bb1[0])
  _13 = const 255_i64
  using: 
  _7 = BitAnd(move _8, move _13)
  using: _8@Mir(bb1[1]), _13@Mir(bb1[2])
  _6 = move _7 as u32 (IntToInt)
  using: _7@Mir(bb1[3])
  _3 = compress::bsW(move _4, move _5, move _6) -> bb2
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1]), _6@Mir(bb1[4])
bb2:
  _15 = _1
  using: _1@Entry
  _16 = const 8_i32
  using: 
  _21 = _2
  using: _2@Entry
  _22 = const 16_i32
  using: 
  _23 = CheckedShr(_21, _22)
  using: _21@Mir(bb2[2]), _22@Mir(bb2[3])
  assert(!move (_23.1: bool), "attempt to shift right by `{}`, which would overflow", move _22) -> bb3
  using: _23@Entry, _21@Entry, _22@Entry
bb3:
  _20 = move (_23.0: u32)
  using: _23@Mir(bb2[4])
  _19 = move _20 as i64 (IntToInt)
  using: _20@Mir(bb3[0])
  _24 = const 255_i64
  using: 
  _18 = BitAnd(move _19, move _24)
  using: _19@Mir(bb3[1]), _24@Mir(bb3[2])
  _17 = move _18 as u32 (IntToInt)
  using: _18@Mir(bb3[3])
  _14 = compress::bsW(move _15, move _16, move _17) -> bb4
  using: _15@Mir(bb2[0]), _16@Mir(bb2[1]), _17@Mir(bb3[4])
bb4:
  _26 = _1
  using: _1@Entry
  _27 = const 8_i32
  using: 
  _32 = _2
  using: _2@Entry
  _33 = const 8_i32
  using: 
  _34 = CheckedShr(_32, _33)
  using: _32@Mir(bb4[2]), _33@Mir(bb4[3])
  assert(!move (_34.1: bool), "attempt to shift right by `{}`, which would overflow", move _33) -> bb5
  using: _34@Entry, _32@Entry, _33@Entry
bb5:
  _31 = move (_34.0: u32)
  using: _34@Mir(bb4[4])
  _30 = move _31 as i64 (IntToInt)
  using: _31@Mir(bb5[0])
  _35 = const 255_i64
  using: 
  _29 = BitAnd(move _30, move _35)
  using: _30@Mir(bb5[1]), _35@Mir(bb5[2])
  _28 = move _29 as u32 (IntToInt)
  using: _29@Mir(bb5[3])
  _25 = compress::bsW(move _26, move _27, move _28) -> bb6
  using: _26@Mir(bb4[0]), _27@Mir(bb4[1]), _28@Mir(bb5[4])
bb6:
  _37 = _1
  using: _1@Entry
  _38 = const 8_i32
  using: 
  _42 = _2
  using: _2@Entry
  _41 = move _42 as i64 (IntToInt)
  using: _42@Mir(bb6[2])
  _43 = const 255_i64
  using: 
  _40 = BitAnd(move _41, move _43)
  using: _41@Mir(bb6[3]), _43@Mir(bb6[4])
  _39 = move _40 as u32 (IntToInt)
  using: _40@Mir(bb6[5])
  _36 = compress::bsW(move _37, move _38, move _39) -> bb7
  using: _37@Mir(bb6[0]), _38@Mir(bb6[1]), _39@Mir(bb6[6])
bb7:
  return
  using: _0@Entry
@DefId(0:422 ~ c2rust_lib[1043]::compress::bsPutUChar)
bb0:
  _4 = _1
  using: _1@Entry
  _5 = const 8_i32
  using: 
  _7 = _2
  using: _2@Entry
  _6 = move _7 as u32 (IntToInt)
  using: _7@Mir(bb0[2])
  _3 = compress::bsW(move _4, move _5, move _6) -> bb1
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1]), _6@Mir(bb0[3])
bb1:
  return
  using: _0@Entry
@DefId(0:423 ~ c2rust_lib[1043]::compress::makeMaps_e)
bb0:
  _2 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  ((*_1).21: i32) = move _3
  using: _1@Entry, _3@Mir(bb0[1])
  _2 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _2
  using: _2@Phi(bb1)
  _6 = const 256_i32
  using: 
  _4 = Lt(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb9, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _9 = _2
  using: _2@Phi(bb1)
  _8 = move _9 as usize (IntToInt)
  using: _9@Mir(bb2[0])
  _10 = const 256_usize
  using: 
  _11 = Lt(_8, _10)
  using: _8@Mir(bb2[1]), _10@Mir(bb2[2])
  assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _8) -> bb3
  using: _11@Entry, _10@Entry, _8@Entry
bb3:
  _7 = ((*_1).22: [u8; 256])[_8]
  using: _1@Phi(bb1), _8@Mir(bb2[1])
  switchInt(move _7) -> [0: bb7, otherwise: bb4]
  using: _7@Mir(bb3[0])
bb4:
  _12 = ((*_1).21: i32)
  using: _1@Phi(bb1)
  _14 = _2
  using: _2@Phi(bb1)
  _13 = move _14 as usize (IntToInt)
  using: _14@Mir(bb4[1])
  _15 = const 256_usize
  using: 
  _16 = Lt(_13, _15)
  using: _13@Mir(bb4[2]), _15@Mir(bb4[3])
  assert(move _16, "index out of bounds: the length is {} but the index is {}", move _15, _13) -> bb5
  using: _16@Entry, _15@Entry, _13@Entry
bb5:
  ((*_1).23: [u8; 256])[_13] = move _12 as u8 (IntToInt)
  using: _1@Phi(bb1), _13@Mir(bb4[2]), _12@Mir(bb4[0])
  _17 = CheckedAdd(((*_1).21: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_17.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).21: i32), const 1_i32) -> bb6
  using: _17@Entry, _1@Entry
bb6:
  ((*_1).21: i32) = move (_17.0: i32)
  using: _1@Phi(bb1), _17@Mir(bb5[1])
  goto -> bb7
  using: 
bb7:
  _18 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb7)
  assert(!move (_18.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb8
  using: _18@Entry, _2@Entry
bb8:
  _2 = move (_18.0: i32)
  using: _18@Mir(bb7[0])
  goto -> bb1
  using: 
bb9:
  return
  using: _0@Entry
@DefId(0:424 ~ c2rust_lib[1043]::compress::generateMTFValues)
bb0:
  _2 = [const 0_u8; 256]
  using: 
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = ((*_1).8: *mut u32)
  using: _1@Entry
  _9 = ((*_1).9: *mut u8)
  using: _1@Entry
  _10 = ((*_1).10: *mut u16)
  using: _1@Entry
  _12 = _1
  using: _1@Entry
  _11 = compress::makeMaps_e(move _12) -> bb1
  using: _12@Mir(bb0[9])
bb1:
  _13 = ((*_1).21: i32)
  using: _1@Entry
  _14 = const 1_i32
  using: 
  _15 = CheckedAdd(_13, _14)
  using: _13@Mir(bb1[0]), _14@Mir(bb1[1])
  assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", move _13, move _14) -> bb2
  using: _15@Entry, _13@Entry, _14@Entry
bb2:
  _7 = move (_15.0: i32)
  using: _15@Mir(bb1[2])
  _3 = const 0_i32
  using: 
  goto -> bb3
  using: 
bb3:
  _17 = _3
  using: _3@Phi(bb3)
  _18 = _7
  using: _7@Mir(bb2[0])
  _16 = Le(move _17, move _18)
  using: _17@Mir(bb3[0]), _18@Mir(bb3[1])
  switchInt(move _16) -> [0: bb7, otherwise: bb4]
  using: _16@Mir(bb3[2])
bb4:
  _19 = const 0_i32
  using: 
  _21 = _3
  using: _3@Phi(bb3)
  _20 = move _21 as usize (IntToInt)
  using: _21@Mir(bb4[1])
  _22 = const 258_usize
  using: 
  _23 = Lt(_20, _22)
  using: _20@Mir(bb4[2]), _22@Mir(bb4[3])
  assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _20) -> bb5
  using: _23@Entry, _22@Entry, _20@Entry
bb5:
  ((*_1).32: [i32; 258])[_20] = move _19
  using: _1@Phi(bb3), _20@Mir(bb4[2]), _19@Mir(bb4[0])
  _24 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb3)
  assert(!move (_24.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb6
  using: _24@Entry, _3@Entry
bb6:
  _3 = move (_24.0: i32)
  using: _24@Mir(bb5[1])
  goto -> bb3
  using: 
bb7:
  _6 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  goto -> bb8
  using: 
bb8:
  _26 = _3
  using: _3@Phi(bb8)
  _27 = ((*_1).21: i32)
  using: _1@Phi(bb3)
  _25 = Lt(move _26, move _27)
  using: _26@Mir(bb8[0]), _27@Mir(bb8[1])
  switchInt(move _25) -> [0: bb12, otherwise: bb9]
  using: _25@Mir(bb8[2])
bb9:
  _28 = _3
  using: _3@Phi(bb8)
  _30 = _3
  using: _3@Phi(bb8)
  _29 = move _30 as usize (IntToInt)
  using: _30@Mir(bb9[1])
  _31 = const 256_usize
  using: 
  _32 = Lt(_29, _31)
  using: _29@Mir(bb9[2]), _31@Mir(bb9[3])
  assert(move _32, "index out of bounds: the length is {} but the index is {}", move _31, _29) -> bb10
  using: _32@Entry, _31@Entry, _29@Entry
bb10:
  _2[_29] = move _28 as u8 (IntToInt)
  using: _29@Mir(bb9[2]), _28@Mir(bb9[0])
  _33 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb8)
  assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb11
  using: _33@Entry, _3@Entry
bb11:
  _3 = move (_33.0: i32)
  using: _33@Mir(bb10[1])
  goto -> bb8
  using: 
bb12:
  _3 = const 0_i32
  using: 
  goto -> bb13
  using: 
bb13:
  _35 = _3
  using: _3@Phi(bb13)
  _36 = ((*_1).17: i32)
  using: _1@Phi(bb13)
  _34 = Lt(move _35, move _36)
  using: _35@Mir(bb13[0]), _36@Mir(bb13[1])
  switchInt(move _34) -> [0: bb59, otherwise: bb14]
  using: _34@Mir(bb13[2])
bb14:
  _37 = const 0_u8
  using: 
  _41 = _8
  using: _8@Phi(bb13)
  _43 = _3
  using: _3@Phi(bb13)
  _42 = move _43 as isize (IntToInt)
  using: _43@Mir(bb14[2])
  _40 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _41, move _42) -> bb15
  using: _41@Mir(bb14[1]), _42@Mir(bb14[3])
bb15:
  _39 = (*_40)
  using: _40@Mir(bb14[4])
  _44 = const 1_u32
  using: 
  _38 = core::num::<impl u32>::wrapping_sub(move _39, move _44) -> bb16
  using: _39@Mir(bb15[0]), _44@Mir(bb15[1])
bb16:
  _4 = move _38 as i32 (IntToInt)
  using: _38@Mir(bb15[2])
  _46 = _4
  using: _4@Mir(bb16[0])
  _47 = const 0_i32
  using: 
  _45 = Lt(move _46, move _47)
  using: _46@Mir(bb16[1]), _47@Mir(bb16[2])
  switchInt(move _45) -> [0: bb19, otherwise: bb17]
  using: _45@Mir(bb16[3])
bb17:
  _48 = ((*_1).17: i32)
  using: _1@Phi(bb13)
  _49 = CheckedAdd(_4, _48)
  using: _4@Mir(bb16[0]), _48@Mir(bb17[0])
  assert(!move (_49.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _48) -> bb18
  using: _49@Entry, _4@Entry, _48@Entry
bb18:
  _4 = move (_49.0: i32)
  using: _49@Mir(bb17[1])
  goto -> bb19
  using: 
bb19:
  _54 = _9
  using: _9@Phi(bb13)
  _56 = _4
  using: _4@Phi(bb19)
  _55 = move _56 as isize (IntToInt)
  using: _56@Mir(bb19[1])
  _53 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _54, move _55) -> bb20
  using: _54@Mir(bb19[0]), _55@Mir(bb19[2])
bb20:
  _52 = (*_53)
  using: _53@Mir(bb19[3])
  _51 = move _52 as usize (IntToInt)
  using: _52@Mir(bb20[0])
  _57 = const 256_usize
  using: 
  _58 = Lt(_51, _57)
  using: _51@Mir(bb20[1]), _57@Mir(bb20[2])
  assert(move _58, "index out of bounds: the length is {} but the index is {}", move _57, _51) -> bb21
  using: _58@Entry, _57@Entry, _51@Entry
bb21:
  _50 = ((*_1).23: [u8; 256])[_51]
  using: _1@Phi(bb19), _51@Mir(bb20[1])
  _37 = move _50
  using: _50@Mir(bb21[0])
  _62 = const 0_usize
  using: 
  _61 = _2[_62]
  using: _2@Phi(bb13), _62@Mir(bb21[2])
  _60 = move _61 as i32 (IntToInt)
  using: _61@Mir(bb21[3])
  _64 = _37
  using: _37@Mir(bb21[1])
  _63 = move _64 as i32 (IntToInt)
  using: _64@Mir(bb21[5])
  _59 = Eq(move _60, move _63)
  using: _60@Mir(bb21[4]), _63@Mir(bb21[6])
  switchInt(move _59) -> [0: bb24, otherwise: bb22]
  using: _59@Mir(bb21[7])
bb22:
  _65 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb13)
  assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb23
  using: _65@Entry, _5@Entry
bb23:
  _5 = move (_65.0: i32)
  using: _65@Mir(bb22[0])
  goto -> bb57
  using: 
bb24:
  _67 = _5
  using: _5@Phi(bb13)
  _68 = const 0_i32
  using: 
  _66 = Gt(move _67, move _68)
  using: _67@Mir(bb24[0]), _68@Mir(bb24[1])
  switchInt(move _66) -> [0: bb41, otherwise: bb25]
  using: _66@Mir(bb24[2])
bb25:
  _69 = CheckedSub(_5, const 1_i32)
  using: _5@Phi(bb13)
  assert(!move (_69.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> bb26
  using: _69@Entry, _5@Entry
bb26:
  _5 = move (_69.0: i32)
  using: _69@Mir(bb25[0])
  goto -> bb27
  using: 
bb27:
  _71 = _5
  using: _5@Phi(bb27)
  _72 = const 1_i32
  using: 
  _70 = BitAnd(move _71, move _72)
  using: _71@Mir(bb27[0]), _72@Mir(bb27[1])
  switchInt(move _70) -> [0: bb32, otherwise: bb28]
  using: _70@Mir(bb27[2])
bb28:
  _73 = const 1_i32
  using: 
  _75 = _10
  using: _10@Phi(bb27)
  _77 = _6
  using: _6@Phi(bb27)
  _76 = move _77 as isize (IntToInt)
  using: _77@Mir(bb28[2])
  _74 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _75, move _76) -> bb29
  using: _75@Mir(bb28[1]), _76@Mir(bb28[3])
bb29:
  (*_74) = move _73 as u16 (IntToInt)
  using: _74@Mir(bb28[4]), _73@Mir(bb28[0])
  _78 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb27)
  assert(!move (_78.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb30
  using: _78@Entry, _6@Entry
bb30:
  _6 = move (_78.0: i32)
  using: _78@Mir(bb29[1])
  _79 = const 1_usize
  using: 
  _80 = CheckedAdd(((*_1).32: [i32; 258])[_79], const 1_i32)
  using: _1@Phi(bb27), _79@Mir(bb30[1])
  assert(!move (_80.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).32: [i32; 258])[_79], const 1_i32) -> bb31
  using: _80@Entry, _1@Entry, _79@Entry
bb31:
  ((*_1).32: [i32; 258])[_79] = move (_80.0: i32)
  using: _1@Phi(bb27), _79@Mir(bb30[1]), _80@Mir(bb30[2])
  goto -> bb36
  using: 
bb32:
  _81 = const 0_i32
  using: 
  _83 = _10
  using: _10@Phi(bb27)
  _85 = _6
  using: _6@Phi(bb27)
  _84 = move _85 as isize (IntToInt)
  using: _85@Mir(bb32[2])
  _82 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _83, move _84) -> bb33
  using: _83@Mir(bb32[1]), _84@Mir(bb32[3])
bb33:
  (*_82) = move _81 as u16 (IntToInt)
  using: _82@Mir(bb32[4]), _81@Mir(bb32[0])
  _86 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb27)
  assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb34
  using: _86@Entry, _6@Entry
bb34:
  _6 = move (_86.0: i32)
  using: _86@Mir(bb33[1])
  _87 = const 0_usize
  using: 
  _88 = CheckedAdd(((*_1).32: [i32; 258])[_87], const 1_i32)
  using: _1@Phi(bb27), _87@Mir(bb34[1])
  assert(!move (_88.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).32: [i32; 258])[_87], const 1_i32) -> bb35
  using: _88@Entry, _1@Entry, _87@Entry
bb35:
  ((*_1).32: [i32; 258])[_87] = move (_88.0: i32)
  using: _1@Phi(bb27), _87@Mir(bb34[1]), _88@Mir(bb34[2])
  goto -> bb36
  using: 
bb36:
  _90 = _5
  using: _5@Phi(bb27)
  _91 = const 2_i32
  using: 
  _89 = Lt(move _90, move _91)
  using: _90@Mir(bb36[0]), _91@Mir(bb36[1])
  switchInt(move _89) -> [0: bb37, otherwise: bb40]
  using: _89@Mir(bb36[2])
bb37:
  _93 = _5
  using: _5@Phi(bb27)
  _94 = const 2_i32
  using: 
  _95 = CheckedSub(_93, _94)
  using: _93@Mir(bb37[0]), _94@Mir(bb37[1])
  assert(!move (_95.1: bool), "attempt to compute `{} - {}`, which would overflow", move _93, move _94) -> bb38
  using: _95@Entry, _93@Entry, _94@Entry
bb38:
  _92 = move (_95.0: i32)
  using: _95@Mir(bb37[2])
  _96 = const 2_i32
  using: 
  _97 = const false
  using: 
  _98 = Eq(_92, const i32::MIN)
  using: _92@Mir(bb38[0])
  _99 = BitAnd(move _97, move _98)
  using: _97@Mir(bb38[2]), _98@Mir(bb38[3])
  assert(!move _99, "attempt to compute `{} / {}`, which would overflow", _92, _96) -> bb39
  using: _99@Entry, _92@Entry, _96@Entry
bb39:
  _5 = Div(move _92, move _96)
  using: _92@Mir(bb38[0]), _96@Mir(bb38[1])
  goto -> bb27
  using: 
bb40:
  _5 = const 0_i32
  using: 
  goto -> bb41
  using: 
bb41:
  _100 = const 0_u8
  using: 
  _101 = const {0x0 as *mut u8}
  using: 
  _102 = const 0_u8
  using: 
  _104 = const 1_usize
  using: 
  _103 = _2[_104]
  using: _2@Phi(bb13), _104@Mir(bb41[3])
  _100 = move _103
  using: _103@Mir(bb41[4])
  _106 = const 0_usize
  using: 
  _105 = _2[_106]
  using: _2@Phi(bb13), _106@Mir(bb41[6])
  _107 = const 1_usize
  using: 
  _2[_107] = move _105
  using: _107@Mir(bb41[8]), _105@Mir(bb41[7])
  _113 = &mut _2
  using: _2@Phi(bb13)
  _112 = move _113 as &mut [u8] (Pointer(Unsize))
  using: _113@Mir(bb41[10])
  _111 = core::slice::<impl [u8]>::as_mut_ptr(move _112) -> bb42
  using: _112@Mir(bb41[11])
bb42:
  _114 = const 1_isize
  using: 
  _110 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _111, move _114) -> bb43
  using: _111@Mir(bb41[12]), _114@Mir(bb42[0])
bb43:
  _109 = &mut (*_110)
  using: _110@Mir(bb42[1])
  _108 = &raw mut (*_109)
  using: _109@Mir(bb43[0])
  _101 = move _108
  using: _108@Mir(bb43[1])
  _115 = _37
  using: _37@Mir(bb21[1])
  _102 = move _115
  using: _115@Mir(bb43[3])
  goto -> bb44
  using: 
bb44:
  _118 = _102
  using: _102@Mir(bb43[4])
  _117 = move _118 as i32 (IntToInt)
  using: _118@Mir(bb44[0])
  _120 = _100
  using: _100@Phi(bb44)
  _119 = move _120 as i32 (IntToInt)
  using: _120@Mir(bb44[2])
  _116 = Ne(move _117, move _119)
  using: _117@Mir(bb44[1]), _119@Mir(bb44[3])
  switchInt(move _116) -> [0: bb47, otherwise: bb45]
  using: _116@Mir(bb44[4])
bb45:
  _121 = const 0_u8
  using: 
  _123 = _101
  using: _101@Phi(bb44)
  _122 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _123, const 1_isize) -> bb46
  using: _123@Mir(bb45[1])
bb46:
  _101 = move _122
  using: _122@Mir(bb45[2])
  _124 = _100
  using: _100@Phi(bb44)
  _121 = move _124
  using: _124@Mir(bb46[1])
  _125 = (*_101)
  using: _101@Mir(bb46[0])
  _100 = move _125
  using: _125@Mir(bb46[3])
  _126 = _121
  using: _121@Mir(bb46[2])
  (*_101) = move _126
  using: _101@Mir(bb46[0]), _126@Mir(bb46[5])
  goto -> bb44
  using: 
bb47:
  _127 = _100
  using: _100@Phi(bb44)
  _128 = const 0_usize
  using: 
  _2[_128] = move _127
  using: _128@Mir(bb47[1]), _127@Mir(bb47[0])
  _131 = _101
  using: _101@Phi(bb44)
  _138 = &mut _2
  using: _2@Phi(bb13)
  _137 = move _138 as &mut [u8] (Pointer(Unsize))
  using: _138@Mir(bb47[4])
  _136 = core::slice::<impl [u8]>::as_mut_ptr(move _137) -> bb48
  using: _137@Mir(bb47[5])
bb48:
  _139 = const 0_isize
  using: 
  _135 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _136, move _139) -> bb49
  using: _136@Mir(bb47[6]), _139@Mir(bb48[0])
bb49:
  _134 = &mut (*_135)
  using: _135@Mir(bb48[1])
  _133 = &raw mut (*_134)
  using: _134@Mir(bb49[0])
  _132 = move _133 as *const u8 (Pointer(MutToConstPointer))
  using: _133@Mir(bb49[1])
  _130 = std::ptr::mut_ptr::<impl *mut u8>::offset_from(move _131, move _132) -> bb50
  using: _131@Mir(bb47[3]), _132@Mir(bb49[2])
bb50:
  _129 = move _130 as i64 (IntToInt)
  using: _130@Mir(bb49[3])
  _4 = move _129 as i32 (IntToInt)
  using: _129@Mir(bb50[0])
  _141 = _4
  using: _4@Mir(bb50[1])
  _142 = const 1_i32
  using: 
  _143 = CheckedAdd(_141, _142)
  using: _141@Mir(bb50[2]), _142@Mir(bb50[3])
  assert(!move (_143.1: bool), "attempt to compute `{} + {}`, which would overflow", move _141, move _142) -> bb51
  using: _143@Entry, _141@Entry, _142@Entry
bb51:
  _140 = move (_143.0: i32)
  using: _143@Mir(bb50[4])
  _145 = _10
  using: _10@Phi(bb41)
  _147 = _6
  using: _6@Phi(bb41)
  _146 = move _147 as isize (IntToInt)
  using: _147@Mir(bb51[2])
  _144 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _145, move _146) -> bb52
  using: _145@Mir(bb51[1]), _146@Mir(bb51[3])
bb52:
  (*_144) = move _140 as u16 (IntToInt)
  using: _144@Mir(bb51[4]), _140@Mir(bb51[0])
  _148 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb41)
  assert(!move (_148.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb53
  using: _148@Entry, _6@Entry
bb53:
  _6 = move (_148.0: i32)
  using: _148@Mir(bb52[1])
  _151 = _4
  using: _4@Mir(bb50[1])
  _152 = const 1_i32
  using: 
  _153 = CheckedAdd(_151, _152)
  using: _151@Mir(bb53[1]), _152@Mir(bb53[2])
  assert(!move (_153.1: bool), "attempt to compute `{} + {}`, which would overflow", move _151, move _152) -> bb54
  using: _153@Entry, _151@Entry, _152@Entry
bb54:
  _150 = move (_153.0: i32)
  using: _153@Mir(bb53[3])
  _149 = move _150 as usize (IntToInt)
  using: _150@Mir(bb54[0])
  _154 = const 258_usize
  using: 
  _155 = Lt(_149, _154)
  using: _149@Mir(bb54[1]), _154@Mir(bb54[2])
  assert(move _155, "index out of bounds: the length is {} but the index is {}", move _154, _149) -> bb55
  using: _155@Entry, _154@Entry, _149@Entry
bb55:
  _156 = CheckedAdd(((*_1).32: [i32; 258])[_149], const 1_i32)
  using: _1@Phi(bb41), _149@Mir(bb54[1])
  assert(!move (_156.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).32: [i32; 258])[_149], const 1_i32) -> bb56
  using: _156@Entry, _1@Entry, _149@Entry
bb56:
  ((*_1).32: [i32; 258])[_149] = move (_156.0: i32)
  using: _1@Phi(bb41), _149@Mir(bb54[1]), _156@Mir(bb55[0])
  goto -> bb57
  using: 
bb57:
  _157 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb13)
  assert(!move (_157.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb58
  using: _157@Entry, _3@Entry
bb58:
  _3 = move (_157.0: i32)
  using: _157@Mir(bb57[0])
  goto -> bb13
  using: 
bb59:
  _159 = _5
  using: _5@Phi(bb57)
  _160 = const 0_i32
  using: 
  _158 = Gt(move _159, move _160)
  using: _159@Mir(bb59[0]), _160@Mir(bb59[1])
  switchInt(move _158) -> [0: bb76, otherwise: bb60]
  using: _158@Mir(bb59[2])
bb60:
  _161 = CheckedSub(_5, const 1_i32)
  using: _5@Phi(bb57)
  assert(!move (_161.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> bb61
  using: _161@Entry, _5@Entry
bb61:
  _5 = move (_161.0: i32)
  using: _161@Mir(bb60[0])
  goto -> bb62
  using: 
bb62:
  _163 = _5
  using: _5@Phi(bb62)
  _164 = const 1_i32
  using: 
  _162 = BitAnd(move _163, move _164)
  using: _163@Mir(bb62[0]), _164@Mir(bb62[1])
  switchInt(move _162) -> [0: bb67, otherwise: bb63]
  using: _162@Mir(bb62[2])
bb63:
  _165 = const 1_i32
  using: 
  _167 = _10
  using: _10@Phi(bb62)
  _169 = _6
  using: _6@Phi(bb62)
  _168 = move _169 as isize (IntToInt)
  using: _169@Mir(bb63[2])
  _166 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _167, move _168) -> bb64
  using: _167@Mir(bb63[1]), _168@Mir(bb63[3])
bb64:
  (*_166) = move _165 as u16 (IntToInt)
  using: _166@Mir(bb63[4]), _165@Mir(bb63[0])
  _170 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb62)
  assert(!move (_170.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb65
  using: _170@Entry, _6@Entry
bb65:
  _6 = move (_170.0: i32)
  using: _170@Mir(bb64[1])
  _171 = const 1_usize
  using: 
  _172 = CheckedAdd(((*_1).32: [i32; 258])[_171], const 1_i32)
  using: _1@Phi(bb62), _171@Mir(bb65[1])
  assert(!move (_172.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).32: [i32; 258])[_171], const 1_i32) -> bb66
  using: _172@Entry, _1@Entry, _171@Entry
bb66:
  ((*_1).32: [i32; 258])[_171] = move (_172.0: i32)
  using: _1@Phi(bb62), _171@Mir(bb65[1]), _172@Mir(bb65[2])
  goto -> bb71
  using: 
bb67:
  _173 = const 0_i32
  using: 
  _175 = _10
  using: _10@Phi(bb62)
  _177 = _6
  using: _6@Phi(bb62)
  _176 = move _177 as isize (IntToInt)
  using: _177@Mir(bb67[2])
  _174 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _175, move _176) -> bb68
  using: _175@Mir(bb67[1]), _176@Mir(bb67[3])
bb68:
  (*_174) = move _173 as u16 (IntToInt)
  using: _174@Mir(bb67[4]), _173@Mir(bb67[0])
  _178 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb62)
  assert(!move (_178.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb69
  using: _178@Entry, _6@Entry
bb69:
  _6 = move (_178.0: i32)
  using: _178@Mir(bb68[1])
  _179 = const 0_usize
  using: 
  _180 = CheckedAdd(((*_1).32: [i32; 258])[_179], const 1_i32)
  using: _1@Phi(bb62), _179@Mir(bb69[1])
  assert(!move (_180.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).32: [i32; 258])[_179], const 1_i32) -> bb70
  using: _180@Entry, _1@Entry, _179@Entry
bb70:
  ((*_1).32: [i32; 258])[_179] = move (_180.0: i32)
  using: _1@Phi(bb62), _179@Mir(bb69[1]), _180@Mir(bb69[2])
  goto -> bb71
  using: 
bb71:
  _182 = _5
  using: _5@Phi(bb62)
  _183 = const 2_i32
  using: 
  _181 = Lt(move _182, move _183)
  using: _182@Mir(bb71[0]), _183@Mir(bb71[1])
  switchInt(move _181) -> [0: bb72, otherwise: bb75]
  using: _181@Mir(bb71[2])
bb72:
  _185 = _5
  using: _5@Phi(bb62)
  _186 = const 2_i32
  using: 
  _187 = CheckedSub(_185, _186)
  using: _185@Mir(bb72[0]), _186@Mir(bb72[1])
  assert(!move (_187.1: bool), "attempt to compute `{} - {}`, which would overflow", move _185, move _186) -> bb73
  using: _187@Entry, _185@Entry, _186@Entry
bb73:
  _184 = move (_187.0: i32)
  using: _187@Mir(bb72[2])
  _188 = const 2_i32
  using: 
  _189 = const false
  using: 
  _190 = Eq(_184, const i32::MIN)
  using: _184@Mir(bb73[0])
  _191 = BitAnd(move _189, move _190)
  using: _189@Mir(bb73[2]), _190@Mir(bb73[3])
  assert(!move _191, "attempt to compute `{} / {}`, which would overflow", _184, _188) -> bb74
  using: _191@Entry, _184@Entry, _188@Entry
bb74:
  _5 = Div(move _184, move _188)
  using: _184@Mir(bb73[0]), _188@Mir(bb73[1])
  goto -> bb62
  using: 
bb75:
  _5 = const 0_i32
  using: 
  goto -> bb76
  using: 
bb76:
  _192 = _7
  using: _7@Mir(bb2[0])
  _194 = _10
  using: _10@Phi(bb76)
  _196 = _6
  using: _6@Phi(bb76)
  _195 = move _196 as isize (IntToInt)
  using: _196@Mir(bb76[2])
  _193 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _194, move _195) -> bb77
  using: _194@Mir(bb76[1]), _195@Mir(bb76[3])
bb77:
  (*_193) = move _192 as u16 (IntToInt)
  using: _193@Mir(bb76[4]), _192@Mir(bb76[0])
  _197 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb76)
  assert(!move (_197.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb78
  using: _197@Entry, _6@Entry
bb78:
  _6 = move (_197.0: i32)
  using: _197@Mir(bb77[1])
  _199 = _7
  using: _7@Mir(bb2[0])
  _198 = move _199 as usize (IntToInt)
  using: _199@Mir(bb78[1])
  _200 = const 258_usize
  using: 
  _201 = Lt(_198, _200)
  using: _198@Mir(bb78[2]), _200@Mir(bb78[3])
  assert(move _201, "index out of bounds: the length is {} but the index is {}", move _200, _198) -> bb79
  using: _201@Entry, _200@Entry, _198@Entry
bb79:
  _202 = CheckedAdd(((*_1).32: [i32; 258])[_198], const 1_i32)
  using: _1@Phi(bb76), _198@Mir(bb78[2])
  assert(!move (_202.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).32: [i32; 258])[_198], const 1_i32) -> bb80
  using: _202@Entry, _1@Entry, _198@Entry
bb80:
  ((*_1).32: [i32; 258])[_198] = move (_202.0: i32)
  using: _1@Phi(bb76), _198@Mir(bb78[2]), _202@Mir(bb79[0])
  _203 = _6
  using: _6@Mir(bb78[0])
  ((*_1).31: i32) = move _203
  using: _1@Phi(bb76), _203@Mir(bb80[1])
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 256] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:173:19: 174:36 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/compress.rs:174:38: 175:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:177:39: 177:57 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:186:31: 186:50 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:191:31: 191:50 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:207:39: 207:80 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:212:31: 212:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:219:57: 222:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset_from @ workspace/bzip2/rust/compress.rs:219:23: 223:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:225:19: 225:38 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:235:23: 235:42 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:239:23: 239:42 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:248:11: 248:30 (#0) by default
@DefId(0:427 ~ c2rust_lib[1043]::compress::sendMTFValues)
bb0:
  _2 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  _14 = const 0_i32
  using: 
  _15 = const 0_i32
  using: 
  _16 = const 0_i32
  using: 
  _17 = const 0_i32
  using: 
  _18 = const 0_i32
  using: 
  _19 = [const 0_u16; 6]
  using: 
  _20 = [const 0_i32; 6]
  using: 
  _21 = ((*_1).10: *mut u16)
  using: _1@Entry
  _23 = ((*_1).28: i32)
  using: _1@Entry
  _24 = const 3_i32
  using: 
  _22 = Ge(move _23, move _24)
  using: _23@Mir(bb0[20]), _24@Mir(bb0[21])
  switchInt(move _22) -> [0: bb2, otherwise: bb1]
  using: _22@Mir(bb0[22])
bb1:
  _27 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _26 = (*_27)
  using: _27@Mir(bb1[0])
  _31 = const b"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n\x00"
  using: 
  _30 = &raw const (*_31)
  using: _31@Mir(bb1[2])
  _29 = move _30 as *const u8 (Pointer(ArrayToPointer))
  using: _30@Mir(bb1[3])
  _28 = move _29 as *const i8 (PtrToPtr)
  using: _29@Mir(bb1[4])
  _32 = ((*_1).17: i32)
  using: _1@Entry
  _33 = ((*_1).31: i32)
  using: _1@Entry
  _34 = ((*_1).21: i32)
  using: _1@Entry
  _25 = compress::fprintf(move _26, move _28, move _32, move _33, move _34) -> bb2
  using: _26@Mir(bb1[1]), _28@Mir(bb1[5]), _32@Mir(bb1[6]), _33@Mir(bb1[7]), _34@Mir(bb1[8])
bb2:
  _35 = ((*_1).21: i32)
  using: _1@Phi(bb2)
  _36 = const 2_i32
  using: 
  _37 = CheckedAdd(_35, _36)
  using: _35@Mir(bb2[0]), _36@Mir(bb2[1])
  assert(!move (_37.1: bool), "attempt to compute `{} + {}`, which would overflow", move _35, move _36) -> bb3
  using: _37@Entry, _35@Entry, _36@Entry
bb3:
  _13 = move (_37.0: i32)
  using: _37@Mir(bb2[2])
  _3 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _39 = _3
  using: _3@Phi(bb4)
  _40 = const 6_i32
  using: 
  _38 = Lt(move _39, move _40)
  using: _39@Mir(bb4[0]), _40@Mir(bb4[1])
  switchInt(move _38) -> [0: bb13, otherwise: bb5]
  using: _38@Mir(bb4[2])
bb5:
  _2 = const 0_i32
  using: 
  goto -> bb6
  using: 
bb6:
  _42 = _2
  using: _2@Phi(bb6)
  _43 = _13
  using: _13@Phi(bb4)
  _41 = Lt(move _42, move _43)
  using: _42@Mir(bb6[0]), _43@Mir(bb6[1])
  switchInt(move _41) -> [0: bb11, otherwise: bb7]
  using: _41@Mir(bb6[2])
bb7:
  _44 = const 15_i32
  using: 
  _46 = _3
  using: _3@Phi(bb6)
  _45 = move _46 as usize (IntToInt)
  using: _46@Mir(bb7[1])
  _47 = const 6_usize
  using: 
  _48 = Lt(_45, _47)
  using: _45@Mir(bb7[2]), _47@Mir(bb7[3])
  assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _45) -> bb8
  using: _48@Entry, _47@Entry, _45@Entry
bb8:
  _50 = _2
  using: _2@Phi(bb6)
  _49 = move _50 as usize (IntToInt)
  using: _50@Mir(bb8[0])
  _51 = const 258_usize
  using: 
  _52 = Lt(_49, _51)
  using: _49@Mir(bb8[1]), _51@Mir(bb8[2])
  assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _49) -> bb9
  using: _52@Entry, _51@Entry, _49@Entry
bb9:
  ((*_1).35: [[u8; 258]; 6])[_45][_49] = move _44 as u8 (IntToInt)
  using: _1@Phi(bb6), _49@Mir(bb8[1]), _45@Mir(bb7[2]), _44@Mir(bb7[0])
  _53 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb6)
  assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb10
  using: _53@Entry, _2@Entry
bb10:
  _2 = move (_53.0: i32)
  using: _53@Mir(bb9[1])
  goto -> bb6
  using: 
bb11:
  _54 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb6)
  assert(!move (_54.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb12
  using: _54@Entry, _3@Entry
bb12:
  _3 = move (_54.0: i32)
  using: _54@Mir(bb11[0])
  goto -> bb4
  using: 
bb13:
  _57 = ((*_1).31: i32)
  using: _1@Phi(bb6)
  _58 = const 0_i32
  using: 
  _56 = Gt(move _57, move _58)
  using: _57@Mir(bb13[0]), _58@Mir(bb13[1])
  _55 = Not(move _56)
  using: _56@Mir(bb13[2])
  switchInt(move _55) -> [0: bb15, otherwise: bb14]
  using: _55@Mir(bb13[3])
bb14:
  _60 = const 3001_i32
  using: 
  _59 = bzlib::BZ2_bz__AssertH__fail(move _60) -> bb15
  using: _60@Mir(bb14[0])
bb15:
  _62 = ((*_1).31: i32)
  using: _1@Phi(bb6)
  _63 = const 200_i32
  using: 
  _61 = Lt(move _62, move _63)
  using: _62@Mir(bb15[0]), _63@Mir(bb15[1])
  switchInt(move _61) -> [0: bb17, otherwise: bb16]
  using: _61@Mir(bb15[2])
bb16:
  _17 = const 2_i32
  using: 
  goto -> bb24
  using: 
bb17:
  _65 = ((*_1).31: i32)
  using: _1@Phi(bb6)
  _66 = const 600_i32
  using: 
  _64 = Lt(move _65, move _66)
  using: _65@Mir(bb17[0]), _66@Mir(bb17[1])
  switchInt(move _64) -> [0: bb19, otherwise: bb18]
  using: _64@Mir(bb17[2])
bb18:
  _17 = const 3_i32
  using: 
  goto -> bb24
  using: 
bb19:
  _68 = ((*_1).31: i32)
  using: _1@Phi(bb6)
  _69 = const 1200_i32
  using: 
  _67 = Lt(move _68, move _69)
  using: _68@Mir(bb19[0]), _69@Mir(bb19[1])
  switchInt(move _67) -> [0: bb21, otherwise: bb20]
  using: _67@Mir(bb19[2])
bb20:
  _17 = const 4_i32
  using: 
  goto -> bb24
  using: 
bb21:
  _71 = ((*_1).31: i32)
  using: _1@Phi(bb6)
  _72 = const 2400_i32
  using: 
  _70 = Lt(move _71, move _72)
  using: _71@Mir(bb21[0]), _72@Mir(bb21[1])
  switchInt(move _70) -> [0: bb23, otherwise: bb22]
  using: _70@Mir(bb21[2])
bb22:
  _17 = const 5_i32
  using: 
  goto -> bb24
  using: 
bb23:
  _17 = const 6_i32
  using: 
  goto -> bb24
  using: 
bb24:
  _73 = const 0_i32
  using: 
  _74 = const 0_i32
  using: 
  _75 = const 0_i32
  using: 
  _76 = const 0_i32
  using: 
  _77 = _17
  using: _17@Phi(bb24)
  _73 = move _77
  using: _77@Mir(bb24[4])
  _78 = ((*_1).31: i32)
  using: _1@Phi(bb24)
  _74 = move _78
  using: _78@Mir(bb24[6])
  _6 = const 0_i32
  using: 
  goto -> bb25
  using: 
bb25:
  _80 = _73
  using: _73@Phi(bb25)
  _81 = const 0_i32
  using: 
  _79 = Gt(move _80, move _81)
  using: _80@Mir(bb25[0]), _81@Mir(bb25[1])
  switchInt(move _79) -> [0: bb77, otherwise: bb26]
  using: _79@Mir(bb25[2])
bb26:
  _82 = _74
  using: _74@Phi(bb25)
  _83 = _73
  using: _73@Phi(bb25)
  _84 = Eq(_83, const 0_i32)
  using: _83@Mir(bb26[1])
  assert(!move _84, "attempt to divide `{}` by zero", _82) -> bb27
  using: _84@Entry, _82@Entry
bb27:
  _85 = Eq(_83, const -1_i32)
  using: _83@Mir(bb26[1])
  _86 = Eq(_82, const i32::MIN)
  using: _82@Mir(bb26[0])
  _87 = BitAnd(move _85, move _86)
  using: _85@Mir(bb27[0]), _86@Mir(bb27[1])
  assert(!move _87, "attempt to compute `{} / {}`, which would overflow", _82, _83) -> bb28
  using: _87@Entry, _82@Entry, _83@Entry
bb28:
  _75 = Div(move _82, move _83)
  using: _82@Mir(bb26[0]), _83@Mir(bb26[1])
  _88 = _6
  using: _6@Phi(bb25)
  _89 = const 1_i32
  using: 
  _90 = CheckedSub(_88, _89)
  using: _88@Mir(bb28[1]), _89@Mir(bb28[2])
  assert(!move (_90.1: bool), "attempt to compute `{} - {}`, which would overflow", move _88, move _89) -> bb29
  using: _90@Entry, _88@Entry, _89@Entry
bb29:
  _7 = move (_90.0: i32)
  using: _90@Mir(bb28[3])
  _76 = const 0_i32
  using: 
  goto -> bb30
  using: 
bb30:
  _93 = _76
  using: _76@Phi(bb30)
  _94 = _75
  using: _75@Mir(bb28[0])
  _92 = Lt(move _93, move _94)
  using: _93@Mir(bb30[0]), _94@Mir(bb30[1])
  switchInt(move _92) -> [0: bb31, otherwise: bb32]
  using: _92@Mir(bb30[2])
bb31:
  _91 = const false
  using: 
  goto -> bb33
  using: 
bb32:
  _96 = _7
  using: _7@Phi(bb30)
  _98 = _13
  using: _13@Phi(bb30)
  _99 = const 1_i32
  using: 
  _100 = CheckedSub(_98, _99)
  using: _98@Mir(bb32[1]), _99@Mir(bb32[2])
  assert(!move (_100.1: bool), "attempt to compute `{} - {}`, which would overflow", move _98, move _99) -> bb34
  using: _100@Entry, _98@Entry, _99@Entry
bb33:
  switchInt(move _91) -> [0: bb39, otherwise: bb35]
  using: _91@Phi(bb33)
bb34:
  _97 = move (_100.0: i32)
  using: _100@Mir(bb32[3])
  _95 = Lt(move _96, move _97)
  using: _96@Mir(bb32[0]), _97@Mir(bb34[0])
  _91 = move _95
  using: _95@Mir(bb34[1])
  goto -> bb33
  using: 
bb35:
  _101 = CheckedAdd(_7, const 1_i32)
  using: _7@Phi(bb33)
  assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> bb36
  using: _101@Entry, _7@Entry
bb36:
  _7 = move (_101.0: i32)
  using: _101@Mir(bb35[0])
  _104 = _7
  using: _7@Mir(bb36[0])
  _103 = move _104 as usize (IntToInt)
  using: _104@Mir(bb36[1])
  _105 = const 258_usize
  using: 
  _106 = Lt(_103, _105)
  using: _103@Mir(bb36[2]), _105@Mir(bb36[3])
  assert(move _106, "index out of bounds: the length is {} but the index is {}", move _105, _103) -> bb37
  using: _106@Entry, _105@Entry, _103@Entry
bb37:
  _102 = ((*_1).32: [i32; 258])[_103]
  using: _1@Phi(bb30), _103@Mir(bb36[2])
  _107 = CheckedAdd(_76, _102)
  using: _76@Phi(bb30), _102@Mir(bb37[0])
  assert(!move (_107.1: bool), "attempt to compute `{} + {}`, which would overflow", _76, move _102) -> bb38
  using: _107@Entry, _76@Entry, _102@Entry
bb38:
  _76 = move (_107.0: i32)
  using: _107@Mir(bb37[1])
  goto -> bb30
  using: 
bb39:
  _112 = _7
  using: _7@Phi(bb33)
  _113 = _6
  using: _6@Phi(bb25)
  _111 = Gt(move _112, move _113)
  using: _112@Mir(bb39[0]), _113@Mir(bb39[1])
  switchInt(move _111) -> [0: bb46, otherwise: bb47]
  using: _111@Mir(bb39[2])
bb40:
  _108 = const false
  using: 
  goto -> bb42
  using: 
bb41:
  _123 = _17
  using: _17@Phi(bb48)
  _124 = _73
  using: _73@Phi(bb45)
  _125 = CheckedSub(_123, _124)
  using: _123@Mir(bb41[0]), _124@Mir(bb41[1])
  assert(!move (_125.1: bool), "attempt to compute `{} - {}`, which would overflow", move _123, move _124) -> bb49
  using: _125@Entry, _123@Entry, _124@Entry
bb42:
  switchInt(move _108) -> [0: bb55, otherwise: bb51]
  using: _108@Phi(bb42)
bb43:
  _109 = const false
  using: 
  goto -> bb45
  using: 
bb44:
  _118 = _73
  using: _73@Phi(bb48)
  _119 = const 1_i32
  using: 
  _117 = Ne(move _118, move _119)
  using: _118@Mir(bb44[0]), _119@Mir(bb44[1])
  _109 = move _117
  using: _117@Mir(bb44[2])
  goto -> bb45
  using: 
bb45:
  switchInt(move _109) -> [0: bb40, otherwise: bb41]
  using: _109@Phi(bb45)
bb46:
  _110 = const false
  using: 
  goto -> bb48
  using: 
bb47:
  _115 = _73
  using: _73@Phi(bb25)
  _116 = _17
  using: _17@Phi(bb25)
  _114 = Ne(move _115, move _116)
  using: _115@Mir(bb47[0]), _116@Mir(bb47[1])
  _110 = move _114
  using: _114@Mir(bb47[2])
  goto -> bb48
  using: 
bb48:
  switchInt(move _110) -> [0: bb43, otherwise: bb44]
  using: _110@Phi(bb48)
bb49:
  _122 = move (_125.0: i32)
  using: _125@Mir(bb41[2])
  _126 = const 2_i32
  using: 
  _127 = const false
  using: 
  _128 = Eq(_122, const i32::MIN)
  using: _122@Mir(bb49[0])
  _129 = BitAnd(move _127, move _128)
  using: _127@Mir(bb49[2]), _128@Mir(bb49[3])
  assert(!move _129, "attempt to compute the remainder of `{} % {}`, which would overflow", _122, _126) -> bb50
  using: _129@Entry, _122@Entry, _126@Entry
bb50:
  _121 = Rem(move _122, move _126)
  using: _122@Mir(bb49[0]), _126@Mir(bb49[1])
  _130 = const 1_i32
  using: 
  _120 = Eq(move _121, move _130)
  using: _121@Mir(bb50[0]), _130@Mir(bb50[1])
  _108 = move _120
  using: _120@Mir(bb50[2])
  goto -> bb42
  using: 
bb51:
  _133 = _7
  using: _7@Phi(bb33)
  _132 = move _133 as usize (IntToInt)
  using: _133@Mir(bb51[0])
  _134 = const 258_usize
  using: 
  _135 = Lt(_132, _134)
  using: _132@Mir(bb51[1]), _134@Mir(bb51[2])
  assert(move _135, "index out of bounds: the length is {} but the index is {}", move _134, _132) -> bb52
  using: _135@Entry, _134@Entry, _132@Entry
bb52:
  _131 = ((*_1).32: [i32; 258])[_132]
  using: _1@Phi(bb30), _132@Mir(bb51[1])
  _136 = CheckedSub(_76, _131)
  using: _76@Phi(bb30), _131@Mir(bb52[0])
  assert(!move (_136.1: bool), "attempt to compute `{} - {}`, which would overflow", _76, move _131) -> bb53
  using: _136@Entry, _76@Entry, _131@Entry
bb53:
  _76 = move (_136.0: i32)
  using: _136@Mir(bb52[1])
  _137 = CheckedSub(_7, const 1_i32)
  using: _7@Phi(bb33)
  assert(!move (_137.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_i32) -> bb54
  using: _137@Entry, _7@Entry
bb54:
  _7 = move (_137.0: i32)
  using: _137@Mir(bb53[1])
  goto -> bb55
  using: 
bb55:
  _139 = ((*_1).28: i32)
  using: _1@Phi(bb55)
  _140 = const 3_i32
  using: 
  _138 = Ge(move _139, move _140)
  using: _139@Mir(bb55[0]), _140@Mir(bb55[1])
  switchInt(move _138) -> [0: bb57, otherwise: bb56]
  using: _138@Mir(bb55[2])
bb56:
  _143 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _142 = (*_143)
  using: _143@Mir(bb56[0])
  _147 = const b"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n\x00"
  using: 
  _146 = &raw const (*_147)
  using: _147@Mir(bb56[2])
  _145 = move _146 as *const u8 (Pointer(ArrayToPointer))
  using: _146@Mir(bb56[3])
  _144 = move _145 as *const i8 (PtrToPtr)
  using: _145@Mir(bb56[4])
  _148 = _73
  using: _73@Phi(bb42)
  _149 = _6
  using: _6@Phi(bb25)
  _150 = _7
  using: _7@Phi(bb55)
  _151 = _76
  using: _76@Phi(bb55)
  _156 = _76
  using: _76@Phi(bb55)
  _155 = move _156 as f32 (IntToFloat)
  using: _156@Mir(bb56[10])
  _154 = move _155 as f64 (FloatToFloat)
  using: _155@Mir(bb56[11])
  _153 = Mul(const 100f64, move _154)
  using: _154@Mir(bb56[12])
  _159 = ((*_1).31: i32)
  using: _1@Phi(bb55)
  _158 = move _159 as f32 (IntToFloat)
  using: _159@Mir(bb56[14])
  _157 = move _158 as f64 (FloatToFloat)
  using: _158@Mir(bb56[15])
  _152 = Div(move _153, move _157)
  using: _153@Mir(bb56[13]), _157@Mir(bb56[16])
  _141 = compress::fprintf(move _142, move _144, move _148, move _149, move _150, move _151, move _152) -> bb57
  using: _142@Mir(bb56[1]), _144@Mir(bb56[5]), _148@Mir(bb56[6]), _149@Mir(bb56[7]), _150@Mir(bb56[8]), _151@Mir(bb56[9]), _152@Mir(bb56[17])
bb57:
  _2 = const 0_i32
  using: 
  goto -> bb58
  using: 
bb58:
  _161 = _2
  using: _2@Phi(bb58)
  _162 = _13
  using: _13@Phi(bb33)
  _160 = Lt(move _161, move _162)
  using: _161@Mir(bb58[0]), _162@Mir(bb58[1])
  switchInt(move _160) -> [0: bb73, otherwise: bb59]
  using: _160@Mir(bb58[2])
bb59:
  _165 = _2
  using: _2@Phi(bb58)
  _166 = _6
  using: _6@Phi(bb58)
  _164 = Ge(move _165, move _166)
  using: _165@Mir(bb59[0]), _166@Mir(bb59[1])
  switchInt(move _164) -> [0: bb60, otherwise: bb61]
  using: _164@Mir(bb59[2])
bb60:
  _163 = const false
  using: 
  goto -> bb62
  using: 
bb61:
  _168 = _2
  using: _2@Phi(bb58)
  _169 = _7
  using: _7@Phi(bb58)
  _167 = Le(move _168, move _169)
  using: _168@Mir(bb61[0]), _169@Mir(bb61[1])
  _163 = move _167
  using: _167@Mir(bb61[2])
  goto -> bb62
  using: 
bb62:
  switchInt(move _163) -> [0: bb67, otherwise: bb63]
  using: _163@Phi(bb62)
bb63:
  _170 = const 0_i32
  using: 
  _173 = _73
  using: _73@Phi(bb58)
  _174 = const 1_i32
  using: 
  _175 = CheckedSub(_173, _174)
  using: _173@Mir(bb63[1]), _174@Mir(bb63[2])
  assert(!move (_175.1: bool), "attempt to compute `{} - {}`, which would overflow", move _173, move _174) -> bb64
  using: _175@Entry, _173@Entry, _174@Entry
bb64:
  _172 = move (_175.0: i32)
  using: _175@Mir(bb63[3])
  _171 = move _172 as usize (IntToInt)
  using: _172@Mir(bb64[0])
  _176 = const 6_usize
  using: 
  _177 = Lt(_171, _176)
  using: _171@Mir(bb64[1]), _176@Mir(bb64[2])
  assert(move _177, "index out of bounds: the length is {} but the index is {}", move _176, _171) -> bb65
  using: _177@Entry, _176@Entry, _171@Entry
bb65:
  _179 = _2
  using: _2@Phi(bb62)
  _178 = move _179 as usize (IntToInt)
  using: _179@Mir(bb65[0])
  _180 = const 258_usize
  using: 
  _181 = Lt(_178, _180)
  using: _178@Mir(bb65[1]), _180@Mir(bb65[2])
  assert(move _181, "index out of bounds: the length is {} but the index is {}", move _180, _178) -> bb66
  using: _181@Entry, _180@Entry, _178@Entry
bb66:
  ((*_1).35: [[u8; 258]; 6])[_171][_178] = move _170 as u8 (IntToInt)
  using: _1@Phi(bb58), _178@Mir(bb65[1]), _171@Mir(bb64[1]), _170@Mir(bb63[0])
  goto -> bb71
  using: 
bb67:
  _182 = const 15_i32
  using: 
  _185 = _73
  using: _73@Phi(bb58)
  _186 = const 1_i32
  using: 
  _187 = CheckedSub(_185, _186)
  using: _185@Mir(bb67[1]), _186@Mir(bb67[2])
  assert(!move (_187.1: bool), "attempt to compute `{} - {}`, which would overflow", move _185, move _186) -> bb68
  using: _187@Entry, _185@Entry, _186@Entry
bb68:
  _184 = move (_187.0: i32)
  using: _187@Mir(bb67[3])
  _183 = move _184 as usize (IntToInt)
  using: _184@Mir(bb68[0])
  _188 = const 6_usize
  using: 
  _189 = Lt(_183, _188)
  using: _183@Mir(bb68[1]), _188@Mir(bb68[2])
  assert(move _189, "index out of bounds: the length is {} but the index is {}", move _188, _183) -> bb69
  using: _189@Entry, _188@Entry, _183@Entry
bb69:
  _191 = _2
  using: _2@Phi(bb62)
  _190 = move _191 as usize (IntToInt)
  using: _191@Mir(bb69[0])
  _192 = const 258_usize
  using: 
  _193 = Lt(_190, _192)
  using: _190@Mir(bb69[1]), _192@Mir(bb69[2])
  assert(move _193, "index out of bounds: the length is {} but the index is {}", move _192, _190) -> bb70
  using: _193@Entry, _192@Entry, _190@Entry
bb70:
  ((*_1).35: [[u8; 258]; 6])[_183][_190] = move _182 as u8 (IntToInt)
  using: _1@Phi(bb58), _190@Mir(bb69[1]), _183@Mir(bb68[1]), _182@Mir(bb67[0])
  goto -> bb71
  using: 
bb71:
  _194 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb71)
  assert(!move (_194.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb72
  using: _194@Entry, _2@Entry
bb72:
  _2 = move (_194.0: i32)
  using: _194@Mir(bb71[0])
  goto -> bb58
  using: 
bb73:
  _195 = CheckedSub(_73, const 1_i32)
  using: _73@Phi(bb71)
  assert(!move (_195.1: bool), "attempt to compute `{} - {}`, which would overflow", _73, const 1_i32) -> bb74
  using: _195@Entry, _73@Entry
bb74:
  _73 = move (_195.0: i32)
  using: _195@Mir(bb73[0])
  _196 = _7
  using: _7@Phi(bb62)
  _197 = const 1_i32
  using: 
  _198 = CheckedAdd(_196, _197)
  using: _196@Mir(bb74[1]), _197@Mir(bb74[2])
  assert(!move (_198.1: bool), "attempt to compute `{} + {}`, which would overflow", move _196, move _197) -> bb75
  using: _198@Entry, _196@Entry, _197@Entry
bb75:
  _6 = move (_198.0: i32)
  using: _198@Mir(bb74[3])
  _199 = _76
  using: _76@Phi(bb57)
  _200 = CheckedSub(_74, _199)
  using: _74@Phi(bb25), _199@Mir(bb75[1])
  assert(!move (_200.1: bool), "attempt to compute `{} - {}`, which would overflow", _74, move _199) -> bb76
  using: _200@Entry, _74@Entry, _199@Entry
bb76:
  _74 = move (_200.0: i32)
  using: _200@Mir(bb75[2])
  goto -> bb25
  using: 
bb77:
  _11 = const 0_i32
  using: 
  goto -> bb78
  using: 
bb78:
  _202 = _11
  using: _11@Phi(bb78)
  _203 = const 4_i32
  using: 
  _201 = Lt(move _202, move _203)
  using: _202@Mir(bb78[0]), _203@Mir(bb78[1])
  switchInt(move _201) -> [0: bb853, otherwise: bb79]
  using: _201@Mir(bb78[2])
bb79:
  _3 = const 0_i32
  using: 
  goto -> bb80
  using: 
bb80:
  _205 = _3
  using: _3@Phi(bb80)
  _206 = _17
  using: _17@Phi(bb78)
  _204 = Lt(move _205, move _206)
  using: _205@Mir(bb80[0]), _206@Mir(bb80[1])
  switchInt(move _204) -> [0: bb84, otherwise: bb81]
  using: _204@Mir(bb80[2])
bb81:
  _207 = const 0_i32
  using: 
  _209 = _3
  using: _3@Phi(bb80)
  _208 = move _209 as usize (IntToInt)
  using: _209@Mir(bb81[1])
  _210 = const 6_usize
  using: 
  _211 = Lt(_208, _210)
  using: _208@Mir(bb81[2]), _210@Mir(bb81[3])
  assert(move _211, "index out of bounds: the length is {} but the index is {}", move _210, _208) -> bb82
  using: _211@Entry, _210@Entry, _208@Entry
bb82:
  _20[_208] = move _207
  using: _208@Mir(bb81[2]), _207@Mir(bb81[0])
  _212 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb80)
  assert(!move (_212.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb83
  using: _212@Entry, _3@Entry
bb83:
  _3 = move (_212.0: i32)
  using: _212@Mir(bb82[1])
  goto -> bb80
  using: 
bb84:
  _3 = const 0_i32
  using: 
  goto -> bb85
  using: 
bb85:
  _214 = _3
  using: _3@Phi(bb85)
  _215 = _17
  using: _17@Phi(bb78)
  _213 = Lt(move _214, move _215)
  using: _214@Mir(bb85[0]), _215@Mir(bb85[1])
  switchInt(move _213) -> [0: bb94, otherwise: bb86]
  using: _213@Mir(bb85[2])
bb86:
  _2 = const 0_i32
  using: 
  goto -> bb87
  using: 
bb87:
  _217 = _2
  using: _2@Phi(bb87)
  _218 = _13
  using: _13@Phi(bb85)
  _216 = Lt(move _217, move _218)
  using: _217@Mir(bb87[0]), _218@Mir(bb87[1])
  switchInt(move _216) -> [0: bb92, otherwise: bb88]
  using: _216@Mir(bb87[2])
bb88:
  _219 = const 0_i32
  using: 
  _221 = _3
  using: _3@Phi(bb87)
  _220 = move _221 as usize (IntToInt)
  using: _221@Mir(bb88[1])
  _222 = const 6_usize
  using: 
  _223 = Lt(_220, _222)
  using: _220@Mir(bb88[2]), _222@Mir(bb88[3])
  assert(move _223, "index out of bounds: the length is {} but the index is {}", move _222, _220) -> bb89
  using: _223@Entry, _222@Entry, _220@Entry
bb89:
  _225 = _2
  using: _2@Phi(bb87)
  _224 = move _225 as usize (IntToInt)
  using: _225@Mir(bb89[0])
  _226 = const 258_usize
  using: 
  _227 = Lt(_224, _226)
  using: _224@Mir(bb89[1]), _226@Mir(bb89[2])
  assert(move _227, "index out of bounds: the length is {} but the index is {}", move _226, _224) -> bb90
  using: _227@Entry, _226@Entry, _224@Entry
bb90:
  ((*_1).37: [[i32; 258]; 6])[_220][_224] = move _219
  using: _1@Phi(bb87), _224@Mir(bb89[1]), _220@Mir(bb88[2]), _219@Mir(bb88[0])
  _228 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb87)
  assert(!move (_228.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb91
  using: _228@Entry, _2@Entry
bb91:
  _2 = move (_228.0: i32)
  using: _228@Mir(bb90[1])
  goto -> bb87
  using: 
bb92:
  _229 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb87)
  assert(!move (_229.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb93
  using: _229@Entry, _3@Entry
bb93:
  _3 = move (_229.0: i32)
  using: _229@Mir(bb92[0])
  goto -> bb85
  using: 
bb94:
  _231 = _17
  using: _17@Phi(bb78)
  _232 = const 6_i32
  using: 
  _230 = Eq(move _231, move _232)
  using: _231@Mir(bb94[0]), _232@Mir(bb94[1])
  switchInt(move _230) -> [0: bb111, otherwise: bb95]
  using: _230@Mir(bb94[2])
bb95:
  _2 = const 0_i32
  using: 
  goto -> bb96
  using: 
bb96:
  _234 = _2
  using: _2@Phi(bb96)
  _235 = _13
  using: _13@Phi(bb85)
  _233 = Lt(move _234, move _235)
  using: _234@Mir(bb96[0]), _235@Mir(bb96[1])
  switchInt(move _233) -> [0: bb111, otherwise: bb97]
  using: _233@Mir(bb96[2])
bb97:
  _240 = const 1_usize
  using: 
  _242 = _2
  using: _2@Phi(bb96)
  _241 = move _242 as usize (IntToInt)
  using: _242@Mir(bb97[1])
  _243 = const 258_usize
  using: 
  _244 = Lt(_241, _243)
  using: _241@Mir(bb97[2]), _243@Mir(bb97[3])
  assert(move _244, "index out of bounds: the length is {} but the index is {}", move _243, _241) -> bb98
  using: _244@Entry, _243@Entry, _241@Entry
bb98:
  _239 = ((*_1).35: [[u8; 258]; 6])[_240][_241]
  using: _1@Phi(bb96), _241@Mir(bb97[2]), _240@Mir(bb97[0])
  _238 = move _239 as i32 (IntToInt)
  using: _239@Mir(bb98[0])
  _245 = const 16_i32
  using: 
  _246 = CheckedShl(_238, _245)
  using: _238@Mir(bb98[1]), _245@Mir(bb98[2])
  assert(!move (_246.1: bool), "attempt to shift left by `{}`, which would overflow", move _245) -> bb99
  using: _246@Entry, _238@Entry, _245@Entry
bb99:
  _237 = move (_246.0: i32)
  using: _246@Mir(bb98[3])
  _249 = const 0_usize
  using: 
  _251 = _2
  using: _2@Phi(bb96)
  _250 = move _251 as usize (IntToInt)
  using: _251@Mir(bb99[2])
  _252 = const 258_usize
  using: 
  _253 = Lt(_250, _252)
  using: _250@Mir(bb99[3]), _252@Mir(bb99[4])
  assert(move _253, "index out of bounds: the length is {} but the index is {}", move _252, _250) -> bb100
  using: _253@Entry, _252@Entry, _250@Entry
bb100:
  _248 = ((*_1).35: [[u8; 258]; 6])[_249][_250]
  using: _1@Phi(bb96), _250@Mir(bb99[3]), _249@Mir(bb99[1])
  _247 = move _248 as i32 (IntToInt)
  using: _248@Mir(bb100[0])
  _236 = BitOr(move _237, move _247)
  using: _237@Mir(bb99[0]), _247@Mir(bb100[1])
  _255 = _2
  using: _2@Phi(bb96)
  _254 = move _255 as usize (IntToInt)
  using: _255@Mir(bb100[3])
  _256 = const 258_usize
  using: 
  _257 = Lt(_254, _256)
  using: _254@Mir(bb100[4]), _256@Mir(bb100[5])
  assert(move _257, "index out of bounds: the length is {} but the index is {}", move _256, _254) -> bb101
  using: _257@Entry, _256@Entry, _254@Entry
bb101:
  _258 = const 0_usize
  using: 
  ((*_1).38: [[u32; 4]; 258])[_254][_258] = move _236 as u32 (IntToInt)
  using: _1@Phi(bb96), _258@Mir(bb101[0]), _254@Mir(bb100[4]), _236@Mir(bb100[2])
  _263 = const 3_usize
  using: 
  _265 = _2
  using: _2@Phi(bb96)
  _264 = move _265 as usize (IntToInt)
  using: _265@Mir(bb101[3])
  _266 = const 258_usize
  using: 
  _267 = Lt(_264, _266)
  using: _264@Mir(bb101[4]), _266@Mir(bb101[5])
  assert(move _267, "index out of bounds: the length is {} but the index is {}", move _266, _264) -> bb102
  using: _267@Entry, _266@Entry, _264@Entry
bb102:
  _262 = ((*_1).35: [[u8; 258]; 6])[_263][_264]
  using: _1@Phi(bb96), _264@Mir(bb101[4]), _263@Mir(bb101[2])
  _261 = move _262 as i32 (IntToInt)
  using: _262@Mir(bb102[0])
  _268 = const 16_i32
  using: 
  _269 = CheckedShl(_261, _268)
  using: _261@Mir(bb102[1]), _268@Mir(bb102[2])
  assert(!move (_269.1: bool), "attempt to shift left by `{}`, which would overflow", move _268) -> bb103
  using: _269@Entry, _261@Entry, _268@Entry
bb103:
  _260 = move (_269.0: i32)
  using: _269@Mir(bb102[3])
  _272 = const 2_usize
  using: 
  _274 = _2
  using: _2@Phi(bb96)
  _273 = move _274 as usize (IntToInt)
  using: _274@Mir(bb103[2])
  _275 = const 258_usize
  using: 
  _276 = Lt(_273, _275)
  using: _273@Mir(bb103[3]), _275@Mir(bb103[4])
  assert(move _276, "index out of bounds: the length is {} but the index is {}", move _275, _273) -> bb104
  using: _276@Entry, _275@Entry, _273@Entry
bb104:
  _271 = ((*_1).35: [[u8; 258]; 6])[_272][_273]
  using: _1@Phi(bb96), _273@Mir(bb103[3]), _272@Mir(bb103[1])
  _270 = move _271 as i32 (IntToInt)
  using: _271@Mir(bb104[0])
  _259 = BitOr(move _260, move _270)
  using: _260@Mir(bb103[0]), _270@Mir(bb104[1])
  _278 = _2
  using: _2@Phi(bb96)
  _277 = move _278 as usize (IntToInt)
  using: _278@Mir(bb104[3])
  _279 = const 258_usize
  using: 
  _280 = Lt(_277, _279)
  using: _277@Mir(bb104[4]), _279@Mir(bb104[5])
  assert(move _280, "index out of bounds: the length is {} but the index is {}", move _279, _277) -> bb105
  using: _280@Entry, _279@Entry, _277@Entry
bb105:
  _281 = const 1_usize
  using: 
  ((*_1).38: [[u32; 4]; 258])[_277][_281] = move _259 as u32 (IntToInt)
  using: _1@Phi(bb96), _281@Mir(bb105[0]), _277@Mir(bb104[4]), _259@Mir(bb104[2])
  _286 = const 5_usize
  using: 
  _288 = _2
  using: _2@Phi(bb96)
  _287 = move _288 as usize (IntToInt)
  using: _288@Mir(bb105[3])
  _289 = const 258_usize
  using: 
  _290 = Lt(_287, _289)
  using: _287@Mir(bb105[4]), _289@Mir(bb105[5])
  assert(move _290, "index out of bounds: the length is {} but the index is {}", move _289, _287) -> bb106
  using: _290@Entry, _289@Entry, _287@Entry
bb106:
  _285 = ((*_1).35: [[u8; 258]; 6])[_286][_287]
  using: _1@Phi(bb96), _287@Mir(bb105[4]), _286@Mir(bb105[2])
  _284 = move _285 as i32 (IntToInt)
  using: _285@Mir(bb106[0])
  _291 = const 16_i32
  using: 
  _292 = CheckedShl(_284, _291)
  using: _284@Mir(bb106[1]), _291@Mir(bb106[2])
  assert(!move (_292.1: bool), "attempt to shift left by `{}`, which would overflow", move _291) -> bb107
  using: _292@Entry, _284@Entry, _291@Entry
bb107:
  _283 = move (_292.0: i32)
  using: _292@Mir(bb106[3])
  _295 = const 4_usize
  using: 
  _297 = _2
  using: _2@Phi(bb96)
  _296 = move _297 as usize (IntToInt)
  using: _297@Mir(bb107[2])
  _298 = const 258_usize
  using: 
  _299 = Lt(_296, _298)
  using: _296@Mir(bb107[3]), _298@Mir(bb107[4])
  assert(move _299, "index out of bounds: the length is {} but the index is {}", move _298, _296) -> bb108
  using: _299@Entry, _298@Entry, _296@Entry
bb108:
  _294 = ((*_1).35: [[u8; 258]; 6])[_295][_296]
  using: _1@Phi(bb96), _296@Mir(bb107[3]), _295@Mir(bb107[1])
  _293 = move _294 as i32 (IntToInt)
  using: _294@Mir(bb108[0])
  _282 = BitOr(move _283, move _293)
  using: _283@Mir(bb107[0]), _293@Mir(bb108[1])
  _301 = _2
  using: _2@Phi(bb96)
  _300 = move _301 as usize (IntToInt)
  using: _301@Mir(bb108[3])
  _302 = const 258_usize
  using: 
  _303 = Lt(_300, _302)
  using: _300@Mir(bb108[4]), _302@Mir(bb108[5])
  assert(move _303, "index out of bounds: the length is {} but the index is {}", move _302, _300) -> bb109
  using: _303@Entry, _302@Entry, _300@Entry
bb109:
  _304 = const 2_usize
  using: 
  ((*_1).38: [[u32; 4]; 258])[_300][_304] = move _282 as u32 (IntToInt)
  using: _1@Phi(bb96), _304@Mir(bb109[0]), _300@Mir(bb108[4]), _282@Mir(bb108[2])
  _305 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb96)
  assert(!move (_305.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb110
  using: _305@Entry, _2@Entry
bb110:
  _2 = move (_305.0: i32)
  using: _305@Mir(bb109[2])
  goto -> bb96
  using: 
bb111:
  _12 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  goto -> bb112
  using: 
bb112:
  _307 = _6
  using: _6@Phi(bb112)
  _308 = ((*_1).31: i32)
  using: _1@Phi(bb112)
  _306 = Ge(move _307, move _308)
  using: _307@Mir(bb112[0]), _308@Mir(bb112[1])
  switchInt(move _306) -> [0: bb114, otherwise: bb113]
  using: _306@Mir(bb112[2])
bb113:
  _2876 = ((*_1).28: i32)
  using: _1@Phi(bb112)
  _2877 = const 3_i32
  using: 
  _2875 = Ge(move _2876, move _2877)
  using: _2876@Mir(bb113[0]), _2877@Mir(bb113[1])
  switchInt(move _2875) -> [0: bb838, otherwise: bb828]
  using: _2875@Mir(bb113[2])
bb114:
  _310 = _6
  using: _6@Phi(bb112)
  _311 = const 50_i32
  using: 
  _312 = CheckedAdd(_310, _311)
  using: _310@Mir(bb114[0]), _311@Mir(bb114[1])
  assert(!move (_312.1: bool), "attempt to compute `{} + {}`, which would overflow", move _310, move _311) -> bb115
  using: _312@Entry, _310@Entry, _311@Entry
bb115:
  _309 = move (_312.0: i32)
  using: _312@Mir(bb114[2])
  _313 = const 1_i32
  using: 
  _314 = CheckedSub(_309, _313)
  using: _309@Mir(bb115[0]), _313@Mir(bb115[1])
  assert(!move (_314.1: bool), "attempt to compute `{} - {}`, which would overflow", move _309, move _313) -> bb116
  using: _314@Entry, _309@Entry, _313@Entry
bb116:
  _7 = move (_314.0: i32)
  using: _314@Mir(bb115[2])
  _316 = _7
  using: _7@Mir(bb116[0])
  _317 = ((*_1).31: i32)
  using: _1@Phi(bb839)
  _315 = Ge(move _316, move _317)
  using: _316@Mir(bb116[1]), _317@Mir(bb116[2])
  switchInt(move _315) -> [0: bb119, otherwise: bb117]
  using: _315@Mir(bb116[3])
bb117:
  _318 = ((*_1).31: i32)
  using: _1@Phi(bb839)
  _319 = const 1_i32
  using: 
  _320 = CheckedSub(_318, _319)
  using: _318@Mir(bb117[0]), _319@Mir(bb117[1])
  assert(!move (_320.1: bool), "attempt to compute `{} - {}`, which would overflow", move _318, move _319) -> bb118
  using: _320@Entry, _318@Entry, _319@Entry
bb118:
  _7 = move (_320.0: i32)
  using: _320@Mir(bb117[2])
  goto -> bb119
  using: 
bb119:
  _3 = const 0_i32
  using: 
  goto -> bb120
  using: 
bb120:
  _322 = _3
  using: _3@Phi(bb120)
  _323 = _17
  using: _17@Phi(bb838)
  _321 = Lt(move _322, move _323)
  using: _322@Mir(bb120[0]), _323@Mir(bb120[1])
  switchInt(move _321) -> [0: bb124, otherwise: bb121]
  using: _321@Mir(bb120[2])
bb121:
  _324 = const 0_i32
  using: 
  _326 = _3
  using: _3@Phi(bb120)
  _325 = move _326 as usize (IntToInt)
  using: _326@Mir(bb121[1])
  _327 = const 6_usize
  using: 
  _328 = Lt(_325, _327)
  using: _325@Mir(bb121[2]), _327@Mir(bb121[3])
  assert(move _328, "index out of bounds: the length is {} but the index is {}", move _327, _325) -> bb122
  using: _328@Entry, _327@Entry, _325@Entry
bb122:
  _19[_325] = move _324 as u16 (IntToInt)
  using: _325@Mir(bb121[2]), _324@Mir(bb121[0])
  _329 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb120)
  assert(!move (_329.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb123
  using: _329@Entry, _3@Entry
bb123:
  _3 = move (_329.0: i32)
  using: _329@Mir(bb122[1])
  goto -> bb120
  using: 
bb124:
  _332 = _17
  using: _17@Phi(bb838)
  _333 = const 6_i32
  using: 
  _331 = Eq(move _332, move _333)
  using: _332@Mir(bb124[0]), _333@Mir(bb124[1])
  switchInt(move _331) -> [0: bb125, otherwise: bb126]
  using: _331@Mir(bb124[2])
bb125:
  _330 = const false
  using: 
  goto -> bb127
  using: 
bb126:
  _335 = const 50_i32
  using: 
  _338 = _7
  using: _7@Phi(bb119)
  _339 = _6
  using: _6@Phi(bb112)
  _340 = CheckedSub(_338, _339)
  using: _338@Mir(bb126[1]), _339@Mir(bb126[2])
  assert(!move (_340.1: bool), "attempt to compute `{} - {}`, which would overflow", move _338, move _339) -> bb128
  using: _340@Entry, _338@Entry, _339@Entry
bb127:
  switchInt(move _330) -> [0: bb534, otherwise: bb130]
  using: _330@Phi(bb127)
bb128:
  _337 = move (_340.0: i32)
  using: _340@Mir(bb126[3])
  _341 = const 1_i32
  using: 
  _342 = CheckedAdd(_337, _341)
  using: _337@Mir(bb128[0]), _341@Mir(bb128[1])
  assert(!move (_342.1: bool), "attempt to compute `{} + {}`, which would overflow", move _337, move _341) -> bb129
  using: _342@Entry, _337@Entry, _341@Entry
bb129:
  _336 = move (_342.0: i32)
  using: _342@Mir(bb128[2])
  _334 = Eq(move _335, move _336)
  using: _335@Mir(bb126[0]), _336@Mir(bb129[0])
  _330 = move _334
  using: _334@Mir(bb129[1])
  goto -> bb127
  using: 
bb130:
  _343 = const 0_u32
  using: 
  _344 = const 0_u32
  using: 
  _345 = const 0_u32
  using: 
  _346 = const 0_u16
  using: 
  _345 = const 0_u32
  using: 
  _344 = const 0_u32
  using: 
  _343 = const 0_u32
  using: 
  _349 = _21
  using: _21@Phi(bb112)
  _352 = _6
  using: _6@Phi(bb127)
  _353 = const 0_i32
  using: 
  _354 = CheckedAdd(_352, _353)
  using: _352@Mir(bb130[8]), _353@Mir(bb130[9])
  assert(!move (_354.1: bool), "attempt to compute `{} + {}`, which would overflow", move _352, move _353) -> bb131
  using: _354@Entry, _352@Entry, _353@Entry
bb131:
  _351 = move (_354.0: i32)
  using: _354@Mir(bb130[10])
  _350 = move _351 as isize (IntToInt)
  using: _351@Mir(bb131[0])
  _348 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _349, move _350) -> bb132
  using: _349@Mir(bb130[7]), _350@Mir(bb131[1])
bb132:
  _347 = (*_348)
  using: _348@Mir(bb131[2])
  _346 = move _347
  using: _347@Mir(bb132[0])
  _356 = _343
  using: _343@Mir(bb130[6])
  _359 = _346
  using: _346@Mir(bb132[1])
  _358 = move _359 as usize (IntToInt)
  using: _359@Mir(bb132[3])
  _360 = const 258_usize
  using: 
  _361 = Lt(_358, _360)
  using: _358@Mir(bb132[4]), _360@Mir(bb132[5])
  assert(move _361, "index out of bounds: the length is {} but the index is {}", move _360, _358) -> bb133
  using: _361@Entry, _360@Entry, _358@Entry
bb133:
  _362 = const 0_usize
  using: 
  _357 = ((*_1).38: [[u32; 4]; 258])[_358][_362]
  using: _1@Phi(bb119), _362@Mir(bb133[0]), _358@Mir(bb132[4])
  _355 = core::num::<impl u32>::wrapping_add(move _356, move _357) -> bb134
  using: _356@Mir(bb132[2]), _357@Mir(bb133[1])
bb134:
  _343 = move _355
  using: _355@Mir(bb133[2])
  _364 = _344
  using: _344@Mir(bb130[5])
  _367 = _346
  using: _346@Mir(bb132[1])
  _366 = move _367 as usize (IntToInt)
  using: _367@Mir(bb134[2])
  _368 = const 258_usize
  using: 
  _369 = Lt(_366, _368)
  using: _366@Mir(bb134[3]), _368@Mir(bb134[4])
  assert(move _369, "index out of bounds: the length is {} but the index is {}", move _368, _366) -> bb135
  using: _369@Entry, _368@Entry, _366@Entry
bb135:
  _370 = const 1_usize
  using: 
  _365 = ((*_1).38: [[u32; 4]; 258])[_366][_370]
  using: _1@Phi(bb119), _370@Mir(bb135[0]), _366@Mir(bb134[3])
  _363 = core::num::<impl u32>::wrapping_add(move _364, move _365) -> bb136
  using: _364@Mir(bb134[1]), _365@Mir(bb135[1])
bb136:
  _344 = move _363
  using: _363@Mir(bb135[2])
  _372 = _345
  using: _345@Mir(bb130[4])
  _375 = _346
  using: _346@Mir(bb132[1])
  _374 = move _375 as usize (IntToInt)
  using: _375@Mir(bb136[2])
  _376 = const 258_usize
  using: 
  _377 = Lt(_374, _376)
  using: _374@Mir(bb136[3]), _376@Mir(bb136[4])
  assert(move _377, "index out of bounds: the length is {} but the index is {}", move _376, _374) -> bb137
  using: _377@Entry, _376@Entry, _374@Entry
bb137:
  _378 = const 2_usize
  using: 
  _373 = ((*_1).38: [[u32; 4]; 258])[_374][_378]
  using: _1@Phi(bb119), _378@Mir(bb137[0]), _374@Mir(bb136[3])
  _371 = core::num::<impl u32>::wrapping_add(move _372, move _373) -> bb138
  using: _372@Mir(bb136[1]), _373@Mir(bb137[1])
bb138:
  _345 = move _371
  using: _371@Mir(bb137[2])
  _381 = _21
  using: _21@Phi(bb112)
  _384 = _6
  using: _6@Phi(bb127)
  _385 = const 1_i32
  using: 
  _386 = CheckedAdd(_384, _385)
  using: _384@Mir(bb138[2]), _385@Mir(bb138[3])
  assert(!move (_386.1: bool), "attempt to compute `{} + {}`, which would overflow", move _384, move _385) -> bb139
  using: _386@Entry, _384@Entry, _385@Entry
bb139:
  _383 = move (_386.0: i32)
  using: _386@Mir(bb138[4])
  _382 = move _383 as isize (IntToInt)
  using: _383@Mir(bb139[0])
  _380 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _381, move _382) -> bb140
  using: _381@Mir(bb138[1]), _382@Mir(bb139[1])
bb140:
  _379 = (*_380)
  using: _380@Mir(bb139[2])
  _346 = move _379
  using: _379@Mir(bb140[0])
  _388 = _343
  using: _343@Mir(bb134[0])
  _391 = _346
  using: _346@Mir(bb140[1])
  _390 = move _391 as usize (IntToInt)
  using: _391@Mir(bb140[3])
  _392 = const 258_usize
  using: 
  _393 = Lt(_390, _392)
  using: _390@Mir(bb140[4]), _392@Mir(bb140[5])
  assert(move _393, "index out of bounds: the length is {} but the index is {}", move _392, _390) -> bb141
  using: _393@Entry, _392@Entry, _390@Entry
bb141:
  _394 = const 0_usize
  using: 
  _389 = ((*_1).38: [[u32; 4]; 258])[_390][_394]
  using: _1@Phi(bb119), _394@Mir(bb141[0]), _390@Mir(bb140[4])
  _387 = core::num::<impl u32>::wrapping_add(move _388, move _389) -> bb142
  using: _388@Mir(bb140[2]), _389@Mir(bb141[1])
bb142:
  _343 = move _387
  using: _387@Mir(bb141[2])
  _396 = _344
  using: _344@Mir(bb136[0])
  _399 = _346
  using: _346@Mir(bb140[1])
  _398 = move _399 as usize (IntToInt)
  using: _399@Mir(bb142[2])
  _400 = const 258_usize
  using: 
  _401 = Lt(_398, _400)
  using: _398@Mir(bb142[3]), _400@Mir(bb142[4])
  assert(move _401, "index out of bounds: the length is {} but the index is {}", move _400, _398) -> bb143
  using: _401@Entry, _400@Entry, _398@Entry
bb143:
  _402 = const 1_usize
  using: 
  _397 = ((*_1).38: [[u32; 4]; 258])[_398][_402]
  using: _1@Phi(bb119), _402@Mir(bb143[0]), _398@Mir(bb142[3])
  _395 = core::num::<impl u32>::wrapping_add(move _396, move _397) -> bb144
  using: _396@Mir(bb142[1]), _397@Mir(bb143[1])
bb144:
  _344 = move _395
  using: _395@Mir(bb143[2])
  _404 = _345
  using: _345@Mir(bb138[0])
  _407 = _346
  using: _346@Mir(bb140[1])
  _406 = move _407 as usize (IntToInt)
  using: _407@Mir(bb144[2])
  _408 = const 258_usize
  using: 
  _409 = Lt(_406, _408)
  using: _406@Mir(bb144[3]), _408@Mir(bb144[4])
  assert(move _409, "index out of bounds: the length is {} but the index is {}", move _408, _406) -> bb145
  using: _409@Entry, _408@Entry, _406@Entry
bb145:
  _410 = const 2_usize
  using: 
  _405 = ((*_1).38: [[u32; 4]; 258])[_406][_410]
  using: _1@Phi(bb119), _410@Mir(bb145[0]), _406@Mir(bb144[3])
  _403 = core::num::<impl u32>::wrapping_add(move _404, move _405) -> bb146
  using: _404@Mir(bb144[1]), _405@Mir(bb145[1])
bb146:
  _345 = move _403
  using: _403@Mir(bb145[2])
  _413 = _21
  using: _21@Phi(bb112)
  _416 = _6
  using: _6@Phi(bb127)
  _417 = const 2_i32
  using: 
  _418 = CheckedAdd(_416, _417)
  using: _416@Mir(bb146[2]), _417@Mir(bb146[3])
  assert(!move (_418.1: bool), "attempt to compute `{} + {}`, which would overflow", move _416, move _417) -> bb147
  using: _418@Entry, _416@Entry, _417@Entry
bb147:
  _415 = move (_418.0: i32)
  using: _418@Mir(bb146[4])
  _414 = move _415 as isize (IntToInt)
  using: _415@Mir(bb147[0])
  _412 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _413, move _414) -> bb148
  using: _413@Mir(bb146[1]), _414@Mir(bb147[1])
bb148:
  _411 = (*_412)
  using: _412@Mir(bb147[2])
  _346 = move _411
  using: _411@Mir(bb148[0])
  _420 = _343
  using: _343@Mir(bb142[0])
  _423 = _346
  using: _346@Mir(bb148[1])
  _422 = move _423 as usize (IntToInt)
  using: _423@Mir(bb148[3])
  _424 = const 258_usize
  using: 
  _425 = Lt(_422, _424)
  using: _422@Mir(bb148[4]), _424@Mir(bb148[5])
  assert(move _425, "index out of bounds: the length is {} but the index is {}", move _424, _422) -> bb149
  using: _425@Entry, _424@Entry, _422@Entry
bb149:
  _426 = const 0_usize
  using: 
  _421 = ((*_1).38: [[u32; 4]; 258])[_422][_426]
  using: _1@Phi(bb119), _426@Mir(bb149[0]), _422@Mir(bb148[4])
  _419 = core::num::<impl u32>::wrapping_add(move _420, move _421) -> bb150
  using: _420@Mir(bb148[2]), _421@Mir(bb149[1])
bb150:
  _343 = move _419
  using: _419@Mir(bb149[2])
  _428 = _344
  using: _344@Mir(bb144[0])
  _431 = _346
  using: _346@Mir(bb148[1])
  _430 = move _431 as usize (IntToInt)
  using: _431@Mir(bb150[2])
  _432 = const 258_usize
  using: 
  _433 = Lt(_430, _432)
  using: _430@Mir(bb150[3]), _432@Mir(bb150[4])
  assert(move _433, "index out of bounds: the length is {} but the index is {}", move _432, _430) -> bb151
  using: _433@Entry, _432@Entry, _430@Entry
bb151:
  _434 = const 1_usize
  using: 
  _429 = ((*_1).38: [[u32; 4]; 258])[_430][_434]
  using: _1@Phi(bb119), _434@Mir(bb151[0]), _430@Mir(bb150[3])
  _427 = core::num::<impl u32>::wrapping_add(move _428, move _429) -> bb152
  using: _428@Mir(bb150[1]), _429@Mir(bb151[1])
bb152:
  _344 = move _427
  using: _427@Mir(bb151[2])
  _436 = _345
  using: _345@Mir(bb146[0])
  _439 = _346
  using: _346@Mir(bb148[1])
  _438 = move _439 as usize (IntToInt)
  using: _439@Mir(bb152[2])
  _440 = const 258_usize
  using: 
  _441 = Lt(_438, _440)
  using: _438@Mir(bb152[3]), _440@Mir(bb152[4])
  assert(move _441, "index out of bounds: the length is {} but the index is {}", move _440, _438) -> bb153
  using: _441@Entry, _440@Entry, _438@Entry
bb153:
  _442 = const 2_usize
  using: 
  _437 = ((*_1).38: [[u32; 4]; 258])[_438][_442]
  using: _1@Phi(bb119), _442@Mir(bb153[0]), _438@Mir(bb152[3])
  _435 = core::num::<impl u32>::wrapping_add(move _436, move _437) -> bb154
  using: _436@Mir(bb152[1]), _437@Mir(bb153[1])
bb154:
  _345 = move _435
  using: _435@Mir(bb153[2])
  _445 = _21
  using: _21@Phi(bb112)
  _448 = _6
  using: _6@Phi(bb127)
  _449 = const 3_i32
  using: 
  _450 = CheckedAdd(_448, _449)
  using: _448@Mir(bb154[2]), _449@Mir(bb154[3])
  assert(!move (_450.1: bool), "attempt to compute `{} + {}`, which would overflow", move _448, move _449) -> bb155
  using: _450@Entry, _448@Entry, _449@Entry
bb155:
  _447 = move (_450.0: i32)
  using: _450@Mir(bb154[4])
  _446 = move _447 as isize (IntToInt)
  using: _447@Mir(bb155[0])
  _444 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _445, move _446) -> bb156
  using: _445@Mir(bb154[1]), _446@Mir(bb155[1])
bb156:
  _443 = (*_444)
  using: _444@Mir(bb155[2])
  _346 = move _443
  using: _443@Mir(bb156[0])
  _452 = _343
  using: _343@Mir(bb150[0])
  _455 = _346
  using: _346@Mir(bb156[1])
  _454 = move _455 as usize (IntToInt)
  using: _455@Mir(bb156[3])
  _456 = const 258_usize
  using: 
  _457 = Lt(_454, _456)
  using: _454@Mir(bb156[4]), _456@Mir(bb156[5])
  assert(move _457, "index out of bounds: the length is {} but the index is {}", move _456, _454) -> bb157
  using: _457@Entry, _456@Entry, _454@Entry
bb157:
  _458 = const 0_usize
  using: 
  _453 = ((*_1).38: [[u32; 4]; 258])[_454][_458]
  using: _1@Phi(bb119), _458@Mir(bb157[0]), _454@Mir(bb156[4])
  _451 = core::num::<impl u32>::wrapping_add(move _452, move _453) -> bb158
  using: _452@Mir(bb156[2]), _453@Mir(bb157[1])
bb158:
  _343 = move _451
  using: _451@Mir(bb157[2])
  _460 = _344
  using: _344@Mir(bb152[0])
  _463 = _346
  using: _346@Mir(bb156[1])
  _462 = move _463 as usize (IntToInt)
  using: _463@Mir(bb158[2])
  _464 = const 258_usize
  using: 
  _465 = Lt(_462, _464)
  using: _462@Mir(bb158[3]), _464@Mir(bb158[4])
  assert(move _465, "index out of bounds: the length is {} but the index is {}", move _464, _462) -> bb159
  using: _465@Entry, _464@Entry, _462@Entry
bb159:
  _466 = const 1_usize
  using: 
  _461 = ((*_1).38: [[u32; 4]; 258])[_462][_466]
  using: _1@Phi(bb119), _466@Mir(bb159[0]), _462@Mir(bb158[3])
  _459 = core::num::<impl u32>::wrapping_add(move _460, move _461) -> bb160
  using: _460@Mir(bb158[1]), _461@Mir(bb159[1])
bb160:
  _344 = move _459
  using: _459@Mir(bb159[2])
  _468 = _345
  using: _345@Mir(bb154[0])
  _471 = _346
  using: _346@Mir(bb156[1])
  _470 = move _471 as usize (IntToInt)
  using: _471@Mir(bb160[2])
  _472 = const 258_usize
  using: 
  _473 = Lt(_470, _472)
  using: _470@Mir(bb160[3]), _472@Mir(bb160[4])
  assert(move _473, "index out of bounds: the length is {} but the index is {}", move _472, _470) -> bb161
  using: _473@Entry, _472@Entry, _470@Entry
bb161:
  _474 = const 2_usize
  using: 
  _469 = ((*_1).38: [[u32; 4]; 258])[_470][_474]
  using: _1@Phi(bb119), _474@Mir(bb161[0]), _470@Mir(bb160[3])
  _467 = core::num::<impl u32>::wrapping_add(move _468, move _469) -> bb162
  using: _468@Mir(bb160[1]), _469@Mir(bb161[1])
bb162:
  _345 = move _467
  using: _467@Mir(bb161[2])
  _477 = _21
  using: _21@Phi(bb112)
  _480 = _6
  using: _6@Phi(bb127)
  _481 = const 4_i32
  using: 
  _482 = CheckedAdd(_480, _481)
  using: _480@Mir(bb162[2]), _481@Mir(bb162[3])
  assert(!move (_482.1: bool), "attempt to compute `{} + {}`, which would overflow", move _480, move _481) -> bb163
  using: _482@Entry, _480@Entry, _481@Entry
bb163:
  _479 = move (_482.0: i32)
  using: _482@Mir(bb162[4])
  _478 = move _479 as isize (IntToInt)
  using: _479@Mir(bb163[0])
  _476 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _477, move _478) -> bb164
  using: _477@Mir(bb162[1]), _478@Mir(bb163[1])
bb164:
  _475 = (*_476)
  using: _476@Mir(bb163[2])
  _346 = move _475
  using: _475@Mir(bb164[0])
  _484 = _343
  using: _343@Mir(bb158[0])
  _487 = _346
  using: _346@Mir(bb164[1])
  _486 = move _487 as usize (IntToInt)
  using: _487@Mir(bb164[3])
  _488 = const 258_usize
  using: 
  _489 = Lt(_486, _488)
  using: _486@Mir(bb164[4]), _488@Mir(bb164[5])
  assert(move _489, "index out of bounds: the length is {} but the index is {}", move _488, _486) -> bb165
  using: _489@Entry, _488@Entry, _486@Entry
bb165:
  _490 = const 0_usize
  using: 
  _485 = ((*_1).38: [[u32; 4]; 258])[_486][_490]
  using: _1@Phi(bb119), _490@Mir(bb165[0]), _486@Mir(bb164[4])
  _483 = core::num::<impl u32>::wrapping_add(move _484, move _485) -> bb166
  using: _484@Mir(bb164[2]), _485@Mir(bb165[1])
bb166:
  _343 = move _483
  using: _483@Mir(bb165[2])
  _492 = _344
  using: _344@Mir(bb160[0])
  _495 = _346
  using: _346@Mir(bb164[1])
  _494 = move _495 as usize (IntToInt)
  using: _495@Mir(bb166[2])
  _496 = const 258_usize
  using: 
  _497 = Lt(_494, _496)
  using: _494@Mir(bb166[3]), _496@Mir(bb166[4])
  assert(move _497, "index out of bounds: the length is {} but the index is {}", move _496, _494) -> bb167
  using: _497@Entry, _496@Entry, _494@Entry
bb167:
  _498 = const 1_usize
  using: 
  _493 = ((*_1).38: [[u32; 4]; 258])[_494][_498]
  using: _1@Phi(bb119), _498@Mir(bb167[0]), _494@Mir(bb166[3])
  _491 = core::num::<impl u32>::wrapping_add(move _492, move _493) -> bb168
  using: _492@Mir(bb166[1]), _493@Mir(bb167[1])
bb168:
  _344 = move _491
  using: _491@Mir(bb167[2])
  _500 = _345
  using: _345@Mir(bb162[0])
  _503 = _346
  using: _346@Mir(bb164[1])
  _502 = move _503 as usize (IntToInt)
  using: _503@Mir(bb168[2])
  _504 = const 258_usize
  using: 
  _505 = Lt(_502, _504)
  using: _502@Mir(bb168[3]), _504@Mir(bb168[4])
  assert(move _505, "index out of bounds: the length is {} but the index is {}", move _504, _502) -> bb169
  using: _505@Entry, _504@Entry, _502@Entry
bb169:
  _506 = const 2_usize
  using: 
  _501 = ((*_1).38: [[u32; 4]; 258])[_502][_506]
  using: _1@Phi(bb119), _506@Mir(bb169[0]), _502@Mir(bb168[3])
  _499 = core::num::<impl u32>::wrapping_add(move _500, move _501) -> bb170
  using: _500@Mir(bb168[1]), _501@Mir(bb169[1])
bb170:
  _345 = move _499
  using: _499@Mir(bb169[2])
  _509 = _21
  using: _21@Phi(bb112)
  _512 = _6
  using: _6@Phi(bb127)
  _513 = const 5_i32
  using: 
  _514 = CheckedAdd(_512, _513)
  using: _512@Mir(bb170[2]), _513@Mir(bb170[3])
  assert(!move (_514.1: bool), "attempt to compute `{} + {}`, which would overflow", move _512, move _513) -> bb171
  using: _514@Entry, _512@Entry, _513@Entry
bb171:
  _511 = move (_514.0: i32)
  using: _514@Mir(bb170[4])
  _510 = move _511 as isize (IntToInt)
  using: _511@Mir(bb171[0])
  _508 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _509, move _510) -> bb172
  using: _509@Mir(bb170[1]), _510@Mir(bb171[1])
bb172:
  _507 = (*_508)
  using: _508@Mir(bb171[2])
  _346 = move _507
  using: _507@Mir(bb172[0])
  _516 = _343
  using: _343@Mir(bb166[0])
  _519 = _346
  using: _346@Mir(bb172[1])
  _518 = move _519 as usize (IntToInt)
  using: _519@Mir(bb172[3])
  _520 = const 258_usize
  using: 
  _521 = Lt(_518, _520)
  using: _518@Mir(bb172[4]), _520@Mir(bb172[5])
  assert(move _521, "index out of bounds: the length is {} but the index is {}", move _520, _518) -> bb173
  using: _521@Entry, _520@Entry, _518@Entry
bb173:
  _522 = const 0_usize
  using: 
  _517 = ((*_1).38: [[u32; 4]; 258])[_518][_522]
  using: _1@Phi(bb119), _522@Mir(bb173[0]), _518@Mir(bb172[4])
  _515 = core::num::<impl u32>::wrapping_add(move _516, move _517) -> bb174
  using: _516@Mir(bb172[2]), _517@Mir(bb173[1])
bb174:
  _343 = move _515
  using: _515@Mir(bb173[2])
  _524 = _344
  using: _344@Mir(bb168[0])
  _527 = _346
  using: _346@Mir(bb172[1])
  _526 = move _527 as usize (IntToInt)
  using: _527@Mir(bb174[2])
  _528 = const 258_usize
  using: 
  _529 = Lt(_526, _528)
  using: _526@Mir(bb174[3]), _528@Mir(bb174[4])
  assert(move _529, "index out of bounds: the length is {} but the index is {}", move _528, _526) -> bb175
  using: _529@Entry, _528@Entry, _526@Entry
bb175:
  _530 = const 1_usize
  using: 
  _525 = ((*_1).38: [[u32; 4]; 258])[_526][_530]
  using: _1@Phi(bb119), _530@Mir(bb175[0]), _526@Mir(bb174[3])
  _523 = core::num::<impl u32>::wrapping_add(move _524, move _525) -> bb176
  using: _524@Mir(bb174[1]), _525@Mir(bb175[1])
bb176:
  _344 = move _523
  using: _523@Mir(bb175[2])
  _532 = _345
  using: _345@Mir(bb170[0])
  _535 = _346
  using: _346@Mir(bb172[1])
  _534 = move _535 as usize (IntToInt)
  using: _535@Mir(bb176[2])
  _536 = const 258_usize
  using: 
  _537 = Lt(_534, _536)
  using: _534@Mir(bb176[3]), _536@Mir(bb176[4])
  assert(move _537, "index out of bounds: the length is {} but the index is {}", move _536, _534) -> bb177
  using: _537@Entry, _536@Entry, _534@Entry
bb177:
  _538 = const 2_usize
  using: 
  _533 = ((*_1).38: [[u32; 4]; 258])[_534][_538]
  using: _1@Phi(bb119), _538@Mir(bb177[0]), _534@Mir(bb176[3])
  _531 = core::num::<impl u32>::wrapping_add(move _532, move _533) -> bb178
  using: _532@Mir(bb176[1]), _533@Mir(bb177[1])
bb178:
  _345 = move _531
  using: _531@Mir(bb177[2])
  _541 = _21
  using: _21@Phi(bb112)
  _544 = _6
  using: _6@Phi(bb127)
  _545 = const 6_i32
  using: 
  _546 = CheckedAdd(_544, _545)
  using: _544@Mir(bb178[2]), _545@Mir(bb178[3])
  assert(!move (_546.1: bool), "attempt to compute `{} + {}`, which would overflow", move _544, move _545) -> bb179
  using: _546@Entry, _544@Entry, _545@Entry
bb179:
  _543 = move (_546.0: i32)
  using: _546@Mir(bb178[4])
  _542 = move _543 as isize (IntToInt)
  using: _543@Mir(bb179[0])
  _540 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _541, move _542) -> bb180
  using: _541@Mir(bb178[1]), _542@Mir(bb179[1])
bb180:
  _539 = (*_540)
  using: _540@Mir(bb179[2])
  _346 = move _539
  using: _539@Mir(bb180[0])
  _548 = _343
  using: _343@Mir(bb174[0])
  _551 = _346
  using: _346@Mir(bb180[1])
  _550 = move _551 as usize (IntToInt)
  using: _551@Mir(bb180[3])
  _552 = const 258_usize
  using: 
  _553 = Lt(_550, _552)
  using: _550@Mir(bb180[4]), _552@Mir(bb180[5])
  assert(move _553, "index out of bounds: the length is {} but the index is {}", move _552, _550) -> bb181
  using: _553@Entry, _552@Entry, _550@Entry
bb181:
  _554 = const 0_usize
  using: 
  _549 = ((*_1).38: [[u32; 4]; 258])[_550][_554]
  using: _1@Phi(bb119), _554@Mir(bb181[0]), _550@Mir(bb180[4])
  _547 = core::num::<impl u32>::wrapping_add(move _548, move _549) -> bb182
  using: _548@Mir(bb180[2]), _549@Mir(bb181[1])
bb182:
  _343 = move _547
  using: _547@Mir(bb181[2])
  _556 = _344
  using: _344@Mir(bb176[0])
  _559 = _346
  using: _346@Mir(bb180[1])
  _558 = move _559 as usize (IntToInt)
  using: _559@Mir(bb182[2])
  _560 = const 258_usize
  using: 
  _561 = Lt(_558, _560)
  using: _558@Mir(bb182[3]), _560@Mir(bb182[4])
  assert(move _561, "index out of bounds: the length is {} but the index is {}", move _560, _558) -> bb183
  using: _561@Entry, _560@Entry, _558@Entry
bb183:
  _562 = const 1_usize
  using: 
  _557 = ((*_1).38: [[u32; 4]; 258])[_558][_562]
  using: _1@Phi(bb119), _562@Mir(bb183[0]), _558@Mir(bb182[3])
  _555 = core::num::<impl u32>::wrapping_add(move _556, move _557) -> bb184
  using: _556@Mir(bb182[1]), _557@Mir(bb183[1])
bb184:
  _344 = move _555
  using: _555@Mir(bb183[2])
  _564 = _345
  using: _345@Mir(bb178[0])
  _567 = _346
  using: _346@Mir(bb180[1])
  _566 = move _567 as usize (IntToInt)
  using: _567@Mir(bb184[2])
  _568 = const 258_usize
  using: 
  _569 = Lt(_566, _568)
  using: _566@Mir(bb184[3]), _568@Mir(bb184[4])
  assert(move _569, "index out of bounds: the length is {} but the index is {}", move _568, _566) -> bb185
  using: _569@Entry, _568@Entry, _566@Entry
bb185:
  _570 = const 2_usize
  using: 
  _565 = ((*_1).38: [[u32; 4]; 258])[_566][_570]
  using: _1@Phi(bb119), _570@Mir(bb185[0]), _566@Mir(bb184[3])
  _563 = core::num::<impl u32>::wrapping_add(move _564, move _565) -> bb186
  using: _564@Mir(bb184[1]), _565@Mir(bb185[1])
bb186:
  _345 = move _563
  using: _563@Mir(bb185[2])
  _573 = _21
  using: _21@Phi(bb112)
  _576 = _6
  using: _6@Phi(bb127)
  _577 = const 7_i32
  using: 
  _578 = CheckedAdd(_576, _577)
  using: _576@Mir(bb186[2]), _577@Mir(bb186[3])
  assert(!move (_578.1: bool), "attempt to compute `{} + {}`, which would overflow", move _576, move _577) -> bb187
  using: _578@Entry, _576@Entry, _577@Entry
bb187:
  _575 = move (_578.0: i32)
  using: _578@Mir(bb186[4])
  _574 = move _575 as isize (IntToInt)
  using: _575@Mir(bb187[0])
  _572 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _573, move _574) -> bb188
  using: _573@Mir(bb186[1]), _574@Mir(bb187[1])
bb188:
  _571 = (*_572)
  using: _572@Mir(bb187[2])
  _346 = move _571
  using: _571@Mir(bb188[0])
  _580 = _343
  using: _343@Mir(bb182[0])
  _583 = _346
  using: _346@Mir(bb188[1])
  _582 = move _583 as usize (IntToInt)
  using: _583@Mir(bb188[3])
  _584 = const 258_usize
  using: 
  _585 = Lt(_582, _584)
  using: _582@Mir(bb188[4]), _584@Mir(bb188[5])
  assert(move _585, "index out of bounds: the length is {} but the index is {}", move _584, _582) -> bb189
  using: _585@Entry, _584@Entry, _582@Entry
bb189:
  _586 = const 0_usize
  using: 
  _581 = ((*_1).38: [[u32; 4]; 258])[_582][_586]
  using: _1@Phi(bb119), _586@Mir(bb189[0]), _582@Mir(bb188[4])
  _579 = core::num::<impl u32>::wrapping_add(move _580, move _581) -> bb190
  using: _580@Mir(bb188[2]), _581@Mir(bb189[1])
bb190:
  _343 = move _579
  using: _579@Mir(bb189[2])
  _588 = _344
  using: _344@Mir(bb184[0])
  _591 = _346
  using: _346@Mir(bb188[1])
  _590 = move _591 as usize (IntToInt)
  using: _591@Mir(bb190[2])
  _592 = const 258_usize
  using: 
  _593 = Lt(_590, _592)
  using: _590@Mir(bb190[3]), _592@Mir(bb190[4])
  assert(move _593, "index out of bounds: the length is {} but the index is {}", move _592, _590) -> bb191
  using: _593@Entry, _592@Entry, _590@Entry
bb191:
  _594 = const 1_usize
  using: 
  _589 = ((*_1).38: [[u32; 4]; 258])[_590][_594]
  using: _1@Phi(bb119), _594@Mir(bb191[0]), _590@Mir(bb190[3])
  _587 = core::num::<impl u32>::wrapping_add(move _588, move _589) -> bb192
  using: _588@Mir(bb190[1]), _589@Mir(bb191[1])
bb192:
  _344 = move _587
  using: _587@Mir(bb191[2])
  _596 = _345
  using: _345@Mir(bb186[0])
  _599 = _346
  using: _346@Mir(bb188[1])
  _598 = move _599 as usize (IntToInt)
  using: _599@Mir(bb192[2])
  _600 = const 258_usize
  using: 
  _601 = Lt(_598, _600)
  using: _598@Mir(bb192[3]), _600@Mir(bb192[4])
  assert(move _601, "index out of bounds: the length is {} but the index is {}", move _600, _598) -> bb193
  using: _601@Entry, _600@Entry, _598@Entry
bb193:
  _602 = const 2_usize
  using: 
  _597 = ((*_1).38: [[u32; 4]; 258])[_598][_602]
  using: _1@Phi(bb119), _602@Mir(bb193[0]), _598@Mir(bb192[3])
  _595 = core::num::<impl u32>::wrapping_add(move _596, move _597) -> bb194
  using: _596@Mir(bb192[1]), _597@Mir(bb193[1])
bb194:
  _345 = move _595
  using: _595@Mir(bb193[2])
  _605 = _21
  using: _21@Phi(bb112)
  _608 = _6
  using: _6@Phi(bb127)
  _609 = const 8_i32
  using: 
  _610 = CheckedAdd(_608, _609)
  using: _608@Mir(bb194[2]), _609@Mir(bb194[3])
  assert(!move (_610.1: bool), "attempt to compute `{} + {}`, which would overflow", move _608, move _609) -> bb195
  using: _610@Entry, _608@Entry, _609@Entry
bb195:
  _607 = move (_610.0: i32)
  using: _610@Mir(bb194[4])
  _606 = move _607 as isize (IntToInt)
  using: _607@Mir(bb195[0])
  _604 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _605, move _606) -> bb196
  using: _605@Mir(bb194[1]), _606@Mir(bb195[1])
bb196:
  _603 = (*_604)
  using: _604@Mir(bb195[2])
  _346 = move _603
  using: _603@Mir(bb196[0])
  _612 = _343
  using: _343@Mir(bb190[0])
  _615 = _346
  using: _346@Mir(bb196[1])
  _614 = move _615 as usize (IntToInt)
  using: _615@Mir(bb196[3])
  _616 = const 258_usize
  using: 
  _617 = Lt(_614, _616)
  using: _614@Mir(bb196[4]), _616@Mir(bb196[5])
  assert(move _617, "index out of bounds: the length is {} but the index is {}", move _616, _614) -> bb197
  using: _617@Entry, _616@Entry, _614@Entry
bb197:
  _618 = const 0_usize
  using: 
  _613 = ((*_1).38: [[u32; 4]; 258])[_614][_618]
  using: _1@Phi(bb119), _618@Mir(bb197[0]), _614@Mir(bb196[4])
  _611 = core::num::<impl u32>::wrapping_add(move _612, move _613) -> bb198
  using: _612@Mir(bb196[2]), _613@Mir(bb197[1])
bb198:
  _343 = move _611
  using: _611@Mir(bb197[2])
  _620 = _344
  using: _344@Mir(bb192[0])
  _623 = _346
  using: _346@Mir(bb196[1])
  _622 = move _623 as usize (IntToInt)
  using: _623@Mir(bb198[2])
  _624 = const 258_usize
  using: 
  _625 = Lt(_622, _624)
  using: _622@Mir(bb198[3]), _624@Mir(bb198[4])
  assert(move _625, "index out of bounds: the length is {} but the index is {}", move _624, _622) -> bb199
  using: _625@Entry, _624@Entry, _622@Entry
bb199:
  _626 = const 1_usize
  using: 
  _621 = ((*_1).38: [[u32; 4]; 258])[_622][_626]
  using: _1@Phi(bb119), _626@Mir(bb199[0]), _622@Mir(bb198[3])
  _619 = core::num::<impl u32>::wrapping_add(move _620, move _621) -> bb200
  using: _620@Mir(bb198[1]), _621@Mir(bb199[1])
bb200:
  _344 = move _619
  using: _619@Mir(bb199[2])
  _628 = _345
  using: _345@Mir(bb194[0])
  _631 = _346
  using: _346@Mir(bb196[1])
  _630 = move _631 as usize (IntToInt)
  using: _631@Mir(bb200[2])
  _632 = const 258_usize
  using: 
  _633 = Lt(_630, _632)
  using: _630@Mir(bb200[3]), _632@Mir(bb200[4])
  assert(move _633, "index out of bounds: the length is {} but the index is {}", move _632, _630) -> bb201
  using: _633@Entry, _632@Entry, _630@Entry
bb201:
  _634 = const 2_usize
  using: 
  _629 = ((*_1).38: [[u32; 4]; 258])[_630][_634]
  using: _1@Phi(bb119), _634@Mir(bb201[0]), _630@Mir(bb200[3])
  _627 = core::num::<impl u32>::wrapping_add(move _628, move _629) -> bb202
  using: _628@Mir(bb200[1]), _629@Mir(bb201[1])
bb202:
  _345 = move _627
  using: _627@Mir(bb201[2])
  _637 = _21
  using: _21@Phi(bb112)
  _640 = _6
  using: _6@Phi(bb127)
  _641 = const 9_i32
  using: 
  _642 = CheckedAdd(_640, _641)
  using: _640@Mir(bb202[2]), _641@Mir(bb202[3])
  assert(!move (_642.1: bool), "attempt to compute `{} + {}`, which would overflow", move _640, move _641) -> bb203
  using: _642@Entry, _640@Entry, _641@Entry
bb203:
  _639 = move (_642.0: i32)
  using: _642@Mir(bb202[4])
  _638 = move _639 as isize (IntToInt)
  using: _639@Mir(bb203[0])
  _636 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _637, move _638) -> bb204
  using: _637@Mir(bb202[1]), _638@Mir(bb203[1])
bb204:
  _635 = (*_636)
  using: _636@Mir(bb203[2])
  _346 = move _635
  using: _635@Mir(bb204[0])
  _644 = _343
  using: _343@Mir(bb198[0])
  _647 = _346
  using: _346@Mir(bb204[1])
  _646 = move _647 as usize (IntToInt)
  using: _647@Mir(bb204[3])
  _648 = const 258_usize
  using: 
  _649 = Lt(_646, _648)
  using: _646@Mir(bb204[4]), _648@Mir(bb204[5])
  assert(move _649, "index out of bounds: the length is {} but the index is {}", move _648, _646) -> bb205
  using: _649@Entry, _648@Entry, _646@Entry
bb205:
  _650 = const 0_usize
  using: 
  _645 = ((*_1).38: [[u32; 4]; 258])[_646][_650]
  using: _1@Phi(bb119), _650@Mir(bb205[0]), _646@Mir(bb204[4])
  _643 = core::num::<impl u32>::wrapping_add(move _644, move _645) -> bb206
  using: _644@Mir(bb204[2]), _645@Mir(bb205[1])
bb206:
  _343 = move _643
  using: _643@Mir(bb205[2])
  _652 = _344
  using: _344@Mir(bb200[0])
  _655 = _346
  using: _346@Mir(bb204[1])
  _654 = move _655 as usize (IntToInt)
  using: _655@Mir(bb206[2])
  _656 = const 258_usize
  using: 
  _657 = Lt(_654, _656)
  using: _654@Mir(bb206[3]), _656@Mir(bb206[4])
  assert(move _657, "index out of bounds: the length is {} but the index is {}", move _656, _654) -> bb207
  using: _657@Entry, _656@Entry, _654@Entry
bb207:
  _658 = const 1_usize
  using: 
  _653 = ((*_1).38: [[u32; 4]; 258])[_654][_658]
  using: _1@Phi(bb119), _658@Mir(bb207[0]), _654@Mir(bb206[3])
  _651 = core::num::<impl u32>::wrapping_add(move _652, move _653) -> bb208
  using: _652@Mir(bb206[1]), _653@Mir(bb207[1])
bb208:
  _344 = move _651
  using: _651@Mir(bb207[2])
  _660 = _345
  using: _345@Mir(bb202[0])
  _663 = _346
  using: _346@Mir(bb204[1])
  _662 = move _663 as usize (IntToInt)
  using: _663@Mir(bb208[2])
  _664 = const 258_usize
  using: 
  _665 = Lt(_662, _664)
  using: _662@Mir(bb208[3]), _664@Mir(bb208[4])
  assert(move _665, "index out of bounds: the length is {} but the index is {}", move _664, _662) -> bb209
  using: _665@Entry, _664@Entry, _662@Entry
bb209:
  _666 = const 2_usize
  using: 
  _661 = ((*_1).38: [[u32; 4]; 258])[_662][_666]
  using: _1@Phi(bb119), _666@Mir(bb209[0]), _662@Mir(bb208[3])
  _659 = core::num::<impl u32>::wrapping_add(move _660, move _661) -> bb210
  using: _660@Mir(bb208[1]), _661@Mir(bb209[1])
bb210:
  _345 = move _659
  using: _659@Mir(bb209[2])
  _669 = _21
  using: _21@Phi(bb112)
  _672 = _6
  using: _6@Phi(bb127)
  _673 = const 10_i32
  using: 
  _674 = CheckedAdd(_672, _673)
  using: _672@Mir(bb210[2]), _673@Mir(bb210[3])
  assert(!move (_674.1: bool), "attempt to compute `{} + {}`, which would overflow", move _672, move _673) -> bb211
  using: _674@Entry, _672@Entry, _673@Entry
bb211:
  _671 = move (_674.0: i32)
  using: _674@Mir(bb210[4])
  _670 = move _671 as isize (IntToInt)
  using: _671@Mir(bb211[0])
  _668 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _669, move _670) -> bb212
  using: _669@Mir(bb210[1]), _670@Mir(bb211[1])
bb212:
  _667 = (*_668)
  using: _668@Mir(bb211[2])
  _346 = move _667
  using: _667@Mir(bb212[0])
  _676 = _343
  using: _343@Mir(bb206[0])
  _679 = _346
  using: _346@Mir(bb212[1])
  _678 = move _679 as usize (IntToInt)
  using: _679@Mir(bb212[3])
  _680 = const 258_usize
  using: 
  _681 = Lt(_678, _680)
  using: _678@Mir(bb212[4]), _680@Mir(bb212[5])
  assert(move _681, "index out of bounds: the length is {} but the index is {}", move _680, _678) -> bb213
  using: _681@Entry, _680@Entry, _678@Entry
bb213:
  _682 = const 0_usize
  using: 
  _677 = ((*_1).38: [[u32; 4]; 258])[_678][_682]
  using: _1@Phi(bb119), _682@Mir(bb213[0]), _678@Mir(bb212[4])
  _675 = core::num::<impl u32>::wrapping_add(move _676, move _677) -> bb214
  using: _676@Mir(bb212[2]), _677@Mir(bb213[1])
bb214:
  _343 = move _675
  using: _675@Mir(bb213[2])
  _684 = _344
  using: _344@Mir(bb208[0])
  _687 = _346
  using: _346@Mir(bb212[1])
  _686 = move _687 as usize (IntToInt)
  using: _687@Mir(bb214[2])
  _688 = const 258_usize
  using: 
  _689 = Lt(_686, _688)
  using: _686@Mir(bb214[3]), _688@Mir(bb214[4])
  assert(move _689, "index out of bounds: the length is {} but the index is {}", move _688, _686) -> bb215
  using: _689@Entry, _688@Entry, _686@Entry
bb215:
  _690 = const 1_usize
  using: 
  _685 = ((*_1).38: [[u32; 4]; 258])[_686][_690]
  using: _1@Phi(bb119), _690@Mir(bb215[0]), _686@Mir(bb214[3])
  _683 = core::num::<impl u32>::wrapping_add(move _684, move _685) -> bb216
  using: _684@Mir(bb214[1]), _685@Mir(bb215[1])
bb216:
  _344 = move _683
  using: _683@Mir(bb215[2])
  _692 = _345
  using: _345@Mir(bb210[0])
  _695 = _346
  using: _346@Mir(bb212[1])
  _694 = move _695 as usize (IntToInt)
  using: _695@Mir(bb216[2])
  _696 = const 258_usize
  using: 
  _697 = Lt(_694, _696)
  using: _694@Mir(bb216[3]), _696@Mir(bb216[4])
  assert(move _697, "index out of bounds: the length is {} but the index is {}", move _696, _694) -> bb217
  using: _697@Entry, _696@Entry, _694@Entry
bb217:
  _698 = const 2_usize
  using: 
  _693 = ((*_1).38: [[u32; 4]; 258])[_694][_698]
  using: _1@Phi(bb119), _698@Mir(bb217[0]), _694@Mir(bb216[3])
  _691 = core::num::<impl u32>::wrapping_add(move _692, move _693) -> bb218
  using: _692@Mir(bb216[1]), _693@Mir(bb217[1])
bb218:
  _345 = move _691
  using: _691@Mir(bb217[2])
  _701 = _21
  using: _21@Phi(bb112)
  _704 = _6
  using: _6@Phi(bb127)
  _705 = const 11_i32
  using: 
  _706 = CheckedAdd(_704, _705)
  using: _704@Mir(bb218[2]), _705@Mir(bb218[3])
  assert(!move (_706.1: bool), "attempt to compute `{} + {}`, which would overflow", move _704, move _705) -> bb219
  using: _706@Entry, _704@Entry, _705@Entry
bb219:
  _703 = move (_706.0: i32)
  using: _706@Mir(bb218[4])
  _702 = move _703 as isize (IntToInt)
  using: _703@Mir(bb219[0])
  _700 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _701, move _702) -> bb220
  using: _701@Mir(bb218[1]), _702@Mir(bb219[1])
bb220:
  _699 = (*_700)
  using: _700@Mir(bb219[2])
  _346 = move _699
  using: _699@Mir(bb220[0])
  _708 = _343
  using: _343@Mir(bb214[0])
  _711 = _346
  using: _346@Mir(bb220[1])
  _710 = move _711 as usize (IntToInt)
  using: _711@Mir(bb220[3])
  _712 = const 258_usize
  using: 
  _713 = Lt(_710, _712)
  using: _710@Mir(bb220[4]), _712@Mir(bb220[5])
  assert(move _713, "index out of bounds: the length is {} but the index is {}", move _712, _710) -> bb221
  using: _713@Entry, _712@Entry, _710@Entry
bb221:
  _714 = const 0_usize
  using: 
  _709 = ((*_1).38: [[u32; 4]; 258])[_710][_714]
  using: _1@Phi(bb119), _714@Mir(bb221[0]), _710@Mir(bb220[4])
  _707 = core::num::<impl u32>::wrapping_add(move _708, move _709) -> bb222
  using: _708@Mir(bb220[2]), _709@Mir(bb221[1])
bb222:
  _343 = move _707
  using: _707@Mir(bb221[2])
  _716 = _344
  using: _344@Mir(bb216[0])
  _719 = _346
  using: _346@Mir(bb220[1])
  _718 = move _719 as usize (IntToInt)
  using: _719@Mir(bb222[2])
  _720 = const 258_usize
  using: 
  _721 = Lt(_718, _720)
  using: _718@Mir(bb222[3]), _720@Mir(bb222[4])
  assert(move _721, "index out of bounds: the length is {} but the index is {}", move _720, _718) -> bb223
  using: _721@Entry, _720@Entry, _718@Entry
bb223:
  _722 = const 1_usize
  using: 
  _717 = ((*_1).38: [[u32; 4]; 258])[_718][_722]
  using: _1@Phi(bb119), _722@Mir(bb223[0]), _718@Mir(bb222[3])
  _715 = core::num::<impl u32>::wrapping_add(move _716, move _717) -> bb224
  using: _716@Mir(bb222[1]), _717@Mir(bb223[1])
bb224:
  _344 = move _715
  using: _715@Mir(bb223[2])
  _724 = _345
  using: _345@Mir(bb218[0])
  _727 = _346
  using: _346@Mir(bb220[1])
  _726 = move _727 as usize (IntToInt)
  using: _727@Mir(bb224[2])
  _728 = const 258_usize
  using: 
  _729 = Lt(_726, _728)
  using: _726@Mir(bb224[3]), _728@Mir(bb224[4])
  assert(move _729, "index out of bounds: the length is {} but the index is {}", move _728, _726) -> bb225
  using: _729@Entry, _728@Entry, _726@Entry
bb225:
  _730 = const 2_usize
  using: 
  _725 = ((*_1).38: [[u32; 4]; 258])[_726][_730]
  using: _1@Phi(bb119), _730@Mir(bb225[0]), _726@Mir(bb224[3])
  _723 = core::num::<impl u32>::wrapping_add(move _724, move _725) -> bb226
  using: _724@Mir(bb224[1]), _725@Mir(bb225[1])
bb226:
  _345 = move _723
  using: _723@Mir(bb225[2])
  _733 = _21
  using: _21@Phi(bb112)
  _736 = _6
  using: _6@Phi(bb127)
  _737 = const 12_i32
  using: 
  _738 = CheckedAdd(_736, _737)
  using: _736@Mir(bb226[2]), _737@Mir(bb226[3])
  assert(!move (_738.1: bool), "attempt to compute `{} + {}`, which would overflow", move _736, move _737) -> bb227
  using: _738@Entry, _736@Entry, _737@Entry
bb227:
  _735 = move (_738.0: i32)
  using: _738@Mir(bb226[4])
  _734 = move _735 as isize (IntToInt)
  using: _735@Mir(bb227[0])
  _732 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _733, move _734) -> bb228
  using: _733@Mir(bb226[1]), _734@Mir(bb227[1])
bb228:
  _731 = (*_732)
  using: _732@Mir(bb227[2])
  _346 = move _731
  using: _731@Mir(bb228[0])
  _740 = _343
  using: _343@Mir(bb222[0])
  _743 = _346
  using: _346@Mir(bb228[1])
  _742 = move _743 as usize (IntToInt)
  using: _743@Mir(bb228[3])
  _744 = const 258_usize
  using: 
  _745 = Lt(_742, _744)
  using: _742@Mir(bb228[4]), _744@Mir(bb228[5])
  assert(move _745, "index out of bounds: the length is {} but the index is {}", move _744, _742) -> bb229
  using: _745@Entry, _744@Entry, _742@Entry
bb229:
  _746 = const 0_usize
  using: 
  _741 = ((*_1).38: [[u32; 4]; 258])[_742][_746]
  using: _1@Phi(bb119), _746@Mir(bb229[0]), _742@Mir(bb228[4])
  _739 = core::num::<impl u32>::wrapping_add(move _740, move _741) -> bb230
  using: _740@Mir(bb228[2]), _741@Mir(bb229[1])
bb230:
  _343 = move _739
  using: _739@Mir(bb229[2])
  _748 = _344
  using: _344@Mir(bb224[0])
  _751 = _346
  using: _346@Mir(bb228[1])
  _750 = move _751 as usize (IntToInt)
  using: _751@Mir(bb230[2])
  _752 = const 258_usize
  using: 
  _753 = Lt(_750, _752)
  using: _750@Mir(bb230[3]), _752@Mir(bb230[4])
  assert(move _753, "index out of bounds: the length is {} but the index is {}", move _752, _750) -> bb231
  using: _753@Entry, _752@Entry, _750@Entry
bb231:
  _754 = const 1_usize
  using: 
  _749 = ((*_1).38: [[u32; 4]; 258])[_750][_754]
  using: _1@Phi(bb119), _754@Mir(bb231[0]), _750@Mir(bb230[3])
  _747 = core::num::<impl u32>::wrapping_add(move _748, move _749) -> bb232
  using: _748@Mir(bb230[1]), _749@Mir(bb231[1])
bb232:
  _344 = move _747
  using: _747@Mir(bb231[2])
  _756 = _345
  using: _345@Mir(bb226[0])
  _759 = _346
  using: _346@Mir(bb228[1])
  _758 = move _759 as usize (IntToInt)
  using: _759@Mir(bb232[2])
  _760 = const 258_usize
  using: 
  _761 = Lt(_758, _760)
  using: _758@Mir(bb232[3]), _760@Mir(bb232[4])
  assert(move _761, "index out of bounds: the length is {} but the index is {}", move _760, _758) -> bb233
  using: _761@Entry, _760@Entry, _758@Entry
bb233:
  _762 = const 2_usize
  using: 
  _757 = ((*_1).38: [[u32; 4]; 258])[_758][_762]
  using: _1@Phi(bb119), _762@Mir(bb233[0]), _758@Mir(bb232[3])
  _755 = core::num::<impl u32>::wrapping_add(move _756, move _757) -> bb234
  using: _756@Mir(bb232[1]), _757@Mir(bb233[1])
bb234:
  _345 = move _755
  using: _755@Mir(bb233[2])
  _765 = _21
  using: _21@Phi(bb112)
  _768 = _6
  using: _6@Phi(bb127)
  _769 = const 13_i32
  using: 
  _770 = CheckedAdd(_768, _769)
  using: _768@Mir(bb234[2]), _769@Mir(bb234[3])
  assert(!move (_770.1: bool), "attempt to compute `{} + {}`, which would overflow", move _768, move _769) -> bb235
  using: _770@Entry, _768@Entry, _769@Entry
bb235:
  _767 = move (_770.0: i32)
  using: _770@Mir(bb234[4])
  _766 = move _767 as isize (IntToInt)
  using: _767@Mir(bb235[0])
  _764 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _765, move _766) -> bb236
  using: _765@Mir(bb234[1]), _766@Mir(bb235[1])
bb236:
  _763 = (*_764)
  using: _764@Mir(bb235[2])
  _346 = move _763
  using: _763@Mir(bb236[0])
  _772 = _343
  using: _343@Mir(bb230[0])
  _775 = _346
  using: _346@Mir(bb236[1])
  _774 = move _775 as usize (IntToInt)
  using: _775@Mir(bb236[3])
  _776 = const 258_usize
  using: 
  _777 = Lt(_774, _776)
  using: _774@Mir(bb236[4]), _776@Mir(bb236[5])
  assert(move _777, "index out of bounds: the length is {} but the index is {}", move _776, _774) -> bb237
  using: _777@Entry, _776@Entry, _774@Entry
bb237:
  _778 = const 0_usize
  using: 
  _773 = ((*_1).38: [[u32; 4]; 258])[_774][_778]
  using: _1@Phi(bb119), _778@Mir(bb237[0]), _774@Mir(bb236[4])
  _771 = core::num::<impl u32>::wrapping_add(move _772, move _773) -> bb238
  using: _772@Mir(bb236[2]), _773@Mir(bb237[1])
bb238:
  _343 = move _771
  using: _771@Mir(bb237[2])
  _780 = _344
  using: _344@Mir(bb232[0])
  _783 = _346
  using: _346@Mir(bb236[1])
  _782 = move _783 as usize (IntToInt)
  using: _783@Mir(bb238[2])
  _784 = const 258_usize
  using: 
  _785 = Lt(_782, _784)
  using: _782@Mir(bb238[3]), _784@Mir(bb238[4])
  assert(move _785, "index out of bounds: the length is {} but the index is {}", move _784, _782) -> bb239
  using: _785@Entry, _784@Entry, _782@Entry
bb239:
  _786 = const 1_usize
  using: 
  _781 = ((*_1).38: [[u32; 4]; 258])[_782][_786]
  using: _1@Phi(bb119), _786@Mir(bb239[0]), _782@Mir(bb238[3])
  _779 = core::num::<impl u32>::wrapping_add(move _780, move _781) -> bb240
  using: _780@Mir(bb238[1]), _781@Mir(bb239[1])
bb240:
  _344 = move _779
  using: _779@Mir(bb239[2])
  _788 = _345
  using: _345@Mir(bb234[0])
  _791 = _346
  using: _346@Mir(bb236[1])
  _790 = move _791 as usize (IntToInt)
  using: _791@Mir(bb240[2])
  _792 = const 258_usize
  using: 
  _793 = Lt(_790, _792)
  using: _790@Mir(bb240[3]), _792@Mir(bb240[4])
  assert(move _793, "index out of bounds: the length is {} but the index is {}", move _792, _790) -> bb241
  using: _793@Entry, _792@Entry, _790@Entry
bb241:
  _794 = const 2_usize
  using: 
  _789 = ((*_1).38: [[u32; 4]; 258])[_790][_794]
  using: _1@Phi(bb119), _794@Mir(bb241[0]), _790@Mir(bb240[3])
  _787 = core::num::<impl u32>::wrapping_add(move _788, move _789) -> bb242
  using: _788@Mir(bb240[1]), _789@Mir(bb241[1])
bb242:
  _345 = move _787
  using: _787@Mir(bb241[2])
  _797 = _21
  using: _21@Phi(bb112)
  _800 = _6
  using: _6@Phi(bb127)
  _801 = const 14_i32
  using: 
  _802 = CheckedAdd(_800, _801)
  using: _800@Mir(bb242[2]), _801@Mir(bb242[3])
  assert(!move (_802.1: bool), "attempt to compute `{} + {}`, which would overflow", move _800, move _801) -> bb243
  using: _802@Entry, _800@Entry, _801@Entry
bb243:
  _799 = move (_802.0: i32)
  using: _802@Mir(bb242[4])
  _798 = move _799 as isize (IntToInt)
  using: _799@Mir(bb243[0])
  _796 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _797, move _798) -> bb244
  using: _797@Mir(bb242[1]), _798@Mir(bb243[1])
bb244:
  _795 = (*_796)
  using: _796@Mir(bb243[2])
  _346 = move _795
  using: _795@Mir(bb244[0])
  _804 = _343
  using: _343@Mir(bb238[0])
  _807 = _346
  using: _346@Mir(bb244[1])
  _806 = move _807 as usize (IntToInt)
  using: _807@Mir(bb244[3])
  _808 = const 258_usize
  using: 
  _809 = Lt(_806, _808)
  using: _806@Mir(bb244[4]), _808@Mir(bb244[5])
  assert(move _809, "index out of bounds: the length is {} but the index is {}", move _808, _806) -> bb245
  using: _809@Entry, _808@Entry, _806@Entry
bb245:
  _810 = const 0_usize
  using: 
  _805 = ((*_1).38: [[u32; 4]; 258])[_806][_810]
  using: _1@Phi(bb119), _810@Mir(bb245[0]), _806@Mir(bb244[4])
  _803 = core::num::<impl u32>::wrapping_add(move _804, move _805) -> bb246
  using: _804@Mir(bb244[2]), _805@Mir(bb245[1])
bb246:
  _343 = move _803
  using: _803@Mir(bb245[2])
  _812 = _344
  using: _344@Mir(bb240[0])
  _815 = _346
  using: _346@Mir(bb244[1])
  _814 = move _815 as usize (IntToInt)
  using: _815@Mir(bb246[2])
  _816 = const 258_usize
  using: 
  _817 = Lt(_814, _816)
  using: _814@Mir(bb246[3]), _816@Mir(bb246[4])
  assert(move _817, "index out of bounds: the length is {} but the index is {}", move _816, _814) -> bb247
  using: _817@Entry, _816@Entry, _814@Entry
bb247:
  _818 = const 1_usize
  using: 
  _813 = ((*_1).38: [[u32; 4]; 258])[_814][_818]
  using: _1@Phi(bb119), _818@Mir(bb247[0]), _814@Mir(bb246[3])
  _811 = core::num::<impl u32>::wrapping_add(move _812, move _813) -> bb248
  using: _812@Mir(bb246[1]), _813@Mir(bb247[1])
bb248:
  _344 = move _811
  using: _811@Mir(bb247[2])
  _820 = _345
  using: _345@Mir(bb242[0])
  _823 = _346
  using: _346@Mir(bb244[1])
  _822 = move _823 as usize (IntToInt)
  using: _823@Mir(bb248[2])
  _824 = const 258_usize
  using: 
  _825 = Lt(_822, _824)
  using: _822@Mir(bb248[3]), _824@Mir(bb248[4])
  assert(move _825, "index out of bounds: the length is {} but the index is {}", move _824, _822) -> bb249
  using: _825@Entry, _824@Entry, _822@Entry
bb249:
  _826 = const 2_usize
  using: 
  _821 = ((*_1).38: [[u32; 4]; 258])[_822][_826]
  using: _1@Phi(bb119), _826@Mir(bb249[0]), _822@Mir(bb248[3])
  _819 = core::num::<impl u32>::wrapping_add(move _820, move _821) -> bb250
  using: _820@Mir(bb248[1]), _821@Mir(bb249[1])
bb250:
  _345 = move _819
  using: _819@Mir(bb249[2])
  _829 = _21
  using: _21@Phi(bb112)
  _832 = _6
  using: _6@Phi(bb127)
  _833 = const 15_i32
  using: 
  _834 = CheckedAdd(_832, _833)
  using: _832@Mir(bb250[2]), _833@Mir(bb250[3])
  assert(!move (_834.1: bool), "attempt to compute `{} + {}`, which would overflow", move _832, move _833) -> bb251
  using: _834@Entry, _832@Entry, _833@Entry
bb251:
  _831 = move (_834.0: i32)
  using: _834@Mir(bb250[4])
  _830 = move _831 as isize (IntToInt)
  using: _831@Mir(bb251[0])
  _828 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _829, move _830) -> bb252
  using: _829@Mir(bb250[1]), _830@Mir(bb251[1])
bb252:
  _827 = (*_828)
  using: _828@Mir(bb251[2])
  _346 = move _827
  using: _827@Mir(bb252[0])
  _836 = _343
  using: _343@Mir(bb246[0])
  _839 = _346
  using: _346@Mir(bb252[1])
  _838 = move _839 as usize (IntToInt)
  using: _839@Mir(bb252[3])
  _840 = const 258_usize
  using: 
  _841 = Lt(_838, _840)
  using: _838@Mir(bb252[4]), _840@Mir(bb252[5])
  assert(move _841, "index out of bounds: the length is {} but the index is {}", move _840, _838) -> bb253
  using: _841@Entry, _840@Entry, _838@Entry
bb253:
  _842 = const 0_usize
  using: 
  _837 = ((*_1).38: [[u32; 4]; 258])[_838][_842]
  using: _1@Phi(bb119), _842@Mir(bb253[0]), _838@Mir(bb252[4])
  _835 = core::num::<impl u32>::wrapping_add(move _836, move _837) -> bb254
  using: _836@Mir(bb252[2]), _837@Mir(bb253[1])
bb254:
  _343 = move _835
  using: _835@Mir(bb253[2])
  _844 = _344
  using: _344@Mir(bb248[0])
  _847 = _346
  using: _346@Mir(bb252[1])
  _846 = move _847 as usize (IntToInt)
  using: _847@Mir(bb254[2])
  _848 = const 258_usize
  using: 
  _849 = Lt(_846, _848)
  using: _846@Mir(bb254[3]), _848@Mir(bb254[4])
  assert(move _849, "index out of bounds: the length is {} but the index is {}", move _848, _846) -> bb255
  using: _849@Entry, _848@Entry, _846@Entry
bb255:
  _850 = const 1_usize
  using: 
  _845 = ((*_1).38: [[u32; 4]; 258])[_846][_850]
  using: _1@Phi(bb119), _850@Mir(bb255[0]), _846@Mir(bb254[3])
  _843 = core::num::<impl u32>::wrapping_add(move _844, move _845) -> bb256
  using: _844@Mir(bb254[1]), _845@Mir(bb255[1])
bb256:
  _344 = move _843
  using: _843@Mir(bb255[2])
  _852 = _345
  using: _345@Mir(bb250[0])
  _855 = _346
  using: _346@Mir(bb252[1])
  _854 = move _855 as usize (IntToInt)
  using: _855@Mir(bb256[2])
  _856 = const 258_usize
  using: 
  _857 = Lt(_854, _856)
  using: _854@Mir(bb256[3]), _856@Mir(bb256[4])
  assert(move _857, "index out of bounds: the length is {} but the index is {}", move _856, _854) -> bb257
  using: _857@Entry, _856@Entry, _854@Entry
bb257:
  _858 = const 2_usize
  using: 
  _853 = ((*_1).38: [[u32; 4]; 258])[_854][_858]
  using: _1@Phi(bb119), _858@Mir(bb257[0]), _854@Mir(bb256[3])
  _851 = core::num::<impl u32>::wrapping_add(move _852, move _853) -> bb258
  using: _852@Mir(bb256[1]), _853@Mir(bb257[1])
bb258:
  _345 = move _851
  using: _851@Mir(bb257[2])
  _861 = _21
  using: _21@Phi(bb112)
  _864 = _6
  using: _6@Phi(bb127)
  _865 = const 16_i32
  using: 
  _866 = CheckedAdd(_864, _865)
  using: _864@Mir(bb258[2]), _865@Mir(bb258[3])
  assert(!move (_866.1: bool), "attempt to compute `{} + {}`, which would overflow", move _864, move _865) -> bb259
  using: _866@Entry, _864@Entry, _865@Entry
bb259:
  _863 = move (_866.0: i32)
  using: _866@Mir(bb258[4])
  _862 = move _863 as isize (IntToInt)
  using: _863@Mir(bb259[0])
  _860 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _861, move _862) -> bb260
  using: _861@Mir(bb258[1]), _862@Mir(bb259[1])
bb260:
  _859 = (*_860)
  using: _860@Mir(bb259[2])
  _346 = move _859
  using: _859@Mir(bb260[0])
  _868 = _343
  using: _343@Mir(bb254[0])
  _871 = _346
  using: _346@Mir(bb260[1])
  _870 = move _871 as usize (IntToInt)
  using: _871@Mir(bb260[3])
  _872 = const 258_usize
  using: 
  _873 = Lt(_870, _872)
  using: _870@Mir(bb260[4]), _872@Mir(bb260[5])
  assert(move _873, "index out of bounds: the length is {} but the index is {}", move _872, _870) -> bb261
  using: _873@Entry, _872@Entry, _870@Entry
bb261:
  _874 = const 0_usize
  using: 
  _869 = ((*_1).38: [[u32; 4]; 258])[_870][_874]
  using: _1@Phi(bb119), _874@Mir(bb261[0]), _870@Mir(bb260[4])
  _867 = core::num::<impl u32>::wrapping_add(move _868, move _869) -> bb262
  using: _868@Mir(bb260[2]), _869@Mir(bb261[1])
bb262:
  _343 = move _867
  using: _867@Mir(bb261[2])
  _876 = _344
  using: _344@Mir(bb256[0])
  _879 = _346
  using: _346@Mir(bb260[1])
  _878 = move _879 as usize (IntToInt)
  using: _879@Mir(bb262[2])
  _880 = const 258_usize
  using: 
  _881 = Lt(_878, _880)
  using: _878@Mir(bb262[3]), _880@Mir(bb262[4])
  assert(move _881, "index out of bounds: the length is {} but the index is {}", move _880, _878) -> bb263
  using: _881@Entry, _880@Entry, _878@Entry
bb263:
  _882 = const 1_usize
  using: 
  _877 = ((*_1).38: [[u32; 4]; 258])[_878][_882]
  using: _1@Phi(bb119), _882@Mir(bb263[0]), _878@Mir(bb262[3])
  _875 = core::num::<impl u32>::wrapping_add(move _876, move _877) -> bb264
  using: _876@Mir(bb262[1]), _877@Mir(bb263[1])
bb264:
  _344 = move _875
  using: _875@Mir(bb263[2])
  _884 = _345
  using: _345@Mir(bb258[0])
  _887 = _346
  using: _346@Mir(bb260[1])
  _886 = move _887 as usize (IntToInt)
  using: _887@Mir(bb264[2])
  _888 = const 258_usize
  using: 
  _889 = Lt(_886, _888)
  using: _886@Mir(bb264[3]), _888@Mir(bb264[4])
  assert(move _889, "index out of bounds: the length is {} but the index is {}", move _888, _886) -> bb265
  using: _889@Entry, _888@Entry, _886@Entry
bb265:
  _890 = const 2_usize
  using: 
  _885 = ((*_1).38: [[u32; 4]; 258])[_886][_890]
  using: _1@Phi(bb119), _890@Mir(bb265[0]), _886@Mir(bb264[3])
  _883 = core::num::<impl u32>::wrapping_add(move _884, move _885) -> bb266
  using: _884@Mir(bb264[1]), _885@Mir(bb265[1])
bb266:
  _345 = move _883
  using: _883@Mir(bb265[2])
  _893 = _21
  using: _21@Phi(bb112)
  _896 = _6
  using: _6@Phi(bb127)
  _897 = const 17_i32
  using: 
  _898 = CheckedAdd(_896, _897)
  using: _896@Mir(bb266[2]), _897@Mir(bb266[3])
  assert(!move (_898.1: bool), "attempt to compute `{} + {}`, which would overflow", move _896, move _897) -> bb267
  using: _898@Entry, _896@Entry, _897@Entry
bb267:
  _895 = move (_898.0: i32)
  using: _898@Mir(bb266[4])
  _894 = move _895 as isize (IntToInt)
  using: _895@Mir(bb267[0])
  _892 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _893, move _894) -> bb268
  using: _893@Mir(bb266[1]), _894@Mir(bb267[1])
bb268:
  _891 = (*_892)
  using: _892@Mir(bb267[2])
  _346 = move _891
  using: _891@Mir(bb268[0])
  _900 = _343
  using: _343@Mir(bb262[0])
  _903 = _346
  using: _346@Mir(bb268[1])
  _902 = move _903 as usize (IntToInt)
  using: _903@Mir(bb268[3])
  _904 = const 258_usize
  using: 
  _905 = Lt(_902, _904)
  using: _902@Mir(bb268[4]), _904@Mir(bb268[5])
  assert(move _905, "index out of bounds: the length is {} but the index is {}", move _904, _902) -> bb269
  using: _905@Entry, _904@Entry, _902@Entry
bb269:
  _906 = const 0_usize
  using: 
  _901 = ((*_1).38: [[u32; 4]; 258])[_902][_906]
  using: _1@Phi(bb119), _906@Mir(bb269[0]), _902@Mir(bb268[4])
  _899 = core::num::<impl u32>::wrapping_add(move _900, move _901) -> bb270
  using: _900@Mir(bb268[2]), _901@Mir(bb269[1])
bb270:
  _343 = move _899
  using: _899@Mir(bb269[2])
  _908 = _344
  using: _344@Mir(bb264[0])
  _911 = _346
  using: _346@Mir(bb268[1])
  _910 = move _911 as usize (IntToInt)
  using: _911@Mir(bb270[2])
  _912 = const 258_usize
  using: 
  _913 = Lt(_910, _912)
  using: _910@Mir(bb270[3]), _912@Mir(bb270[4])
  assert(move _913, "index out of bounds: the length is {} but the index is {}", move _912, _910) -> bb271
  using: _913@Entry, _912@Entry, _910@Entry
bb271:
  _914 = const 1_usize
  using: 
  _909 = ((*_1).38: [[u32; 4]; 258])[_910][_914]
  using: _1@Phi(bb119), _914@Mir(bb271[0]), _910@Mir(bb270[3])
  _907 = core::num::<impl u32>::wrapping_add(move _908, move _909) -> bb272
  using: _908@Mir(bb270[1]), _909@Mir(bb271[1])
bb272:
  _344 = move _907
  using: _907@Mir(bb271[2])
  _916 = _345
  using: _345@Mir(bb266[0])
  _919 = _346
  using: _346@Mir(bb268[1])
  _918 = move _919 as usize (IntToInt)
  using: _919@Mir(bb272[2])
  _920 = const 258_usize
  using: 
  _921 = Lt(_918, _920)
  using: _918@Mir(bb272[3]), _920@Mir(bb272[4])
  assert(move _921, "index out of bounds: the length is {} but the index is {}", move _920, _918) -> bb273
  using: _921@Entry, _920@Entry, _918@Entry
bb273:
  _922 = const 2_usize
  using: 
  _917 = ((*_1).38: [[u32; 4]; 258])[_918][_922]
  using: _1@Phi(bb119), _922@Mir(bb273[0]), _918@Mir(bb272[3])
  _915 = core::num::<impl u32>::wrapping_add(move _916, move _917) -> bb274
  using: _916@Mir(bb272[1]), _917@Mir(bb273[1])
bb274:
  _345 = move _915
  using: _915@Mir(bb273[2])
  _925 = _21
  using: _21@Phi(bb112)
  _928 = _6
  using: _6@Phi(bb127)
  _929 = const 18_i32
  using: 
  _930 = CheckedAdd(_928, _929)
  using: _928@Mir(bb274[2]), _929@Mir(bb274[3])
  assert(!move (_930.1: bool), "attempt to compute `{} + {}`, which would overflow", move _928, move _929) -> bb275
  using: _930@Entry, _928@Entry, _929@Entry
bb275:
  _927 = move (_930.0: i32)
  using: _930@Mir(bb274[4])
  _926 = move _927 as isize (IntToInt)
  using: _927@Mir(bb275[0])
  _924 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _925, move _926) -> bb276
  using: _925@Mir(bb274[1]), _926@Mir(bb275[1])
bb276:
  _923 = (*_924)
  using: _924@Mir(bb275[2])
  _346 = move _923
  using: _923@Mir(bb276[0])
  _932 = _343
  using: _343@Mir(bb270[0])
  _935 = _346
  using: _346@Mir(bb276[1])
  _934 = move _935 as usize (IntToInt)
  using: _935@Mir(bb276[3])
  _936 = const 258_usize
  using: 
  _937 = Lt(_934, _936)
  using: _934@Mir(bb276[4]), _936@Mir(bb276[5])
  assert(move _937, "index out of bounds: the length is {} but the index is {}", move _936, _934) -> bb277
  using: _937@Entry, _936@Entry, _934@Entry
bb277:
  _938 = const 0_usize
  using: 
  _933 = ((*_1).38: [[u32; 4]; 258])[_934][_938]
  using: _1@Phi(bb119), _938@Mir(bb277[0]), _934@Mir(bb276[4])
  _931 = core::num::<impl u32>::wrapping_add(move _932, move _933) -> bb278
  using: _932@Mir(bb276[2]), _933@Mir(bb277[1])
bb278:
  _343 = move _931
  using: _931@Mir(bb277[2])
  _940 = _344
  using: _344@Mir(bb272[0])
  _943 = _346
  using: _346@Mir(bb276[1])
  _942 = move _943 as usize (IntToInt)
  using: _943@Mir(bb278[2])
  _944 = const 258_usize
  using: 
  _945 = Lt(_942, _944)
  using: _942@Mir(bb278[3]), _944@Mir(bb278[4])
  assert(move _945, "index out of bounds: the length is {} but the index is {}", move _944, _942) -> bb279
  using: _945@Entry, _944@Entry, _942@Entry
bb279:
  _946 = const 1_usize
  using: 
  _941 = ((*_1).38: [[u32; 4]; 258])[_942][_946]
  using: _1@Phi(bb119), _946@Mir(bb279[0]), _942@Mir(bb278[3])
  _939 = core::num::<impl u32>::wrapping_add(move _940, move _941) -> bb280
  using: _940@Mir(bb278[1]), _941@Mir(bb279[1])
bb280:
  _344 = move _939
  using: _939@Mir(bb279[2])
  _948 = _345
  using: _345@Mir(bb274[0])
  _951 = _346
  using: _346@Mir(bb276[1])
  _950 = move _951 as usize (IntToInt)
  using: _951@Mir(bb280[2])
  _952 = const 258_usize
  using: 
  _953 = Lt(_950, _952)
  using: _950@Mir(bb280[3]), _952@Mir(bb280[4])
  assert(move _953, "index out of bounds: the length is {} but the index is {}", move _952, _950) -> bb281
  using: _953@Entry, _952@Entry, _950@Entry
bb281:
  _954 = const 2_usize
  using: 
  _949 = ((*_1).38: [[u32; 4]; 258])[_950][_954]
  using: _1@Phi(bb119), _954@Mir(bb281[0]), _950@Mir(bb280[3])
  _947 = core::num::<impl u32>::wrapping_add(move _948, move _949) -> bb282
  using: _948@Mir(bb280[1]), _949@Mir(bb281[1])
bb282:
  _345 = move _947
  using: _947@Mir(bb281[2])
  _957 = _21
  using: _21@Phi(bb112)
  _960 = _6
  using: _6@Phi(bb127)
  _961 = const 19_i32
  using: 
  _962 = CheckedAdd(_960, _961)
  using: _960@Mir(bb282[2]), _961@Mir(bb282[3])
  assert(!move (_962.1: bool), "attempt to compute `{} + {}`, which would overflow", move _960, move _961) -> bb283
  using: _962@Entry, _960@Entry, _961@Entry
bb283:
  _959 = move (_962.0: i32)
  using: _962@Mir(bb282[4])
  _958 = move _959 as isize (IntToInt)
  using: _959@Mir(bb283[0])
  _956 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _957, move _958) -> bb284
  using: _957@Mir(bb282[1]), _958@Mir(bb283[1])
bb284:
  _955 = (*_956)
  using: _956@Mir(bb283[2])
  _346 = move _955
  using: _955@Mir(bb284[0])
  _964 = _343
  using: _343@Mir(bb278[0])
  _967 = _346
  using: _346@Mir(bb284[1])
  _966 = move _967 as usize (IntToInt)
  using: _967@Mir(bb284[3])
  _968 = const 258_usize
  using: 
  _969 = Lt(_966, _968)
  using: _966@Mir(bb284[4]), _968@Mir(bb284[5])
  assert(move _969, "index out of bounds: the length is {} but the index is {}", move _968, _966) -> bb285
  using: _969@Entry, _968@Entry, _966@Entry
bb285:
  _970 = const 0_usize
  using: 
  _965 = ((*_1).38: [[u32; 4]; 258])[_966][_970]
  using: _1@Phi(bb119), _970@Mir(bb285[0]), _966@Mir(bb284[4])
  _963 = core::num::<impl u32>::wrapping_add(move _964, move _965) -> bb286
  using: _964@Mir(bb284[2]), _965@Mir(bb285[1])
bb286:
  _343 = move _963
  using: _963@Mir(bb285[2])
  _972 = _344
  using: _344@Mir(bb280[0])
  _975 = _346
  using: _346@Mir(bb284[1])
  _974 = move _975 as usize (IntToInt)
  using: _975@Mir(bb286[2])
  _976 = const 258_usize
  using: 
  _977 = Lt(_974, _976)
  using: _974@Mir(bb286[3]), _976@Mir(bb286[4])
  assert(move _977, "index out of bounds: the length is {} but the index is {}", move _976, _974) -> bb287
  using: _977@Entry, _976@Entry, _974@Entry
bb287:
  _978 = const 1_usize
  using: 
  _973 = ((*_1).38: [[u32; 4]; 258])[_974][_978]
  using: _1@Phi(bb119), _978@Mir(bb287[0]), _974@Mir(bb286[3])
  _971 = core::num::<impl u32>::wrapping_add(move _972, move _973) -> bb288
  using: _972@Mir(bb286[1]), _973@Mir(bb287[1])
bb288:
  _344 = move _971
  using: _971@Mir(bb287[2])
  _980 = _345
  using: _345@Mir(bb282[0])
  _983 = _346
  using: _346@Mir(bb284[1])
  _982 = move _983 as usize (IntToInt)
  using: _983@Mir(bb288[2])
  _984 = const 258_usize
  using: 
  _985 = Lt(_982, _984)
  using: _982@Mir(bb288[3]), _984@Mir(bb288[4])
  assert(move _985, "index out of bounds: the length is {} but the index is {}", move _984, _982) -> bb289
  using: _985@Entry, _984@Entry, _982@Entry
bb289:
  _986 = const 2_usize
  using: 
  _981 = ((*_1).38: [[u32; 4]; 258])[_982][_986]
  using: _1@Phi(bb119), _986@Mir(bb289[0]), _982@Mir(bb288[3])
  _979 = core::num::<impl u32>::wrapping_add(move _980, move _981) -> bb290
  using: _980@Mir(bb288[1]), _981@Mir(bb289[1])
bb290:
  _345 = move _979
  using: _979@Mir(bb289[2])
  _989 = _21
  using: _21@Phi(bb112)
  _992 = _6
  using: _6@Phi(bb127)
  _993 = const 20_i32
  using: 
  _994 = CheckedAdd(_992, _993)
  using: _992@Mir(bb290[2]), _993@Mir(bb290[3])
  assert(!move (_994.1: bool), "attempt to compute `{} + {}`, which would overflow", move _992, move _993) -> bb291
  using: _994@Entry, _992@Entry, _993@Entry
bb291:
  _991 = move (_994.0: i32)
  using: _994@Mir(bb290[4])
  _990 = move _991 as isize (IntToInt)
  using: _991@Mir(bb291[0])
  _988 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _989, move _990) -> bb292
  using: _989@Mir(bb290[1]), _990@Mir(bb291[1])
bb292:
  _987 = (*_988)
  using: _988@Mir(bb291[2])
  _346 = move _987
  using: _987@Mir(bb292[0])
  _996 = _343
  using: _343@Mir(bb286[0])
  _999 = _346
  using: _346@Mir(bb292[1])
  _998 = move _999 as usize (IntToInt)
  using: _999@Mir(bb292[3])
  _1000 = const 258_usize
  using: 
  _1001 = Lt(_998, _1000)
  using: _998@Mir(bb292[4]), _1000@Mir(bb292[5])
  assert(move _1001, "index out of bounds: the length is {} but the index is {}", move _1000, _998) -> bb293
  using: _1001@Entry, _1000@Entry, _998@Entry
bb293:
  _1002 = const 0_usize
  using: 
  _997 = ((*_1).38: [[u32; 4]; 258])[_998][_1002]
  using: _1@Phi(bb119), _1002@Mir(bb293[0]), _998@Mir(bb292[4])
  _995 = core::num::<impl u32>::wrapping_add(move _996, move _997) -> bb294
  using: _996@Mir(bb292[2]), _997@Mir(bb293[1])
bb294:
  _343 = move _995
  using: _995@Mir(bb293[2])
  _1004 = _344
  using: _344@Mir(bb288[0])
  _1007 = _346
  using: _346@Mir(bb292[1])
  _1006 = move _1007 as usize (IntToInt)
  using: _1007@Mir(bb294[2])
  _1008 = const 258_usize
  using: 
  _1009 = Lt(_1006, _1008)
  using: _1006@Mir(bb294[3]), _1008@Mir(bb294[4])
  assert(move _1009, "index out of bounds: the length is {} but the index is {}", move _1008, _1006) -> bb295
  using: _1009@Entry, _1008@Entry, _1006@Entry
bb295:
  _1010 = const 1_usize
  using: 
  _1005 = ((*_1).38: [[u32; 4]; 258])[_1006][_1010]
  using: _1@Phi(bb119), _1010@Mir(bb295[0]), _1006@Mir(bb294[3])
  _1003 = core::num::<impl u32>::wrapping_add(move _1004, move _1005) -> bb296
  using: _1004@Mir(bb294[1]), _1005@Mir(bb295[1])
bb296:
  _344 = move _1003
  using: _1003@Mir(bb295[2])
  _1012 = _345
  using: _345@Mir(bb290[0])
  _1015 = _346
  using: _346@Mir(bb292[1])
  _1014 = move _1015 as usize (IntToInt)
  using: _1015@Mir(bb296[2])
  _1016 = const 258_usize
  using: 
  _1017 = Lt(_1014, _1016)
  using: _1014@Mir(bb296[3]), _1016@Mir(bb296[4])
  assert(move _1017, "index out of bounds: the length is {} but the index is {}", move _1016, _1014) -> bb297
  using: _1017@Entry, _1016@Entry, _1014@Entry
bb297:
  _1018 = const 2_usize
  using: 
  _1013 = ((*_1).38: [[u32; 4]; 258])[_1014][_1018]
  using: _1@Phi(bb119), _1018@Mir(bb297[0]), _1014@Mir(bb296[3])
  _1011 = core::num::<impl u32>::wrapping_add(move _1012, move _1013) -> bb298
  using: _1012@Mir(bb296[1]), _1013@Mir(bb297[1])
bb298:
  _345 = move _1011
  using: _1011@Mir(bb297[2])
  _1021 = _21
  using: _21@Phi(bb112)
  _1024 = _6
  using: _6@Phi(bb127)
  _1025 = const 21_i32
  using: 
  _1026 = CheckedAdd(_1024, _1025)
  using: _1024@Mir(bb298[2]), _1025@Mir(bb298[3])
  assert(!move (_1026.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1024, move _1025) -> bb299
  using: _1026@Entry, _1024@Entry, _1025@Entry
bb299:
  _1023 = move (_1026.0: i32)
  using: _1026@Mir(bb298[4])
  _1022 = move _1023 as isize (IntToInt)
  using: _1023@Mir(bb299[0])
  _1020 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1021, move _1022) -> bb300
  using: _1021@Mir(bb298[1]), _1022@Mir(bb299[1])
bb300:
  _1019 = (*_1020)
  using: _1020@Mir(bb299[2])
  _346 = move _1019
  using: _1019@Mir(bb300[0])
  _1028 = _343
  using: _343@Mir(bb294[0])
  _1031 = _346
  using: _346@Mir(bb300[1])
  _1030 = move _1031 as usize (IntToInt)
  using: _1031@Mir(bb300[3])
  _1032 = const 258_usize
  using: 
  _1033 = Lt(_1030, _1032)
  using: _1030@Mir(bb300[4]), _1032@Mir(bb300[5])
  assert(move _1033, "index out of bounds: the length is {} but the index is {}", move _1032, _1030) -> bb301
  using: _1033@Entry, _1032@Entry, _1030@Entry
bb301:
  _1034 = const 0_usize
  using: 
  _1029 = ((*_1).38: [[u32; 4]; 258])[_1030][_1034]
  using: _1@Phi(bb119), _1034@Mir(bb301[0]), _1030@Mir(bb300[4])
  _1027 = core::num::<impl u32>::wrapping_add(move _1028, move _1029) -> bb302
  using: _1028@Mir(bb300[2]), _1029@Mir(bb301[1])
bb302:
  _343 = move _1027
  using: _1027@Mir(bb301[2])
  _1036 = _344
  using: _344@Mir(bb296[0])
  _1039 = _346
  using: _346@Mir(bb300[1])
  _1038 = move _1039 as usize (IntToInt)
  using: _1039@Mir(bb302[2])
  _1040 = const 258_usize
  using: 
  _1041 = Lt(_1038, _1040)
  using: _1038@Mir(bb302[3]), _1040@Mir(bb302[4])
  assert(move _1041, "index out of bounds: the length is {} but the index is {}", move _1040, _1038) -> bb303
  using: _1041@Entry, _1040@Entry, _1038@Entry
bb303:
  _1042 = const 1_usize
  using: 
  _1037 = ((*_1).38: [[u32; 4]; 258])[_1038][_1042]
  using: _1@Phi(bb119), _1042@Mir(bb303[0]), _1038@Mir(bb302[3])
  _1035 = core::num::<impl u32>::wrapping_add(move _1036, move _1037) -> bb304
  using: _1036@Mir(bb302[1]), _1037@Mir(bb303[1])
bb304:
  _344 = move _1035
  using: _1035@Mir(bb303[2])
  _1044 = _345
  using: _345@Mir(bb298[0])
  _1047 = _346
  using: _346@Mir(bb300[1])
  _1046 = move _1047 as usize (IntToInt)
  using: _1047@Mir(bb304[2])
  _1048 = const 258_usize
  using: 
  _1049 = Lt(_1046, _1048)
  using: _1046@Mir(bb304[3]), _1048@Mir(bb304[4])
  assert(move _1049, "index out of bounds: the length is {} but the index is {}", move _1048, _1046) -> bb305
  using: _1049@Entry, _1048@Entry, _1046@Entry
bb305:
  _1050 = const 2_usize
  using: 
  _1045 = ((*_1).38: [[u32; 4]; 258])[_1046][_1050]
  using: _1@Phi(bb119), _1050@Mir(bb305[0]), _1046@Mir(bb304[3])
  _1043 = core::num::<impl u32>::wrapping_add(move _1044, move _1045) -> bb306
  using: _1044@Mir(bb304[1]), _1045@Mir(bb305[1])
bb306:
  _345 = move _1043
  using: _1043@Mir(bb305[2])
  _1053 = _21
  using: _21@Phi(bb112)
  _1056 = _6
  using: _6@Phi(bb127)
  _1057 = const 22_i32
  using: 
  _1058 = CheckedAdd(_1056, _1057)
  using: _1056@Mir(bb306[2]), _1057@Mir(bb306[3])
  assert(!move (_1058.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1056, move _1057) -> bb307
  using: _1058@Entry, _1056@Entry, _1057@Entry
bb307:
  _1055 = move (_1058.0: i32)
  using: _1058@Mir(bb306[4])
  _1054 = move _1055 as isize (IntToInt)
  using: _1055@Mir(bb307[0])
  _1052 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1053, move _1054) -> bb308
  using: _1053@Mir(bb306[1]), _1054@Mir(bb307[1])
bb308:
  _1051 = (*_1052)
  using: _1052@Mir(bb307[2])
  _346 = move _1051
  using: _1051@Mir(bb308[0])
  _1060 = _343
  using: _343@Mir(bb302[0])
  _1063 = _346
  using: _346@Mir(bb308[1])
  _1062 = move _1063 as usize (IntToInt)
  using: _1063@Mir(bb308[3])
  _1064 = const 258_usize
  using: 
  _1065 = Lt(_1062, _1064)
  using: _1062@Mir(bb308[4]), _1064@Mir(bb308[5])
  assert(move _1065, "index out of bounds: the length is {} but the index is {}", move _1064, _1062) -> bb309
  using: _1065@Entry, _1064@Entry, _1062@Entry
bb309:
  _1066 = const 0_usize
  using: 
  _1061 = ((*_1).38: [[u32; 4]; 258])[_1062][_1066]
  using: _1@Phi(bb119), _1066@Mir(bb309[0]), _1062@Mir(bb308[4])
  _1059 = core::num::<impl u32>::wrapping_add(move _1060, move _1061) -> bb310
  using: _1060@Mir(bb308[2]), _1061@Mir(bb309[1])
bb310:
  _343 = move _1059
  using: _1059@Mir(bb309[2])
  _1068 = _344
  using: _344@Mir(bb304[0])
  _1071 = _346
  using: _346@Mir(bb308[1])
  _1070 = move _1071 as usize (IntToInt)
  using: _1071@Mir(bb310[2])
  _1072 = const 258_usize
  using: 
  _1073 = Lt(_1070, _1072)
  using: _1070@Mir(bb310[3]), _1072@Mir(bb310[4])
  assert(move _1073, "index out of bounds: the length is {} but the index is {}", move _1072, _1070) -> bb311
  using: _1073@Entry, _1072@Entry, _1070@Entry
bb311:
  _1074 = const 1_usize
  using: 
  _1069 = ((*_1).38: [[u32; 4]; 258])[_1070][_1074]
  using: _1@Phi(bb119), _1074@Mir(bb311[0]), _1070@Mir(bb310[3])
  _1067 = core::num::<impl u32>::wrapping_add(move _1068, move _1069) -> bb312
  using: _1068@Mir(bb310[1]), _1069@Mir(bb311[1])
bb312:
  _344 = move _1067
  using: _1067@Mir(bb311[2])
  _1076 = _345
  using: _345@Mir(bb306[0])
  _1079 = _346
  using: _346@Mir(bb308[1])
  _1078 = move _1079 as usize (IntToInt)
  using: _1079@Mir(bb312[2])
  _1080 = const 258_usize
  using: 
  _1081 = Lt(_1078, _1080)
  using: _1078@Mir(bb312[3]), _1080@Mir(bb312[4])
  assert(move _1081, "index out of bounds: the length is {} but the index is {}", move _1080, _1078) -> bb313
  using: _1081@Entry, _1080@Entry, _1078@Entry
bb313:
  _1082 = const 2_usize
  using: 
  _1077 = ((*_1).38: [[u32; 4]; 258])[_1078][_1082]
  using: _1@Phi(bb119), _1082@Mir(bb313[0]), _1078@Mir(bb312[3])
  _1075 = core::num::<impl u32>::wrapping_add(move _1076, move _1077) -> bb314
  using: _1076@Mir(bb312[1]), _1077@Mir(bb313[1])
bb314:
  _345 = move _1075
  using: _1075@Mir(bb313[2])
  _1085 = _21
  using: _21@Phi(bb112)
  _1088 = _6
  using: _6@Phi(bb127)
  _1089 = const 23_i32
  using: 
  _1090 = CheckedAdd(_1088, _1089)
  using: _1088@Mir(bb314[2]), _1089@Mir(bb314[3])
  assert(!move (_1090.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1088, move _1089) -> bb315
  using: _1090@Entry, _1088@Entry, _1089@Entry
bb315:
  _1087 = move (_1090.0: i32)
  using: _1090@Mir(bb314[4])
  _1086 = move _1087 as isize (IntToInt)
  using: _1087@Mir(bb315[0])
  _1084 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1085, move _1086) -> bb316
  using: _1085@Mir(bb314[1]), _1086@Mir(bb315[1])
bb316:
  _1083 = (*_1084)
  using: _1084@Mir(bb315[2])
  _346 = move _1083
  using: _1083@Mir(bb316[0])
  _1092 = _343
  using: _343@Mir(bb310[0])
  _1095 = _346
  using: _346@Mir(bb316[1])
  _1094 = move _1095 as usize (IntToInt)
  using: _1095@Mir(bb316[3])
  _1096 = const 258_usize
  using: 
  _1097 = Lt(_1094, _1096)
  using: _1094@Mir(bb316[4]), _1096@Mir(bb316[5])
  assert(move _1097, "index out of bounds: the length is {} but the index is {}", move _1096, _1094) -> bb317
  using: _1097@Entry, _1096@Entry, _1094@Entry
bb317:
  _1098 = const 0_usize
  using: 
  _1093 = ((*_1).38: [[u32; 4]; 258])[_1094][_1098]
  using: _1@Phi(bb119), _1098@Mir(bb317[0]), _1094@Mir(bb316[4])
  _1091 = core::num::<impl u32>::wrapping_add(move _1092, move _1093) -> bb318
  using: _1092@Mir(bb316[2]), _1093@Mir(bb317[1])
bb318:
  _343 = move _1091
  using: _1091@Mir(bb317[2])
  _1100 = _344
  using: _344@Mir(bb312[0])
  _1103 = _346
  using: _346@Mir(bb316[1])
  _1102 = move _1103 as usize (IntToInt)
  using: _1103@Mir(bb318[2])
  _1104 = const 258_usize
  using: 
  _1105 = Lt(_1102, _1104)
  using: _1102@Mir(bb318[3]), _1104@Mir(bb318[4])
  assert(move _1105, "index out of bounds: the length is {} but the index is {}", move _1104, _1102) -> bb319
  using: _1105@Entry, _1104@Entry, _1102@Entry
bb319:
  _1106 = const 1_usize
  using: 
  _1101 = ((*_1).38: [[u32; 4]; 258])[_1102][_1106]
  using: _1@Phi(bb119), _1106@Mir(bb319[0]), _1102@Mir(bb318[3])
  _1099 = core::num::<impl u32>::wrapping_add(move _1100, move _1101) -> bb320
  using: _1100@Mir(bb318[1]), _1101@Mir(bb319[1])
bb320:
  _344 = move _1099
  using: _1099@Mir(bb319[2])
  _1108 = _345
  using: _345@Mir(bb314[0])
  _1111 = _346
  using: _346@Mir(bb316[1])
  _1110 = move _1111 as usize (IntToInt)
  using: _1111@Mir(bb320[2])
  _1112 = const 258_usize
  using: 
  _1113 = Lt(_1110, _1112)
  using: _1110@Mir(bb320[3]), _1112@Mir(bb320[4])
  assert(move _1113, "index out of bounds: the length is {} but the index is {}", move _1112, _1110) -> bb321
  using: _1113@Entry, _1112@Entry, _1110@Entry
bb321:
  _1114 = const 2_usize
  using: 
  _1109 = ((*_1).38: [[u32; 4]; 258])[_1110][_1114]
  using: _1@Phi(bb119), _1114@Mir(bb321[0]), _1110@Mir(bb320[3])
  _1107 = core::num::<impl u32>::wrapping_add(move _1108, move _1109) -> bb322
  using: _1108@Mir(bb320[1]), _1109@Mir(bb321[1])
bb322:
  _345 = move _1107
  using: _1107@Mir(bb321[2])
  _1117 = _21
  using: _21@Phi(bb112)
  _1120 = _6
  using: _6@Phi(bb127)
  _1121 = const 24_i32
  using: 
  _1122 = CheckedAdd(_1120, _1121)
  using: _1120@Mir(bb322[2]), _1121@Mir(bb322[3])
  assert(!move (_1122.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1120, move _1121) -> bb323
  using: _1122@Entry, _1120@Entry, _1121@Entry
bb323:
  _1119 = move (_1122.0: i32)
  using: _1122@Mir(bb322[4])
  _1118 = move _1119 as isize (IntToInt)
  using: _1119@Mir(bb323[0])
  _1116 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1117, move _1118) -> bb324
  using: _1117@Mir(bb322[1]), _1118@Mir(bb323[1])
bb324:
  _1115 = (*_1116)
  using: _1116@Mir(bb323[2])
  _346 = move _1115
  using: _1115@Mir(bb324[0])
  _1124 = _343
  using: _343@Mir(bb318[0])
  _1127 = _346
  using: _346@Mir(bb324[1])
  _1126 = move _1127 as usize (IntToInt)
  using: _1127@Mir(bb324[3])
  _1128 = const 258_usize
  using: 
  _1129 = Lt(_1126, _1128)
  using: _1126@Mir(bb324[4]), _1128@Mir(bb324[5])
  assert(move _1129, "index out of bounds: the length is {} but the index is {}", move _1128, _1126) -> bb325
  using: _1129@Entry, _1128@Entry, _1126@Entry
bb325:
  _1130 = const 0_usize
  using: 
  _1125 = ((*_1).38: [[u32; 4]; 258])[_1126][_1130]
  using: _1@Phi(bb119), _1130@Mir(bb325[0]), _1126@Mir(bb324[4])
  _1123 = core::num::<impl u32>::wrapping_add(move _1124, move _1125) -> bb326
  using: _1124@Mir(bb324[2]), _1125@Mir(bb325[1])
bb326:
  _343 = move _1123
  using: _1123@Mir(bb325[2])
  _1132 = _344
  using: _344@Mir(bb320[0])
  _1135 = _346
  using: _346@Mir(bb324[1])
  _1134 = move _1135 as usize (IntToInt)
  using: _1135@Mir(bb326[2])
  _1136 = const 258_usize
  using: 
  _1137 = Lt(_1134, _1136)
  using: _1134@Mir(bb326[3]), _1136@Mir(bb326[4])
  assert(move _1137, "index out of bounds: the length is {} but the index is {}", move _1136, _1134) -> bb327
  using: _1137@Entry, _1136@Entry, _1134@Entry
bb327:
  _1138 = const 1_usize
  using: 
  _1133 = ((*_1).38: [[u32; 4]; 258])[_1134][_1138]
  using: _1@Phi(bb119), _1138@Mir(bb327[0]), _1134@Mir(bb326[3])
  _1131 = core::num::<impl u32>::wrapping_add(move _1132, move _1133) -> bb328
  using: _1132@Mir(bb326[1]), _1133@Mir(bb327[1])
bb328:
  _344 = move _1131
  using: _1131@Mir(bb327[2])
  _1140 = _345
  using: _345@Mir(bb322[0])
  _1143 = _346
  using: _346@Mir(bb324[1])
  _1142 = move _1143 as usize (IntToInt)
  using: _1143@Mir(bb328[2])
  _1144 = const 258_usize
  using: 
  _1145 = Lt(_1142, _1144)
  using: _1142@Mir(bb328[3]), _1144@Mir(bb328[4])
  assert(move _1145, "index out of bounds: the length is {} but the index is {}", move _1144, _1142) -> bb329
  using: _1145@Entry, _1144@Entry, _1142@Entry
bb329:
  _1146 = const 2_usize
  using: 
  _1141 = ((*_1).38: [[u32; 4]; 258])[_1142][_1146]
  using: _1@Phi(bb119), _1146@Mir(bb329[0]), _1142@Mir(bb328[3])
  _1139 = core::num::<impl u32>::wrapping_add(move _1140, move _1141) -> bb330
  using: _1140@Mir(bb328[1]), _1141@Mir(bb329[1])
bb330:
  _345 = move _1139
  using: _1139@Mir(bb329[2])
  _1149 = _21
  using: _21@Phi(bb112)
  _1152 = _6
  using: _6@Phi(bb127)
  _1153 = const 25_i32
  using: 
  _1154 = CheckedAdd(_1152, _1153)
  using: _1152@Mir(bb330[2]), _1153@Mir(bb330[3])
  assert(!move (_1154.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1152, move _1153) -> bb331
  using: _1154@Entry, _1152@Entry, _1153@Entry
bb331:
  _1151 = move (_1154.0: i32)
  using: _1154@Mir(bb330[4])
  _1150 = move _1151 as isize (IntToInt)
  using: _1151@Mir(bb331[0])
  _1148 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1149, move _1150) -> bb332
  using: _1149@Mir(bb330[1]), _1150@Mir(bb331[1])
bb332:
  _1147 = (*_1148)
  using: _1148@Mir(bb331[2])
  _346 = move _1147
  using: _1147@Mir(bb332[0])
  _1156 = _343
  using: _343@Mir(bb326[0])
  _1159 = _346
  using: _346@Mir(bb332[1])
  _1158 = move _1159 as usize (IntToInt)
  using: _1159@Mir(bb332[3])
  _1160 = const 258_usize
  using: 
  _1161 = Lt(_1158, _1160)
  using: _1158@Mir(bb332[4]), _1160@Mir(bb332[5])
  assert(move _1161, "index out of bounds: the length is {} but the index is {}", move _1160, _1158) -> bb333
  using: _1161@Entry, _1160@Entry, _1158@Entry
bb333:
  _1162 = const 0_usize
  using: 
  _1157 = ((*_1).38: [[u32; 4]; 258])[_1158][_1162]
  using: _1@Phi(bb119), _1162@Mir(bb333[0]), _1158@Mir(bb332[4])
  _1155 = core::num::<impl u32>::wrapping_add(move _1156, move _1157) -> bb334
  using: _1156@Mir(bb332[2]), _1157@Mir(bb333[1])
bb334:
  _343 = move _1155
  using: _1155@Mir(bb333[2])
  _1164 = _344
  using: _344@Mir(bb328[0])
  _1167 = _346
  using: _346@Mir(bb332[1])
  _1166 = move _1167 as usize (IntToInt)
  using: _1167@Mir(bb334[2])
  _1168 = const 258_usize
  using: 
  _1169 = Lt(_1166, _1168)
  using: _1166@Mir(bb334[3]), _1168@Mir(bb334[4])
  assert(move _1169, "index out of bounds: the length is {} but the index is {}", move _1168, _1166) -> bb335
  using: _1169@Entry, _1168@Entry, _1166@Entry
bb335:
  _1170 = const 1_usize
  using: 
  _1165 = ((*_1).38: [[u32; 4]; 258])[_1166][_1170]
  using: _1@Phi(bb119), _1170@Mir(bb335[0]), _1166@Mir(bb334[3])
  _1163 = core::num::<impl u32>::wrapping_add(move _1164, move _1165) -> bb336
  using: _1164@Mir(bb334[1]), _1165@Mir(bb335[1])
bb336:
  _344 = move _1163
  using: _1163@Mir(bb335[2])
  _1172 = _345
  using: _345@Mir(bb330[0])
  _1175 = _346
  using: _346@Mir(bb332[1])
  _1174 = move _1175 as usize (IntToInt)
  using: _1175@Mir(bb336[2])
  _1176 = const 258_usize
  using: 
  _1177 = Lt(_1174, _1176)
  using: _1174@Mir(bb336[3]), _1176@Mir(bb336[4])
  assert(move _1177, "index out of bounds: the length is {} but the index is {}", move _1176, _1174) -> bb337
  using: _1177@Entry, _1176@Entry, _1174@Entry
bb337:
  _1178 = const 2_usize
  using: 
  _1173 = ((*_1).38: [[u32; 4]; 258])[_1174][_1178]
  using: _1@Phi(bb119), _1178@Mir(bb337[0]), _1174@Mir(bb336[3])
  _1171 = core::num::<impl u32>::wrapping_add(move _1172, move _1173) -> bb338
  using: _1172@Mir(bb336[1]), _1173@Mir(bb337[1])
bb338:
  _345 = move _1171
  using: _1171@Mir(bb337[2])
  _1181 = _21
  using: _21@Phi(bb112)
  _1184 = _6
  using: _6@Phi(bb127)
  _1185 = const 26_i32
  using: 
  _1186 = CheckedAdd(_1184, _1185)
  using: _1184@Mir(bb338[2]), _1185@Mir(bb338[3])
  assert(!move (_1186.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1184, move _1185) -> bb339
  using: _1186@Entry, _1184@Entry, _1185@Entry
bb339:
  _1183 = move (_1186.0: i32)
  using: _1186@Mir(bb338[4])
  _1182 = move _1183 as isize (IntToInt)
  using: _1183@Mir(bb339[0])
  _1180 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1181, move _1182) -> bb340
  using: _1181@Mir(bb338[1]), _1182@Mir(bb339[1])
bb340:
  _1179 = (*_1180)
  using: _1180@Mir(bb339[2])
  _346 = move _1179
  using: _1179@Mir(bb340[0])
  _1188 = _343
  using: _343@Mir(bb334[0])
  _1191 = _346
  using: _346@Mir(bb340[1])
  _1190 = move _1191 as usize (IntToInt)
  using: _1191@Mir(bb340[3])
  _1192 = const 258_usize
  using: 
  _1193 = Lt(_1190, _1192)
  using: _1190@Mir(bb340[4]), _1192@Mir(bb340[5])
  assert(move _1193, "index out of bounds: the length is {} but the index is {}", move _1192, _1190) -> bb341
  using: _1193@Entry, _1192@Entry, _1190@Entry
bb341:
  _1194 = const 0_usize
  using: 
  _1189 = ((*_1).38: [[u32; 4]; 258])[_1190][_1194]
  using: _1@Phi(bb119), _1194@Mir(bb341[0]), _1190@Mir(bb340[4])
  _1187 = core::num::<impl u32>::wrapping_add(move _1188, move _1189) -> bb342
  using: _1188@Mir(bb340[2]), _1189@Mir(bb341[1])
bb342:
  _343 = move _1187
  using: _1187@Mir(bb341[2])
  _1196 = _344
  using: _344@Mir(bb336[0])
  _1199 = _346
  using: _346@Mir(bb340[1])
  _1198 = move _1199 as usize (IntToInt)
  using: _1199@Mir(bb342[2])
  _1200 = const 258_usize
  using: 
  _1201 = Lt(_1198, _1200)
  using: _1198@Mir(bb342[3]), _1200@Mir(bb342[4])
  assert(move _1201, "index out of bounds: the length is {} but the index is {}", move _1200, _1198) -> bb343
  using: _1201@Entry, _1200@Entry, _1198@Entry
bb343:
  _1202 = const 1_usize
  using: 
  _1197 = ((*_1).38: [[u32; 4]; 258])[_1198][_1202]
  using: _1@Phi(bb119), _1202@Mir(bb343[0]), _1198@Mir(bb342[3])
  _1195 = core::num::<impl u32>::wrapping_add(move _1196, move _1197) -> bb344
  using: _1196@Mir(bb342[1]), _1197@Mir(bb343[1])
bb344:
  _344 = move _1195
  using: _1195@Mir(bb343[2])
  _1204 = _345
  using: _345@Mir(bb338[0])
  _1207 = _346
  using: _346@Mir(bb340[1])
  _1206 = move _1207 as usize (IntToInt)
  using: _1207@Mir(bb344[2])
  _1208 = const 258_usize
  using: 
  _1209 = Lt(_1206, _1208)
  using: _1206@Mir(bb344[3]), _1208@Mir(bb344[4])
  assert(move _1209, "index out of bounds: the length is {} but the index is {}", move _1208, _1206) -> bb345
  using: _1209@Entry, _1208@Entry, _1206@Entry
bb345:
  _1210 = const 2_usize
  using: 
  _1205 = ((*_1).38: [[u32; 4]; 258])[_1206][_1210]
  using: _1@Phi(bb119), _1210@Mir(bb345[0]), _1206@Mir(bb344[3])
  _1203 = core::num::<impl u32>::wrapping_add(move _1204, move _1205) -> bb346
  using: _1204@Mir(bb344[1]), _1205@Mir(bb345[1])
bb346:
  _345 = move _1203
  using: _1203@Mir(bb345[2])
  _1213 = _21
  using: _21@Phi(bb112)
  _1216 = _6
  using: _6@Phi(bb127)
  _1217 = const 27_i32
  using: 
  _1218 = CheckedAdd(_1216, _1217)
  using: _1216@Mir(bb346[2]), _1217@Mir(bb346[3])
  assert(!move (_1218.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1216, move _1217) -> bb347
  using: _1218@Entry, _1216@Entry, _1217@Entry
bb347:
  _1215 = move (_1218.0: i32)
  using: _1218@Mir(bb346[4])
  _1214 = move _1215 as isize (IntToInt)
  using: _1215@Mir(bb347[0])
  _1212 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1213, move _1214) -> bb348
  using: _1213@Mir(bb346[1]), _1214@Mir(bb347[1])
bb348:
  _1211 = (*_1212)
  using: _1212@Mir(bb347[2])
  _346 = move _1211
  using: _1211@Mir(bb348[0])
  _1220 = _343
  using: _343@Mir(bb342[0])
  _1223 = _346
  using: _346@Mir(bb348[1])
  _1222 = move _1223 as usize (IntToInt)
  using: _1223@Mir(bb348[3])
  _1224 = const 258_usize
  using: 
  _1225 = Lt(_1222, _1224)
  using: _1222@Mir(bb348[4]), _1224@Mir(bb348[5])
  assert(move _1225, "index out of bounds: the length is {} but the index is {}", move _1224, _1222) -> bb349
  using: _1225@Entry, _1224@Entry, _1222@Entry
bb349:
  _1226 = const 0_usize
  using: 
  _1221 = ((*_1).38: [[u32; 4]; 258])[_1222][_1226]
  using: _1@Phi(bb119), _1226@Mir(bb349[0]), _1222@Mir(bb348[4])
  _1219 = core::num::<impl u32>::wrapping_add(move _1220, move _1221) -> bb350
  using: _1220@Mir(bb348[2]), _1221@Mir(bb349[1])
bb350:
  _343 = move _1219
  using: _1219@Mir(bb349[2])
  _1228 = _344
  using: _344@Mir(bb344[0])
  _1231 = _346
  using: _346@Mir(bb348[1])
  _1230 = move _1231 as usize (IntToInt)
  using: _1231@Mir(bb350[2])
  _1232 = const 258_usize
  using: 
  _1233 = Lt(_1230, _1232)
  using: _1230@Mir(bb350[3]), _1232@Mir(bb350[4])
  assert(move _1233, "index out of bounds: the length is {} but the index is {}", move _1232, _1230) -> bb351
  using: _1233@Entry, _1232@Entry, _1230@Entry
bb351:
  _1234 = const 1_usize
  using: 
  _1229 = ((*_1).38: [[u32; 4]; 258])[_1230][_1234]
  using: _1@Phi(bb119), _1234@Mir(bb351[0]), _1230@Mir(bb350[3])
  _1227 = core::num::<impl u32>::wrapping_add(move _1228, move _1229) -> bb352
  using: _1228@Mir(bb350[1]), _1229@Mir(bb351[1])
bb352:
  _344 = move _1227
  using: _1227@Mir(bb351[2])
  _1236 = _345
  using: _345@Mir(bb346[0])
  _1239 = _346
  using: _346@Mir(bb348[1])
  _1238 = move _1239 as usize (IntToInt)
  using: _1239@Mir(bb352[2])
  _1240 = const 258_usize
  using: 
  _1241 = Lt(_1238, _1240)
  using: _1238@Mir(bb352[3]), _1240@Mir(bb352[4])
  assert(move _1241, "index out of bounds: the length is {} but the index is {}", move _1240, _1238) -> bb353
  using: _1241@Entry, _1240@Entry, _1238@Entry
bb353:
  _1242 = const 2_usize
  using: 
  _1237 = ((*_1).38: [[u32; 4]; 258])[_1238][_1242]
  using: _1@Phi(bb119), _1242@Mir(bb353[0]), _1238@Mir(bb352[3])
  _1235 = core::num::<impl u32>::wrapping_add(move _1236, move _1237) -> bb354
  using: _1236@Mir(bb352[1]), _1237@Mir(bb353[1])
bb354:
  _345 = move _1235
  using: _1235@Mir(bb353[2])
  _1245 = _21
  using: _21@Phi(bb112)
  _1248 = _6
  using: _6@Phi(bb127)
  _1249 = const 28_i32
  using: 
  _1250 = CheckedAdd(_1248, _1249)
  using: _1248@Mir(bb354[2]), _1249@Mir(bb354[3])
  assert(!move (_1250.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1248, move _1249) -> bb355
  using: _1250@Entry, _1248@Entry, _1249@Entry
bb355:
  _1247 = move (_1250.0: i32)
  using: _1250@Mir(bb354[4])
  _1246 = move _1247 as isize (IntToInt)
  using: _1247@Mir(bb355[0])
  _1244 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1245, move _1246) -> bb356
  using: _1245@Mir(bb354[1]), _1246@Mir(bb355[1])
bb356:
  _1243 = (*_1244)
  using: _1244@Mir(bb355[2])
  _346 = move _1243
  using: _1243@Mir(bb356[0])
  _1252 = _343
  using: _343@Mir(bb350[0])
  _1255 = _346
  using: _346@Mir(bb356[1])
  _1254 = move _1255 as usize (IntToInt)
  using: _1255@Mir(bb356[3])
  _1256 = const 258_usize
  using: 
  _1257 = Lt(_1254, _1256)
  using: _1254@Mir(bb356[4]), _1256@Mir(bb356[5])
  assert(move _1257, "index out of bounds: the length is {} but the index is {}", move _1256, _1254) -> bb357
  using: _1257@Entry, _1256@Entry, _1254@Entry
bb357:
  _1258 = const 0_usize
  using: 
  _1253 = ((*_1).38: [[u32; 4]; 258])[_1254][_1258]
  using: _1@Phi(bb119), _1258@Mir(bb357[0]), _1254@Mir(bb356[4])
  _1251 = core::num::<impl u32>::wrapping_add(move _1252, move _1253) -> bb358
  using: _1252@Mir(bb356[2]), _1253@Mir(bb357[1])
bb358:
  _343 = move _1251
  using: _1251@Mir(bb357[2])
  _1260 = _344
  using: _344@Mir(bb352[0])
  _1263 = _346
  using: _346@Mir(bb356[1])
  _1262 = move _1263 as usize (IntToInt)
  using: _1263@Mir(bb358[2])
  _1264 = const 258_usize
  using: 
  _1265 = Lt(_1262, _1264)
  using: _1262@Mir(bb358[3]), _1264@Mir(bb358[4])
  assert(move _1265, "index out of bounds: the length is {} but the index is {}", move _1264, _1262) -> bb359
  using: _1265@Entry, _1264@Entry, _1262@Entry
bb359:
  _1266 = const 1_usize
  using: 
  _1261 = ((*_1).38: [[u32; 4]; 258])[_1262][_1266]
  using: _1@Phi(bb119), _1266@Mir(bb359[0]), _1262@Mir(bb358[3])
  _1259 = core::num::<impl u32>::wrapping_add(move _1260, move _1261) -> bb360
  using: _1260@Mir(bb358[1]), _1261@Mir(bb359[1])
bb360:
  _344 = move _1259
  using: _1259@Mir(bb359[2])
  _1268 = _345
  using: _345@Mir(bb354[0])
  _1271 = _346
  using: _346@Mir(bb356[1])
  _1270 = move _1271 as usize (IntToInt)
  using: _1271@Mir(bb360[2])
  _1272 = const 258_usize
  using: 
  _1273 = Lt(_1270, _1272)
  using: _1270@Mir(bb360[3]), _1272@Mir(bb360[4])
  assert(move _1273, "index out of bounds: the length is {} but the index is {}", move _1272, _1270) -> bb361
  using: _1273@Entry, _1272@Entry, _1270@Entry
bb361:
  _1274 = const 2_usize
  using: 
  _1269 = ((*_1).38: [[u32; 4]; 258])[_1270][_1274]
  using: _1@Phi(bb119), _1274@Mir(bb361[0]), _1270@Mir(bb360[3])
  _1267 = core::num::<impl u32>::wrapping_add(move _1268, move _1269) -> bb362
  using: _1268@Mir(bb360[1]), _1269@Mir(bb361[1])
bb362:
  _345 = move _1267
  using: _1267@Mir(bb361[2])
  _1277 = _21
  using: _21@Phi(bb112)
  _1280 = _6
  using: _6@Phi(bb127)
  _1281 = const 29_i32
  using: 
  _1282 = CheckedAdd(_1280, _1281)
  using: _1280@Mir(bb362[2]), _1281@Mir(bb362[3])
  assert(!move (_1282.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1280, move _1281) -> bb363
  using: _1282@Entry, _1280@Entry, _1281@Entry
bb363:
  _1279 = move (_1282.0: i32)
  using: _1282@Mir(bb362[4])
  _1278 = move _1279 as isize (IntToInt)
  using: _1279@Mir(bb363[0])
  _1276 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1277, move _1278) -> bb364
  using: _1277@Mir(bb362[1]), _1278@Mir(bb363[1])
bb364:
  _1275 = (*_1276)
  using: _1276@Mir(bb363[2])
  _346 = move _1275
  using: _1275@Mir(bb364[0])
  _1284 = _343
  using: _343@Mir(bb358[0])
  _1287 = _346
  using: _346@Mir(bb364[1])
  _1286 = move _1287 as usize (IntToInt)
  using: _1287@Mir(bb364[3])
  _1288 = const 258_usize
  using: 
  _1289 = Lt(_1286, _1288)
  using: _1286@Mir(bb364[4]), _1288@Mir(bb364[5])
  assert(move _1289, "index out of bounds: the length is {} but the index is {}", move _1288, _1286) -> bb365
  using: _1289@Entry, _1288@Entry, _1286@Entry
bb365:
  _1290 = const 0_usize
  using: 
  _1285 = ((*_1).38: [[u32; 4]; 258])[_1286][_1290]
  using: _1@Phi(bb119), _1290@Mir(bb365[0]), _1286@Mir(bb364[4])
  _1283 = core::num::<impl u32>::wrapping_add(move _1284, move _1285) -> bb366
  using: _1284@Mir(bb364[2]), _1285@Mir(bb365[1])
bb366:
  _343 = move _1283
  using: _1283@Mir(bb365[2])
  _1292 = _344
  using: _344@Mir(bb360[0])
  _1295 = _346
  using: _346@Mir(bb364[1])
  _1294 = move _1295 as usize (IntToInt)
  using: _1295@Mir(bb366[2])
  _1296 = const 258_usize
  using: 
  _1297 = Lt(_1294, _1296)
  using: _1294@Mir(bb366[3]), _1296@Mir(bb366[4])
  assert(move _1297, "index out of bounds: the length is {} but the index is {}", move _1296, _1294) -> bb367
  using: _1297@Entry, _1296@Entry, _1294@Entry
bb367:
  _1298 = const 1_usize
  using: 
  _1293 = ((*_1).38: [[u32; 4]; 258])[_1294][_1298]
  using: _1@Phi(bb119), _1298@Mir(bb367[0]), _1294@Mir(bb366[3])
  _1291 = core::num::<impl u32>::wrapping_add(move _1292, move _1293) -> bb368
  using: _1292@Mir(bb366[1]), _1293@Mir(bb367[1])
bb368:
  _344 = move _1291
  using: _1291@Mir(bb367[2])
  _1300 = _345
  using: _345@Mir(bb362[0])
  _1303 = _346
  using: _346@Mir(bb364[1])
  _1302 = move _1303 as usize (IntToInt)
  using: _1303@Mir(bb368[2])
  _1304 = const 258_usize
  using: 
  _1305 = Lt(_1302, _1304)
  using: _1302@Mir(bb368[3]), _1304@Mir(bb368[4])
  assert(move _1305, "index out of bounds: the length is {} but the index is {}", move _1304, _1302) -> bb369
  using: _1305@Entry, _1304@Entry, _1302@Entry
bb369:
  _1306 = const 2_usize
  using: 
  _1301 = ((*_1).38: [[u32; 4]; 258])[_1302][_1306]
  using: _1@Phi(bb119), _1306@Mir(bb369[0]), _1302@Mir(bb368[3])
  _1299 = core::num::<impl u32>::wrapping_add(move _1300, move _1301) -> bb370
  using: _1300@Mir(bb368[1]), _1301@Mir(bb369[1])
bb370:
  _345 = move _1299
  using: _1299@Mir(bb369[2])
  _1309 = _21
  using: _21@Phi(bb112)
  _1312 = _6
  using: _6@Phi(bb127)
  _1313 = const 30_i32
  using: 
  _1314 = CheckedAdd(_1312, _1313)
  using: _1312@Mir(bb370[2]), _1313@Mir(bb370[3])
  assert(!move (_1314.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1312, move _1313) -> bb371
  using: _1314@Entry, _1312@Entry, _1313@Entry
bb371:
  _1311 = move (_1314.0: i32)
  using: _1314@Mir(bb370[4])
  _1310 = move _1311 as isize (IntToInt)
  using: _1311@Mir(bb371[0])
  _1308 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1309, move _1310) -> bb372
  using: _1309@Mir(bb370[1]), _1310@Mir(bb371[1])
bb372:
  _1307 = (*_1308)
  using: _1308@Mir(bb371[2])
  _346 = move _1307
  using: _1307@Mir(bb372[0])
  _1316 = _343
  using: _343@Mir(bb366[0])
  _1319 = _346
  using: _346@Mir(bb372[1])
  _1318 = move _1319 as usize (IntToInt)
  using: _1319@Mir(bb372[3])
  _1320 = const 258_usize
  using: 
  _1321 = Lt(_1318, _1320)
  using: _1318@Mir(bb372[4]), _1320@Mir(bb372[5])
  assert(move _1321, "index out of bounds: the length is {} but the index is {}", move _1320, _1318) -> bb373
  using: _1321@Entry, _1320@Entry, _1318@Entry
bb373:
  _1322 = const 0_usize
  using: 
  _1317 = ((*_1).38: [[u32; 4]; 258])[_1318][_1322]
  using: _1@Phi(bb119), _1322@Mir(bb373[0]), _1318@Mir(bb372[4])
  _1315 = core::num::<impl u32>::wrapping_add(move _1316, move _1317) -> bb374
  using: _1316@Mir(bb372[2]), _1317@Mir(bb373[1])
bb374:
  _343 = move _1315
  using: _1315@Mir(bb373[2])
  _1324 = _344
  using: _344@Mir(bb368[0])
  _1327 = _346
  using: _346@Mir(bb372[1])
  _1326 = move _1327 as usize (IntToInt)
  using: _1327@Mir(bb374[2])
  _1328 = const 258_usize
  using: 
  _1329 = Lt(_1326, _1328)
  using: _1326@Mir(bb374[3]), _1328@Mir(bb374[4])
  assert(move _1329, "index out of bounds: the length is {} but the index is {}", move _1328, _1326) -> bb375
  using: _1329@Entry, _1328@Entry, _1326@Entry
bb375:
  _1330 = const 1_usize
  using: 
  _1325 = ((*_1).38: [[u32; 4]; 258])[_1326][_1330]
  using: _1@Phi(bb119), _1330@Mir(bb375[0]), _1326@Mir(bb374[3])
  _1323 = core::num::<impl u32>::wrapping_add(move _1324, move _1325) -> bb376
  using: _1324@Mir(bb374[1]), _1325@Mir(bb375[1])
bb376:
  _344 = move _1323
  using: _1323@Mir(bb375[2])
  _1332 = _345
  using: _345@Mir(bb370[0])
  _1335 = _346
  using: _346@Mir(bb372[1])
  _1334 = move _1335 as usize (IntToInt)
  using: _1335@Mir(bb376[2])
  _1336 = const 258_usize
  using: 
  _1337 = Lt(_1334, _1336)
  using: _1334@Mir(bb376[3]), _1336@Mir(bb376[4])
  assert(move _1337, "index out of bounds: the length is {} but the index is {}", move _1336, _1334) -> bb377
  using: _1337@Entry, _1336@Entry, _1334@Entry
bb377:
  _1338 = const 2_usize
  using: 
  _1333 = ((*_1).38: [[u32; 4]; 258])[_1334][_1338]
  using: _1@Phi(bb119), _1338@Mir(bb377[0]), _1334@Mir(bb376[3])
  _1331 = core::num::<impl u32>::wrapping_add(move _1332, move _1333) -> bb378
  using: _1332@Mir(bb376[1]), _1333@Mir(bb377[1])
bb378:
  _345 = move _1331
  using: _1331@Mir(bb377[2])
  _1341 = _21
  using: _21@Phi(bb112)
  _1344 = _6
  using: _6@Phi(bb127)
  _1345 = const 31_i32
  using: 
  _1346 = CheckedAdd(_1344, _1345)
  using: _1344@Mir(bb378[2]), _1345@Mir(bb378[3])
  assert(!move (_1346.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1344, move _1345) -> bb379
  using: _1346@Entry, _1344@Entry, _1345@Entry
bb379:
  _1343 = move (_1346.0: i32)
  using: _1346@Mir(bb378[4])
  _1342 = move _1343 as isize (IntToInt)
  using: _1343@Mir(bb379[0])
  _1340 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1341, move _1342) -> bb380
  using: _1341@Mir(bb378[1]), _1342@Mir(bb379[1])
bb380:
  _1339 = (*_1340)
  using: _1340@Mir(bb379[2])
  _346 = move _1339
  using: _1339@Mir(bb380[0])
  _1348 = _343
  using: _343@Mir(bb374[0])
  _1351 = _346
  using: _346@Mir(bb380[1])
  _1350 = move _1351 as usize (IntToInt)
  using: _1351@Mir(bb380[3])
  _1352 = const 258_usize
  using: 
  _1353 = Lt(_1350, _1352)
  using: _1350@Mir(bb380[4]), _1352@Mir(bb380[5])
  assert(move _1353, "index out of bounds: the length is {} but the index is {}", move _1352, _1350) -> bb381
  using: _1353@Entry, _1352@Entry, _1350@Entry
bb381:
  _1354 = const 0_usize
  using: 
  _1349 = ((*_1).38: [[u32; 4]; 258])[_1350][_1354]
  using: _1@Phi(bb119), _1354@Mir(bb381[0]), _1350@Mir(bb380[4])
  _1347 = core::num::<impl u32>::wrapping_add(move _1348, move _1349) -> bb382
  using: _1348@Mir(bb380[2]), _1349@Mir(bb381[1])
bb382:
  _343 = move _1347
  using: _1347@Mir(bb381[2])
  _1356 = _344
  using: _344@Mir(bb376[0])
  _1359 = _346
  using: _346@Mir(bb380[1])
  _1358 = move _1359 as usize (IntToInt)
  using: _1359@Mir(bb382[2])
  _1360 = const 258_usize
  using: 
  _1361 = Lt(_1358, _1360)
  using: _1358@Mir(bb382[3]), _1360@Mir(bb382[4])
  assert(move _1361, "index out of bounds: the length is {} but the index is {}", move _1360, _1358) -> bb383
  using: _1361@Entry, _1360@Entry, _1358@Entry
bb383:
  _1362 = const 1_usize
  using: 
  _1357 = ((*_1).38: [[u32; 4]; 258])[_1358][_1362]
  using: _1@Phi(bb119), _1362@Mir(bb383[0]), _1358@Mir(bb382[3])
  _1355 = core::num::<impl u32>::wrapping_add(move _1356, move _1357) -> bb384
  using: _1356@Mir(bb382[1]), _1357@Mir(bb383[1])
bb384:
  _344 = move _1355
  using: _1355@Mir(bb383[2])
  _1364 = _345
  using: _345@Mir(bb378[0])
  _1367 = _346
  using: _346@Mir(bb380[1])
  _1366 = move _1367 as usize (IntToInt)
  using: _1367@Mir(bb384[2])
  _1368 = const 258_usize
  using: 
  _1369 = Lt(_1366, _1368)
  using: _1366@Mir(bb384[3]), _1368@Mir(bb384[4])
  assert(move _1369, "index out of bounds: the length is {} but the index is {}", move _1368, _1366) -> bb385
  using: _1369@Entry, _1368@Entry, _1366@Entry
bb385:
  _1370 = const 2_usize
  using: 
  _1365 = ((*_1).38: [[u32; 4]; 258])[_1366][_1370]
  using: _1@Phi(bb119), _1370@Mir(bb385[0]), _1366@Mir(bb384[3])
  _1363 = core::num::<impl u32>::wrapping_add(move _1364, move _1365) -> bb386
  using: _1364@Mir(bb384[1]), _1365@Mir(bb385[1])
bb386:
  _345 = move _1363
  using: _1363@Mir(bb385[2])
  _1373 = _21
  using: _21@Phi(bb112)
  _1376 = _6
  using: _6@Phi(bb127)
  _1377 = const 32_i32
  using: 
  _1378 = CheckedAdd(_1376, _1377)
  using: _1376@Mir(bb386[2]), _1377@Mir(bb386[3])
  assert(!move (_1378.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1376, move _1377) -> bb387
  using: _1378@Entry, _1376@Entry, _1377@Entry
bb387:
  _1375 = move (_1378.0: i32)
  using: _1378@Mir(bb386[4])
  _1374 = move _1375 as isize (IntToInt)
  using: _1375@Mir(bb387[0])
  _1372 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1373, move _1374) -> bb388
  using: _1373@Mir(bb386[1]), _1374@Mir(bb387[1])
bb388:
  _1371 = (*_1372)
  using: _1372@Mir(bb387[2])
  _346 = move _1371
  using: _1371@Mir(bb388[0])
  _1380 = _343
  using: _343@Mir(bb382[0])
  _1383 = _346
  using: _346@Mir(bb388[1])
  _1382 = move _1383 as usize (IntToInt)
  using: _1383@Mir(bb388[3])
  _1384 = const 258_usize
  using: 
  _1385 = Lt(_1382, _1384)
  using: _1382@Mir(bb388[4]), _1384@Mir(bb388[5])
  assert(move _1385, "index out of bounds: the length is {} but the index is {}", move _1384, _1382) -> bb389
  using: _1385@Entry, _1384@Entry, _1382@Entry
bb389:
  _1386 = const 0_usize
  using: 
  _1381 = ((*_1).38: [[u32; 4]; 258])[_1382][_1386]
  using: _1@Phi(bb119), _1386@Mir(bb389[0]), _1382@Mir(bb388[4])
  _1379 = core::num::<impl u32>::wrapping_add(move _1380, move _1381) -> bb390
  using: _1380@Mir(bb388[2]), _1381@Mir(bb389[1])
bb390:
  _343 = move _1379
  using: _1379@Mir(bb389[2])
  _1388 = _344
  using: _344@Mir(bb384[0])
  _1391 = _346
  using: _346@Mir(bb388[1])
  _1390 = move _1391 as usize (IntToInt)
  using: _1391@Mir(bb390[2])
  _1392 = const 258_usize
  using: 
  _1393 = Lt(_1390, _1392)
  using: _1390@Mir(bb390[3]), _1392@Mir(bb390[4])
  assert(move _1393, "index out of bounds: the length is {} but the index is {}", move _1392, _1390) -> bb391
  using: _1393@Entry, _1392@Entry, _1390@Entry
bb391:
  _1394 = const 1_usize
  using: 
  _1389 = ((*_1).38: [[u32; 4]; 258])[_1390][_1394]
  using: _1@Phi(bb119), _1394@Mir(bb391[0]), _1390@Mir(bb390[3])
  _1387 = core::num::<impl u32>::wrapping_add(move _1388, move _1389) -> bb392
  using: _1388@Mir(bb390[1]), _1389@Mir(bb391[1])
bb392:
  _344 = move _1387
  using: _1387@Mir(bb391[2])
  _1396 = _345
  using: _345@Mir(bb386[0])
  _1399 = _346
  using: _346@Mir(bb388[1])
  _1398 = move _1399 as usize (IntToInt)
  using: _1399@Mir(bb392[2])
  _1400 = const 258_usize
  using: 
  _1401 = Lt(_1398, _1400)
  using: _1398@Mir(bb392[3]), _1400@Mir(bb392[4])
  assert(move _1401, "index out of bounds: the length is {} but the index is {}", move _1400, _1398) -> bb393
  using: _1401@Entry, _1400@Entry, _1398@Entry
bb393:
  _1402 = const 2_usize
  using: 
  _1397 = ((*_1).38: [[u32; 4]; 258])[_1398][_1402]
  using: _1@Phi(bb119), _1402@Mir(bb393[0]), _1398@Mir(bb392[3])
  _1395 = core::num::<impl u32>::wrapping_add(move _1396, move _1397) -> bb394
  using: _1396@Mir(bb392[1]), _1397@Mir(bb393[1])
bb394:
  _345 = move _1395
  using: _1395@Mir(bb393[2])
  _1405 = _21
  using: _21@Phi(bb112)
  _1408 = _6
  using: _6@Phi(bb127)
  _1409 = const 33_i32
  using: 
  _1410 = CheckedAdd(_1408, _1409)
  using: _1408@Mir(bb394[2]), _1409@Mir(bb394[3])
  assert(!move (_1410.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1408, move _1409) -> bb395
  using: _1410@Entry, _1408@Entry, _1409@Entry
bb395:
  _1407 = move (_1410.0: i32)
  using: _1410@Mir(bb394[4])
  _1406 = move _1407 as isize (IntToInt)
  using: _1407@Mir(bb395[0])
  _1404 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1405, move _1406) -> bb396
  using: _1405@Mir(bb394[1]), _1406@Mir(bb395[1])
bb396:
  _1403 = (*_1404)
  using: _1404@Mir(bb395[2])
  _346 = move _1403
  using: _1403@Mir(bb396[0])
  _1412 = _343
  using: _343@Mir(bb390[0])
  _1415 = _346
  using: _346@Mir(bb396[1])
  _1414 = move _1415 as usize (IntToInt)
  using: _1415@Mir(bb396[3])
  _1416 = const 258_usize
  using: 
  _1417 = Lt(_1414, _1416)
  using: _1414@Mir(bb396[4]), _1416@Mir(bb396[5])
  assert(move _1417, "index out of bounds: the length is {} but the index is {}", move _1416, _1414) -> bb397
  using: _1417@Entry, _1416@Entry, _1414@Entry
bb397:
  _1418 = const 0_usize
  using: 
  _1413 = ((*_1).38: [[u32; 4]; 258])[_1414][_1418]
  using: _1@Phi(bb119), _1418@Mir(bb397[0]), _1414@Mir(bb396[4])
  _1411 = core::num::<impl u32>::wrapping_add(move _1412, move _1413) -> bb398
  using: _1412@Mir(bb396[2]), _1413@Mir(bb397[1])
bb398:
  _343 = move _1411
  using: _1411@Mir(bb397[2])
  _1420 = _344
  using: _344@Mir(bb392[0])
  _1423 = _346
  using: _346@Mir(bb396[1])
  _1422 = move _1423 as usize (IntToInt)
  using: _1423@Mir(bb398[2])
  _1424 = const 258_usize
  using: 
  _1425 = Lt(_1422, _1424)
  using: _1422@Mir(bb398[3]), _1424@Mir(bb398[4])
  assert(move _1425, "index out of bounds: the length is {} but the index is {}", move _1424, _1422) -> bb399
  using: _1425@Entry, _1424@Entry, _1422@Entry
bb399:
  _1426 = const 1_usize
  using: 
  _1421 = ((*_1).38: [[u32; 4]; 258])[_1422][_1426]
  using: _1@Phi(bb119), _1426@Mir(bb399[0]), _1422@Mir(bb398[3])
  _1419 = core::num::<impl u32>::wrapping_add(move _1420, move _1421) -> bb400
  using: _1420@Mir(bb398[1]), _1421@Mir(bb399[1])
bb400:
  _344 = move _1419
  using: _1419@Mir(bb399[2])
  _1428 = _345
  using: _345@Mir(bb394[0])
  _1431 = _346
  using: _346@Mir(bb396[1])
  _1430 = move _1431 as usize (IntToInt)
  using: _1431@Mir(bb400[2])
  _1432 = const 258_usize
  using: 
  _1433 = Lt(_1430, _1432)
  using: _1430@Mir(bb400[3]), _1432@Mir(bb400[4])
  assert(move _1433, "index out of bounds: the length is {} but the index is {}", move _1432, _1430) -> bb401
  using: _1433@Entry, _1432@Entry, _1430@Entry
bb401:
  _1434 = const 2_usize
  using: 
  _1429 = ((*_1).38: [[u32; 4]; 258])[_1430][_1434]
  using: _1@Phi(bb119), _1434@Mir(bb401[0]), _1430@Mir(bb400[3])
  _1427 = core::num::<impl u32>::wrapping_add(move _1428, move _1429) -> bb402
  using: _1428@Mir(bb400[1]), _1429@Mir(bb401[1])
bb402:
  _345 = move _1427
  using: _1427@Mir(bb401[2])
  _1437 = _21
  using: _21@Phi(bb112)
  _1440 = _6
  using: _6@Phi(bb127)
  _1441 = const 34_i32
  using: 
  _1442 = CheckedAdd(_1440, _1441)
  using: _1440@Mir(bb402[2]), _1441@Mir(bb402[3])
  assert(!move (_1442.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1440, move _1441) -> bb403
  using: _1442@Entry, _1440@Entry, _1441@Entry
bb403:
  _1439 = move (_1442.0: i32)
  using: _1442@Mir(bb402[4])
  _1438 = move _1439 as isize (IntToInt)
  using: _1439@Mir(bb403[0])
  _1436 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1437, move _1438) -> bb404
  using: _1437@Mir(bb402[1]), _1438@Mir(bb403[1])
bb404:
  _1435 = (*_1436)
  using: _1436@Mir(bb403[2])
  _346 = move _1435
  using: _1435@Mir(bb404[0])
  _1444 = _343
  using: _343@Mir(bb398[0])
  _1447 = _346
  using: _346@Mir(bb404[1])
  _1446 = move _1447 as usize (IntToInt)
  using: _1447@Mir(bb404[3])
  _1448 = const 258_usize
  using: 
  _1449 = Lt(_1446, _1448)
  using: _1446@Mir(bb404[4]), _1448@Mir(bb404[5])
  assert(move _1449, "index out of bounds: the length is {} but the index is {}", move _1448, _1446) -> bb405
  using: _1449@Entry, _1448@Entry, _1446@Entry
bb405:
  _1450 = const 0_usize
  using: 
  _1445 = ((*_1).38: [[u32; 4]; 258])[_1446][_1450]
  using: _1@Phi(bb119), _1450@Mir(bb405[0]), _1446@Mir(bb404[4])
  _1443 = core::num::<impl u32>::wrapping_add(move _1444, move _1445) -> bb406
  using: _1444@Mir(bb404[2]), _1445@Mir(bb405[1])
bb406:
  _343 = move _1443
  using: _1443@Mir(bb405[2])
  _1452 = _344
  using: _344@Mir(bb400[0])
  _1455 = _346
  using: _346@Mir(bb404[1])
  _1454 = move _1455 as usize (IntToInt)
  using: _1455@Mir(bb406[2])
  _1456 = const 258_usize
  using: 
  _1457 = Lt(_1454, _1456)
  using: _1454@Mir(bb406[3]), _1456@Mir(bb406[4])
  assert(move _1457, "index out of bounds: the length is {} but the index is {}", move _1456, _1454) -> bb407
  using: _1457@Entry, _1456@Entry, _1454@Entry
bb407:
  _1458 = const 1_usize
  using: 
  _1453 = ((*_1).38: [[u32; 4]; 258])[_1454][_1458]
  using: _1@Phi(bb119), _1458@Mir(bb407[0]), _1454@Mir(bb406[3])
  _1451 = core::num::<impl u32>::wrapping_add(move _1452, move _1453) -> bb408
  using: _1452@Mir(bb406[1]), _1453@Mir(bb407[1])
bb408:
  _344 = move _1451
  using: _1451@Mir(bb407[2])
  _1460 = _345
  using: _345@Mir(bb402[0])
  _1463 = _346
  using: _346@Mir(bb404[1])
  _1462 = move _1463 as usize (IntToInt)
  using: _1463@Mir(bb408[2])
  _1464 = const 258_usize
  using: 
  _1465 = Lt(_1462, _1464)
  using: _1462@Mir(bb408[3]), _1464@Mir(bb408[4])
  assert(move _1465, "index out of bounds: the length is {} but the index is {}", move _1464, _1462) -> bb409
  using: _1465@Entry, _1464@Entry, _1462@Entry
bb409:
  _1466 = const 2_usize
  using: 
  _1461 = ((*_1).38: [[u32; 4]; 258])[_1462][_1466]
  using: _1@Phi(bb119), _1466@Mir(bb409[0]), _1462@Mir(bb408[3])
  _1459 = core::num::<impl u32>::wrapping_add(move _1460, move _1461) -> bb410
  using: _1460@Mir(bb408[1]), _1461@Mir(bb409[1])
bb410:
  _345 = move _1459
  using: _1459@Mir(bb409[2])
  _1469 = _21
  using: _21@Phi(bb112)
  _1472 = _6
  using: _6@Phi(bb127)
  _1473 = const 35_i32
  using: 
  _1474 = CheckedAdd(_1472, _1473)
  using: _1472@Mir(bb410[2]), _1473@Mir(bb410[3])
  assert(!move (_1474.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1472, move _1473) -> bb411
  using: _1474@Entry, _1472@Entry, _1473@Entry
bb411:
  _1471 = move (_1474.0: i32)
  using: _1474@Mir(bb410[4])
  _1470 = move _1471 as isize (IntToInt)
  using: _1471@Mir(bb411[0])
  _1468 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1469, move _1470) -> bb412
  using: _1469@Mir(bb410[1]), _1470@Mir(bb411[1])
bb412:
  _1467 = (*_1468)
  using: _1468@Mir(bb411[2])
  _346 = move _1467
  using: _1467@Mir(bb412[0])
  _1476 = _343
  using: _343@Mir(bb406[0])
  _1479 = _346
  using: _346@Mir(bb412[1])
  _1478 = move _1479 as usize (IntToInt)
  using: _1479@Mir(bb412[3])
  _1480 = const 258_usize
  using: 
  _1481 = Lt(_1478, _1480)
  using: _1478@Mir(bb412[4]), _1480@Mir(bb412[5])
  assert(move _1481, "index out of bounds: the length is {} but the index is {}", move _1480, _1478) -> bb413
  using: _1481@Entry, _1480@Entry, _1478@Entry
bb413:
  _1482 = const 0_usize
  using: 
  _1477 = ((*_1).38: [[u32; 4]; 258])[_1478][_1482]
  using: _1@Phi(bb119), _1482@Mir(bb413[0]), _1478@Mir(bb412[4])
  _1475 = core::num::<impl u32>::wrapping_add(move _1476, move _1477) -> bb414
  using: _1476@Mir(bb412[2]), _1477@Mir(bb413[1])
bb414:
  _343 = move _1475
  using: _1475@Mir(bb413[2])
  _1484 = _344
  using: _344@Mir(bb408[0])
  _1487 = _346
  using: _346@Mir(bb412[1])
  _1486 = move _1487 as usize (IntToInt)
  using: _1487@Mir(bb414[2])
  _1488 = const 258_usize
  using: 
  _1489 = Lt(_1486, _1488)
  using: _1486@Mir(bb414[3]), _1488@Mir(bb414[4])
  assert(move _1489, "index out of bounds: the length is {} but the index is {}", move _1488, _1486) -> bb415
  using: _1489@Entry, _1488@Entry, _1486@Entry
bb415:
  _1490 = const 1_usize
  using: 
  _1485 = ((*_1).38: [[u32; 4]; 258])[_1486][_1490]
  using: _1@Phi(bb119), _1490@Mir(bb415[0]), _1486@Mir(bb414[3])
  _1483 = core::num::<impl u32>::wrapping_add(move _1484, move _1485) -> bb416
  using: _1484@Mir(bb414[1]), _1485@Mir(bb415[1])
bb416:
  _344 = move _1483
  using: _1483@Mir(bb415[2])
  _1492 = _345
  using: _345@Mir(bb410[0])
  _1495 = _346
  using: _346@Mir(bb412[1])
  _1494 = move _1495 as usize (IntToInt)
  using: _1495@Mir(bb416[2])
  _1496 = const 258_usize
  using: 
  _1497 = Lt(_1494, _1496)
  using: _1494@Mir(bb416[3]), _1496@Mir(bb416[4])
  assert(move _1497, "index out of bounds: the length is {} but the index is {}", move _1496, _1494) -> bb417
  using: _1497@Entry, _1496@Entry, _1494@Entry
bb417:
  _1498 = const 2_usize
  using: 
  _1493 = ((*_1).38: [[u32; 4]; 258])[_1494][_1498]
  using: _1@Phi(bb119), _1498@Mir(bb417[0]), _1494@Mir(bb416[3])
  _1491 = core::num::<impl u32>::wrapping_add(move _1492, move _1493) -> bb418
  using: _1492@Mir(bb416[1]), _1493@Mir(bb417[1])
bb418:
  _345 = move _1491
  using: _1491@Mir(bb417[2])
  _1501 = _21
  using: _21@Phi(bb112)
  _1504 = _6
  using: _6@Phi(bb127)
  _1505 = const 36_i32
  using: 
  _1506 = CheckedAdd(_1504, _1505)
  using: _1504@Mir(bb418[2]), _1505@Mir(bb418[3])
  assert(!move (_1506.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1504, move _1505) -> bb419
  using: _1506@Entry, _1504@Entry, _1505@Entry
bb419:
  _1503 = move (_1506.0: i32)
  using: _1506@Mir(bb418[4])
  _1502 = move _1503 as isize (IntToInt)
  using: _1503@Mir(bb419[0])
  _1500 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1501, move _1502) -> bb420
  using: _1501@Mir(bb418[1]), _1502@Mir(bb419[1])
bb420:
  _1499 = (*_1500)
  using: _1500@Mir(bb419[2])
  _346 = move _1499
  using: _1499@Mir(bb420[0])
  _1508 = _343
  using: _343@Mir(bb414[0])
  _1511 = _346
  using: _346@Mir(bb420[1])
  _1510 = move _1511 as usize (IntToInt)
  using: _1511@Mir(bb420[3])
  _1512 = const 258_usize
  using: 
  _1513 = Lt(_1510, _1512)
  using: _1510@Mir(bb420[4]), _1512@Mir(bb420[5])
  assert(move _1513, "index out of bounds: the length is {} but the index is {}", move _1512, _1510) -> bb421
  using: _1513@Entry, _1512@Entry, _1510@Entry
bb421:
  _1514 = const 0_usize
  using: 
  _1509 = ((*_1).38: [[u32; 4]; 258])[_1510][_1514]
  using: _1@Phi(bb119), _1514@Mir(bb421[0]), _1510@Mir(bb420[4])
  _1507 = core::num::<impl u32>::wrapping_add(move _1508, move _1509) -> bb422
  using: _1508@Mir(bb420[2]), _1509@Mir(bb421[1])
bb422:
  _343 = move _1507
  using: _1507@Mir(bb421[2])
  _1516 = _344
  using: _344@Mir(bb416[0])
  _1519 = _346
  using: _346@Mir(bb420[1])
  _1518 = move _1519 as usize (IntToInt)
  using: _1519@Mir(bb422[2])
  _1520 = const 258_usize
  using: 
  _1521 = Lt(_1518, _1520)
  using: _1518@Mir(bb422[3]), _1520@Mir(bb422[4])
  assert(move _1521, "index out of bounds: the length is {} but the index is {}", move _1520, _1518) -> bb423
  using: _1521@Entry, _1520@Entry, _1518@Entry
bb423:
  _1522 = const 1_usize
  using: 
  _1517 = ((*_1).38: [[u32; 4]; 258])[_1518][_1522]
  using: _1@Phi(bb119), _1522@Mir(bb423[0]), _1518@Mir(bb422[3])
  _1515 = core::num::<impl u32>::wrapping_add(move _1516, move _1517) -> bb424
  using: _1516@Mir(bb422[1]), _1517@Mir(bb423[1])
bb424:
  _344 = move _1515
  using: _1515@Mir(bb423[2])
  _1524 = _345
  using: _345@Mir(bb418[0])
  _1527 = _346
  using: _346@Mir(bb420[1])
  _1526 = move _1527 as usize (IntToInt)
  using: _1527@Mir(bb424[2])
  _1528 = const 258_usize
  using: 
  _1529 = Lt(_1526, _1528)
  using: _1526@Mir(bb424[3]), _1528@Mir(bb424[4])
  assert(move _1529, "index out of bounds: the length is {} but the index is {}", move _1528, _1526) -> bb425
  using: _1529@Entry, _1528@Entry, _1526@Entry
bb425:
  _1530 = const 2_usize
  using: 
  _1525 = ((*_1).38: [[u32; 4]; 258])[_1526][_1530]
  using: _1@Phi(bb119), _1530@Mir(bb425[0]), _1526@Mir(bb424[3])
  _1523 = core::num::<impl u32>::wrapping_add(move _1524, move _1525) -> bb426
  using: _1524@Mir(bb424[1]), _1525@Mir(bb425[1])
bb426:
  _345 = move _1523
  using: _1523@Mir(bb425[2])
  _1533 = _21
  using: _21@Phi(bb112)
  _1536 = _6
  using: _6@Phi(bb127)
  _1537 = const 37_i32
  using: 
  _1538 = CheckedAdd(_1536, _1537)
  using: _1536@Mir(bb426[2]), _1537@Mir(bb426[3])
  assert(!move (_1538.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1536, move _1537) -> bb427
  using: _1538@Entry, _1536@Entry, _1537@Entry
bb427:
  _1535 = move (_1538.0: i32)
  using: _1538@Mir(bb426[4])
  _1534 = move _1535 as isize (IntToInt)
  using: _1535@Mir(bb427[0])
  _1532 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1533, move _1534) -> bb428
  using: _1533@Mir(bb426[1]), _1534@Mir(bb427[1])
bb428:
  _1531 = (*_1532)
  using: _1532@Mir(bb427[2])
  _346 = move _1531
  using: _1531@Mir(bb428[0])
  _1540 = _343
  using: _343@Mir(bb422[0])
  _1543 = _346
  using: _346@Mir(bb428[1])
  _1542 = move _1543 as usize (IntToInt)
  using: _1543@Mir(bb428[3])
  _1544 = const 258_usize
  using: 
  _1545 = Lt(_1542, _1544)
  using: _1542@Mir(bb428[4]), _1544@Mir(bb428[5])
  assert(move _1545, "index out of bounds: the length is {} but the index is {}", move _1544, _1542) -> bb429
  using: _1545@Entry, _1544@Entry, _1542@Entry
bb429:
  _1546 = const 0_usize
  using: 
  _1541 = ((*_1).38: [[u32; 4]; 258])[_1542][_1546]
  using: _1@Phi(bb119), _1546@Mir(bb429[0]), _1542@Mir(bb428[4])
  _1539 = core::num::<impl u32>::wrapping_add(move _1540, move _1541) -> bb430
  using: _1540@Mir(bb428[2]), _1541@Mir(bb429[1])
bb430:
  _343 = move _1539
  using: _1539@Mir(bb429[2])
  _1548 = _344
  using: _344@Mir(bb424[0])
  _1551 = _346
  using: _346@Mir(bb428[1])
  _1550 = move _1551 as usize (IntToInt)
  using: _1551@Mir(bb430[2])
  _1552 = const 258_usize
  using: 
  _1553 = Lt(_1550, _1552)
  using: _1550@Mir(bb430[3]), _1552@Mir(bb430[4])
  assert(move _1553, "index out of bounds: the length is {} but the index is {}", move _1552, _1550) -> bb431
  using: _1553@Entry, _1552@Entry, _1550@Entry
bb431:
  _1554 = const 1_usize
  using: 
  _1549 = ((*_1).38: [[u32; 4]; 258])[_1550][_1554]
  using: _1@Phi(bb119), _1554@Mir(bb431[0]), _1550@Mir(bb430[3])
  _1547 = core::num::<impl u32>::wrapping_add(move _1548, move _1549) -> bb432
  using: _1548@Mir(bb430[1]), _1549@Mir(bb431[1])
bb432:
  _344 = move _1547
  using: _1547@Mir(bb431[2])
  _1556 = _345
  using: _345@Mir(bb426[0])
  _1559 = _346
  using: _346@Mir(bb428[1])
  _1558 = move _1559 as usize (IntToInt)
  using: _1559@Mir(bb432[2])
  _1560 = const 258_usize
  using: 
  _1561 = Lt(_1558, _1560)
  using: _1558@Mir(bb432[3]), _1560@Mir(bb432[4])
  assert(move _1561, "index out of bounds: the length is {} but the index is {}", move _1560, _1558) -> bb433
  using: _1561@Entry, _1560@Entry, _1558@Entry
bb433:
  _1562 = const 2_usize
  using: 
  _1557 = ((*_1).38: [[u32; 4]; 258])[_1558][_1562]
  using: _1@Phi(bb119), _1562@Mir(bb433[0]), _1558@Mir(bb432[3])
  _1555 = core::num::<impl u32>::wrapping_add(move _1556, move _1557) -> bb434
  using: _1556@Mir(bb432[1]), _1557@Mir(bb433[1])
bb434:
  _345 = move _1555
  using: _1555@Mir(bb433[2])
  _1565 = _21
  using: _21@Phi(bb112)
  _1568 = _6
  using: _6@Phi(bb127)
  _1569 = const 38_i32
  using: 
  _1570 = CheckedAdd(_1568, _1569)
  using: _1568@Mir(bb434[2]), _1569@Mir(bb434[3])
  assert(!move (_1570.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1568, move _1569) -> bb435
  using: _1570@Entry, _1568@Entry, _1569@Entry
bb435:
  _1567 = move (_1570.0: i32)
  using: _1570@Mir(bb434[4])
  _1566 = move _1567 as isize (IntToInt)
  using: _1567@Mir(bb435[0])
  _1564 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1565, move _1566) -> bb436
  using: _1565@Mir(bb434[1]), _1566@Mir(bb435[1])
bb436:
  _1563 = (*_1564)
  using: _1564@Mir(bb435[2])
  _346 = move _1563
  using: _1563@Mir(bb436[0])
  _1572 = _343
  using: _343@Mir(bb430[0])
  _1575 = _346
  using: _346@Mir(bb436[1])
  _1574 = move _1575 as usize (IntToInt)
  using: _1575@Mir(bb436[3])
  _1576 = const 258_usize
  using: 
  _1577 = Lt(_1574, _1576)
  using: _1574@Mir(bb436[4]), _1576@Mir(bb436[5])
  assert(move _1577, "index out of bounds: the length is {} but the index is {}", move _1576, _1574) -> bb437
  using: _1577@Entry, _1576@Entry, _1574@Entry
bb437:
  _1578 = const 0_usize
  using: 
  _1573 = ((*_1).38: [[u32; 4]; 258])[_1574][_1578]
  using: _1@Phi(bb119), _1578@Mir(bb437[0]), _1574@Mir(bb436[4])
  _1571 = core::num::<impl u32>::wrapping_add(move _1572, move _1573) -> bb438
  using: _1572@Mir(bb436[2]), _1573@Mir(bb437[1])
bb438:
  _343 = move _1571
  using: _1571@Mir(bb437[2])
  _1580 = _344
  using: _344@Mir(bb432[0])
  _1583 = _346
  using: _346@Mir(bb436[1])
  _1582 = move _1583 as usize (IntToInt)
  using: _1583@Mir(bb438[2])
  _1584 = const 258_usize
  using: 
  _1585 = Lt(_1582, _1584)
  using: _1582@Mir(bb438[3]), _1584@Mir(bb438[4])
  assert(move _1585, "index out of bounds: the length is {} but the index is {}", move _1584, _1582) -> bb439
  using: _1585@Entry, _1584@Entry, _1582@Entry
bb439:
  _1586 = const 1_usize
  using: 
  _1581 = ((*_1).38: [[u32; 4]; 258])[_1582][_1586]
  using: _1@Phi(bb119), _1586@Mir(bb439[0]), _1582@Mir(bb438[3])
  _1579 = core::num::<impl u32>::wrapping_add(move _1580, move _1581) -> bb440
  using: _1580@Mir(bb438[1]), _1581@Mir(bb439[1])
bb440:
  _344 = move _1579
  using: _1579@Mir(bb439[2])
  _1588 = _345
  using: _345@Mir(bb434[0])
  _1591 = _346
  using: _346@Mir(bb436[1])
  _1590 = move _1591 as usize (IntToInt)
  using: _1591@Mir(bb440[2])
  _1592 = const 258_usize
  using: 
  _1593 = Lt(_1590, _1592)
  using: _1590@Mir(bb440[3]), _1592@Mir(bb440[4])
  assert(move _1593, "index out of bounds: the length is {} but the index is {}", move _1592, _1590) -> bb441
  using: _1593@Entry, _1592@Entry, _1590@Entry
bb441:
  _1594 = const 2_usize
  using: 
  _1589 = ((*_1).38: [[u32; 4]; 258])[_1590][_1594]
  using: _1@Phi(bb119), _1594@Mir(bb441[0]), _1590@Mir(bb440[3])
  _1587 = core::num::<impl u32>::wrapping_add(move _1588, move _1589) -> bb442
  using: _1588@Mir(bb440[1]), _1589@Mir(bb441[1])
bb442:
  _345 = move _1587
  using: _1587@Mir(bb441[2])
  _1597 = _21
  using: _21@Phi(bb112)
  _1600 = _6
  using: _6@Phi(bb127)
  _1601 = const 39_i32
  using: 
  _1602 = CheckedAdd(_1600, _1601)
  using: _1600@Mir(bb442[2]), _1601@Mir(bb442[3])
  assert(!move (_1602.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1600, move _1601) -> bb443
  using: _1602@Entry, _1600@Entry, _1601@Entry
bb443:
  _1599 = move (_1602.0: i32)
  using: _1602@Mir(bb442[4])
  _1598 = move _1599 as isize (IntToInt)
  using: _1599@Mir(bb443[0])
  _1596 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1597, move _1598) -> bb444
  using: _1597@Mir(bb442[1]), _1598@Mir(bb443[1])
bb444:
  _1595 = (*_1596)
  using: _1596@Mir(bb443[2])
  _346 = move _1595
  using: _1595@Mir(bb444[0])
  _1604 = _343
  using: _343@Mir(bb438[0])
  _1607 = _346
  using: _346@Mir(bb444[1])
  _1606 = move _1607 as usize (IntToInt)
  using: _1607@Mir(bb444[3])
  _1608 = const 258_usize
  using: 
  _1609 = Lt(_1606, _1608)
  using: _1606@Mir(bb444[4]), _1608@Mir(bb444[5])
  assert(move _1609, "index out of bounds: the length is {} but the index is {}", move _1608, _1606) -> bb445
  using: _1609@Entry, _1608@Entry, _1606@Entry
bb445:
  _1610 = const 0_usize
  using: 
  _1605 = ((*_1).38: [[u32; 4]; 258])[_1606][_1610]
  using: _1@Phi(bb119), _1610@Mir(bb445[0]), _1606@Mir(bb444[4])
  _1603 = core::num::<impl u32>::wrapping_add(move _1604, move _1605) -> bb446
  using: _1604@Mir(bb444[2]), _1605@Mir(bb445[1])
bb446:
  _343 = move _1603
  using: _1603@Mir(bb445[2])
  _1612 = _344
  using: _344@Mir(bb440[0])
  _1615 = _346
  using: _346@Mir(bb444[1])
  _1614 = move _1615 as usize (IntToInt)
  using: _1615@Mir(bb446[2])
  _1616 = const 258_usize
  using: 
  _1617 = Lt(_1614, _1616)
  using: _1614@Mir(bb446[3]), _1616@Mir(bb446[4])
  assert(move _1617, "index out of bounds: the length is {} but the index is {}", move _1616, _1614) -> bb447
  using: _1617@Entry, _1616@Entry, _1614@Entry
bb447:
  _1618 = const 1_usize
  using: 
  _1613 = ((*_1).38: [[u32; 4]; 258])[_1614][_1618]
  using: _1@Phi(bb119), _1618@Mir(bb447[0]), _1614@Mir(bb446[3])
  _1611 = core::num::<impl u32>::wrapping_add(move _1612, move _1613) -> bb448
  using: _1612@Mir(bb446[1]), _1613@Mir(bb447[1])
bb448:
  _344 = move _1611
  using: _1611@Mir(bb447[2])
  _1620 = _345
  using: _345@Mir(bb442[0])
  _1623 = _346
  using: _346@Mir(bb444[1])
  _1622 = move _1623 as usize (IntToInt)
  using: _1623@Mir(bb448[2])
  _1624 = const 258_usize
  using: 
  _1625 = Lt(_1622, _1624)
  using: _1622@Mir(bb448[3]), _1624@Mir(bb448[4])
  assert(move _1625, "index out of bounds: the length is {} but the index is {}", move _1624, _1622) -> bb449
  using: _1625@Entry, _1624@Entry, _1622@Entry
bb449:
  _1626 = const 2_usize
  using: 
  _1621 = ((*_1).38: [[u32; 4]; 258])[_1622][_1626]
  using: _1@Phi(bb119), _1626@Mir(bb449[0]), _1622@Mir(bb448[3])
  _1619 = core::num::<impl u32>::wrapping_add(move _1620, move _1621) -> bb450
  using: _1620@Mir(bb448[1]), _1621@Mir(bb449[1])
bb450:
  _345 = move _1619
  using: _1619@Mir(bb449[2])
  _1629 = _21
  using: _21@Phi(bb112)
  _1632 = _6
  using: _6@Phi(bb127)
  _1633 = const 40_i32
  using: 
  _1634 = CheckedAdd(_1632, _1633)
  using: _1632@Mir(bb450[2]), _1633@Mir(bb450[3])
  assert(!move (_1634.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1632, move _1633) -> bb451
  using: _1634@Entry, _1632@Entry, _1633@Entry
bb451:
  _1631 = move (_1634.0: i32)
  using: _1634@Mir(bb450[4])
  _1630 = move _1631 as isize (IntToInt)
  using: _1631@Mir(bb451[0])
  _1628 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1629, move _1630) -> bb452
  using: _1629@Mir(bb450[1]), _1630@Mir(bb451[1])
bb452:
  _1627 = (*_1628)
  using: _1628@Mir(bb451[2])
  _346 = move _1627
  using: _1627@Mir(bb452[0])
  _1636 = _343
  using: _343@Mir(bb446[0])
  _1639 = _346
  using: _346@Mir(bb452[1])
  _1638 = move _1639 as usize (IntToInt)
  using: _1639@Mir(bb452[3])
  _1640 = const 258_usize
  using: 
  _1641 = Lt(_1638, _1640)
  using: _1638@Mir(bb452[4]), _1640@Mir(bb452[5])
  assert(move _1641, "index out of bounds: the length is {} but the index is {}", move _1640, _1638) -> bb453
  using: _1641@Entry, _1640@Entry, _1638@Entry
bb453:
  _1642 = const 0_usize
  using: 
  _1637 = ((*_1).38: [[u32; 4]; 258])[_1638][_1642]
  using: _1@Phi(bb119), _1642@Mir(bb453[0]), _1638@Mir(bb452[4])
  _1635 = core::num::<impl u32>::wrapping_add(move _1636, move _1637) -> bb454
  using: _1636@Mir(bb452[2]), _1637@Mir(bb453[1])
bb454:
  _343 = move _1635
  using: _1635@Mir(bb453[2])
  _1644 = _344
  using: _344@Mir(bb448[0])
  _1647 = _346
  using: _346@Mir(bb452[1])
  _1646 = move _1647 as usize (IntToInt)
  using: _1647@Mir(bb454[2])
  _1648 = const 258_usize
  using: 
  _1649 = Lt(_1646, _1648)
  using: _1646@Mir(bb454[3]), _1648@Mir(bb454[4])
  assert(move _1649, "index out of bounds: the length is {} but the index is {}", move _1648, _1646) -> bb455
  using: _1649@Entry, _1648@Entry, _1646@Entry
bb455:
  _1650 = const 1_usize
  using: 
  _1645 = ((*_1).38: [[u32; 4]; 258])[_1646][_1650]
  using: _1@Phi(bb119), _1650@Mir(bb455[0]), _1646@Mir(bb454[3])
  _1643 = core::num::<impl u32>::wrapping_add(move _1644, move _1645) -> bb456
  using: _1644@Mir(bb454[1]), _1645@Mir(bb455[1])
bb456:
  _344 = move _1643
  using: _1643@Mir(bb455[2])
  _1652 = _345
  using: _345@Mir(bb450[0])
  _1655 = _346
  using: _346@Mir(bb452[1])
  _1654 = move _1655 as usize (IntToInt)
  using: _1655@Mir(bb456[2])
  _1656 = const 258_usize
  using: 
  _1657 = Lt(_1654, _1656)
  using: _1654@Mir(bb456[3]), _1656@Mir(bb456[4])
  assert(move _1657, "index out of bounds: the length is {} but the index is {}", move _1656, _1654) -> bb457
  using: _1657@Entry, _1656@Entry, _1654@Entry
bb457:
  _1658 = const 2_usize
  using: 
  _1653 = ((*_1).38: [[u32; 4]; 258])[_1654][_1658]
  using: _1@Phi(bb119), _1658@Mir(bb457[0]), _1654@Mir(bb456[3])
  _1651 = core::num::<impl u32>::wrapping_add(move _1652, move _1653) -> bb458
  using: _1652@Mir(bb456[1]), _1653@Mir(bb457[1])
bb458:
  _345 = move _1651
  using: _1651@Mir(bb457[2])
  _1661 = _21
  using: _21@Phi(bb112)
  _1664 = _6
  using: _6@Phi(bb127)
  _1665 = const 41_i32
  using: 
  _1666 = CheckedAdd(_1664, _1665)
  using: _1664@Mir(bb458[2]), _1665@Mir(bb458[3])
  assert(!move (_1666.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1664, move _1665) -> bb459
  using: _1666@Entry, _1664@Entry, _1665@Entry
bb459:
  _1663 = move (_1666.0: i32)
  using: _1666@Mir(bb458[4])
  _1662 = move _1663 as isize (IntToInt)
  using: _1663@Mir(bb459[0])
  _1660 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1661, move _1662) -> bb460
  using: _1661@Mir(bb458[1]), _1662@Mir(bb459[1])
bb460:
  _1659 = (*_1660)
  using: _1660@Mir(bb459[2])
  _346 = move _1659
  using: _1659@Mir(bb460[0])
  _1668 = _343
  using: _343@Mir(bb454[0])
  _1671 = _346
  using: _346@Mir(bb460[1])
  _1670 = move _1671 as usize (IntToInt)
  using: _1671@Mir(bb460[3])
  _1672 = const 258_usize
  using: 
  _1673 = Lt(_1670, _1672)
  using: _1670@Mir(bb460[4]), _1672@Mir(bb460[5])
  assert(move _1673, "index out of bounds: the length is {} but the index is {}", move _1672, _1670) -> bb461
  using: _1673@Entry, _1672@Entry, _1670@Entry
bb461:
  _1674 = const 0_usize
  using: 
  _1669 = ((*_1).38: [[u32; 4]; 258])[_1670][_1674]
  using: _1@Phi(bb119), _1674@Mir(bb461[0]), _1670@Mir(bb460[4])
  _1667 = core::num::<impl u32>::wrapping_add(move _1668, move _1669) -> bb462
  using: _1668@Mir(bb460[2]), _1669@Mir(bb461[1])
bb462:
  _343 = move _1667
  using: _1667@Mir(bb461[2])
  _1676 = _344
  using: _344@Mir(bb456[0])
  _1679 = _346
  using: _346@Mir(bb460[1])
  _1678 = move _1679 as usize (IntToInt)
  using: _1679@Mir(bb462[2])
  _1680 = const 258_usize
  using: 
  _1681 = Lt(_1678, _1680)
  using: _1678@Mir(bb462[3]), _1680@Mir(bb462[4])
  assert(move _1681, "index out of bounds: the length is {} but the index is {}", move _1680, _1678) -> bb463
  using: _1681@Entry, _1680@Entry, _1678@Entry
bb463:
  _1682 = const 1_usize
  using: 
  _1677 = ((*_1).38: [[u32; 4]; 258])[_1678][_1682]
  using: _1@Phi(bb119), _1682@Mir(bb463[0]), _1678@Mir(bb462[3])
  _1675 = core::num::<impl u32>::wrapping_add(move _1676, move _1677) -> bb464
  using: _1676@Mir(bb462[1]), _1677@Mir(bb463[1])
bb464:
  _344 = move _1675
  using: _1675@Mir(bb463[2])
  _1684 = _345
  using: _345@Mir(bb458[0])
  _1687 = _346
  using: _346@Mir(bb460[1])
  _1686 = move _1687 as usize (IntToInt)
  using: _1687@Mir(bb464[2])
  _1688 = const 258_usize
  using: 
  _1689 = Lt(_1686, _1688)
  using: _1686@Mir(bb464[3]), _1688@Mir(bb464[4])
  assert(move _1689, "index out of bounds: the length is {} but the index is {}", move _1688, _1686) -> bb465
  using: _1689@Entry, _1688@Entry, _1686@Entry
bb465:
  _1690 = const 2_usize
  using: 
  _1685 = ((*_1).38: [[u32; 4]; 258])[_1686][_1690]
  using: _1@Phi(bb119), _1690@Mir(bb465[0]), _1686@Mir(bb464[3])
  _1683 = core::num::<impl u32>::wrapping_add(move _1684, move _1685) -> bb466
  using: _1684@Mir(bb464[1]), _1685@Mir(bb465[1])
bb466:
  _345 = move _1683
  using: _1683@Mir(bb465[2])
  _1693 = _21
  using: _21@Phi(bb112)
  _1696 = _6
  using: _6@Phi(bb127)
  _1697 = const 42_i32
  using: 
  _1698 = CheckedAdd(_1696, _1697)
  using: _1696@Mir(bb466[2]), _1697@Mir(bb466[3])
  assert(!move (_1698.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1696, move _1697) -> bb467
  using: _1698@Entry, _1696@Entry, _1697@Entry
bb467:
  _1695 = move (_1698.0: i32)
  using: _1698@Mir(bb466[4])
  _1694 = move _1695 as isize (IntToInt)
  using: _1695@Mir(bb467[0])
  _1692 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1693, move _1694) -> bb468
  using: _1693@Mir(bb466[1]), _1694@Mir(bb467[1])
bb468:
  _1691 = (*_1692)
  using: _1692@Mir(bb467[2])
  _346 = move _1691
  using: _1691@Mir(bb468[0])
  _1700 = _343
  using: _343@Mir(bb462[0])
  _1703 = _346
  using: _346@Mir(bb468[1])
  _1702 = move _1703 as usize (IntToInt)
  using: _1703@Mir(bb468[3])
  _1704 = const 258_usize
  using: 
  _1705 = Lt(_1702, _1704)
  using: _1702@Mir(bb468[4]), _1704@Mir(bb468[5])
  assert(move _1705, "index out of bounds: the length is {} but the index is {}", move _1704, _1702) -> bb469
  using: _1705@Entry, _1704@Entry, _1702@Entry
bb469:
  _1706 = const 0_usize
  using: 
  _1701 = ((*_1).38: [[u32; 4]; 258])[_1702][_1706]
  using: _1@Phi(bb119), _1706@Mir(bb469[0]), _1702@Mir(bb468[4])
  _1699 = core::num::<impl u32>::wrapping_add(move _1700, move _1701) -> bb470
  using: _1700@Mir(bb468[2]), _1701@Mir(bb469[1])
bb470:
  _343 = move _1699
  using: _1699@Mir(bb469[2])
  _1708 = _344
  using: _344@Mir(bb464[0])
  _1711 = _346
  using: _346@Mir(bb468[1])
  _1710 = move _1711 as usize (IntToInt)
  using: _1711@Mir(bb470[2])
  _1712 = const 258_usize
  using: 
  _1713 = Lt(_1710, _1712)
  using: _1710@Mir(bb470[3]), _1712@Mir(bb470[4])
  assert(move _1713, "index out of bounds: the length is {} but the index is {}", move _1712, _1710) -> bb471
  using: _1713@Entry, _1712@Entry, _1710@Entry
bb471:
  _1714 = const 1_usize
  using: 
  _1709 = ((*_1).38: [[u32; 4]; 258])[_1710][_1714]
  using: _1@Phi(bb119), _1714@Mir(bb471[0]), _1710@Mir(bb470[3])
  _1707 = core::num::<impl u32>::wrapping_add(move _1708, move _1709) -> bb472
  using: _1708@Mir(bb470[1]), _1709@Mir(bb471[1])
bb472:
  _344 = move _1707
  using: _1707@Mir(bb471[2])
  _1716 = _345
  using: _345@Mir(bb466[0])
  _1719 = _346
  using: _346@Mir(bb468[1])
  _1718 = move _1719 as usize (IntToInt)
  using: _1719@Mir(bb472[2])
  _1720 = const 258_usize
  using: 
  _1721 = Lt(_1718, _1720)
  using: _1718@Mir(bb472[3]), _1720@Mir(bb472[4])
  assert(move _1721, "index out of bounds: the length is {} but the index is {}", move _1720, _1718) -> bb473
  using: _1721@Entry, _1720@Entry, _1718@Entry
bb473:
  _1722 = const 2_usize
  using: 
  _1717 = ((*_1).38: [[u32; 4]; 258])[_1718][_1722]
  using: _1@Phi(bb119), _1722@Mir(bb473[0]), _1718@Mir(bb472[3])
  _1715 = core::num::<impl u32>::wrapping_add(move _1716, move _1717) -> bb474
  using: _1716@Mir(bb472[1]), _1717@Mir(bb473[1])
bb474:
  _345 = move _1715
  using: _1715@Mir(bb473[2])
  _1725 = _21
  using: _21@Phi(bb112)
  _1728 = _6
  using: _6@Phi(bb127)
  _1729 = const 43_i32
  using: 
  _1730 = CheckedAdd(_1728, _1729)
  using: _1728@Mir(bb474[2]), _1729@Mir(bb474[3])
  assert(!move (_1730.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1728, move _1729) -> bb475
  using: _1730@Entry, _1728@Entry, _1729@Entry
bb475:
  _1727 = move (_1730.0: i32)
  using: _1730@Mir(bb474[4])
  _1726 = move _1727 as isize (IntToInt)
  using: _1727@Mir(bb475[0])
  _1724 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1725, move _1726) -> bb476
  using: _1725@Mir(bb474[1]), _1726@Mir(bb475[1])
bb476:
  _1723 = (*_1724)
  using: _1724@Mir(bb475[2])
  _346 = move _1723
  using: _1723@Mir(bb476[0])
  _1732 = _343
  using: _343@Mir(bb470[0])
  _1735 = _346
  using: _346@Mir(bb476[1])
  _1734 = move _1735 as usize (IntToInt)
  using: _1735@Mir(bb476[3])
  _1736 = const 258_usize
  using: 
  _1737 = Lt(_1734, _1736)
  using: _1734@Mir(bb476[4]), _1736@Mir(bb476[5])
  assert(move _1737, "index out of bounds: the length is {} but the index is {}", move _1736, _1734) -> bb477
  using: _1737@Entry, _1736@Entry, _1734@Entry
bb477:
  _1738 = const 0_usize
  using: 
  _1733 = ((*_1).38: [[u32; 4]; 258])[_1734][_1738]
  using: _1@Phi(bb119), _1738@Mir(bb477[0]), _1734@Mir(bb476[4])
  _1731 = core::num::<impl u32>::wrapping_add(move _1732, move _1733) -> bb478
  using: _1732@Mir(bb476[2]), _1733@Mir(bb477[1])
bb478:
  _343 = move _1731
  using: _1731@Mir(bb477[2])
  _1740 = _344
  using: _344@Mir(bb472[0])
  _1743 = _346
  using: _346@Mir(bb476[1])
  _1742 = move _1743 as usize (IntToInt)
  using: _1743@Mir(bb478[2])
  _1744 = const 258_usize
  using: 
  _1745 = Lt(_1742, _1744)
  using: _1742@Mir(bb478[3]), _1744@Mir(bb478[4])
  assert(move _1745, "index out of bounds: the length is {} but the index is {}", move _1744, _1742) -> bb479
  using: _1745@Entry, _1744@Entry, _1742@Entry
bb479:
  _1746 = const 1_usize
  using: 
  _1741 = ((*_1).38: [[u32; 4]; 258])[_1742][_1746]
  using: _1@Phi(bb119), _1746@Mir(bb479[0]), _1742@Mir(bb478[3])
  _1739 = core::num::<impl u32>::wrapping_add(move _1740, move _1741) -> bb480
  using: _1740@Mir(bb478[1]), _1741@Mir(bb479[1])
bb480:
  _344 = move _1739
  using: _1739@Mir(bb479[2])
  _1748 = _345
  using: _345@Mir(bb474[0])
  _1751 = _346
  using: _346@Mir(bb476[1])
  _1750 = move _1751 as usize (IntToInt)
  using: _1751@Mir(bb480[2])
  _1752 = const 258_usize
  using: 
  _1753 = Lt(_1750, _1752)
  using: _1750@Mir(bb480[3]), _1752@Mir(bb480[4])
  assert(move _1753, "index out of bounds: the length is {} but the index is {}", move _1752, _1750) -> bb481
  using: _1753@Entry, _1752@Entry, _1750@Entry
bb481:
  _1754 = const 2_usize
  using: 
  _1749 = ((*_1).38: [[u32; 4]; 258])[_1750][_1754]
  using: _1@Phi(bb119), _1754@Mir(bb481[0]), _1750@Mir(bb480[3])
  _1747 = core::num::<impl u32>::wrapping_add(move _1748, move _1749) -> bb482
  using: _1748@Mir(bb480[1]), _1749@Mir(bb481[1])
bb482:
  _345 = move _1747
  using: _1747@Mir(bb481[2])
  _1757 = _21
  using: _21@Phi(bb112)
  _1760 = _6
  using: _6@Phi(bb127)
  _1761 = const 44_i32
  using: 
  _1762 = CheckedAdd(_1760, _1761)
  using: _1760@Mir(bb482[2]), _1761@Mir(bb482[3])
  assert(!move (_1762.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1760, move _1761) -> bb483
  using: _1762@Entry, _1760@Entry, _1761@Entry
bb483:
  _1759 = move (_1762.0: i32)
  using: _1762@Mir(bb482[4])
  _1758 = move _1759 as isize (IntToInt)
  using: _1759@Mir(bb483[0])
  _1756 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1757, move _1758) -> bb484
  using: _1757@Mir(bb482[1]), _1758@Mir(bb483[1])
bb484:
  _1755 = (*_1756)
  using: _1756@Mir(bb483[2])
  _346 = move _1755
  using: _1755@Mir(bb484[0])
  _1764 = _343
  using: _343@Mir(bb478[0])
  _1767 = _346
  using: _346@Mir(bb484[1])
  _1766 = move _1767 as usize (IntToInt)
  using: _1767@Mir(bb484[3])
  _1768 = const 258_usize
  using: 
  _1769 = Lt(_1766, _1768)
  using: _1766@Mir(bb484[4]), _1768@Mir(bb484[5])
  assert(move _1769, "index out of bounds: the length is {} but the index is {}", move _1768, _1766) -> bb485
  using: _1769@Entry, _1768@Entry, _1766@Entry
bb485:
  _1770 = const 0_usize
  using: 
  _1765 = ((*_1).38: [[u32; 4]; 258])[_1766][_1770]
  using: _1@Phi(bb119), _1770@Mir(bb485[0]), _1766@Mir(bb484[4])
  _1763 = core::num::<impl u32>::wrapping_add(move _1764, move _1765) -> bb486
  using: _1764@Mir(bb484[2]), _1765@Mir(bb485[1])
bb486:
  _343 = move _1763
  using: _1763@Mir(bb485[2])
  _1772 = _344
  using: _344@Mir(bb480[0])
  _1775 = _346
  using: _346@Mir(bb484[1])
  _1774 = move _1775 as usize (IntToInt)
  using: _1775@Mir(bb486[2])
  _1776 = const 258_usize
  using: 
  _1777 = Lt(_1774, _1776)
  using: _1774@Mir(bb486[3]), _1776@Mir(bb486[4])
  assert(move _1777, "index out of bounds: the length is {} but the index is {}", move _1776, _1774) -> bb487
  using: _1777@Entry, _1776@Entry, _1774@Entry
bb487:
  _1778 = const 1_usize
  using: 
  _1773 = ((*_1).38: [[u32; 4]; 258])[_1774][_1778]
  using: _1@Phi(bb119), _1778@Mir(bb487[0]), _1774@Mir(bb486[3])
  _1771 = core::num::<impl u32>::wrapping_add(move _1772, move _1773) -> bb488
  using: _1772@Mir(bb486[1]), _1773@Mir(bb487[1])
bb488:
  _344 = move _1771
  using: _1771@Mir(bb487[2])
  _1780 = _345
  using: _345@Mir(bb482[0])
  _1783 = _346
  using: _346@Mir(bb484[1])
  _1782 = move _1783 as usize (IntToInt)
  using: _1783@Mir(bb488[2])
  _1784 = const 258_usize
  using: 
  _1785 = Lt(_1782, _1784)
  using: _1782@Mir(bb488[3]), _1784@Mir(bb488[4])
  assert(move _1785, "index out of bounds: the length is {} but the index is {}", move _1784, _1782) -> bb489
  using: _1785@Entry, _1784@Entry, _1782@Entry
bb489:
  _1786 = const 2_usize
  using: 
  _1781 = ((*_1).38: [[u32; 4]; 258])[_1782][_1786]
  using: _1@Phi(bb119), _1786@Mir(bb489[0]), _1782@Mir(bb488[3])
  _1779 = core::num::<impl u32>::wrapping_add(move _1780, move _1781) -> bb490
  using: _1780@Mir(bb488[1]), _1781@Mir(bb489[1])
bb490:
  _345 = move _1779
  using: _1779@Mir(bb489[2])
  _1789 = _21
  using: _21@Phi(bb112)
  _1792 = _6
  using: _6@Phi(bb127)
  _1793 = const 45_i32
  using: 
  _1794 = CheckedAdd(_1792, _1793)
  using: _1792@Mir(bb490[2]), _1793@Mir(bb490[3])
  assert(!move (_1794.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1792, move _1793) -> bb491
  using: _1794@Entry, _1792@Entry, _1793@Entry
bb491:
  _1791 = move (_1794.0: i32)
  using: _1794@Mir(bb490[4])
  _1790 = move _1791 as isize (IntToInt)
  using: _1791@Mir(bb491[0])
  _1788 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1789, move _1790) -> bb492
  using: _1789@Mir(bb490[1]), _1790@Mir(bb491[1])
bb492:
  _1787 = (*_1788)
  using: _1788@Mir(bb491[2])
  _346 = move _1787
  using: _1787@Mir(bb492[0])
  _1796 = _343
  using: _343@Mir(bb486[0])
  _1799 = _346
  using: _346@Mir(bb492[1])
  _1798 = move _1799 as usize (IntToInt)
  using: _1799@Mir(bb492[3])
  _1800 = const 258_usize
  using: 
  _1801 = Lt(_1798, _1800)
  using: _1798@Mir(bb492[4]), _1800@Mir(bb492[5])
  assert(move _1801, "index out of bounds: the length is {} but the index is {}", move _1800, _1798) -> bb493
  using: _1801@Entry, _1800@Entry, _1798@Entry
bb493:
  _1802 = const 0_usize
  using: 
  _1797 = ((*_1).38: [[u32; 4]; 258])[_1798][_1802]
  using: _1@Phi(bb119), _1802@Mir(bb493[0]), _1798@Mir(bb492[4])
  _1795 = core::num::<impl u32>::wrapping_add(move _1796, move _1797) -> bb494
  using: _1796@Mir(bb492[2]), _1797@Mir(bb493[1])
bb494:
  _343 = move _1795
  using: _1795@Mir(bb493[2])
  _1804 = _344
  using: _344@Mir(bb488[0])
  _1807 = _346
  using: _346@Mir(bb492[1])
  _1806 = move _1807 as usize (IntToInt)
  using: _1807@Mir(bb494[2])
  _1808 = const 258_usize
  using: 
  _1809 = Lt(_1806, _1808)
  using: _1806@Mir(bb494[3]), _1808@Mir(bb494[4])
  assert(move _1809, "index out of bounds: the length is {} but the index is {}", move _1808, _1806) -> bb495
  using: _1809@Entry, _1808@Entry, _1806@Entry
bb495:
  _1810 = const 1_usize
  using: 
  _1805 = ((*_1).38: [[u32; 4]; 258])[_1806][_1810]
  using: _1@Phi(bb119), _1810@Mir(bb495[0]), _1806@Mir(bb494[3])
  _1803 = core::num::<impl u32>::wrapping_add(move _1804, move _1805) -> bb496
  using: _1804@Mir(bb494[1]), _1805@Mir(bb495[1])
bb496:
  _344 = move _1803
  using: _1803@Mir(bb495[2])
  _1812 = _345
  using: _345@Mir(bb490[0])
  _1815 = _346
  using: _346@Mir(bb492[1])
  _1814 = move _1815 as usize (IntToInt)
  using: _1815@Mir(bb496[2])
  _1816 = const 258_usize
  using: 
  _1817 = Lt(_1814, _1816)
  using: _1814@Mir(bb496[3]), _1816@Mir(bb496[4])
  assert(move _1817, "index out of bounds: the length is {} but the index is {}", move _1816, _1814) -> bb497
  using: _1817@Entry, _1816@Entry, _1814@Entry
bb497:
  _1818 = const 2_usize
  using: 
  _1813 = ((*_1).38: [[u32; 4]; 258])[_1814][_1818]
  using: _1@Phi(bb119), _1818@Mir(bb497[0]), _1814@Mir(bb496[3])
  _1811 = core::num::<impl u32>::wrapping_add(move _1812, move _1813) -> bb498
  using: _1812@Mir(bb496[1]), _1813@Mir(bb497[1])
bb498:
  _345 = move _1811
  using: _1811@Mir(bb497[2])
  _1821 = _21
  using: _21@Phi(bb112)
  _1824 = _6
  using: _6@Phi(bb127)
  _1825 = const 46_i32
  using: 
  _1826 = CheckedAdd(_1824, _1825)
  using: _1824@Mir(bb498[2]), _1825@Mir(bb498[3])
  assert(!move (_1826.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1824, move _1825) -> bb499
  using: _1826@Entry, _1824@Entry, _1825@Entry
bb499:
  _1823 = move (_1826.0: i32)
  using: _1826@Mir(bb498[4])
  _1822 = move _1823 as isize (IntToInt)
  using: _1823@Mir(bb499[0])
  _1820 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1821, move _1822) -> bb500
  using: _1821@Mir(bb498[1]), _1822@Mir(bb499[1])
bb500:
  _1819 = (*_1820)
  using: _1820@Mir(bb499[2])
  _346 = move _1819
  using: _1819@Mir(bb500[0])
  _1828 = _343
  using: _343@Mir(bb494[0])
  _1831 = _346
  using: _346@Mir(bb500[1])
  _1830 = move _1831 as usize (IntToInt)
  using: _1831@Mir(bb500[3])
  _1832 = const 258_usize
  using: 
  _1833 = Lt(_1830, _1832)
  using: _1830@Mir(bb500[4]), _1832@Mir(bb500[5])
  assert(move _1833, "index out of bounds: the length is {} but the index is {}", move _1832, _1830) -> bb501
  using: _1833@Entry, _1832@Entry, _1830@Entry
bb501:
  _1834 = const 0_usize
  using: 
  _1829 = ((*_1).38: [[u32; 4]; 258])[_1830][_1834]
  using: _1@Phi(bb119), _1834@Mir(bb501[0]), _1830@Mir(bb500[4])
  _1827 = core::num::<impl u32>::wrapping_add(move _1828, move _1829) -> bb502
  using: _1828@Mir(bb500[2]), _1829@Mir(bb501[1])
bb502:
  _343 = move _1827
  using: _1827@Mir(bb501[2])
  _1836 = _344
  using: _344@Mir(bb496[0])
  _1839 = _346
  using: _346@Mir(bb500[1])
  _1838 = move _1839 as usize (IntToInt)
  using: _1839@Mir(bb502[2])
  _1840 = const 258_usize
  using: 
  _1841 = Lt(_1838, _1840)
  using: _1838@Mir(bb502[3]), _1840@Mir(bb502[4])
  assert(move _1841, "index out of bounds: the length is {} but the index is {}", move _1840, _1838) -> bb503
  using: _1841@Entry, _1840@Entry, _1838@Entry
bb503:
  _1842 = const 1_usize
  using: 
  _1837 = ((*_1).38: [[u32; 4]; 258])[_1838][_1842]
  using: _1@Phi(bb119), _1842@Mir(bb503[0]), _1838@Mir(bb502[3])
  _1835 = core::num::<impl u32>::wrapping_add(move _1836, move _1837) -> bb504
  using: _1836@Mir(bb502[1]), _1837@Mir(bb503[1])
bb504:
  _344 = move _1835
  using: _1835@Mir(bb503[2])
  _1844 = _345
  using: _345@Mir(bb498[0])
  _1847 = _346
  using: _346@Mir(bb500[1])
  _1846 = move _1847 as usize (IntToInt)
  using: _1847@Mir(bb504[2])
  _1848 = const 258_usize
  using: 
  _1849 = Lt(_1846, _1848)
  using: _1846@Mir(bb504[3]), _1848@Mir(bb504[4])
  assert(move _1849, "index out of bounds: the length is {} but the index is {}", move _1848, _1846) -> bb505
  using: _1849@Entry, _1848@Entry, _1846@Entry
bb505:
  _1850 = const 2_usize
  using: 
  _1845 = ((*_1).38: [[u32; 4]; 258])[_1846][_1850]
  using: _1@Phi(bb119), _1850@Mir(bb505[0]), _1846@Mir(bb504[3])
  _1843 = core::num::<impl u32>::wrapping_add(move _1844, move _1845) -> bb506
  using: _1844@Mir(bb504[1]), _1845@Mir(bb505[1])
bb506:
  _345 = move _1843
  using: _1843@Mir(bb505[2])
  _1853 = _21
  using: _21@Phi(bb112)
  _1856 = _6
  using: _6@Phi(bb127)
  _1857 = const 47_i32
  using: 
  _1858 = CheckedAdd(_1856, _1857)
  using: _1856@Mir(bb506[2]), _1857@Mir(bb506[3])
  assert(!move (_1858.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1856, move _1857) -> bb507
  using: _1858@Entry, _1856@Entry, _1857@Entry
bb507:
  _1855 = move (_1858.0: i32)
  using: _1858@Mir(bb506[4])
  _1854 = move _1855 as isize (IntToInt)
  using: _1855@Mir(bb507[0])
  _1852 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1853, move _1854) -> bb508
  using: _1853@Mir(bb506[1]), _1854@Mir(bb507[1])
bb508:
  _1851 = (*_1852)
  using: _1852@Mir(bb507[2])
  _346 = move _1851
  using: _1851@Mir(bb508[0])
  _1860 = _343
  using: _343@Mir(bb502[0])
  _1863 = _346
  using: _346@Mir(bb508[1])
  _1862 = move _1863 as usize (IntToInt)
  using: _1863@Mir(bb508[3])
  _1864 = const 258_usize
  using: 
  _1865 = Lt(_1862, _1864)
  using: _1862@Mir(bb508[4]), _1864@Mir(bb508[5])
  assert(move _1865, "index out of bounds: the length is {} but the index is {}", move _1864, _1862) -> bb509
  using: _1865@Entry, _1864@Entry, _1862@Entry
bb509:
  _1866 = const 0_usize
  using: 
  _1861 = ((*_1).38: [[u32; 4]; 258])[_1862][_1866]
  using: _1@Phi(bb119), _1866@Mir(bb509[0]), _1862@Mir(bb508[4])
  _1859 = core::num::<impl u32>::wrapping_add(move _1860, move _1861) -> bb510
  using: _1860@Mir(bb508[2]), _1861@Mir(bb509[1])
bb510:
  _343 = move _1859
  using: _1859@Mir(bb509[2])
  _1868 = _344
  using: _344@Mir(bb504[0])
  _1871 = _346
  using: _346@Mir(bb508[1])
  _1870 = move _1871 as usize (IntToInt)
  using: _1871@Mir(bb510[2])
  _1872 = const 258_usize
  using: 
  _1873 = Lt(_1870, _1872)
  using: _1870@Mir(bb510[3]), _1872@Mir(bb510[4])
  assert(move _1873, "index out of bounds: the length is {} but the index is {}", move _1872, _1870) -> bb511
  using: _1873@Entry, _1872@Entry, _1870@Entry
bb511:
  _1874 = const 1_usize
  using: 
  _1869 = ((*_1).38: [[u32; 4]; 258])[_1870][_1874]
  using: _1@Phi(bb119), _1874@Mir(bb511[0]), _1870@Mir(bb510[3])
  _1867 = core::num::<impl u32>::wrapping_add(move _1868, move _1869) -> bb512
  using: _1868@Mir(bb510[1]), _1869@Mir(bb511[1])
bb512:
  _344 = move _1867
  using: _1867@Mir(bb511[2])
  _1876 = _345
  using: _345@Mir(bb506[0])
  _1879 = _346
  using: _346@Mir(bb508[1])
  _1878 = move _1879 as usize (IntToInt)
  using: _1879@Mir(bb512[2])
  _1880 = const 258_usize
  using: 
  _1881 = Lt(_1878, _1880)
  using: _1878@Mir(bb512[3]), _1880@Mir(bb512[4])
  assert(move _1881, "index out of bounds: the length is {} but the index is {}", move _1880, _1878) -> bb513
  using: _1881@Entry, _1880@Entry, _1878@Entry
bb513:
  _1882 = const 2_usize
  using: 
  _1877 = ((*_1).38: [[u32; 4]; 258])[_1878][_1882]
  using: _1@Phi(bb119), _1882@Mir(bb513[0]), _1878@Mir(bb512[3])
  _1875 = core::num::<impl u32>::wrapping_add(move _1876, move _1877) -> bb514
  using: _1876@Mir(bb512[1]), _1877@Mir(bb513[1])
bb514:
  _345 = move _1875
  using: _1875@Mir(bb513[2])
  _1885 = _21
  using: _21@Phi(bb112)
  _1888 = _6
  using: _6@Phi(bb127)
  _1889 = const 48_i32
  using: 
  _1890 = CheckedAdd(_1888, _1889)
  using: _1888@Mir(bb514[2]), _1889@Mir(bb514[3])
  assert(!move (_1890.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1888, move _1889) -> bb515
  using: _1890@Entry, _1888@Entry, _1889@Entry
bb515:
  _1887 = move (_1890.0: i32)
  using: _1890@Mir(bb514[4])
  _1886 = move _1887 as isize (IntToInt)
  using: _1887@Mir(bb515[0])
  _1884 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1885, move _1886) -> bb516
  using: _1885@Mir(bb514[1]), _1886@Mir(bb515[1])
bb516:
  _1883 = (*_1884)
  using: _1884@Mir(bb515[2])
  _346 = move _1883
  using: _1883@Mir(bb516[0])
  _1892 = _343
  using: _343@Mir(bb510[0])
  _1895 = _346
  using: _346@Mir(bb516[1])
  _1894 = move _1895 as usize (IntToInt)
  using: _1895@Mir(bb516[3])
  _1896 = const 258_usize
  using: 
  _1897 = Lt(_1894, _1896)
  using: _1894@Mir(bb516[4]), _1896@Mir(bb516[5])
  assert(move _1897, "index out of bounds: the length is {} but the index is {}", move _1896, _1894) -> bb517
  using: _1897@Entry, _1896@Entry, _1894@Entry
bb517:
  _1898 = const 0_usize
  using: 
  _1893 = ((*_1).38: [[u32; 4]; 258])[_1894][_1898]
  using: _1@Phi(bb119), _1898@Mir(bb517[0]), _1894@Mir(bb516[4])
  _1891 = core::num::<impl u32>::wrapping_add(move _1892, move _1893) -> bb518
  using: _1892@Mir(bb516[2]), _1893@Mir(bb517[1])
bb518:
  _343 = move _1891
  using: _1891@Mir(bb517[2])
  _1900 = _344
  using: _344@Mir(bb512[0])
  _1903 = _346
  using: _346@Mir(bb516[1])
  _1902 = move _1903 as usize (IntToInt)
  using: _1903@Mir(bb518[2])
  _1904 = const 258_usize
  using: 
  _1905 = Lt(_1902, _1904)
  using: _1902@Mir(bb518[3]), _1904@Mir(bb518[4])
  assert(move _1905, "index out of bounds: the length is {} but the index is {}", move _1904, _1902) -> bb519
  using: _1905@Entry, _1904@Entry, _1902@Entry
bb519:
  _1906 = const 1_usize
  using: 
  _1901 = ((*_1).38: [[u32; 4]; 258])[_1902][_1906]
  using: _1@Phi(bb119), _1906@Mir(bb519[0]), _1902@Mir(bb518[3])
  _1899 = core::num::<impl u32>::wrapping_add(move _1900, move _1901) -> bb520
  using: _1900@Mir(bb518[1]), _1901@Mir(bb519[1])
bb520:
  _344 = move _1899
  using: _1899@Mir(bb519[2])
  _1908 = _345
  using: _345@Mir(bb514[0])
  _1911 = _346
  using: _346@Mir(bb516[1])
  _1910 = move _1911 as usize (IntToInt)
  using: _1911@Mir(bb520[2])
  _1912 = const 258_usize
  using: 
  _1913 = Lt(_1910, _1912)
  using: _1910@Mir(bb520[3]), _1912@Mir(bb520[4])
  assert(move _1913, "index out of bounds: the length is {} but the index is {}", move _1912, _1910) -> bb521
  using: _1913@Entry, _1912@Entry, _1910@Entry
bb521:
  _1914 = const 2_usize
  using: 
  _1909 = ((*_1).38: [[u32; 4]; 258])[_1910][_1914]
  using: _1@Phi(bb119), _1914@Mir(bb521[0]), _1910@Mir(bb520[3])
  _1907 = core::num::<impl u32>::wrapping_add(move _1908, move _1909) -> bb522
  using: _1908@Mir(bb520[1]), _1909@Mir(bb521[1])
bb522:
  _345 = move _1907
  using: _1907@Mir(bb521[2])
  _1917 = _21
  using: _21@Phi(bb112)
  _1920 = _6
  using: _6@Phi(bb127)
  _1921 = const 49_i32
  using: 
  _1922 = CheckedAdd(_1920, _1921)
  using: _1920@Mir(bb522[2]), _1921@Mir(bb522[3])
  assert(!move (_1922.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1920, move _1921) -> bb523
  using: _1922@Entry, _1920@Entry, _1921@Entry
bb523:
  _1919 = move (_1922.0: i32)
  using: _1922@Mir(bb522[4])
  _1918 = move _1919 as isize (IntToInt)
  using: _1919@Mir(bb523[0])
  _1916 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1917, move _1918) -> bb524
  using: _1917@Mir(bb522[1]), _1918@Mir(bb523[1])
bb524:
  _1915 = (*_1916)
  using: _1916@Mir(bb523[2])
  _346 = move _1915
  using: _1915@Mir(bb524[0])
  _1924 = _343
  using: _343@Mir(bb518[0])
  _1927 = _346
  using: _346@Mir(bb524[1])
  _1926 = move _1927 as usize (IntToInt)
  using: _1927@Mir(bb524[3])
  _1928 = const 258_usize
  using: 
  _1929 = Lt(_1926, _1928)
  using: _1926@Mir(bb524[4]), _1928@Mir(bb524[5])
  assert(move _1929, "index out of bounds: the length is {} but the index is {}", move _1928, _1926) -> bb525
  using: _1929@Entry, _1928@Entry, _1926@Entry
bb525:
  _1930 = const 0_usize
  using: 
  _1925 = ((*_1).38: [[u32; 4]; 258])[_1926][_1930]
  using: _1@Phi(bb119), _1930@Mir(bb525[0]), _1926@Mir(bb524[4])
  _1923 = core::num::<impl u32>::wrapping_add(move _1924, move _1925) -> bb526
  using: _1924@Mir(bb524[2]), _1925@Mir(bb525[1])
bb526:
  _343 = move _1923
  using: _1923@Mir(bb525[2])
  _1932 = _344
  using: _344@Mir(bb520[0])
  _1935 = _346
  using: _346@Mir(bb524[1])
  _1934 = move _1935 as usize (IntToInt)
  using: _1935@Mir(bb526[2])
  _1936 = const 258_usize
  using: 
  _1937 = Lt(_1934, _1936)
  using: _1934@Mir(bb526[3]), _1936@Mir(bb526[4])
  assert(move _1937, "index out of bounds: the length is {} but the index is {}", move _1936, _1934) -> bb527
  using: _1937@Entry, _1936@Entry, _1934@Entry
bb527:
  _1938 = const 1_usize
  using: 
  _1933 = ((*_1).38: [[u32; 4]; 258])[_1934][_1938]
  using: _1@Phi(bb119), _1938@Mir(bb527[0]), _1934@Mir(bb526[3])
  _1931 = core::num::<impl u32>::wrapping_add(move _1932, move _1933) -> bb528
  using: _1932@Mir(bb526[1]), _1933@Mir(bb527[1])
bb528:
  _344 = move _1931
  using: _1931@Mir(bb527[2])
  _1940 = _345
  using: _345@Mir(bb522[0])
  _1943 = _346
  using: _346@Mir(bb524[1])
  _1942 = move _1943 as usize (IntToInt)
  using: _1943@Mir(bb528[2])
  _1944 = const 258_usize
  using: 
  _1945 = Lt(_1942, _1944)
  using: _1942@Mir(bb528[3]), _1944@Mir(bb528[4])
  assert(move _1945, "index out of bounds: the length is {} but the index is {}", move _1944, _1942) -> bb529
  using: _1945@Entry, _1944@Entry, _1942@Entry
bb529:
  _1946 = const 2_usize
  using: 
  _1941 = ((*_1).38: [[u32; 4]; 258])[_1942][_1946]
  using: _1@Phi(bb119), _1946@Mir(bb529[0]), _1942@Mir(bb528[3])
  _1939 = core::num::<impl u32>::wrapping_add(move _1940, move _1941) -> bb530
  using: _1940@Mir(bb528[1]), _1941@Mir(bb529[1])
bb530:
  _345 = move _1939
  using: _1939@Mir(bb529[2])
  _1948 = _343
  using: _343@Mir(bb526[0])
  _1949 = const 65535_u32
  using: 
  _1947 = BitAnd(move _1948, move _1949)
  using: _1948@Mir(bb530[1]), _1949@Mir(bb530[2])
  _1950 = const 0_usize
  using: 
  _19[_1950] = move _1947 as u16 (IntToInt)
  using: _1950@Mir(bb530[4]), _1947@Mir(bb530[3])
  _1952 = _343
  using: _343@Mir(bb526[0])
  _1953 = const 16_i32
  using: 
  _1954 = CheckedShr(_1952, _1953)
  using: _1952@Mir(bb530[6]), _1953@Mir(bb530[7])
  assert(!move (_1954.1: bool), "attempt to shift right by `{}`, which would overflow", move _1953) -> bb531
  using: _1954@Entry, _1952@Entry, _1953@Entry
bb531:
  _1951 = move (_1954.0: u32)
  using: _1954@Mir(bb530[8])
  _1955 = const 1_usize
  using: 
  _19[_1955] = move _1951 as u16 (IntToInt)
  using: _1955@Mir(bb531[1]), _1951@Mir(bb531[0])
  _1957 = _344
  using: _344@Mir(bb528[0])
  _1958 = const 65535_u32
  using: 
  _1956 = BitAnd(move _1957, move _1958)
  using: _1957@Mir(bb531[3]), _1958@Mir(bb531[4])
  _1959 = const 2_usize
  using: 
  _19[_1959] = move _1956 as u16 (IntToInt)
  using: _1959@Mir(bb531[6]), _1956@Mir(bb531[5])
  _1961 = _344
  using: _344@Mir(bb528[0])
  _1962 = const 16_i32
  using: 
  _1963 = CheckedShr(_1961, _1962)
  using: _1961@Mir(bb531[8]), _1962@Mir(bb531[9])
  assert(!move (_1963.1: bool), "attempt to shift right by `{}`, which would overflow", move _1962) -> bb532
  using: _1963@Entry, _1961@Entry, _1962@Entry
bb532:
  _1960 = move (_1963.0: u32)
  using: _1963@Mir(bb531[10])
  _1964 = const 3_usize
  using: 
  _19[_1964] = move _1960 as u16 (IntToInt)
  using: _1964@Mir(bb532[1]), _1960@Mir(bb532[0])
  _1966 = _345
  using: _345@Mir(bb530[0])
  _1967 = const 65535_u32
  using: 
  _1965 = BitAnd(move _1966, move _1967)
  using: _1966@Mir(bb532[3]), _1967@Mir(bb532[4])
  _1968 = const 4_usize
  using: 
  _19[_1968] = move _1965 as u16 (IntToInt)
  using: _1968@Mir(bb532[6]), _1965@Mir(bb532[5])
  _1970 = _345
  using: _345@Mir(bb530[0])
  _1971 = const 16_i32
  using: 
  _1972 = CheckedShr(_1970, _1971)
  using: _1970@Mir(bb532[8]), _1971@Mir(bb532[9])
  assert(!move (_1972.1: bool), "attempt to shift right by `{}`, which would overflow", move _1971) -> bb533
  using: _1972@Entry, _1970@Entry, _1971@Entry
bb533:
  _1969 = move (_1972.0: u32)
  using: _1972@Mir(bb532[10])
  _1973 = const 5_usize
  using: 
  _19[_1973] = move _1969 as u16 (IntToInt)
  using: _1973@Mir(bb533[1]), _1969@Mir(bb533[0])
  goto -> bb548
  using: 
bb534:
  _1974 = _6
  using: _6@Phi(bb127)
  _4 = move _1974
  using: _1974@Mir(bb534[0])
  goto -> bb535
  using: 
bb535:
  _1976 = _4
  using: _4@Phi(bb535)
  _1977 = _7
  using: _7@Phi(bb127)
  _1975 = Le(move _1976, move _1977)
  using: _1976@Mir(bb535[0]), _1977@Mir(bb535[1])
  switchInt(move _1975) -> [0: bb548, otherwise: bb536]
  using: _1975@Mir(bb535[2])
bb536:
  _1980 = _21
  using: _21@Phi(bb535)
  _1982 = _4
  using: _4@Phi(bb535)
  _1981 = move _1982 as isize (IntToInt)
  using: _1982@Mir(bb536[1])
  _1979 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _1980, move _1981) -> bb537
  using: _1980@Mir(bb536[0]), _1981@Mir(bb536[2])
bb537:
  _1978 = (*_1979)
  using: _1979@Mir(bb536[3])
  _3 = const 0_i32
  using: 
  goto -> bb538
  using: 
bb538:
  _1984 = _3
  using: _3@Phi(bb538)
  _1985 = _17
  using: _17@Phi(bb535)
  _1983 = Lt(move _1984, move _1985)
  using: _1984@Mir(bb538[0]), _1985@Mir(bb538[1])
  switchInt(move _1983) -> [0: bb546, otherwise: bb539]
  using: _1983@Mir(bb538[2])
bb539:
  _1990 = _3
  using: _3@Phi(bb538)
  _1989 = move _1990 as usize (IntToInt)
  using: _1990@Mir(bb539[0])
  _1991 = const 6_usize
  using: 
  _1992 = Lt(_1989, _1991)
  using: _1989@Mir(bb539[1]), _1991@Mir(bb539[2])
  assert(move _1992, "index out of bounds: the length is {} but the index is {}", move _1991, _1989) -> bb540
  using: _1992@Entry, _1991@Entry, _1989@Entry
bb540:
  _1988 = _19[_1989]
  using: _19@Phi(bb538), _1989@Mir(bb539[1])
  _1987 = move _1988 as i32 (IntToInt)
  using: _1988@Mir(bb540[0])
  _1996 = _3
  using: _3@Phi(bb538)
  _1995 = move _1996 as usize (IntToInt)
  using: _1996@Mir(bb540[2])
  _1997 = const 6_usize
  using: 
  _1998 = Lt(_1995, _1997)
  using: _1995@Mir(bb540[3]), _1997@Mir(bb540[4])
  assert(move _1998, "index out of bounds: the length is {} but the index is {}", move _1997, _1995) -> bb541
  using: _1998@Entry, _1997@Entry, _1995@Entry
bb541:
  _2000 = _1978
  using: _1978@Phi(bb538)
  _1999 = move _2000 as usize (IntToInt)
  using: _2000@Mir(bb541[0])
  _2001 = const 258_usize
  using: 
  _2002 = Lt(_1999, _2001)
  using: _1999@Mir(bb541[1]), _2001@Mir(bb541[2])
  assert(move _2002, "index out of bounds: the length is {} but the index is {}", move _2001, _1999) -> bb542
  using: _2002@Entry, _2001@Entry, _1999@Entry
bb542:
  _1994 = ((*_1).35: [[u8; 258]; 6])[_1995][_1999]
  using: _1@Phi(bb538), _1999@Mir(bb541[1]), _1995@Mir(bb540[3])
  _1993 = move _1994 as i32 (IntToInt)
  using: _1994@Mir(bb542[0])
  _2003 = CheckedAdd(_1987, _1993)
  using: _1987@Mir(bb540[1]), _1993@Mir(bb542[1])
  assert(!move (_2003.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1987, move _1993) -> bb543
  using: _2003@Entry, _1987@Entry, _1993@Entry
bb543:
  _1986 = move (_2003.0: i32)
  using: _2003@Mir(bb542[2])
  _2005 = _3
  using: _3@Phi(bb538)
  _2004 = move _2005 as usize (IntToInt)
  using: _2005@Mir(bb543[1])
  _2006 = const 6_usize
  using: 
  _2007 = Lt(_2004, _2006)
  using: _2004@Mir(bb543[2]), _2006@Mir(bb543[3])
  assert(move _2007, "index out of bounds: the length is {} but the index is {}", move _2006, _2004) -> bb544
  using: _2007@Entry, _2006@Entry, _2004@Entry
bb544:
  _19[_2004] = move _1986 as u16 (IntToInt)
  using: _2004@Mir(bb543[2]), _1986@Mir(bb543[0])
  _2008 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb538)
  assert(!move (_2008.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb545
  using: _2008@Entry, _3@Entry
bb545:
  _3 = move (_2008.0: i32)
  using: _2008@Mir(bb544[1])
  goto -> bb538
  using: 
bb546:
  _2009 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb535)
  assert(!move (_2009.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb547
  using: _2009@Entry, _4@Entry
bb547:
  _4 = move (_2009.0: i32)
  using: _2009@Mir(bb546[0])
  goto -> bb535
  using: 
bb548:
  _10 = const 999999999_i32
  using: 
  _9 = const -1_i32
  using: 
  _3 = const 0_i32
  using: 
  goto -> bb549
  using: 
bb549:
  _2011 = _3
  using: _3@Phi(bb549)
  _2012 = _17
  using: _17@Phi(bb548)
  _2010 = Lt(move _2011, move _2012)
  using: _2011@Mir(bb549[0]), _2012@Mir(bb549[1])
  switchInt(move _2010) -> [0: bb556, otherwise: bb550]
  using: _2010@Mir(bb549[2])
bb550:
  _2017 = _3
  using: _3@Phi(bb549)
  _2016 = move _2017 as usize (IntToInt)
  using: _2017@Mir(bb550[0])
  _2018 = const 6_usize
  using: 
  _2019 = Lt(_2016, _2018)
  using: _2016@Mir(bb550[1]), _2018@Mir(bb550[2])
  assert(move _2019, "index out of bounds: the length is {} but the index is {}", move _2018, _2016) -> bb551
  using: _2019@Entry, _2018@Entry, _2016@Entry
bb551:
  _2015 = _19[_2016]
  using: _19@Phi(bb549), _2016@Mir(bb550[1])
  _2014 = move _2015 as i32 (IntToInt)
  using: _2015@Mir(bb551[0])
  _2020 = _10
  using: _10@Phi(bb549)
  _2013 = Lt(move _2014, move _2020)
  using: _2014@Mir(bb551[1]), _2020@Mir(bb551[2])
  switchInt(move _2013) -> [0: bb554, otherwise: bb552]
  using: _2013@Mir(bb551[3])
bb552:
  _2023 = _3
  using: _3@Phi(bb549)
  _2022 = move _2023 as usize (IntToInt)
  using: _2023@Mir(bb552[0])
  _2024 = const 6_usize
  using: 
  _2025 = Lt(_2022, _2024)
  using: _2022@Mir(bb552[1]), _2024@Mir(bb552[2])
  assert(move _2025, "index out of bounds: the length is {} but the index is {}", move _2024, _2022) -> bb553
  using: _2025@Entry, _2024@Entry, _2022@Entry
bb553:
  _2021 = _19[_2022]
  using: _19@Phi(bb549), _2022@Mir(bb552[1])
  _10 = move _2021 as i32 (IntToInt)
  using: _2021@Mir(bb553[0])
  _2026 = _3
  using: _3@Phi(bb549)
  _9 = move _2026
  using: _2026@Mir(bb553[2])
  goto -> bb554
  using: 
bb554:
  _2027 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb554)
  assert(!move (_2027.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb555
  using: _2027@Entry, _3@Entry
bb555:
  _3 = move (_2027.0: i32)
  using: _2027@Mir(bb554[0])
  goto -> bb549
  using: 
bb556:
  _2028 = _10
  using: _10@Phi(bb554)
  _2029 = CheckedAdd(_8, _2028)
  using: _8@Phi(bb838), _2028@Mir(bb556[0])
  assert(!move (_2029.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, move _2028) -> bb557
  using: _2029@Entry, _8@Entry, _2028@Entry
bb557:
  _8 = move (_2029.0: i32)
  using: _2029@Mir(bb556[1])
  _2031 = _9
  using: _9@Phi(bb554)
  _2030 = move _2031 as usize (IntToInt)
  using: _2031@Mir(bb557[1])
  _2032 = const 6_usize
  using: 
  _2033 = Lt(_2030, _2032)
  using: _2030@Mir(bb557[2]), _2032@Mir(bb557[3])
  assert(move _2033, "index out of bounds: the length is {} but the index is {}", move _2032, _2030) -> bb558
  using: _2033@Entry, _2032@Entry, _2030@Entry
bb558:
  _2034 = CheckedAdd(_20[_2030], const 1_i32)
  using: _20@Phi(bb838), _2030@Mir(bb557[2])
  assert(!move (_2034.1: bool), "attempt to compute `{} + {}`, which would overflow", _20[_2030], const 1_i32) -> bb559
  using: _2034@Entry, _20@Entry, _2030@Entry
bb559:
  _20[_2030] = move (_2034.0: i32)
  using: _2030@Mir(bb557[2]), _2034@Mir(bb558[0])
  _2035 = _9
  using: _9@Phi(bb554)
  _2037 = _12
  using: _12@Phi(bb112)
  _2036 = move _2037 as usize (IntToInt)
  using: _2037@Mir(bb559[2])
  _2038 = const 18002_usize
  using: 
  _2039 = Lt(_2036, _2038)
  using: _2036@Mir(bb559[3]), _2038@Mir(bb559[4])
  assert(move _2039, "index out of bounds: the length is {} but the index is {}", move _2038, _2036) -> bb560
  using: _2039@Entry, _2038@Entry, _2036@Entry
bb560:
  ((*_1).33: [u8; 18002])[_2036] = move _2035 as u8 (IntToInt)
  using: _1@Phi(bb548), _2036@Mir(bb559[3]), _2035@Mir(bb559[1])
  _2040 = CheckedAdd(_12, const 1_i32)
  using: _12@Phi(bb112)
  assert(!move (_2040.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_i32) -> bb561
  using: _2040@Entry, _12@Entry
bb561:
  _12 = move (_2040.0: i32)
  using: _2040@Mir(bb560[1])
  _2043 = _17
  using: _17@Phi(bb548)
  _2044 = const 6_i32
  using: 
  _2042 = Eq(move _2043, move _2044)
  using: _2043@Mir(bb561[1]), _2044@Mir(bb561[2])
  switchInt(move _2042) -> [0: bb562, otherwise: bb563]
  using: _2042@Mir(bb561[3])
bb562:
  _2041 = const false
  using: 
  goto -> bb564
  using: 
bb563:
  _2046 = const 50_i32
  using: 
  _2049 = _7
  using: _7@Phi(bb548)
  _2050 = _6
  using: _6@Phi(bb548)
  _2051 = CheckedSub(_2049, _2050)
  using: _2049@Mir(bb563[1]), _2050@Mir(bb563[2])
  assert(!move (_2051.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2049, move _2050) -> bb565
  using: _2051@Entry, _2049@Entry, _2050@Entry
bb564:
  switchInt(move _2041) -> [0: bb818, otherwise: bb567]
  using: _2041@Phi(bb564)
bb565:
  _2048 = move (_2051.0: i32)
  using: _2051@Mir(bb563[3])
  _2052 = const 1_i32
  using: 
  _2053 = CheckedAdd(_2048, _2052)
  using: _2048@Mir(bb565[0]), _2052@Mir(bb565[1])
  assert(!move (_2053.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2048, move _2052) -> bb566
  using: _2053@Entry, _2048@Entry, _2052@Entry
bb566:
  _2047 = move (_2053.0: i32)
  using: _2053@Mir(bb565[2])
  _2045 = Eq(move _2046, move _2047)
  using: _2046@Mir(bb563[0]), _2047@Mir(bb566[0])
  _2041 = move _2045
  using: _2045@Mir(bb566[1])
  goto -> bb564
  using: 
bb567:
  _2055 = _9
  using: _9@Phi(bb554)
  _2054 = move _2055 as usize (IntToInt)
  using: _2055@Mir(bb567[0])
  _2056 = const 6_usize
  using: 
  _2057 = Lt(_2054, _2056)
  using: _2054@Mir(bb567[1]), _2056@Mir(bb567[2])
  assert(move _2057, "index out of bounds: the length is {} but the index is {}", move _2056, _2054) -> bb568
  using: _2057@Entry, _2056@Entry, _2054@Entry
bb568:
  _2061 = _21
  using: _21@Phi(bb548)
  _2064 = _6
  using: _6@Phi(bb564)
  _2065 = const 0_i32
  using: 
  _2066 = CheckedAdd(_2064, _2065)
  using: _2064@Mir(bb568[1]), _2065@Mir(bb568[2])
  assert(!move (_2066.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2064, move _2065) -> bb569
  using: _2066@Entry, _2064@Entry, _2065@Entry
bb569:
  _2063 = move (_2066.0: i32)
  using: _2066@Mir(bb568[3])
  _2062 = move _2063 as isize (IntToInt)
  using: _2063@Mir(bb569[0])
  _2060 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2061, move _2062) -> bb570
  using: _2061@Mir(bb568[0]), _2062@Mir(bb569[1])
bb570:
  _2059 = (*_2060)
  using: _2060@Mir(bb569[2])
  _2058 = move _2059 as usize (IntToInt)
  using: _2059@Mir(bb570[0])
  _2067 = const 258_usize
  using: 
  _2068 = Lt(_2058, _2067)
  using: _2058@Mir(bb570[1]), _2067@Mir(bb570[2])
  assert(move _2068, "index out of bounds: the length is {} but the index is {}", move _2067, _2058) -> bb571
  using: _2068@Entry, _2067@Entry, _2058@Entry
bb571:
  _2069 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2054][_2058], const 1_i32)
  using: _1@Phi(bb548), _2058@Mir(bb570[1]), _2054@Mir(bb567[1])
  assert(!move (_2069.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2054][_2058], const 1_i32) -> bb572
  using: _2069@Entry, _1@Entry, _2058@Entry, _2054@Entry
bb572:
  ((*_1).37: [[i32; 258]; 6])[_2054][_2058] = move (_2069.0: i32)
  using: _1@Phi(bb548), _2058@Mir(bb570[1]), _2054@Mir(bb567[1]), _2069@Mir(bb571[0])
  _2071 = _9
  using: _9@Phi(bb554)
  _2070 = move _2071 as usize (IntToInt)
  using: _2071@Mir(bb572[1])
  _2072 = const 6_usize
  using: 
  _2073 = Lt(_2070, _2072)
  using: _2070@Mir(bb572[2]), _2072@Mir(bb572[3])
  assert(move _2073, "index out of bounds: the length is {} but the index is {}", move _2072, _2070) -> bb573
  using: _2073@Entry, _2072@Entry, _2070@Entry
bb573:
  _2077 = _21
  using: _21@Phi(bb548)
  _2080 = _6
  using: _6@Phi(bb564)
  _2081 = const 1_i32
  using: 
  _2082 = CheckedAdd(_2080, _2081)
  using: _2080@Mir(bb573[1]), _2081@Mir(bb573[2])
  assert(!move (_2082.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2080, move _2081) -> bb574
  using: _2082@Entry, _2080@Entry, _2081@Entry
bb574:
  _2079 = move (_2082.0: i32)
  using: _2082@Mir(bb573[3])
  _2078 = move _2079 as isize (IntToInt)
  using: _2079@Mir(bb574[0])
  _2076 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2077, move _2078) -> bb575
  using: _2077@Mir(bb573[0]), _2078@Mir(bb574[1])
bb575:
  _2075 = (*_2076)
  using: _2076@Mir(bb574[2])
  _2074 = move _2075 as usize (IntToInt)
  using: _2075@Mir(bb575[0])
  _2083 = const 258_usize
  using: 
  _2084 = Lt(_2074, _2083)
  using: _2074@Mir(bb575[1]), _2083@Mir(bb575[2])
  assert(move _2084, "index out of bounds: the length is {} but the index is {}", move _2083, _2074) -> bb576
  using: _2084@Entry, _2083@Entry, _2074@Entry
bb576:
  _2085 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2070][_2074], const 1_i32)
  using: _1@Phi(bb548), _2074@Mir(bb575[1]), _2070@Mir(bb572[2])
  assert(!move (_2085.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2070][_2074], const 1_i32) -> bb577
  using: _2085@Entry, _1@Entry, _2074@Entry, _2070@Entry
bb577:
  ((*_1).37: [[i32; 258]; 6])[_2070][_2074] = move (_2085.0: i32)
  using: _1@Phi(bb548), _2074@Mir(bb575[1]), _2070@Mir(bb572[2]), _2085@Mir(bb576[0])
  _2087 = _9
  using: _9@Phi(bb554)
  _2086 = move _2087 as usize (IntToInt)
  using: _2087@Mir(bb577[1])
  _2088 = const 6_usize
  using: 
  _2089 = Lt(_2086, _2088)
  using: _2086@Mir(bb577[2]), _2088@Mir(bb577[3])
  assert(move _2089, "index out of bounds: the length is {} but the index is {}", move _2088, _2086) -> bb578
  using: _2089@Entry, _2088@Entry, _2086@Entry
bb578:
  _2093 = _21
  using: _21@Phi(bb548)
  _2096 = _6
  using: _6@Phi(bb564)
  _2097 = const 2_i32
  using: 
  _2098 = CheckedAdd(_2096, _2097)
  using: _2096@Mir(bb578[1]), _2097@Mir(bb578[2])
  assert(!move (_2098.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2096, move _2097) -> bb579
  using: _2098@Entry, _2096@Entry, _2097@Entry
bb579:
  _2095 = move (_2098.0: i32)
  using: _2098@Mir(bb578[3])
  _2094 = move _2095 as isize (IntToInt)
  using: _2095@Mir(bb579[0])
  _2092 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2093, move _2094) -> bb580
  using: _2093@Mir(bb578[0]), _2094@Mir(bb579[1])
bb580:
  _2091 = (*_2092)
  using: _2092@Mir(bb579[2])
  _2090 = move _2091 as usize (IntToInt)
  using: _2091@Mir(bb580[0])
  _2099 = const 258_usize
  using: 
  _2100 = Lt(_2090, _2099)
  using: _2090@Mir(bb580[1]), _2099@Mir(bb580[2])
  assert(move _2100, "index out of bounds: the length is {} but the index is {}", move _2099, _2090) -> bb581
  using: _2100@Entry, _2099@Entry, _2090@Entry
bb581:
  _2101 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2086][_2090], const 1_i32)
  using: _1@Phi(bb548), _2090@Mir(bb580[1]), _2086@Mir(bb577[2])
  assert(!move (_2101.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2086][_2090], const 1_i32) -> bb582
  using: _2101@Entry, _1@Entry, _2090@Entry, _2086@Entry
bb582:
  ((*_1).37: [[i32; 258]; 6])[_2086][_2090] = move (_2101.0: i32)
  using: _1@Phi(bb548), _2090@Mir(bb580[1]), _2086@Mir(bb577[2]), _2101@Mir(bb581[0])
  _2103 = _9
  using: _9@Phi(bb554)
  _2102 = move _2103 as usize (IntToInt)
  using: _2103@Mir(bb582[1])
  _2104 = const 6_usize
  using: 
  _2105 = Lt(_2102, _2104)
  using: _2102@Mir(bb582[2]), _2104@Mir(bb582[3])
  assert(move _2105, "index out of bounds: the length is {} but the index is {}", move _2104, _2102) -> bb583
  using: _2105@Entry, _2104@Entry, _2102@Entry
bb583:
  _2109 = _21
  using: _21@Phi(bb548)
  _2112 = _6
  using: _6@Phi(bb564)
  _2113 = const 3_i32
  using: 
  _2114 = CheckedAdd(_2112, _2113)
  using: _2112@Mir(bb583[1]), _2113@Mir(bb583[2])
  assert(!move (_2114.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2112, move _2113) -> bb584
  using: _2114@Entry, _2112@Entry, _2113@Entry
bb584:
  _2111 = move (_2114.0: i32)
  using: _2114@Mir(bb583[3])
  _2110 = move _2111 as isize (IntToInt)
  using: _2111@Mir(bb584[0])
  _2108 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2109, move _2110) -> bb585
  using: _2109@Mir(bb583[0]), _2110@Mir(bb584[1])
bb585:
  _2107 = (*_2108)
  using: _2108@Mir(bb584[2])
  _2106 = move _2107 as usize (IntToInt)
  using: _2107@Mir(bb585[0])
  _2115 = const 258_usize
  using: 
  _2116 = Lt(_2106, _2115)
  using: _2106@Mir(bb585[1]), _2115@Mir(bb585[2])
  assert(move _2116, "index out of bounds: the length is {} but the index is {}", move _2115, _2106) -> bb586
  using: _2116@Entry, _2115@Entry, _2106@Entry
bb586:
  _2117 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2102][_2106], const 1_i32)
  using: _1@Phi(bb548), _2106@Mir(bb585[1]), _2102@Mir(bb582[2])
  assert(!move (_2117.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2102][_2106], const 1_i32) -> bb587
  using: _2117@Entry, _1@Entry, _2106@Entry, _2102@Entry
bb587:
  ((*_1).37: [[i32; 258]; 6])[_2102][_2106] = move (_2117.0: i32)
  using: _1@Phi(bb548), _2106@Mir(bb585[1]), _2102@Mir(bb582[2]), _2117@Mir(bb586[0])
  _2119 = _9
  using: _9@Phi(bb554)
  _2118 = move _2119 as usize (IntToInt)
  using: _2119@Mir(bb587[1])
  _2120 = const 6_usize
  using: 
  _2121 = Lt(_2118, _2120)
  using: _2118@Mir(bb587[2]), _2120@Mir(bb587[3])
  assert(move _2121, "index out of bounds: the length is {} but the index is {}", move _2120, _2118) -> bb588
  using: _2121@Entry, _2120@Entry, _2118@Entry
bb588:
  _2125 = _21
  using: _21@Phi(bb548)
  _2128 = _6
  using: _6@Phi(bb564)
  _2129 = const 4_i32
  using: 
  _2130 = CheckedAdd(_2128, _2129)
  using: _2128@Mir(bb588[1]), _2129@Mir(bb588[2])
  assert(!move (_2130.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2128, move _2129) -> bb589
  using: _2130@Entry, _2128@Entry, _2129@Entry
bb589:
  _2127 = move (_2130.0: i32)
  using: _2130@Mir(bb588[3])
  _2126 = move _2127 as isize (IntToInt)
  using: _2127@Mir(bb589[0])
  _2124 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2125, move _2126) -> bb590
  using: _2125@Mir(bb588[0]), _2126@Mir(bb589[1])
bb590:
  _2123 = (*_2124)
  using: _2124@Mir(bb589[2])
  _2122 = move _2123 as usize (IntToInt)
  using: _2123@Mir(bb590[0])
  _2131 = const 258_usize
  using: 
  _2132 = Lt(_2122, _2131)
  using: _2122@Mir(bb590[1]), _2131@Mir(bb590[2])
  assert(move _2132, "index out of bounds: the length is {} but the index is {}", move _2131, _2122) -> bb591
  using: _2132@Entry, _2131@Entry, _2122@Entry
bb591:
  _2133 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2118][_2122], const 1_i32)
  using: _1@Phi(bb548), _2122@Mir(bb590[1]), _2118@Mir(bb587[2])
  assert(!move (_2133.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2118][_2122], const 1_i32) -> bb592
  using: _2133@Entry, _1@Entry, _2122@Entry, _2118@Entry
bb592:
  ((*_1).37: [[i32; 258]; 6])[_2118][_2122] = move (_2133.0: i32)
  using: _1@Phi(bb548), _2122@Mir(bb590[1]), _2118@Mir(bb587[2]), _2133@Mir(bb591[0])
  _2135 = _9
  using: _9@Phi(bb554)
  _2134 = move _2135 as usize (IntToInt)
  using: _2135@Mir(bb592[1])
  _2136 = const 6_usize
  using: 
  _2137 = Lt(_2134, _2136)
  using: _2134@Mir(bb592[2]), _2136@Mir(bb592[3])
  assert(move _2137, "index out of bounds: the length is {} but the index is {}", move _2136, _2134) -> bb593
  using: _2137@Entry, _2136@Entry, _2134@Entry
bb593:
  _2141 = _21
  using: _21@Phi(bb548)
  _2144 = _6
  using: _6@Phi(bb564)
  _2145 = const 5_i32
  using: 
  _2146 = CheckedAdd(_2144, _2145)
  using: _2144@Mir(bb593[1]), _2145@Mir(bb593[2])
  assert(!move (_2146.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2144, move _2145) -> bb594
  using: _2146@Entry, _2144@Entry, _2145@Entry
bb594:
  _2143 = move (_2146.0: i32)
  using: _2146@Mir(bb593[3])
  _2142 = move _2143 as isize (IntToInt)
  using: _2143@Mir(bb594[0])
  _2140 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2141, move _2142) -> bb595
  using: _2141@Mir(bb593[0]), _2142@Mir(bb594[1])
bb595:
  _2139 = (*_2140)
  using: _2140@Mir(bb594[2])
  _2138 = move _2139 as usize (IntToInt)
  using: _2139@Mir(bb595[0])
  _2147 = const 258_usize
  using: 
  _2148 = Lt(_2138, _2147)
  using: _2138@Mir(bb595[1]), _2147@Mir(bb595[2])
  assert(move _2148, "index out of bounds: the length is {} but the index is {}", move _2147, _2138) -> bb596
  using: _2148@Entry, _2147@Entry, _2138@Entry
bb596:
  _2149 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2134][_2138], const 1_i32)
  using: _1@Phi(bb548), _2138@Mir(bb595[1]), _2134@Mir(bb592[2])
  assert(!move (_2149.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2134][_2138], const 1_i32) -> bb597
  using: _2149@Entry, _1@Entry, _2138@Entry, _2134@Entry
bb597:
  ((*_1).37: [[i32; 258]; 6])[_2134][_2138] = move (_2149.0: i32)
  using: _1@Phi(bb548), _2138@Mir(bb595[1]), _2134@Mir(bb592[2]), _2149@Mir(bb596[0])
  _2151 = _9
  using: _9@Phi(bb554)
  _2150 = move _2151 as usize (IntToInt)
  using: _2151@Mir(bb597[1])
  _2152 = const 6_usize
  using: 
  _2153 = Lt(_2150, _2152)
  using: _2150@Mir(bb597[2]), _2152@Mir(bb597[3])
  assert(move _2153, "index out of bounds: the length is {} but the index is {}", move _2152, _2150) -> bb598
  using: _2153@Entry, _2152@Entry, _2150@Entry
bb598:
  _2157 = _21
  using: _21@Phi(bb548)
  _2160 = _6
  using: _6@Phi(bb564)
  _2161 = const 6_i32
  using: 
  _2162 = CheckedAdd(_2160, _2161)
  using: _2160@Mir(bb598[1]), _2161@Mir(bb598[2])
  assert(!move (_2162.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2160, move _2161) -> bb599
  using: _2162@Entry, _2160@Entry, _2161@Entry
bb599:
  _2159 = move (_2162.0: i32)
  using: _2162@Mir(bb598[3])
  _2158 = move _2159 as isize (IntToInt)
  using: _2159@Mir(bb599[0])
  _2156 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2157, move _2158) -> bb600
  using: _2157@Mir(bb598[0]), _2158@Mir(bb599[1])
bb600:
  _2155 = (*_2156)
  using: _2156@Mir(bb599[2])
  _2154 = move _2155 as usize (IntToInt)
  using: _2155@Mir(bb600[0])
  _2163 = const 258_usize
  using: 
  _2164 = Lt(_2154, _2163)
  using: _2154@Mir(bb600[1]), _2163@Mir(bb600[2])
  assert(move _2164, "index out of bounds: the length is {} but the index is {}", move _2163, _2154) -> bb601
  using: _2164@Entry, _2163@Entry, _2154@Entry
bb601:
  _2165 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2150][_2154], const 1_i32)
  using: _1@Phi(bb548), _2154@Mir(bb600[1]), _2150@Mir(bb597[2])
  assert(!move (_2165.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2150][_2154], const 1_i32) -> bb602
  using: _2165@Entry, _1@Entry, _2154@Entry, _2150@Entry
bb602:
  ((*_1).37: [[i32; 258]; 6])[_2150][_2154] = move (_2165.0: i32)
  using: _1@Phi(bb548), _2154@Mir(bb600[1]), _2150@Mir(bb597[2]), _2165@Mir(bb601[0])
  _2167 = _9
  using: _9@Phi(bb554)
  _2166 = move _2167 as usize (IntToInt)
  using: _2167@Mir(bb602[1])
  _2168 = const 6_usize
  using: 
  _2169 = Lt(_2166, _2168)
  using: _2166@Mir(bb602[2]), _2168@Mir(bb602[3])
  assert(move _2169, "index out of bounds: the length is {} but the index is {}", move _2168, _2166) -> bb603
  using: _2169@Entry, _2168@Entry, _2166@Entry
bb603:
  _2173 = _21
  using: _21@Phi(bb548)
  _2176 = _6
  using: _6@Phi(bb564)
  _2177 = const 7_i32
  using: 
  _2178 = CheckedAdd(_2176, _2177)
  using: _2176@Mir(bb603[1]), _2177@Mir(bb603[2])
  assert(!move (_2178.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2176, move _2177) -> bb604
  using: _2178@Entry, _2176@Entry, _2177@Entry
bb604:
  _2175 = move (_2178.0: i32)
  using: _2178@Mir(bb603[3])
  _2174 = move _2175 as isize (IntToInt)
  using: _2175@Mir(bb604[0])
  _2172 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2173, move _2174) -> bb605
  using: _2173@Mir(bb603[0]), _2174@Mir(bb604[1])
bb605:
  _2171 = (*_2172)
  using: _2172@Mir(bb604[2])
  _2170 = move _2171 as usize (IntToInt)
  using: _2171@Mir(bb605[0])
  _2179 = const 258_usize
  using: 
  _2180 = Lt(_2170, _2179)
  using: _2170@Mir(bb605[1]), _2179@Mir(bb605[2])
  assert(move _2180, "index out of bounds: the length is {} but the index is {}", move _2179, _2170) -> bb606
  using: _2180@Entry, _2179@Entry, _2170@Entry
bb606:
  _2181 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2166][_2170], const 1_i32)
  using: _1@Phi(bb548), _2170@Mir(bb605[1]), _2166@Mir(bb602[2])
  assert(!move (_2181.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2166][_2170], const 1_i32) -> bb607
  using: _2181@Entry, _1@Entry, _2170@Entry, _2166@Entry
bb607:
  ((*_1).37: [[i32; 258]; 6])[_2166][_2170] = move (_2181.0: i32)
  using: _1@Phi(bb548), _2170@Mir(bb605[1]), _2166@Mir(bb602[2]), _2181@Mir(bb606[0])
  _2183 = _9
  using: _9@Phi(bb554)
  _2182 = move _2183 as usize (IntToInt)
  using: _2183@Mir(bb607[1])
  _2184 = const 6_usize
  using: 
  _2185 = Lt(_2182, _2184)
  using: _2182@Mir(bb607[2]), _2184@Mir(bb607[3])
  assert(move _2185, "index out of bounds: the length is {} but the index is {}", move _2184, _2182) -> bb608
  using: _2185@Entry, _2184@Entry, _2182@Entry
bb608:
  _2189 = _21
  using: _21@Phi(bb548)
  _2192 = _6
  using: _6@Phi(bb564)
  _2193 = const 8_i32
  using: 
  _2194 = CheckedAdd(_2192, _2193)
  using: _2192@Mir(bb608[1]), _2193@Mir(bb608[2])
  assert(!move (_2194.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2192, move _2193) -> bb609
  using: _2194@Entry, _2192@Entry, _2193@Entry
bb609:
  _2191 = move (_2194.0: i32)
  using: _2194@Mir(bb608[3])
  _2190 = move _2191 as isize (IntToInt)
  using: _2191@Mir(bb609[0])
  _2188 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2189, move _2190) -> bb610
  using: _2189@Mir(bb608[0]), _2190@Mir(bb609[1])
bb610:
  _2187 = (*_2188)
  using: _2188@Mir(bb609[2])
  _2186 = move _2187 as usize (IntToInt)
  using: _2187@Mir(bb610[0])
  _2195 = const 258_usize
  using: 
  _2196 = Lt(_2186, _2195)
  using: _2186@Mir(bb610[1]), _2195@Mir(bb610[2])
  assert(move _2196, "index out of bounds: the length is {} but the index is {}", move _2195, _2186) -> bb611
  using: _2196@Entry, _2195@Entry, _2186@Entry
bb611:
  _2197 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2182][_2186], const 1_i32)
  using: _1@Phi(bb548), _2186@Mir(bb610[1]), _2182@Mir(bb607[2])
  assert(!move (_2197.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2182][_2186], const 1_i32) -> bb612
  using: _2197@Entry, _1@Entry, _2186@Entry, _2182@Entry
bb612:
  ((*_1).37: [[i32; 258]; 6])[_2182][_2186] = move (_2197.0: i32)
  using: _1@Phi(bb548), _2186@Mir(bb610[1]), _2182@Mir(bb607[2]), _2197@Mir(bb611[0])
  _2199 = _9
  using: _9@Phi(bb554)
  _2198 = move _2199 as usize (IntToInt)
  using: _2199@Mir(bb612[1])
  _2200 = const 6_usize
  using: 
  _2201 = Lt(_2198, _2200)
  using: _2198@Mir(bb612[2]), _2200@Mir(bb612[3])
  assert(move _2201, "index out of bounds: the length is {} but the index is {}", move _2200, _2198) -> bb613
  using: _2201@Entry, _2200@Entry, _2198@Entry
bb613:
  _2205 = _21
  using: _21@Phi(bb548)
  _2208 = _6
  using: _6@Phi(bb564)
  _2209 = const 9_i32
  using: 
  _2210 = CheckedAdd(_2208, _2209)
  using: _2208@Mir(bb613[1]), _2209@Mir(bb613[2])
  assert(!move (_2210.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2208, move _2209) -> bb614
  using: _2210@Entry, _2208@Entry, _2209@Entry
bb614:
  _2207 = move (_2210.0: i32)
  using: _2210@Mir(bb613[3])
  _2206 = move _2207 as isize (IntToInt)
  using: _2207@Mir(bb614[0])
  _2204 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2205, move _2206) -> bb615
  using: _2205@Mir(bb613[0]), _2206@Mir(bb614[1])
bb615:
  _2203 = (*_2204)
  using: _2204@Mir(bb614[2])
  _2202 = move _2203 as usize (IntToInt)
  using: _2203@Mir(bb615[0])
  _2211 = const 258_usize
  using: 
  _2212 = Lt(_2202, _2211)
  using: _2202@Mir(bb615[1]), _2211@Mir(bb615[2])
  assert(move _2212, "index out of bounds: the length is {} but the index is {}", move _2211, _2202) -> bb616
  using: _2212@Entry, _2211@Entry, _2202@Entry
bb616:
  _2213 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2198][_2202], const 1_i32)
  using: _1@Phi(bb548), _2202@Mir(bb615[1]), _2198@Mir(bb612[2])
  assert(!move (_2213.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2198][_2202], const 1_i32) -> bb617
  using: _2213@Entry, _1@Entry, _2202@Entry, _2198@Entry
bb617:
  ((*_1).37: [[i32; 258]; 6])[_2198][_2202] = move (_2213.0: i32)
  using: _1@Phi(bb548), _2202@Mir(bb615[1]), _2198@Mir(bb612[2]), _2213@Mir(bb616[0])
  _2215 = _9
  using: _9@Phi(bb554)
  _2214 = move _2215 as usize (IntToInt)
  using: _2215@Mir(bb617[1])
  _2216 = const 6_usize
  using: 
  _2217 = Lt(_2214, _2216)
  using: _2214@Mir(bb617[2]), _2216@Mir(bb617[3])
  assert(move _2217, "index out of bounds: the length is {} but the index is {}", move _2216, _2214) -> bb618
  using: _2217@Entry, _2216@Entry, _2214@Entry
bb618:
  _2221 = _21
  using: _21@Phi(bb548)
  _2224 = _6
  using: _6@Phi(bb564)
  _2225 = const 10_i32
  using: 
  _2226 = CheckedAdd(_2224, _2225)
  using: _2224@Mir(bb618[1]), _2225@Mir(bb618[2])
  assert(!move (_2226.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2224, move _2225) -> bb619
  using: _2226@Entry, _2224@Entry, _2225@Entry
bb619:
  _2223 = move (_2226.0: i32)
  using: _2226@Mir(bb618[3])
  _2222 = move _2223 as isize (IntToInt)
  using: _2223@Mir(bb619[0])
  _2220 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2221, move _2222) -> bb620
  using: _2221@Mir(bb618[0]), _2222@Mir(bb619[1])
bb620:
  _2219 = (*_2220)
  using: _2220@Mir(bb619[2])
  _2218 = move _2219 as usize (IntToInt)
  using: _2219@Mir(bb620[0])
  _2227 = const 258_usize
  using: 
  _2228 = Lt(_2218, _2227)
  using: _2218@Mir(bb620[1]), _2227@Mir(bb620[2])
  assert(move _2228, "index out of bounds: the length is {} but the index is {}", move _2227, _2218) -> bb621
  using: _2228@Entry, _2227@Entry, _2218@Entry
bb621:
  _2229 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2214][_2218], const 1_i32)
  using: _1@Phi(bb548), _2218@Mir(bb620[1]), _2214@Mir(bb617[2])
  assert(!move (_2229.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2214][_2218], const 1_i32) -> bb622
  using: _2229@Entry, _1@Entry, _2218@Entry, _2214@Entry
bb622:
  ((*_1).37: [[i32; 258]; 6])[_2214][_2218] = move (_2229.0: i32)
  using: _1@Phi(bb548), _2218@Mir(bb620[1]), _2214@Mir(bb617[2]), _2229@Mir(bb621[0])
  _2231 = _9
  using: _9@Phi(bb554)
  _2230 = move _2231 as usize (IntToInt)
  using: _2231@Mir(bb622[1])
  _2232 = const 6_usize
  using: 
  _2233 = Lt(_2230, _2232)
  using: _2230@Mir(bb622[2]), _2232@Mir(bb622[3])
  assert(move _2233, "index out of bounds: the length is {} but the index is {}", move _2232, _2230) -> bb623
  using: _2233@Entry, _2232@Entry, _2230@Entry
bb623:
  _2237 = _21
  using: _21@Phi(bb548)
  _2240 = _6
  using: _6@Phi(bb564)
  _2241 = const 11_i32
  using: 
  _2242 = CheckedAdd(_2240, _2241)
  using: _2240@Mir(bb623[1]), _2241@Mir(bb623[2])
  assert(!move (_2242.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2240, move _2241) -> bb624
  using: _2242@Entry, _2240@Entry, _2241@Entry
bb624:
  _2239 = move (_2242.0: i32)
  using: _2242@Mir(bb623[3])
  _2238 = move _2239 as isize (IntToInt)
  using: _2239@Mir(bb624[0])
  _2236 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2237, move _2238) -> bb625
  using: _2237@Mir(bb623[0]), _2238@Mir(bb624[1])
bb625:
  _2235 = (*_2236)
  using: _2236@Mir(bb624[2])
  _2234 = move _2235 as usize (IntToInt)
  using: _2235@Mir(bb625[0])
  _2243 = const 258_usize
  using: 
  _2244 = Lt(_2234, _2243)
  using: _2234@Mir(bb625[1]), _2243@Mir(bb625[2])
  assert(move _2244, "index out of bounds: the length is {} but the index is {}", move _2243, _2234) -> bb626
  using: _2244@Entry, _2243@Entry, _2234@Entry
bb626:
  _2245 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2230][_2234], const 1_i32)
  using: _1@Phi(bb548), _2234@Mir(bb625[1]), _2230@Mir(bb622[2])
  assert(!move (_2245.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2230][_2234], const 1_i32) -> bb627
  using: _2245@Entry, _1@Entry, _2234@Entry, _2230@Entry
bb627:
  ((*_1).37: [[i32; 258]; 6])[_2230][_2234] = move (_2245.0: i32)
  using: _1@Phi(bb548), _2234@Mir(bb625[1]), _2230@Mir(bb622[2]), _2245@Mir(bb626[0])
  _2247 = _9
  using: _9@Phi(bb554)
  _2246 = move _2247 as usize (IntToInt)
  using: _2247@Mir(bb627[1])
  _2248 = const 6_usize
  using: 
  _2249 = Lt(_2246, _2248)
  using: _2246@Mir(bb627[2]), _2248@Mir(bb627[3])
  assert(move _2249, "index out of bounds: the length is {} but the index is {}", move _2248, _2246) -> bb628
  using: _2249@Entry, _2248@Entry, _2246@Entry
bb628:
  _2253 = _21
  using: _21@Phi(bb548)
  _2256 = _6
  using: _6@Phi(bb564)
  _2257 = const 12_i32
  using: 
  _2258 = CheckedAdd(_2256, _2257)
  using: _2256@Mir(bb628[1]), _2257@Mir(bb628[2])
  assert(!move (_2258.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2256, move _2257) -> bb629
  using: _2258@Entry, _2256@Entry, _2257@Entry
bb629:
  _2255 = move (_2258.0: i32)
  using: _2258@Mir(bb628[3])
  _2254 = move _2255 as isize (IntToInt)
  using: _2255@Mir(bb629[0])
  _2252 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2253, move _2254) -> bb630
  using: _2253@Mir(bb628[0]), _2254@Mir(bb629[1])
bb630:
  _2251 = (*_2252)
  using: _2252@Mir(bb629[2])
  _2250 = move _2251 as usize (IntToInt)
  using: _2251@Mir(bb630[0])
  _2259 = const 258_usize
  using: 
  _2260 = Lt(_2250, _2259)
  using: _2250@Mir(bb630[1]), _2259@Mir(bb630[2])
  assert(move _2260, "index out of bounds: the length is {} but the index is {}", move _2259, _2250) -> bb631
  using: _2260@Entry, _2259@Entry, _2250@Entry
bb631:
  _2261 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2246][_2250], const 1_i32)
  using: _1@Phi(bb548), _2250@Mir(bb630[1]), _2246@Mir(bb627[2])
  assert(!move (_2261.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2246][_2250], const 1_i32) -> bb632
  using: _2261@Entry, _1@Entry, _2250@Entry, _2246@Entry
bb632:
  ((*_1).37: [[i32; 258]; 6])[_2246][_2250] = move (_2261.0: i32)
  using: _1@Phi(bb548), _2250@Mir(bb630[1]), _2246@Mir(bb627[2]), _2261@Mir(bb631[0])
  _2263 = _9
  using: _9@Phi(bb554)
  _2262 = move _2263 as usize (IntToInt)
  using: _2263@Mir(bb632[1])
  _2264 = const 6_usize
  using: 
  _2265 = Lt(_2262, _2264)
  using: _2262@Mir(bb632[2]), _2264@Mir(bb632[3])
  assert(move _2265, "index out of bounds: the length is {} but the index is {}", move _2264, _2262) -> bb633
  using: _2265@Entry, _2264@Entry, _2262@Entry
bb633:
  _2269 = _21
  using: _21@Phi(bb548)
  _2272 = _6
  using: _6@Phi(bb564)
  _2273 = const 13_i32
  using: 
  _2274 = CheckedAdd(_2272, _2273)
  using: _2272@Mir(bb633[1]), _2273@Mir(bb633[2])
  assert(!move (_2274.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2272, move _2273) -> bb634
  using: _2274@Entry, _2272@Entry, _2273@Entry
bb634:
  _2271 = move (_2274.0: i32)
  using: _2274@Mir(bb633[3])
  _2270 = move _2271 as isize (IntToInt)
  using: _2271@Mir(bb634[0])
  _2268 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2269, move _2270) -> bb635
  using: _2269@Mir(bb633[0]), _2270@Mir(bb634[1])
bb635:
  _2267 = (*_2268)
  using: _2268@Mir(bb634[2])
  _2266 = move _2267 as usize (IntToInt)
  using: _2267@Mir(bb635[0])
  _2275 = const 258_usize
  using: 
  _2276 = Lt(_2266, _2275)
  using: _2266@Mir(bb635[1]), _2275@Mir(bb635[2])
  assert(move _2276, "index out of bounds: the length is {} but the index is {}", move _2275, _2266) -> bb636
  using: _2276@Entry, _2275@Entry, _2266@Entry
bb636:
  _2277 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2262][_2266], const 1_i32)
  using: _1@Phi(bb548), _2266@Mir(bb635[1]), _2262@Mir(bb632[2])
  assert(!move (_2277.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2262][_2266], const 1_i32) -> bb637
  using: _2277@Entry, _1@Entry, _2266@Entry, _2262@Entry
bb637:
  ((*_1).37: [[i32; 258]; 6])[_2262][_2266] = move (_2277.0: i32)
  using: _1@Phi(bb548), _2266@Mir(bb635[1]), _2262@Mir(bb632[2]), _2277@Mir(bb636[0])
  _2279 = _9
  using: _9@Phi(bb554)
  _2278 = move _2279 as usize (IntToInt)
  using: _2279@Mir(bb637[1])
  _2280 = const 6_usize
  using: 
  _2281 = Lt(_2278, _2280)
  using: _2278@Mir(bb637[2]), _2280@Mir(bb637[3])
  assert(move _2281, "index out of bounds: the length is {} but the index is {}", move _2280, _2278) -> bb638
  using: _2281@Entry, _2280@Entry, _2278@Entry
bb638:
  _2285 = _21
  using: _21@Phi(bb548)
  _2288 = _6
  using: _6@Phi(bb564)
  _2289 = const 14_i32
  using: 
  _2290 = CheckedAdd(_2288, _2289)
  using: _2288@Mir(bb638[1]), _2289@Mir(bb638[2])
  assert(!move (_2290.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2288, move _2289) -> bb639
  using: _2290@Entry, _2288@Entry, _2289@Entry
bb639:
  _2287 = move (_2290.0: i32)
  using: _2290@Mir(bb638[3])
  _2286 = move _2287 as isize (IntToInt)
  using: _2287@Mir(bb639[0])
  _2284 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2285, move _2286) -> bb640
  using: _2285@Mir(bb638[0]), _2286@Mir(bb639[1])
bb640:
  _2283 = (*_2284)
  using: _2284@Mir(bb639[2])
  _2282 = move _2283 as usize (IntToInt)
  using: _2283@Mir(bb640[0])
  _2291 = const 258_usize
  using: 
  _2292 = Lt(_2282, _2291)
  using: _2282@Mir(bb640[1]), _2291@Mir(bb640[2])
  assert(move _2292, "index out of bounds: the length is {} but the index is {}", move _2291, _2282) -> bb641
  using: _2292@Entry, _2291@Entry, _2282@Entry
bb641:
  _2293 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2278][_2282], const 1_i32)
  using: _1@Phi(bb548), _2282@Mir(bb640[1]), _2278@Mir(bb637[2])
  assert(!move (_2293.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2278][_2282], const 1_i32) -> bb642
  using: _2293@Entry, _1@Entry, _2282@Entry, _2278@Entry
bb642:
  ((*_1).37: [[i32; 258]; 6])[_2278][_2282] = move (_2293.0: i32)
  using: _1@Phi(bb548), _2282@Mir(bb640[1]), _2278@Mir(bb637[2]), _2293@Mir(bb641[0])
  _2295 = _9
  using: _9@Phi(bb554)
  _2294 = move _2295 as usize (IntToInt)
  using: _2295@Mir(bb642[1])
  _2296 = const 6_usize
  using: 
  _2297 = Lt(_2294, _2296)
  using: _2294@Mir(bb642[2]), _2296@Mir(bb642[3])
  assert(move _2297, "index out of bounds: the length is {} but the index is {}", move _2296, _2294) -> bb643
  using: _2297@Entry, _2296@Entry, _2294@Entry
bb643:
  _2301 = _21
  using: _21@Phi(bb548)
  _2304 = _6
  using: _6@Phi(bb564)
  _2305 = const 15_i32
  using: 
  _2306 = CheckedAdd(_2304, _2305)
  using: _2304@Mir(bb643[1]), _2305@Mir(bb643[2])
  assert(!move (_2306.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2304, move _2305) -> bb644
  using: _2306@Entry, _2304@Entry, _2305@Entry
bb644:
  _2303 = move (_2306.0: i32)
  using: _2306@Mir(bb643[3])
  _2302 = move _2303 as isize (IntToInt)
  using: _2303@Mir(bb644[0])
  _2300 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2301, move _2302) -> bb645
  using: _2301@Mir(bb643[0]), _2302@Mir(bb644[1])
bb645:
  _2299 = (*_2300)
  using: _2300@Mir(bb644[2])
  _2298 = move _2299 as usize (IntToInt)
  using: _2299@Mir(bb645[0])
  _2307 = const 258_usize
  using: 
  _2308 = Lt(_2298, _2307)
  using: _2298@Mir(bb645[1]), _2307@Mir(bb645[2])
  assert(move _2308, "index out of bounds: the length is {} but the index is {}", move _2307, _2298) -> bb646
  using: _2308@Entry, _2307@Entry, _2298@Entry
bb646:
  _2309 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2294][_2298], const 1_i32)
  using: _1@Phi(bb548), _2298@Mir(bb645[1]), _2294@Mir(bb642[2])
  assert(!move (_2309.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2294][_2298], const 1_i32) -> bb647
  using: _2309@Entry, _1@Entry, _2298@Entry, _2294@Entry
bb647:
  ((*_1).37: [[i32; 258]; 6])[_2294][_2298] = move (_2309.0: i32)
  using: _1@Phi(bb548), _2298@Mir(bb645[1]), _2294@Mir(bb642[2]), _2309@Mir(bb646[0])
  _2311 = _9
  using: _9@Phi(bb554)
  _2310 = move _2311 as usize (IntToInt)
  using: _2311@Mir(bb647[1])
  _2312 = const 6_usize
  using: 
  _2313 = Lt(_2310, _2312)
  using: _2310@Mir(bb647[2]), _2312@Mir(bb647[3])
  assert(move _2313, "index out of bounds: the length is {} but the index is {}", move _2312, _2310) -> bb648
  using: _2313@Entry, _2312@Entry, _2310@Entry
bb648:
  _2317 = _21
  using: _21@Phi(bb548)
  _2320 = _6
  using: _6@Phi(bb564)
  _2321 = const 16_i32
  using: 
  _2322 = CheckedAdd(_2320, _2321)
  using: _2320@Mir(bb648[1]), _2321@Mir(bb648[2])
  assert(!move (_2322.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2320, move _2321) -> bb649
  using: _2322@Entry, _2320@Entry, _2321@Entry
bb649:
  _2319 = move (_2322.0: i32)
  using: _2322@Mir(bb648[3])
  _2318 = move _2319 as isize (IntToInt)
  using: _2319@Mir(bb649[0])
  _2316 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2317, move _2318) -> bb650
  using: _2317@Mir(bb648[0]), _2318@Mir(bb649[1])
bb650:
  _2315 = (*_2316)
  using: _2316@Mir(bb649[2])
  _2314 = move _2315 as usize (IntToInt)
  using: _2315@Mir(bb650[0])
  _2323 = const 258_usize
  using: 
  _2324 = Lt(_2314, _2323)
  using: _2314@Mir(bb650[1]), _2323@Mir(bb650[2])
  assert(move _2324, "index out of bounds: the length is {} but the index is {}", move _2323, _2314) -> bb651
  using: _2324@Entry, _2323@Entry, _2314@Entry
bb651:
  _2325 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2310][_2314], const 1_i32)
  using: _1@Phi(bb548), _2314@Mir(bb650[1]), _2310@Mir(bb647[2])
  assert(!move (_2325.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2310][_2314], const 1_i32) -> bb652
  using: _2325@Entry, _1@Entry, _2314@Entry, _2310@Entry
bb652:
  ((*_1).37: [[i32; 258]; 6])[_2310][_2314] = move (_2325.0: i32)
  using: _1@Phi(bb548), _2314@Mir(bb650[1]), _2310@Mir(bb647[2]), _2325@Mir(bb651[0])
  _2327 = _9
  using: _9@Phi(bb554)
  _2326 = move _2327 as usize (IntToInt)
  using: _2327@Mir(bb652[1])
  _2328 = const 6_usize
  using: 
  _2329 = Lt(_2326, _2328)
  using: _2326@Mir(bb652[2]), _2328@Mir(bb652[3])
  assert(move _2329, "index out of bounds: the length is {} but the index is {}", move _2328, _2326) -> bb653
  using: _2329@Entry, _2328@Entry, _2326@Entry
bb653:
  _2333 = _21
  using: _21@Phi(bb548)
  _2336 = _6
  using: _6@Phi(bb564)
  _2337 = const 17_i32
  using: 
  _2338 = CheckedAdd(_2336, _2337)
  using: _2336@Mir(bb653[1]), _2337@Mir(bb653[2])
  assert(!move (_2338.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2336, move _2337) -> bb654
  using: _2338@Entry, _2336@Entry, _2337@Entry
bb654:
  _2335 = move (_2338.0: i32)
  using: _2338@Mir(bb653[3])
  _2334 = move _2335 as isize (IntToInt)
  using: _2335@Mir(bb654[0])
  _2332 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2333, move _2334) -> bb655
  using: _2333@Mir(bb653[0]), _2334@Mir(bb654[1])
bb655:
  _2331 = (*_2332)
  using: _2332@Mir(bb654[2])
  _2330 = move _2331 as usize (IntToInt)
  using: _2331@Mir(bb655[0])
  _2339 = const 258_usize
  using: 
  _2340 = Lt(_2330, _2339)
  using: _2330@Mir(bb655[1]), _2339@Mir(bb655[2])
  assert(move _2340, "index out of bounds: the length is {} but the index is {}", move _2339, _2330) -> bb656
  using: _2340@Entry, _2339@Entry, _2330@Entry
bb656:
  _2341 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2326][_2330], const 1_i32)
  using: _1@Phi(bb548), _2330@Mir(bb655[1]), _2326@Mir(bb652[2])
  assert(!move (_2341.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2326][_2330], const 1_i32) -> bb657
  using: _2341@Entry, _1@Entry, _2330@Entry, _2326@Entry
bb657:
  ((*_1).37: [[i32; 258]; 6])[_2326][_2330] = move (_2341.0: i32)
  using: _1@Phi(bb548), _2330@Mir(bb655[1]), _2326@Mir(bb652[2]), _2341@Mir(bb656[0])
  _2343 = _9
  using: _9@Phi(bb554)
  _2342 = move _2343 as usize (IntToInt)
  using: _2343@Mir(bb657[1])
  _2344 = const 6_usize
  using: 
  _2345 = Lt(_2342, _2344)
  using: _2342@Mir(bb657[2]), _2344@Mir(bb657[3])
  assert(move _2345, "index out of bounds: the length is {} but the index is {}", move _2344, _2342) -> bb658
  using: _2345@Entry, _2344@Entry, _2342@Entry
bb658:
  _2349 = _21
  using: _21@Phi(bb548)
  _2352 = _6
  using: _6@Phi(bb564)
  _2353 = const 18_i32
  using: 
  _2354 = CheckedAdd(_2352, _2353)
  using: _2352@Mir(bb658[1]), _2353@Mir(bb658[2])
  assert(!move (_2354.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2352, move _2353) -> bb659
  using: _2354@Entry, _2352@Entry, _2353@Entry
bb659:
  _2351 = move (_2354.0: i32)
  using: _2354@Mir(bb658[3])
  _2350 = move _2351 as isize (IntToInt)
  using: _2351@Mir(bb659[0])
  _2348 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2349, move _2350) -> bb660
  using: _2349@Mir(bb658[0]), _2350@Mir(bb659[1])
bb660:
  _2347 = (*_2348)
  using: _2348@Mir(bb659[2])
  _2346 = move _2347 as usize (IntToInt)
  using: _2347@Mir(bb660[0])
  _2355 = const 258_usize
  using: 
  _2356 = Lt(_2346, _2355)
  using: _2346@Mir(bb660[1]), _2355@Mir(bb660[2])
  assert(move _2356, "index out of bounds: the length is {} but the index is {}", move _2355, _2346) -> bb661
  using: _2356@Entry, _2355@Entry, _2346@Entry
bb661:
  _2357 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2342][_2346], const 1_i32)
  using: _1@Phi(bb548), _2346@Mir(bb660[1]), _2342@Mir(bb657[2])
  assert(!move (_2357.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2342][_2346], const 1_i32) -> bb662
  using: _2357@Entry, _1@Entry, _2346@Entry, _2342@Entry
bb662:
  ((*_1).37: [[i32; 258]; 6])[_2342][_2346] = move (_2357.0: i32)
  using: _1@Phi(bb548), _2346@Mir(bb660[1]), _2342@Mir(bb657[2]), _2357@Mir(bb661[0])
  _2359 = _9
  using: _9@Phi(bb554)
  _2358 = move _2359 as usize (IntToInt)
  using: _2359@Mir(bb662[1])
  _2360 = const 6_usize
  using: 
  _2361 = Lt(_2358, _2360)
  using: _2358@Mir(bb662[2]), _2360@Mir(bb662[3])
  assert(move _2361, "index out of bounds: the length is {} but the index is {}", move _2360, _2358) -> bb663
  using: _2361@Entry, _2360@Entry, _2358@Entry
bb663:
  _2365 = _21
  using: _21@Phi(bb548)
  _2368 = _6
  using: _6@Phi(bb564)
  _2369 = const 19_i32
  using: 
  _2370 = CheckedAdd(_2368, _2369)
  using: _2368@Mir(bb663[1]), _2369@Mir(bb663[2])
  assert(!move (_2370.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2368, move _2369) -> bb664
  using: _2370@Entry, _2368@Entry, _2369@Entry
bb664:
  _2367 = move (_2370.0: i32)
  using: _2370@Mir(bb663[3])
  _2366 = move _2367 as isize (IntToInt)
  using: _2367@Mir(bb664[0])
  _2364 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2365, move _2366) -> bb665
  using: _2365@Mir(bb663[0]), _2366@Mir(bb664[1])
bb665:
  _2363 = (*_2364)
  using: _2364@Mir(bb664[2])
  _2362 = move _2363 as usize (IntToInt)
  using: _2363@Mir(bb665[0])
  _2371 = const 258_usize
  using: 
  _2372 = Lt(_2362, _2371)
  using: _2362@Mir(bb665[1]), _2371@Mir(bb665[2])
  assert(move _2372, "index out of bounds: the length is {} but the index is {}", move _2371, _2362) -> bb666
  using: _2372@Entry, _2371@Entry, _2362@Entry
bb666:
  _2373 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2358][_2362], const 1_i32)
  using: _1@Phi(bb548), _2362@Mir(bb665[1]), _2358@Mir(bb662[2])
  assert(!move (_2373.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2358][_2362], const 1_i32) -> bb667
  using: _2373@Entry, _1@Entry, _2362@Entry, _2358@Entry
bb667:
  ((*_1).37: [[i32; 258]; 6])[_2358][_2362] = move (_2373.0: i32)
  using: _1@Phi(bb548), _2362@Mir(bb665[1]), _2358@Mir(bb662[2]), _2373@Mir(bb666[0])
  _2375 = _9
  using: _9@Phi(bb554)
  _2374 = move _2375 as usize (IntToInt)
  using: _2375@Mir(bb667[1])
  _2376 = const 6_usize
  using: 
  _2377 = Lt(_2374, _2376)
  using: _2374@Mir(bb667[2]), _2376@Mir(bb667[3])
  assert(move _2377, "index out of bounds: the length is {} but the index is {}", move _2376, _2374) -> bb668
  using: _2377@Entry, _2376@Entry, _2374@Entry
bb668:
  _2381 = _21
  using: _21@Phi(bb548)
  _2384 = _6
  using: _6@Phi(bb564)
  _2385 = const 20_i32
  using: 
  _2386 = CheckedAdd(_2384, _2385)
  using: _2384@Mir(bb668[1]), _2385@Mir(bb668[2])
  assert(!move (_2386.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2384, move _2385) -> bb669
  using: _2386@Entry, _2384@Entry, _2385@Entry
bb669:
  _2383 = move (_2386.0: i32)
  using: _2386@Mir(bb668[3])
  _2382 = move _2383 as isize (IntToInt)
  using: _2383@Mir(bb669[0])
  _2380 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2381, move _2382) -> bb670
  using: _2381@Mir(bb668[0]), _2382@Mir(bb669[1])
bb670:
  _2379 = (*_2380)
  using: _2380@Mir(bb669[2])
  _2378 = move _2379 as usize (IntToInt)
  using: _2379@Mir(bb670[0])
  _2387 = const 258_usize
  using: 
  _2388 = Lt(_2378, _2387)
  using: _2378@Mir(bb670[1]), _2387@Mir(bb670[2])
  assert(move _2388, "index out of bounds: the length is {} but the index is {}", move _2387, _2378) -> bb671
  using: _2388@Entry, _2387@Entry, _2378@Entry
bb671:
  _2389 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2374][_2378], const 1_i32)
  using: _1@Phi(bb548), _2378@Mir(bb670[1]), _2374@Mir(bb667[2])
  assert(!move (_2389.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2374][_2378], const 1_i32) -> bb672
  using: _2389@Entry, _1@Entry, _2378@Entry, _2374@Entry
bb672:
  ((*_1).37: [[i32; 258]; 6])[_2374][_2378] = move (_2389.0: i32)
  using: _1@Phi(bb548), _2378@Mir(bb670[1]), _2374@Mir(bb667[2]), _2389@Mir(bb671[0])
  _2391 = _9
  using: _9@Phi(bb554)
  _2390 = move _2391 as usize (IntToInt)
  using: _2391@Mir(bb672[1])
  _2392 = const 6_usize
  using: 
  _2393 = Lt(_2390, _2392)
  using: _2390@Mir(bb672[2]), _2392@Mir(bb672[3])
  assert(move _2393, "index out of bounds: the length is {} but the index is {}", move _2392, _2390) -> bb673
  using: _2393@Entry, _2392@Entry, _2390@Entry
bb673:
  _2397 = _21
  using: _21@Phi(bb548)
  _2400 = _6
  using: _6@Phi(bb564)
  _2401 = const 21_i32
  using: 
  _2402 = CheckedAdd(_2400, _2401)
  using: _2400@Mir(bb673[1]), _2401@Mir(bb673[2])
  assert(!move (_2402.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2400, move _2401) -> bb674
  using: _2402@Entry, _2400@Entry, _2401@Entry
bb674:
  _2399 = move (_2402.0: i32)
  using: _2402@Mir(bb673[3])
  _2398 = move _2399 as isize (IntToInt)
  using: _2399@Mir(bb674[0])
  _2396 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2397, move _2398) -> bb675
  using: _2397@Mir(bb673[0]), _2398@Mir(bb674[1])
bb675:
  _2395 = (*_2396)
  using: _2396@Mir(bb674[2])
  _2394 = move _2395 as usize (IntToInt)
  using: _2395@Mir(bb675[0])
  _2403 = const 258_usize
  using: 
  _2404 = Lt(_2394, _2403)
  using: _2394@Mir(bb675[1]), _2403@Mir(bb675[2])
  assert(move _2404, "index out of bounds: the length is {} but the index is {}", move _2403, _2394) -> bb676
  using: _2404@Entry, _2403@Entry, _2394@Entry
bb676:
  _2405 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2390][_2394], const 1_i32)
  using: _1@Phi(bb548), _2394@Mir(bb675[1]), _2390@Mir(bb672[2])
  assert(!move (_2405.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2390][_2394], const 1_i32) -> bb677
  using: _2405@Entry, _1@Entry, _2394@Entry, _2390@Entry
bb677:
  ((*_1).37: [[i32; 258]; 6])[_2390][_2394] = move (_2405.0: i32)
  using: _1@Phi(bb548), _2394@Mir(bb675[1]), _2390@Mir(bb672[2]), _2405@Mir(bb676[0])
  _2407 = _9
  using: _9@Phi(bb554)
  _2406 = move _2407 as usize (IntToInt)
  using: _2407@Mir(bb677[1])
  _2408 = const 6_usize
  using: 
  _2409 = Lt(_2406, _2408)
  using: _2406@Mir(bb677[2]), _2408@Mir(bb677[3])
  assert(move _2409, "index out of bounds: the length is {} but the index is {}", move _2408, _2406) -> bb678
  using: _2409@Entry, _2408@Entry, _2406@Entry
bb678:
  _2413 = _21
  using: _21@Phi(bb548)
  _2416 = _6
  using: _6@Phi(bb564)
  _2417 = const 22_i32
  using: 
  _2418 = CheckedAdd(_2416, _2417)
  using: _2416@Mir(bb678[1]), _2417@Mir(bb678[2])
  assert(!move (_2418.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2416, move _2417) -> bb679
  using: _2418@Entry, _2416@Entry, _2417@Entry
bb679:
  _2415 = move (_2418.0: i32)
  using: _2418@Mir(bb678[3])
  _2414 = move _2415 as isize (IntToInt)
  using: _2415@Mir(bb679[0])
  _2412 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2413, move _2414) -> bb680
  using: _2413@Mir(bb678[0]), _2414@Mir(bb679[1])
bb680:
  _2411 = (*_2412)
  using: _2412@Mir(bb679[2])
  _2410 = move _2411 as usize (IntToInt)
  using: _2411@Mir(bb680[0])
  _2419 = const 258_usize
  using: 
  _2420 = Lt(_2410, _2419)
  using: _2410@Mir(bb680[1]), _2419@Mir(bb680[2])
  assert(move _2420, "index out of bounds: the length is {} but the index is {}", move _2419, _2410) -> bb681
  using: _2420@Entry, _2419@Entry, _2410@Entry
bb681:
  _2421 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2406][_2410], const 1_i32)
  using: _1@Phi(bb548), _2410@Mir(bb680[1]), _2406@Mir(bb677[2])
  assert(!move (_2421.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2406][_2410], const 1_i32) -> bb682
  using: _2421@Entry, _1@Entry, _2410@Entry, _2406@Entry
bb682:
  ((*_1).37: [[i32; 258]; 6])[_2406][_2410] = move (_2421.0: i32)
  using: _1@Phi(bb548), _2410@Mir(bb680[1]), _2406@Mir(bb677[2]), _2421@Mir(bb681[0])
  _2423 = _9
  using: _9@Phi(bb554)
  _2422 = move _2423 as usize (IntToInt)
  using: _2423@Mir(bb682[1])
  _2424 = const 6_usize
  using: 
  _2425 = Lt(_2422, _2424)
  using: _2422@Mir(bb682[2]), _2424@Mir(bb682[3])
  assert(move _2425, "index out of bounds: the length is {} but the index is {}", move _2424, _2422) -> bb683
  using: _2425@Entry, _2424@Entry, _2422@Entry
bb683:
  _2429 = _21
  using: _21@Phi(bb548)
  _2432 = _6
  using: _6@Phi(bb564)
  _2433 = const 23_i32
  using: 
  _2434 = CheckedAdd(_2432, _2433)
  using: _2432@Mir(bb683[1]), _2433@Mir(bb683[2])
  assert(!move (_2434.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2432, move _2433) -> bb684
  using: _2434@Entry, _2432@Entry, _2433@Entry
bb684:
  _2431 = move (_2434.0: i32)
  using: _2434@Mir(bb683[3])
  _2430 = move _2431 as isize (IntToInt)
  using: _2431@Mir(bb684[0])
  _2428 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2429, move _2430) -> bb685
  using: _2429@Mir(bb683[0]), _2430@Mir(bb684[1])
bb685:
  _2427 = (*_2428)
  using: _2428@Mir(bb684[2])
  _2426 = move _2427 as usize (IntToInt)
  using: _2427@Mir(bb685[0])
  _2435 = const 258_usize
  using: 
  _2436 = Lt(_2426, _2435)
  using: _2426@Mir(bb685[1]), _2435@Mir(bb685[2])
  assert(move _2436, "index out of bounds: the length is {} but the index is {}", move _2435, _2426) -> bb686
  using: _2436@Entry, _2435@Entry, _2426@Entry
bb686:
  _2437 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2422][_2426], const 1_i32)
  using: _1@Phi(bb548), _2426@Mir(bb685[1]), _2422@Mir(bb682[2])
  assert(!move (_2437.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2422][_2426], const 1_i32) -> bb687
  using: _2437@Entry, _1@Entry, _2426@Entry, _2422@Entry
bb687:
  ((*_1).37: [[i32; 258]; 6])[_2422][_2426] = move (_2437.0: i32)
  using: _1@Phi(bb548), _2426@Mir(bb685[1]), _2422@Mir(bb682[2]), _2437@Mir(bb686[0])
  _2439 = _9
  using: _9@Phi(bb554)
  _2438 = move _2439 as usize (IntToInt)
  using: _2439@Mir(bb687[1])
  _2440 = const 6_usize
  using: 
  _2441 = Lt(_2438, _2440)
  using: _2438@Mir(bb687[2]), _2440@Mir(bb687[3])
  assert(move _2441, "index out of bounds: the length is {} but the index is {}", move _2440, _2438) -> bb688
  using: _2441@Entry, _2440@Entry, _2438@Entry
bb688:
  _2445 = _21
  using: _21@Phi(bb548)
  _2448 = _6
  using: _6@Phi(bb564)
  _2449 = const 24_i32
  using: 
  _2450 = CheckedAdd(_2448, _2449)
  using: _2448@Mir(bb688[1]), _2449@Mir(bb688[2])
  assert(!move (_2450.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2448, move _2449) -> bb689
  using: _2450@Entry, _2448@Entry, _2449@Entry
bb689:
  _2447 = move (_2450.0: i32)
  using: _2450@Mir(bb688[3])
  _2446 = move _2447 as isize (IntToInt)
  using: _2447@Mir(bb689[0])
  _2444 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2445, move _2446) -> bb690
  using: _2445@Mir(bb688[0]), _2446@Mir(bb689[1])
bb690:
  _2443 = (*_2444)
  using: _2444@Mir(bb689[2])
  _2442 = move _2443 as usize (IntToInt)
  using: _2443@Mir(bb690[0])
  _2451 = const 258_usize
  using: 
  _2452 = Lt(_2442, _2451)
  using: _2442@Mir(bb690[1]), _2451@Mir(bb690[2])
  assert(move _2452, "index out of bounds: the length is {} but the index is {}", move _2451, _2442) -> bb691
  using: _2452@Entry, _2451@Entry, _2442@Entry
bb691:
  _2453 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2438][_2442], const 1_i32)
  using: _1@Phi(bb548), _2442@Mir(bb690[1]), _2438@Mir(bb687[2])
  assert(!move (_2453.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2438][_2442], const 1_i32) -> bb692
  using: _2453@Entry, _1@Entry, _2442@Entry, _2438@Entry
bb692:
  ((*_1).37: [[i32; 258]; 6])[_2438][_2442] = move (_2453.0: i32)
  using: _1@Phi(bb548), _2442@Mir(bb690[1]), _2438@Mir(bb687[2]), _2453@Mir(bb691[0])
  _2455 = _9
  using: _9@Phi(bb554)
  _2454 = move _2455 as usize (IntToInt)
  using: _2455@Mir(bb692[1])
  _2456 = const 6_usize
  using: 
  _2457 = Lt(_2454, _2456)
  using: _2454@Mir(bb692[2]), _2456@Mir(bb692[3])
  assert(move _2457, "index out of bounds: the length is {} but the index is {}", move _2456, _2454) -> bb693
  using: _2457@Entry, _2456@Entry, _2454@Entry
bb693:
  _2461 = _21
  using: _21@Phi(bb548)
  _2464 = _6
  using: _6@Phi(bb564)
  _2465 = const 25_i32
  using: 
  _2466 = CheckedAdd(_2464, _2465)
  using: _2464@Mir(bb693[1]), _2465@Mir(bb693[2])
  assert(!move (_2466.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2464, move _2465) -> bb694
  using: _2466@Entry, _2464@Entry, _2465@Entry
bb694:
  _2463 = move (_2466.0: i32)
  using: _2466@Mir(bb693[3])
  _2462 = move _2463 as isize (IntToInt)
  using: _2463@Mir(bb694[0])
  _2460 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2461, move _2462) -> bb695
  using: _2461@Mir(bb693[0]), _2462@Mir(bb694[1])
bb695:
  _2459 = (*_2460)
  using: _2460@Mir(bb694[2])
  _2458 = move _2459 as usize (IntToInt)
  using: _2459@Mir(bb695[0])
  _2467 = const 258_usize
  using: 
  _2468 = Lt(_2458, _2467)
  using: _2458@Mir(bb695[1]), _2467@Mir(bb695[2])
  assert(move _2468, "index out of bounds: the length is {} but the index is {}", move _2467, _2458) -> bb696
  using: _2468@Entry, _2467@Entry, _2458@Entry
bb696:
  _2469 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2454][_2458], const 1_i32)
  using: _1@Phi(bb548), _2458@Mir(bb695[1]), _2454@Mir(bb692[2])
  assert(!move (_2469.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2454][_2458], const 1_i32) -> bb697
  using: _2469@Entry, _1@Entry, _2458@Entry, _2454@Entry
bb697:
  ((*_1).37: [[i32; 258]; 6])[_2454][_2458] = move (_2469.0: i32)
  using: _1@Phi(bb548), _2458@Mir(bb695[1]), _2454@Mir(bb692[2]), _2469@Mir(bb696[0])
  _2471 = _9
  using: _9@Phi(bb554)
  _2470 = move _2471 as usize (IntToInt)
  using: _2471@Mir(bb697[1])
  _2472 = const 6_usize
  using: 
  _2473 = Lt(_2470, _2472)
  using: _2470@Mir(bb697[2]), _2472@Mir(bb697[3])
  assert(move _2473, "index out of bounds: the length is {} but the index is {}", move _2472, _2470) -> bb698
  using: _2473@Entry, _2472@Entry, _2470@Entry
bb698:
  _2477 = _21
  using: _21@Phi(bb548)
  _2480 = _6
  using: _6@Phi(bb564)
  _2481 = const 26_i32
  using: 
  _2482 = CheckedAdd(_2480, _2481)
  using: _2480@Mir(bb698[1]), _2481@Mir(bb698[2])
  assert(!move (_2482.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2480, move _2481) -> bb699
  using: _2482@Entry, _2480@Entry, _2481@Entry
bb699:
  _2479 = move (_2482.0: i32)
  using: _2482@Mir(bb698[3])
  _2478 = move _2479 as isize (IntToInt)
  using: _2479@Mir(bb699[0])
  _2476 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2477, move _2478) -> bb700
  using: _2477@Mir(bb698[0]), _2478@Mir(bb699[1])
bb700:
  _2475 = (*_2476)
  using: _2476@Mir(bb699[2])
  _2474 = move _2475 as usize (IntToInt)
  using: _2475@Mir(bb700[0])
  _2483 = const 258_usize
  using: 
  _2484 = Lt(_2474, _2483)
  using: _2474@Mir(bb700[1]), _2483@Mir(bb700[2])
  assert(move _2484, "index out of bounds: the length is {} but the index is {}", move _2483, _2474) -> bb701
  using: _2484@Entry, _2483@Entry, _2474@Entry
bb701:
  _2485 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2470][_2474], const 1_i32)
  using: _1@Phi(bb548), _2474@Mir(bb700[1]), _2470@Mir(bb697[2])
  assert(!move (_2485.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2470][_2474], const 1_i32) -> bb702
  using: _2485@Entry, _1@Entry, _2474@Entry, _2470@Entry
bb702:
  ((*_1).37: [[i32; 258]; 6])[_2470][_2474] = move (_2485.0: i32)
  using: _1@Phi(bb548), _2474@Mir(bb700[1]), _2470@Mir(bb697[2]), _2485@Mir(bb701[0])
  _2487 = _9
  using: _9@Phi(bb554)
  _2486 = move _2487 as usize (IntToInt)
  using: _2487@Mir(bb702[1])
  _2488 = const 6_usize
  using: 
  _2489 = Lt(_2486, _2488)
  using: _2486@Mir(bb702[2]), _2488@Mir(bb702[3])
  assert(move _2489, "index out of bounds: the length is {} but the index is {}", move _2488, _2486) -> bb703
  using: _2489@Entry, _2488@Entry, _2486@Entry
bb703:
  _2493 = _21
  using: _21@Phi(bb548)
  _2496 = _6
  using: _6@Phi(bb564)
  _2497 = const 27_i32
  using: 
  _2498 = CheckedAdd(_2496, _2497)
  using: _2496@Mir(bb703[1]), _2497@Mir(bb703[2])
  assert(!move (_2498.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2496, move _2497) -> bb704
  using: _2498@Entry, _2496@Entry, _2497@Entry
bb704:
  _2495 = move (_2498.0: i32)
  using: _2498@Mir(bb703[3])
  _2494 = move _2495 as isize (IntToInt)
  using: _2495@Mir(bb704[0])
  _2492 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2493, move _2494) -> bb705
  using: _2493@Mir(bb703[0]), _2494@Mir(bb704[1])
bb705:
  _2491 = (*_2492)
  using: _2492@Mir(bb704[2])
  _2490 = move _2491 as usize (IntToInt)
  using: _2491@Mir(bb705[0])
  _2499 = const 258_usize
  using: 
  _2500 = Lt(_2490, _2499)
  using: _2490@Mir(bb705[1]), _2499@Mir(bb705[2])
  assert(move _2500, "index out of bounds: the length is {} but the index is {}", move _2499, _2490) -> bb706
  using: _2500@Entry, _2499@Entry, _2490@Entry
bb706:
  _2501 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2486][_2490], const 1_i32)
  using: _1@Phi(bb548), _2490@Mir(bb705[1]), _2486@Mir(bb702[2])
  assert(!move (_2501.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2486][_2490], const 1_i32) -> bb707
  using: _2501@Entry, _1@Entry, _2490@Entry, _2486@Entry
bb707:
  ((*_1).37: [[i32; 258]; 6])[_2486][_2490] = move (_2501.0: i32)
  using: _1@Phi(bb548), _2490@Mir(bb705[1]), _2486@Mir(bb702[2]), _2501@Mir(bb706[0])
  _2503 = _9
  using: _9@Phi(bb554)
  _2502 = move _2503 as usize (IntToInt)
  using: _2503@Mir(bb707[1])
  _2504 = const 6_usize
  using: 
  _2505 = Lt(_2502, _2504)
  using: _2502@Mir(bb707[2]), _2504@Mir(bb707[3])
  assert(move _2505, "index out of bounds: the length is {} but the index is {}", move _2504, _2502) -> bb708
  using: _2505@Entry, _2504@Entry, _2502@Entry
bb708:
  _2509 = _21
  using: _21@Phi(bb548)
  _2512 = _6
  using: _6@Phi(bb564)
  _2513 = const 28_i32
  using: 
  _2514 = CheckedAdd(_2512, _2513)
  using: _2512@Mir(bb708[1]), _2513@Mir(bb708[2])
  assert(!move (_2514.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2512, move _2513) -> bb709
  using: _2514@Entry, _2512@Entry, _2513@Entry
bb709:
  _2511 = move (_2514.0: i32)
  using: _2514@Mir(bb708[3])
  _2510 = move _2511 as isize (IntToInt)
  using: _2511@Mir(bb709[0])
  _2508 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2509, move _2510) -> bb710
  using: _2509@Mir(bb708[0]), _2510@Mir(bb709[1])
bb710:
  _2507 = (*_2508)
  using: _2508@Mir(bb709[2])
  _2506 = move _2507 as usize (IntToInt)
  using: _2507@Mir(bb710[0])
  _2515 = const 258_usize
  using: 
  _2516 = Lt(_2506, _2515)
  using: _2506@Mir(bb710[1]), _2515@Mir(bb710[2])
  assert(move _2516, "index out of bounds: the length is {} but the index is {}", move _2515, _2506) -> bb711
  using: _2516@Entry, _2515@Entry, _2506@Entry
bb711:
  _2517 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2502][_2506], const 1_i32)
  using: _1@Phi(bb548), _2506@Mir(bb710[1]), _2502@Mir(bb707[2])
  assert(!move (_2517.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2502][_2506], const 1_i32) -> bb712
  using: _2517@Entry, _1@Entry, _2506@Entry, _2502@Entry
bb712:
  ((*_1).37: [[i32; 258]; 6])[_2502][_2506] = move (_2517.0: i32)
  using: _1@Phi(bb548), _2506@Mir(bb710[1]), _2502@Mir(bb707[2]), _2517@Mir(bb711[0])
  _2519 = _9
  using: _9@Phi(bb554)
  _2518 = move _2519 as usize (IntToInt)
  using: _2519@Mir(bb712[1])
  _2520 = const 6_usize
  using: 
  _2521 = Lt(_2518, _2520)
  using: _2518@Mir(bb712[2]), _2520@Mir(bb712[3])
  assert(move _2521, "index out of bounds: the length is {} but the index is {}", move _2520, _2518) -> bb713
  using: _2521@Entry, _2520@Entry, _2518@Entry
bb713:
  _2525 = _21
  using: _21@Phi(bb548)
  _2528 = _6
  using: _6@Phi(bb564)
  _2529 = const 29_i32
  using: 
  _2530 = CheckedAdd(_2528, _2529)
  using: _2528@Mir(bb713[1]), _2529@Mir(bb713[2])
  assert(!move (_2530.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2528, move _2529) -> bb714
  using: _2530@Entry, _2528@Entry, _2529@Entry
bb714:
  _2527 = move (_2530.0: i32)
  using: _2530@Mir(bb713[3])
  _2526 = move _2527 as isize (IntToInt)
  using: _2527@Mir(bb714[0])
  _2524 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2525, move _2526) -> bb715
  using: _2525@Mir(bb713[0]), _2526@Mir(bb714[1])
bb715:
  _2523 = (*_2524)
  using: _2524@Mir(bb714[2])
  _2522 = move _2523 as usize (IntToInt)
  using: _2523@Mir(bb715[0])
  _2531 = const 258_usize
  using: 
  _2532 = Lt(_2522, _2531)
  using: _2522@Mir(bb715[1]), _2531@Mir(bb715[2])
  assert(move _2532, "index out of bounds: the length is {} but the index is {}", move _2531, _2522) -> bb716
  using: _2532@Entry, _2531@Entry, _2522@Entry
bb716:
  _2533 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2518][_2522], const 1_i32)
  using: _1@Phi(bb548), _2522@Mir(bb715[1]), _2518@Mir(bb712[2])
  assert(!move (_2533.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2518][_2522], const 1_i32) -> bb717
  using: _2533@Entry, _1@Entry, _2522@Entry, _2518@Entry
bb717:
  ((*_1).37: [[i32; 258]; 6])[_2518][_2522] = move (_2533.0: i32)
  using: _1@Phi(bb548), _2522@Mir(bb715[1]), _2518@Mir(bb712[2]), _2533@Mir(bb716[0])
  _2535 = _9
  using: _9@Phi(bb554)
  _2534 = move _2535 as usize (IntToInt)
  using: _2535@Mir(bb717[1])
  _2536 = const 6_usize
  using: 
  _2537 = Lt(_2534, _2536)
  using: _2534@Mir(bb717[2]), _2536@Mir(bb717[3])
  assert(move _2537, "index out of bounds: the length is {} but the index is {}", move _2536, _2534) -> bb718
  using: _2537@Entry, _2536@Entry, _2534@Entry
bb718:
  _2541 = _21
  using: _21@Phi(bb548)
  _2544 = _6
  using: _6@Phi(bb564)
  _2545 = const 30_i32
  using: 
  _2546 = CheckedAdd(_2544, _2545)
  using: _2544@Mir(bb718[1]), _2545@Mir(bb718[2])
  assert(!move (_2546.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2544, move _2545) -> bb719
  using: _2546@Entry, _2544@Entry, _2545@Entry
bb719:
  _2543 = move (_2546.0: i32)
  using: _2546@Mir(bb718[3])
  _2542 = move _2543 as isize (IntToInt)
  using: _2543@Mir(bb719[0])
  _2540 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2541, move _2542) -> bb720
  using: _2541@Mir(bb718[0]), _2542@Mir(bb719[1])
bb720:
  _2539 = (*_2540)
  using: _2540@Mir(bb719[2])
  _2538 = move _2539 as usize (IntToInt)
  using: _2539@Mir(bb720[0])
  _2547 = const 258_usize
  using: 
  _2548 = Lt(_2538, _2547)
  using: _2538@Mir(bb720[1]), _2547@Mir(bb720[2])
  assert(move _2548, "index out of bounds: the length is {} but the index is {}", move _2547, _2538) -> bb721
  using: _2548@Entry, _2547@Entry, _2538@Entry
bb721:
  _2549 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2534][_2538], const 1_i32)
  using: _1@Phi(bb548), _2538@Mir(bb720[1]), _2534@Mir(bb717[2])
  assert(!move (_2549.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2534][_2538], const 1_i32) -> bb722
  using: _2549@Entry, _1@Entry, _2538@Entry, _2534@Entry
bb722:
  ((*_1).37: [[i32; 258]; 6])[_2534][_2538] = move (_2549.0: i32)
  using: _1@Phi(bb548), _2538@Mir(bb720[1]), _2534@Mir(bb717[2]), _2549@Mir(bb721[0])
  _2551 = _9
  using: _9@Phi(bb554)
  _2550 = move _2551 as usize (IntToInt)
  using: _2551@Mir(bb722[1])
  _2552 = const 6_usize
  using: 
  _2553 = Lt(_2550, _2552)
  using: _2550@Mir(bb722[2]), _2552@Mir(bb722[3])
  assert(move _2553, "index out of bounds: the length is {} but the index is {}", move _2552, _2550) -> bb723
  using: _2553@Entry, _2552@Entry, _2550@Entry
bb723:
  _2557 = _21
  using: _21@Phi(bb548)
  _2560 = _6
  using: _6@Phi(bb564)
  _2561 = const 31_i32
  using: 
  _2562 = CheckedAdd(_2560, _2561)
  using: _2560@Mir(bb723[1]), _2561@Mir(bb723[2])
  assert(!move (_2562.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2560, move _2561) -> bb724
  using: _2562@Entry, _2560@Entry, _2561@Entry
bb724:
  _2559 = move (_2562.0: i32)
  using: _2562@Mir(bb723[3])
  _2558 = move _2559 as isize (IntToInt)
  using: _2559@Mir(bb724[0])
  _2556 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2557, move _2558) -> bb725
  using: _2557@Mir(bb723[0]), _2558@Mir(bb724[1])
bb725:
  _2555 = (*_2556)
  using: _2556@Mir(bb724[2])
  _2554 = move _2555 as usize (IntToInt)
  using: _2555@Mir(bb725[0])
  _2563 = const 258_usize
  using: 
  _2564 = Lt(_2554, _2563)
  using: _2554@Mir(bb725[1]), _2563@Mir(bb725[2])
  assert(move _2564, "index out of bounds: the length is {} but the index is {}", move _2563, _2554) -> bb726
  using: _2564@Entry, _2563@Entry, _2554@Entry
bb726:
  _2565 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2550][_2554], const 1_i32)
  using: _1@Phi(bb548), _2554@Mir(bb725[1]), _2550@Mir(bb722[2])
  assert(!move (_2565.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2550][_2554], const 1_i32) -> bb727
  using: _2565@Entry, _1@Entry, _2554@Entry, _2550@Entry
bb727:
  ((*_1).37: [[i32; 258]; 6])[_2550][_2554] = move (_2565.0: i32)
  using: _1@Phi(bb548), _2554@Mir(bb725[1]), _2550@Mir(bb722[2]), _2565@Mir(bb726[0])
  _2567 = _9
  using: _9@Phi(bb554)
  _2566 = move _2567 as usize (IntToInt)
  using: _2567@Mir(bb727[1])
  _2568 = const 6_usize
  using: 
  _2569 = Lt(_2566, _2568)
  using: _2566@Mir(bb727[2]), _2568@Mir(bb727[3])
  assert(move _2569, "index out of bounds: the length is {} but the index is {}", move _2568, _2566) -> bb728
  using: _2569@Entry, _2568@Entry, _2566@Entry
bb728:
  _2573 = _21
  using: _21@Phi(bb548)
  _2576 = _6
  using: _6@Phi(bb564)
  _2577 = const 32_i32
  using: 
  _2578 = CheckedAdd(_2576, _2577)
  using: _2576@Mir(bb728[1]), _2577@Mir(bb728[2])
  assert(!move (_2578.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2576, move _2577) -> bb729
  using: _2578@Entry, _2576@Entry, _2577@Entry
bb729:
  _2575 = move (_2578.0: i32)
  using: _2578@Mir(bb728[3])
  _2574 = move _2575 as isize (IntToInt)
  using: _2575@Mir(bb729[0])
  _2572 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2573, move _2574) -> bb730
  using: _2573@Mir(bb728[0]), _2574@Mir(bb729[1])
bb730:
  _2571 = (*_2572)
  using: _2572@Mir(bb729[2])
  _2570 = move _2571 as usize (IntToInt)
  using: _2571@Mir(bb730[0])
  _2579 = const 258_usize
  using: 
  _2580 = Lt(_2570, _2579)
  using: _2570@Mir(bb730[1]), _2579@Mir(bb730[2])
  assert(move _2580, "index out of bounds: the length is {} but the index is {}", move _2579, _2570) -> bb731
  using: _2580@Entry, _2579@Entry, _2570@Entry
bb731:
  _2581 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2566][_2570], const 1_i32)
  using: _1@Phi(bb548), _2570@Mir(bb730[1]), _2566@Mir(bb727[2])
  assert(!move (_2581.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2566][_2570], const 1_i32) -> bb732
  using: _2581@Entry, _1@Entry, _2570@Entry, _2566@Entry
bb732:
  ((*_1).37: [[i32; 258]; 6])[_2566][_2570] = move (_2581.0: i32)
  using: _1@Phi(bb548), _2570@Mir(bb730[1]), _2566@Mir(bb727[2]), _2581@Mir(bb731[0])
  _2583 = _9
  using: _9@Phi(bb554)
  _2582 = move _2583 as usize (IntToInt)
  using: _2583@Mir(bb732[1])
  _2584 = const 6_usize
  using: 
  _2585 = Lt(_2582, _2584)
  using: _2582@Mir(bb732[2]), _2584@Mir(bb732[3])
  assert(move _2585, "index out of bounds: the length is {} but the index is {}", move _2584, _2582) -> bb733
  using: _2585@Entry, _2584@Entry, _2582@Entry
bb733:
  _2589 = _21
  using: _21@Phi(bb548)
  _2592 = _6
  using: _6@Phi(bb564)
  _2593 = const 33_i32
  using: 
  _2594 = CheckedAdd(_2592, _2593)
  using: _2592@Mir(bb733[1]), _2593@Mir(bb733[2])
  assert(!move (_2594.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2592, move _2593) -> bb734
  using: _2594@Entry, _2592@Entry, _2593@Entry
bb734:
  _2591 = move (_2594.0: i32)
  using: _2594@Mir(bb733[3])
  _2590 = move _2591 as isize (IntToInt)
  using: _2591@Mir(bb734[0])
  _2588 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2589, move _2590) -> bb735
  using: _2589@Mir(bb733[0]), _2590@Mir(bb734[1])
bb735:
  _2587 = (*_2588)
  using: _2588@Mir(bb734[2])
  _2586 = move _2587 as usize (IntToInt)
  using: _2587@Mir(bb735[0])
  _2595 = const 258_usize
  using: 
  _2596 = Lt(_2586, _2595)
  using: _2586@Mir(bb735[1]), _2595@Mir(bb735[2])
  assert(move _2596, "index out of bounds: the length is {} but the index is {}", move _2595, _2586) -> bb736
  using: _2596@Entry, _2595@Entry, _2586@Entry
bb736:
  _2597 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2582][_2586], const 1_i32)
  using: _1@Phi(bb548), _2586@Mir(bb735[1]), _2582@Mir(bb732[2])
  assert(!move (_2597.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2582][_2586], const 1_i32) -> bb737
  using: _2597@Entry, _1@Entry, _2586@Entry, _2582@Entry
bb737:
  ((*_1).37: [[i32; 258]; 6])[_2582][_2586] = move (_2597.0: i32)
  using: _1@Phi(bb548), _2586@Mir(bb735[1]), _2582@Mir(bb732[2]), _2597@Mir(bb736[0])
  _2599 = _9
  using: _9@Phi(bb554)
  _2598 = move _2599 as usize (IntToInt)
  using: _2599@Mir(bb737[1])
  _2600 = const 6_usize
  using: 
  _2601 = Lt(_2598, _2600)
  using: _2598@Mir(bb737[2]), _2600@Mir(bb737[3])
  assert(move _2601, "index out of bounds: the length is {} but the index is {}", move _2600, _2598) -> bb738
  using: _2601@Entry, _2600@Entry, _2598@Entry
bb738:
  _2605 = _21
  using: _21@Phi(bb548)
  _2608 = _6
  using: _6@Phi(bb564)
  _2609 = const 34_i32
  using: 
  _2610 = CheckedAdd(_2608, _2609)
  using: _2608@Mir(bb738[1]), _2609@Mir(bb738[2])
  assert(!move (_2610.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2608, move _2609) -> bb739
  using: _2610@Entry, _2608@Entry, _2609@Entry
bb739:
  _2607 = move (_2610.0: i32)
  using: _2610@Mir(bb738[3])
  _2606 = move _2607 as isize (IntToInt)
  using: _2607@Mir(bb739[0])
  _2604 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2605, move _2606) -> bb740
  using: _2605@Mir(bb738[0]), _2606@Mir(bb739[1])
bb740:
  _2603 = (*_2604)
  using: _2604@Mir(bb739[2])
  _2602 = move _2603 as usize (IntToInt)
  using: _2603@Mir(bb740[0])
  _2611 = const 258_usize
  using: 
  _2612 = Lt(_2602, _2611)
  using: _2602@Mir(bb740[1]), _2611@Mir(bb740[2])
  assert(move _2612, "index out of bounds: the length is {} but the index is {}", move _2611, _2602) -> bb741
  using: _2612@Entry, _2611@Entry, _2602@Entry
bb741:
  _2613 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2598][_2602], const 1_i32)
  using: _1@Phi(bb548), _2602@Mir(bb740[1]), _2598@Mir(bb737[2])
  assert(!move (_2613.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2598][_2602], const 1_i32) -> bb742
  using: _2613@Entry, _1@Entry, _2602@Entry, _2598@Entry
bb742:
  ((*_1).37: [[i32; 258]; 6])[_2598][_2602] = move (_2613.0: i32)
  using: _1@Phi(bb548), _2602@Mir(bb740[1]), _2598@Mir(bb737[2]), _2613@Mir(bb741[0])
  _2615 = _9
  using: _9@Phi(bb554)
  _2614 = move _2615 as usize (IntToInt)
  using: _2615@Mir(bb742[1])
  _2616 = const 6_usize
  using: 
  _2617 = Lt(_2614, _2616)
  using: _2614@Mir(bb742[2]), _2616@Mir(bb742[3])
  assert(move _2617, "index out of bounds: the length is {} but the index is {}", move _2616, _2614) -> bb743
  using: _2617@Entry, _2616@Entry, _2614@Entry
bb743:
  _2621 = _21
  using: _21@Phi(bb548)
  _2624 = _6
  using: _6@Phi(bb564)
  _2625 = const 35_i32
  using: 
  _2626 = CheckedAdd(_2624, _2625)
  using: _2624@Mir(bb743[1]), _2625@Mir(bb743[2])
  assert(!move (_2626.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2624, move _2625) -> bb744
  using: _2626@Entry, _2624@Entry, _2625@Entry
bb744:
  _2623 = move (_2626.0: i32)
  using: _2626@Mir(bb743[3])
  _2622 = move _2623 as isize (IntToInt)
  using: _2623@Mir(bb744[0])
  _2620 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2621, move _2622) -> bb745
  using: _2621@Mir(bb743[0]), _2622@Mir(bb744[1])
bb745:
  _2619 = (*_2620)
  using: _2620@Mir(bb744[2])
  _2618 = move _2619 as usize (IntToInt)
  using: _2619@Mir(bb745[0])
  _2627 = const 258_usize
  using: 
  _2628 = Lt(_2618, _2627)
  using: _2618@Mir(bb745[1]), _2627@Mir(bb745[2])
  assert(move _2628, "index out of bounds: the length is {} but the index is {}", move _2627, _2618) -> bb746
  using: _2628@Entry, _2627@Entry, _2618@Entry
bb746:
  _2629 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2614][_2618], const 1_i32)
  using: _1@Phi(bb548), _2618@Mir(bb745[1]), _2614@Mir(bb742[2])
  assert(!move (_2629.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2614][_2618], const 1_i32) -> bb747
  using: _2629@Entry, _1@Entry, _2618@Entry, _2614@Entry
bb747:
  ((*_1).37: [[i32; 258]; 6])[_2614][_2618] = move (_2629.0: i32)
  using: _1@Phi(bb548), _2618@Mir(bb745[1]), _2614@Mir(bb742[2]), _2629@Mir(bb746[0])
  _2631 = _9
  using: _9@Phi(bb554)
  _2630 = move _2631 as usize (IntToInt)
  using: _2631@Mir(bb747[1])
  _2632 = const 6_usize
  using: 
  _2633 = Lt(_2630, _2632)
  using: _2630@Mir(bb747[2]), _2632@Mir(bb747[3])
  assert(move _2633, "index out of bounds: the length is {} but the index is {}", move _2632, _2630) -> bb748
  using: _2633@Entry, _2632@Entry, _2630@Entry
bb748:
  _2637 = _21
  using: _21@Phi(bb548)
  _2640 = _6
  using: _6@Phi(bb564)
  _2641 = const 36_i32
  using: 
  _2642 = CheckedAdd(_2640, _2641)
  using: _2640@Mir(bb748[1]), _2641@Mir(bb748[2])
  assert(!move (_2642.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2640, move _2641) -> bb749
  using: _2642@Entry, _2640@Entry, _2641@Entry
bb749:
  _2639 = move (_2642.0: i32)
  using: _2642@Mir(bb748[3])
  _2638 = move _2639 as isize (IntToInt)
  using: _2639@Mir(bb749[0])
  _2636 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2637, move _2638) -> bb750
  using: _2637@Mir(bb748[0]), _2638@Mir(bb749[1])
bb750:
  _2635 = (*_2636)
  using: _2636@Mir(bb749[2])
  _2634 = move _2635 as usize (IntToInt)
  using: _2635@Mir(bb750[0])
  _2643 = const 258_usize
  using: 
  _2644 = Lt(_2634, _2643)
  using: _2634@Mir(bb750[1]), _2643@Mir(bb750[2])
  assert(move _2644, "index out of bounds: the length is {} but the index is {}", move _2643, _2634) -> bb751
  using: _2644@Entry, _2643@Entry, _2634@Entry
bb751:
  _2645 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2630][_2634], const 1_i32)
  using: _1@Phi(bb548), _2634@Mir(bb750[1]), _2630@Mir(bb747[2])
  assert(!move (_2645.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2630][_2634], const 1_i32) -> bb752
  using: _2645@Entry, _1@Entry, _2634@Entry, _2630@Entry
bb752:
  ((*_1).37: [[i32; 258]; 6])[_2630][_2634] = move (_2645.0: i32)
  using: _1@Phi(bb548), _2634@Mir(bb750[1]), _2630@Mir(bb747[2]), _2645@Mir(bb751[0])
  _2647 = _9
  using: _9@Phi(bb554)
  _2646 = move _2647 as usize (IntToInt)
  using: _2647@Mir(bb752[1])
  _2648 = const 6_usize
  using: 
  _2649 = Lt(_2646, _2648)
  using: _2646@Mir(bb752[2]), _2648@Mir(bb752[3])
  assert(move _2649, "index out of bounds: the length is {} but the index is {}", move _2648, _2646) -> bb753
  using: _2649@Entry, _2648@Entry, _2646@Entry
bb753:
  _2653 = _21
  using: _21@Phi(bb548)
  _2656 = _6
  using: _6@Phi(bb564)
  _2657 = const 37_i32
  using: 
  _2658 = CheckedAdd(_2656, _2657)
  using: _2656@Mir(bb753[1]), _2657@Mir(bb753[2])
  assert(!move (_2658.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2656, move _2657) -> bb754
  using: _2658@Entry, _2656@Entry, _2657@Entry
bb754:
  _2655 = move (_2658.0: i32)
  using: _2658@Mir(bb753[3])
  _2654 = move _2655 as isize (IntToInt)
  using: _2655@Mir(bb754[0])
  _2652 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2653, move _2654) -> bb755
  using: _2653@Mir(bb753[0]), _2654@Mir(bb754[1])
bb755:
  _2651 = (*_2652)
  using: _2652@Mir(bb754[2])
  _2650 = move _2651 as usize (IntToInt)
  using: _2651@Mir(bb755[0])
  _2659 = const 258_usize
  using: 
  _2660 = Lt(_2650, _2659)
  using: _2650@Mir(bb755[1]), _2659@Mir(bb755[2])
  assert(move _2660, "index out of bounds: the length is {} but the index is {}", move _2659, _2650) -> bb756
  using: _2660@Entry, _2659@Entry, _2650@Entry
bb756:
  _2661 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2646][_2650], const 1_i32)
  using: _1@Phi(bb548), _2650@Mir(bb755[1]), _2646@Mir(bb752[2])
  assert(!move (_2661.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2646][_2650], const 1_i32) -> bb757
  using: _2661@Entry, _1@Entry, _2650@Entry, _2646@Entry
bb757:
  ((*_1).37: [[i32; 258]; 6])[_2646][_2650] = move (_2661.0: i32)
  using: _1@Phi(bb548), _2650@Mir(bb755[1]), _2646@Mir(bb752[2]), _2661@Mir(bb756[0])
  _2663 = _9
  using: _9@Phi(bb554)
  _2662 = move _2663 as usize (IntToInt)
  using: _2663@Mir(bb757[1])
  _2664 = const 6_usize
  using: 
  _2665 = Lt(_2662, _2664)
  using: _2662@Mir(bb757[2]), _2664@Mir(bb757[3])
  assert(move _2665, "index out of bounds: the length is {} but the index is {}", move _2664, _2662) -> bb758
  using: _2665@Entry, _2664@Entry, _2662@Entry
bb758:
  _2669 = _21
  using: _21@Phi(bb548)
  _2672 = _6
  using: _6@Phi(bb564)
  _2673 = const 38_i32
  using: 
  _2674 = CheckedAdd(_2672, _2673)
  using: _2672@Mir(bb758[1]), _2673@Mir(bb758[2])
  assert(!move (_2674.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2672, move _2673) -> bb759
  using: _2674@Entry, _2672@Entry, _2673@Entry
bb759:
  _2671 = move (_2674.0: i32)
  using: _2674@Mir(bb758[3])
  _2670 = move _2671 as isize (IntToInt)
  using: _2671@Mir(bb759[0])
  _2668 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2669, move _2670) -> bb760
  using: _2669@Mir(bb758[0]), _2670@Mir(bb759[1])
bb760:
  _2667 = (*_2668)
  using: _2668@Mir(bb759[2])
  _2666 = move _2667 as usize (IntToInt)
  using: _2667@Mir(bb760[0])
  _2675 = const 258_usize
  using: 
  _2676 = Lt(_2666, _2675)
  using: _2666@Mir(bb760[1]), _2675@Mir(bb760[2])
  assert(move _2676, "index out of bounds: the length is {} but the index is {}", move _2675, _2666) -> bb761
  using: _2676@Entry, _2675@Entry, _2666@Entry
bb761:
  _2677 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2662][_2666], const 1_i32)
  using: _1@Phi(bb548), _2666@Mir(bb760[1]), _2662@Mir(bb757[2])
  assert(!move (_2677.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2662][_2666], const 1_i32) -> bb762
  using: _2677@Entry, _1@Entry, _2666@Entry, _2662@Entry
bb762:
  ((*_1).37: [[i32; 258]; 6])[_2662][_2666] = move (_2677.0: i32)
  using: _1@Phi(bb548), _2666@Mir(bb760[1]), _2662@Mir(bb757[2]), _2677@Mir(bb761[0])
  _2679 = _9
  using: _9@Phi(bb554)
  _2678 = move _2679 as usize (IntToInt)
  using: _2679@Mir(bb762[1])
  _2680 = const 6_usize
  using: 
  _2681 = Lt(_2678, _2680)
  using: _2678@Mir(bb762[2]), _2680@Mir(bb762[3])
  assert(move _2681, "index out of bounds: the length is {} but the index is {}", move _2680, _2678) -> bb763
  using: _2681@Entry, _2680@Entry, _2678@Entry
bb763:
  _2685 = _21
  using: _21@Phi(bb548)
  _2688 = _6
  using: _6@Phi(bb564)
  _2689 = const 39_i32
  using: 
  _2690 = CheckedAdd(_2688, _2689)
  using: _2688@Mir(bb763[1]), _2689@Mir(bb763[2])
  assert(!move (_2690.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2688, move _2689) -> bb764
  using: _2690@Entry, _2688@Entry, _2689@Entry
bb764:
  _2687 = move (_2690.0: i32)
  using: _2690@Mir(bb763[3])
  _2686 = move _2687 as isize (IntToInt)
  using: _2687@Mir(bb764[0])
  _2684 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2685, move _2686) -> bb765
  using: _2685@Mir(bb763[0]), _2686@Mir(bb764[1])
bb765:
  _2683 = (*_2684)
  using: _2684@Mir(bb764[2])
  _2682 = move _2683 as usize (IntToInt)
  using: _2683@Mir(bb765[0])
  _2691 = const 258_usize
  using: 
  _2692 = Lt(_2682, _2691)
  using: _2682@Mir(bb765[1]), _2691@Mir(bb765[2])
  assert(move _2692, "index out of bounds: the length is {} but the index is {}", move _2691, _2682) -> bb766
  using: _2692@Entry, _2691@Entry, _2682@Entry
bb766:
  _2693 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2678][_2682], const 1_i32)
  using: _1@Phi(bb548), _2682@Mir(bb765[1]), _2678@Mir(bb762[2])
  assert(!move (_2693.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2678][_2682], const 1_i32) -> bb767
  using: _2693@Entry, _1@Entry, _2682@Entry, _2678@Entry
bb767:
  ((*_1).37: [[i32; 258]; 6])[_2678][_2682] = move (_2693.0: i32)
  using: _1@Phi(bb548), _2682@Mir(bb765[1]), _2678@Mir(bb762[2]), _2693@Mir(bb766[0])
  _2695 = _9
  using: _9@Phi(bb554)
  _2694 = move _2695 as usize (IntToInt)
  using: _2695@Mir(bb767[1])
  _2696 = const 6_usize
  using: 
  _2697 = Lt(_2694, _2696)
  using: _2694@Mir(bb767[2]), _2696@Mir(bb767[3])
  assert(move _2697, "index out of bounds: the length is {} but the index is {}", move _2696, _2694) -> bb768
  using: _2697@Entry, _2696@Entry, _2694@Entry
bb768:
  _2701 = _21
  using: _21@Phi(bb548)
  _2704 = _6
  using: _6@Phi(bb564)
  _2705 = const 40_i32
  using: 
  _2706 = CheckedAdd(_2704, _2705)
  using: _2704@Mir(bb768[1]), _2705@Mir(bb768[2])
  assert(!move (_2706.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2704, move _2705) -> bb769
  using: _2706@Entry, _2704@Entry, _2705@Entry
bb769:
  _2703 = move (_2706.0: i32)
  using: _2706@Mir(bb768[3])
  _2702 = move _2703 as isize (IntToInt)
  using: _2703@Mir(bb769[0])
  _2700 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2701, move _2702) -> bb770
  using: _2701@Mir(bb768[0]), _2702@Mir(bb769[1])
bb770:
  _2699 = (*_2700)
  using: _2700@Mir(bb769[2])
  _2698 = move _2699 as usize (IntToInt)
  using: _2699@Mir(bb770[0])
  _2707 = const 258_usize
  using: 
  _2708 = Lt(_2698, _2707)
  using: _2698@Mir(bb770[1]), _2707@Mir(bb770[2])
  assert(move _2708, "index out of bounds: the length is {} but the index is {}", move _2707, _2698) -> bb771
  using: _2708@Entry, _2707@Entry, _2698@Entry
bb771:
  _2709 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2694][_2698], const 1_i32)
  using: _1@Phi(bb548), _2698@Mir(bb770[1]), _2694@Mir(bb767[2])
  assert(!move (_2709.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2694][_2698], const 1_i32) -> bb772
  using: _2709@Entry, _1@Entry, _2698@Entry, _2694@Entry
bb772:
  ((*_1).37: [[i32; 258]; 6])[_2694][_2698] = move (_2709.0: i32)
  using: _1@Phi(bb548), _2698@Mir(bb770[1]), _2694@Mir(bb767[2]), _2709@Mir(bb771[0])
  _2711 = _9
  using: _9@Phi(bb554)
  _2710 = move _2711 as usize (IntToInt)
  using: _2711@Mir(bb772[1])
  _2712 = const 6_usize
  using: 
  _2713 = Lt(_2710, _2712)
  using: _2710@Mir(bb772[2]), _2712@Mir(bb772[3])
  assert(move _2713, "index out of bounds: the length is {} but the index is {}", move _2712, _2710) -> bb773
  using: _2713@Entry, _2712@Entry, _2710@Entry
bb773:
  _2717 = _21
  using: _21@Phi(bb548)
  _2720 = _6
  using: _6@Phi(bb564)
  _2721 = const 41_i32
  using: 
  _2722 = CheckedAdd(_2720, _2721)
  using: _2720@Mir(bb773[1]), _2721@Mir(bb773[2])
  assert(!move (_2722.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2720, move _2721) -> bb774
  using: _2722@Entry, _2720@Entry, _2721@Entry
bb774:
  _2719 = move (_2722.0: i32)
  using: _2722@Mir(bb773[3])
  _2718 = move _2719 as isize (IntToInt)
  using: _2719@Mir(bb774[0])
  _2716 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2717, move _2718) -> bb775
  using: _2717@Mir(bb773[0]), _2718@Mir(bb774[1])
bb775:
  _2715 = (*_2716)
  using: _2716@Mir(bb774[2])
  _2714 = move _2715 as usize (IntToInt)
  using: _2715@Mir(bb775[0])
  _2723 = const 258_usize
  using: 
  _2724 = Lt(_2714, _2723)
  using: _2714@Mir(bb775[1]), _2723@Mir(bb775[2])
  assert(move _2724, "index out of bounds: the length is {} but the index is {}", move _2723, _2714) -> bb776
  using: _2724@Entry, _2723@Entry, _2714@Entry
bb776:
  _2725 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2710][_2714], const 1_i32)
  using: _1@Phi(bb548), _2714@Mir(bb775[1]), _2710@Mir(bb772[2])
  assert(!move (_2725.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2710][_2714], const 1_i32) -> bb777
  using: _2725@Entry, _1@Entry, _2714@Entry, _2710@Entry
bb777:
  ((*_1).37: [[i32; 258]; 6])[_2710][_2714] = move (_2725.0: i32)
  using: _1@Phi(bb548), _2714@Mir(bb775[1]), _2710@Mir(bb772[2]), _2725@Mir(bb776[0])
  _2727 = _9
  using: _9@Phi(bb554)
  _2726 = move _2727 as usize (IntToInt)
  using: _2727@Mir(bb777[1])
  _2728 = const 6_usize
  using: 
  _2729 = Lt(_2726, _2728)
  using: _2726@Mir(bb777[2]), _2728@Mir(bb777[3])
  assert(move _2729, "index out of bounds: the length is {} but the index is {}", move _2728, _2726) -> bb778
  using: _2729@Entry, _2728@Entry, _2726@Entry
bb778:
  _2733 = _21
  using: _21@Phi(bb548)
  _2736 = _6
  using: _6@Phi(bb564)
  _2737 = const 42_i32
  using: 
  _2738 = CheckedAdd(_2736, _2737)
  using: _2736@Mir(bb778[1]), _2737@Mir(bb778[2])
  assert(!move (_2738.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2736, move _2737) -> bb779
  using: _2738@Entry, _2736@Entry, _2737@Entry
bb779:
  _2735 = move (_2738.0: i32)
  using: _2738@Mir(bb778[3])
  _2734 = move _2735 as isize (IntToInt)
  using: _2735@Mir(bb779[0])
  _2732 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2733, move _2734) -> bb780
  using: _2733@Mir(bb778[0]), _2734@Mir(bb779[1])
bb780:
  _2731 = (*_2732)
  using: _2732@Mir(bb779[2])
  _2730 = move _2731 as usize (IntToInt)
  using: _2731@Mir(bb780[0])
  _2739 = const 258_usize
  using: 
  _2740 = Lt(_2730, _2739)
  using: _2730@Mir(bb780[1]), _2739@Mir(bb780[2])
  assert(move _2740, "index out of bounds: the length is {} but the index is {}", move _2739, _2730) -> bb781
  using: _2740@Entry, _2739@Entry, _2730@Entry
bb781:
  _2741 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2726][_2730], const 1_i32)
  using: _1@Phi(bb548), _2730@Mir(bb780[1]), _2726@Mir(bb777[2])
  assert(!move (_2741.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2726][_2730], const 1_i32) -> bb782
  using: _2741@Entry, _1@Entry, _2730@Entry, _2726@Entry
bb782:
  ((*_1).37: [[i32; 258]; 6])[_2726][_2730] = move (_2741.0: i32)
  using: _1@Phi(bb548), _2730@Mir(bb780[1]), _2726@Mir(bb777[2]), _2741@Mir(bb781[0])
  _2743 = _9
  using: _9@Phi(bb554)
  _2742 = move _2743 as usize (IntToInt)
  using: _2743@Mir(bb782[1])
  _2744 = const 6_usize
  using: 
  _2745 = Lt(_2742, _2744)
  using: _2742@Mir(bb782[2]), _2744@Mir(bb782[3])
  assert(move _2745, "index out of bounds: the length is {} but the index is {}", move _2744, _2742) -> bb783
  using: _2745@Entry, _2744@Entry, _2742@Entry
bb783:
  _2749 = _21
  using: _21@Phi(bb548)
  _2752 = _6
  using: _6@Phi(bb564)
  _2753 = const 43_i32
  using: 
  _2754 = CheckedAdd(_2752, _2753)
  using: _2752@Mir(bb783[1]), _2753@Mir(bb783[2])
  assert(!move (_2754.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2752, move _2753) -> bb784
  using: _2754@Entry, _2752@Entry, _2753@Entry
bb784:
  _2751 = move (_2754.0: i32)
  using: _2754@Mir(bb783[3])
  _2750 = move _2751 as isize (IntToInt)
  using: _2751@Mir(bb784[0])
  _2748 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2749, move _2750) -> bb785
  using: _2749@Mir(bb783[0]), _2750@Mir(bb784[1])
bb785:
  _2747 = (*_2748)
  using: _2748@Mir(bb784[2])
  _2746 = move _2747 as usize (IntToInt)
  using: _2747@Mir(bb785[0])
  _2755 = const 258_usize
  using: 
  _2756 = Lt(_2746, _2755)
  using: _2746@Mir(bb785[1]), _2755@Mir(bb785[2])
  assert(move _2756, "index out of bounds: the length is {} but the index is {}", move _2755, _2746) -> bb786
  using: _2756@Entry, _2755@Entry, _2746@Entry
bb786:
  _2757 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2742][_2746], const 1_i32)
  using: _1@Phi(bb548), _2746@Mir(bb785[1]), _2742@Mir(bb782[2])
  assert(!move (_2757.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2742][_2746], const 1_i32) -> bb787
  using: _2757@Entry, _1@Entry, _2746@Entry, _2742@Entry
bb787:
  ((*_1).37: [[i32; 258]; 6])[_2742][_2746] = move (_2757.0: i32)
  using: _1@Phi(bb548), _2746@Mir(bb785[1]), _2742@Mir(bb782[2]), _2757@Mir(bb786[0])
  _2759 = _9
  using: _9@Phi(bb554)
  _2758 = move _2759 as usize (IntToInt)
  using: _2759@Mir(bb787[1])
  _2760 = const 6_usize
  using: 
  _2761 = Lt(_2758, _2760)
  using: _2758@Mir(bb787[2]), _2760@Mir(bb787[3])
  assert(move _2761, "index out of bounds: the length is {} but the index is {}", move _2760, _2758) -> bb788
  using: _2761@Entry, _2760@Entry, _2758@Entry
bb788:
  _2765 = _21
  using: _21@Phi(bb548)
  _2768 = _6
  using: _6@Phi(bb564)
  _2769 = const 44_i32
  using: 
  _2770 = CheckedAdd(_2768, _2769)
  using: _2768@Mir(bb788[1]), _2769@Mir(bb788[2])
  assert(!move (_2770.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2768, move _2769) -> bb789
  using: _2770@Entry, _2768@Entry, _2769@Entry
bb789:
  _2767 = move (_2770.0: i32)
  using: _2770@Mir(bb788[3])
  _2766 = move _2767 as isize (IntToInt)
  using: _2767@Mir(bb789[0])
  _2764 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2765, move _2766) -> bb790
  using: _2765@Mir(bb788[0]), _2766@Mir(bb789[1])
bb790:
  _2763 = (*_2764)
  using: _2764@Mir(bb789[2])
  _2762 = move _2763 as usize (IntToInt)
  using: _2763@Mir(bb790[0])
  _2771 = const 258_usize
  using: 
  _2772 = Lt(_2762, _2771)
  using: _2762@Mir(bb790[1]), _2771@Mir(bb790[2])
  assert(move _2772, "index out of bounds: the length is {} but the index is {}", move _2771, _2762) -> bb791
  using: _2772@Entry, _2771@Entry, _2762@Entry
bb791:
  _2773 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2758][_2762], const 1_i32)
  using: _1@Phi(bb548), _2762@Mir(bb790[1]), _2758@Mir(bb787[2])
  assert(!move (_2773.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2758][_2762], const 1_i32) -> bb792
  using: _2773@Entry, _1@Entry, _2762@Entry, _2758@Entry
bb792:
  ((*_1).37: [[i32; 258]; 6])[_2758][_2762] = move (_2773.0: i32)
  using: _1@Phi(bb548), _2762@Mir(bb790[1]), _2758@Mir(bb787[2]), _2773@Mir(bb791[0])
  _2775 = _9
  using: _9@Phi(bb554)
  _2774 = move _2775 as usize (IntToInt)
  using: _2775@Mir(bb792[1])
  _2776 = const 6_usize
  using: 
  _2777 = Lt(_2774, _2776)
  using: _2774@Mir(bb792[2]), _2776@Mir(bb792[3])
  assert(move _2777, "index out of bounds: the length is {} but the index is {}", move _2776, _2774) -> bb793
  using: _2777@Entry, _2776@Entry, _2774@Entry
bb793:
  _2781 = _21
  using: _21@Phi(bb548)
  _2784 = _6
  using: _6@Phi(bb564)
  _2785 = const 45_i32
  using: 
  _2786 = CheckedAdd(_2784, _2785)
  using: _2784@Mir(bb793[1]), _2785@Mir(bb793[2])
  assert(!move (_2786.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2784, move _2785) -> bb794
  using: _2786@Entry, _2784@Entry, _2785@Entry
bb794:
  _2783 = move (_2786.0: i32)
  using: _2786@Mir(bb793[3])
  _2782 = move _2783 as isize (IntToInt)
  using: _2783@Mir(bb794[0])
  _2780 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2781, move _2782) -> bb795
  using: _2781@Mir(bb793[0]), _2782@Mir(bb794[1])
bb795:
  _2779 = (*_2780)
  using: _2780@Mir(bb794[2])
  _2778 = move _2779 as usize (IntToInt)
  using: _2779@Mir(bb795[0])
  _2787 = const 258_usize
  using: 
  _2788 = Lt(_2778, _2787)
  using: _2778@Mir(bb795[1]), _2787@Mir(bb795[2])
  assert(move _2788, "index out of bounds: the length is {} but the index is {}", move _2787, _2778) -> bb796
  using: _2788@Entry, _2787@Entry, _2778@Entry
bb796:
  _2789 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2774][_2778], const 1_i32)
  using: _1@Phi(bb548), _2778@Mir(bb795[1]), _2774@Mir(bb792[2])
  assert(!move (_2789.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2774][_2778], const 1_i32) -> bb797
  using: _2789@Entry, _1@Entry, _2778@Entry, _2774@Entry
bb797:
  ((*_1).37: [[i32; 258]; 6])[_2774][_2778] = move (_2789.0: i32)
  using: _1@Phi(bb548), _2778@Mir(bb795[1]), _2774@Mir(bb792[2]), _2789@Mir(bb796[0])
  _2791 = _9
  using: _9@Phi(bb554)
  _2790 = move _2791 as usize (IntToInt)
  using: _2791@Mir(bb797[1])
  _2792 = const 6_usize
  using: 
  _2793 = Lt(_2790, _2792)
  using: _2790@Mir(bb797[2]), _2792@Mir(bb797[3])
  assert(move _2793, "index out of bounds: the length is {} but the index is {}", move _2792, _2790) -> bb798
  using: _2793@Entry, _2792@Entry, _2790@Entry
bb798:
  _2797 = _21
  using: _21@Phi(bb548)
  _2800 = _6
  using: _6@Phi(bb564)
  _2801 = const 46_i32
  using: 
  _2802 = CheckedAdd(_2800, _2801)
  using: _2800@Mir(bb798[1]), _2801@Mir(bb798[2])
  assert(!move (_2802.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2800, move _2801) -> bb799
  using: _2802@Entry, _2800@Entry, _2801@Entry
bb799:
  _2799 = move (_2802.0: i32)
  using: _2802@Mir(bb798[3])
  _2798 = move _2799 as isize (IntToInt)
  using: _2799@Mir(bb799[0])
  _2796 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2797, move _2798) -> bb800
  using: _2797@Mir(bb798[0]), _2798@Mir(bb799[1])
bb800:
  _2795 = (*_2796)
  using: _2796@Mir(bb799[2])
  _2794 = move _2795 as usize (IntToInt)
  using: _2795@Mir(bb800[0])
  _2803 = const 258_usize
  using: 
  _2804 = Lt(_2794, _2803)
  using: _2794@Mir(bb800[1]), _2803@Mir(bb800[2])
  assert(move _2804, "index out of bounds: the length is {} but the index is {}", move _2803, _2794) -> bb801
  using: _2804@Entry, _2803@Entry, _2794@Entry
bb801:
  _2805 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2790][_2794], const 1_i32)
  using: _1@Phi(bb548), _2794@Mir(bb800[1]), _2790@Mir(bb797[2])
  assert(!move (_2805.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2790][_2794], const 1_i32) -> bb802
  using: _2805@Entry, _1@Entry, _2794@Entry, _2790@Entry
bb802:
  ((*_1).37: [[i32; 258]; 6])[_2790][_2794] = move (_2805.0: i32)
  using: _1@Phi(bb548), _2794@Mir(bb800[1]), _2790@Mir(bb797[2]), _2805@Mir(bb801[0])
  _2807 = _9
  using: _9@Phi(bb554)
  _2806 = move _2807 as usize (IntToInt)
  using: _2807@Mir(bb802[1])
  _2808 = const 6_usize
  using: 
  _2809 = Lt(_2806, _2808)
  using: _2806@Mir(bb802[2]), _2808@Mir(bb802[3])
  assert(move _2809, "index out of bounds: the length is {} but the index is {}", move _2808, _2806) -> bb803
  using: _2809@Entry, _2808@Entry, _2806@Entry
bb803:
  _2813 = _21
  using: _21@Phi(bb548)
  _2816 = _6
  using: _6@Phi(bb564)
  _2817 = const 47_i32
  using: 
  _2818 = CheckedAdd(_2816, _2817)
  using: _2816@Mir(bb803[1]), _2817@Mir(bb803[2])
  assert(!move (_2818.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2816, move _2817) -> bb804
  using: _2818@Entry, _2816@Entry, _2817@Entry
bb804:
  _2815 = move (_2818.0: i32)
  using: _2818@Mir(bb803[3])
  _2814 = move _2815 as isize (IntToInt)
  using: _2815@Mir(bb804[0])
  _2812 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2813, move _2814) -> bb805
  using: _2813@Mir(bb803[0]), _2814@Mir(bb804[1])
bb805:
  _2811 = (*_2812)
  using: _2812@Mir(bb804[2])
  _2810 = move _2811 as usize (IntToInt)
  using: _2811@Mir(bb805[0])
  _2819 = const 258_usize
  using: 
  _2820 = Lt(_2810, _2819)
  using: _2810@Mir(bb805[1]), _2819@Mir(bb805[2])
  assert(move _2820, "index out of bounds: the length is {} but the index is {}", move _2819, _2810) -> bb806
  using: _2820@Entry, _2819@Entry, _2810@Entry
bb806:
  _2821 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2806][_2810], const 1_i32)
  using: _1@Phi(bb548), _2810@Mir(bb805[1]), _2806@Mir(bb802[2])
  assert(!move (_2821.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2806][_2810], const 1_i32) -> bb807
  using: _2821@Entry, _1@Entry, _2810@Entry, _2806@Entry
bb807:
  ((*_1).37: [[i32; 258]; 6])[_2806][_2810] = move (_2821.0: i32)
  using: _1@Phi(bb548), _2810@Mir(bb805[1]), _2806@Mir(bb802[2]), _2821@Mir(bb806[0])
  _2823 = _9
  using: _9@Phi(bb554)
  _2822 = move _2823 as usize (IntToInt)
  using: _2823@Mir(bb807[1])
  _2824 = const 6_usize
  using: 
  _2825 = Lt(_2822, _2824)
  using: _2822@Mir(bb807[2]), _2824@Mir(bb807[3])
  assert(move _2825, "index out of bounds: the length is {} but the index is {}", move _2824, _2822) -> bb808
  using: _2825@Entry, _2824@Entry, _2822@Entry
bb808:
  _2829 = _21
  using: _21@Phi(bb548)
  _2832 = _6
  using: _6@Phi(bb564)
  _2833 = const 48_i32
  using: 
  _2834 = CheckedAdd(_2832, _2833)
  using: _2832@Mir(bb808[1]), _2833@Mir(bb808[2])
  assert(!move (_2834.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2832, move _2833) -> bb809
  using: _2834@Entry, _2832@Entry, _2833@Entry
bb809:
  _2831 = move (_2834.0: i32)
  using: _2834@Mir(bb808[3])
  _2830 = move _2831 as isize (IntToInt)
  using: _2831@Mir(bb809[0])
  _2828 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2829, move _2830) -> bb810
  using: _2829@Mir(bb808[0]), _2830@Mir(bb809[1])
bb810:
  _2827 = (*_2828)
  using: _2828@Mir(bb809[2])
  _2826 = move _2827 as usize (IntToInt)
  using: _2827@Mir(bb810[0])
  _2835 = const 258_usize
  using: 
  _2836 = Lt(_2826, _2835)
  using: _2826@Mir(bb810[1]), _2835@Mir(bb810[2])
  assert(move _2836, "index out of bounds: the length is {} but the index is {}", move _2835, _2826) -> bb811
  using: _2836@Entry, _2835@Entry, _2826@Entry
bb811:
  _2837 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2822][_2826], const 1_i32)
  using: _1@Phi(bb548), _2826@Mir(bb810[1]), _2822@Mir(bb807[2])
  assert(!move (_2837.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2822][_2826], const 1_i32) -> bb812
  using: _2837@Entry, _1@Entry, _2826@Entry, _2822@Entry
bb812:
  ((*_1).37: [[i32; 258]; 6])[_2822][_2826] = move (_2837.0: i32)
  using: _1@Phi(bb548), _2826@Mir(bb810[1]), _2822@Mir(bb807[2]), _2837@Mir(bb811[0])
  _2839 = _9
  using: _9@Phi(bb554)
  _2838 = move _2839 as usize (IntToInt)
  using: _2839@Mir(bb812[1])
  _2840 = const 6_usize
  using: 
  _2841 = Lt(_2838, _2840)
  using: _2838@Mir(bb812[2]), _2840@Mir(bb812[3])
  assert(move _2841, "index out of bounds: the length is {} but the index is {}", move _2840, _2838) -> bb813
  using: _2841@Entry, _2840@Entry, _2838@Entry
bb813:
  _2845 = _21
  using: _21@Phi(bb548)
  _2848 = _6
  using: _6@Phi(bb564)
  _2849 = const 49_i32
  using: 
  _2850 = CheckedAdd(_2848, _2849)
  using: _2848@Mir(bb813[1]), _2849@Mir(bb813[2])
  assert(!move (_2850.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2848, move _2849) -> bb814
  using: _2850@Entry, _2848@Entry, _2849@Entry
bb814:
  _2847 = move (_2850.0: i32)
  using: _2850@Mir(bb813[3])
  _2846 = move _2847 as isize (IntToInt)
  using: _2847@Mir(bb814[0])
  _2844 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2845, move _2846) -> bb815
  using: _2845@Mir(bb813[0]), _2846@Mir(bb814[1])
bb815:
  _2843 = (*_2844)
  using: _2844@Mir(bb814[2])
  _2842 = move _2843 as usize (IntToInt)
  using: _2843@Mir(bb815[0])
  _2851 = const 258_usize
  using: 
  _2852 = Lt(_2842, _2851)
  using: _2842@Mir(bb815[1]), _2851@Mir(bb815[2])
  assert(move _2852, "index out of bounds: the length is {} but the index is {}", move _2851, _2842) -> bb816
  using: _2852@Entry, _2851@Entry, _2842@Entry
bb816:
  _2853 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2838][_2842], const 1_i32)
  using: _1@Phi(bb548), _2842@Mir(bb815[1]), _2838@Mir(bb812[2])
  assert(!move (_2853.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2838][_2842], const 1_i32) -> bb817
  using: _2853@Entry, _1@Entry, _2842@Entry, _2838@Entry
bb817:
  ((*_1).37: [[i32; 258]; 6])[_2838][_2842] = move (_2853.0: i32)
  using: _1@Phi(bb548), _2842@Mir(bb815[1]), _2838@Mir(bb812[2]), _2853@Mir(bb816[0])
  goto -> bb826
  using: 
bb818:
  _2854 = _6
  using: _6@Phi(bb564)
  _4 = move _2854
  using: _2854@Mir(bb818[0])
  goto -> bb819
  using: 
bb819:
  _2856 = _4
  using: _4@Phi(bb819)
  _2857 = _7
  using: _7@Phi(bb564)
  _2855 = Le(move _2856, move _2857)
  using: _2856@Mir(bb819[0]), _2857@Mir(bb819[1])
  switchInt(move _2855) -> [0: bb826, otherwise: bb820]
  using: _2855@Mir(bb819[2])
bb820:
  _2859 = _9
  using: _9@Phi(bb819)
  _2858 = move _2859 as usize (IntToInt)
  using: _2859@Mir(bb820[0])
  _2860 = const 6_usize
  using: 
  _2861 = Lt(_2858, _2860)
  using: _2858@Mir(bb820[1]), _2860@Mir(bb820[2])
  assert(move _2861, "index out of bounds: the length is {} but the index is {}", move _2860, _2858) -> bb821
  using: _2861@Entry, _2860@Entry, _2858@Entry
bb821:
  _2865 = _21
  using: _21@Phi(bb819)
  _2867 = _4
  using: _4@Phi(bb819)
  _2866 = move _2867 as isize (IntToInt)
  using: _2867@Mir(bb821[1])
  _2864 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2865, move _2866) -> bb822
  using: _2865@Mir(bb821[0]), _2866@Mir(bb821[2])
bb822:
  _2863 = (*_2864)
  using: _2864@Mir(bb821[3])
  _2862 = move _2863 as usize (IntToInt)
  using: _2863@Mir(bb822[0])
  _2868 = const 258_usize
  using: 
  _2869 = Lt(_2862, _2868)
  using: _2862@Mir(bb822[1]), _2868@Mir(bb822[2])
  assert(move _2869, "index out of bounds: the length is {} but the index is {}", move _2868, _2862) -> bb823
  using: _2869@Entry, _2868@Entry, _2862@Entry
bb823:
  _2870 = CheckedAdd(((*_1).37: [[i32; 258]; 6])[_2858][_2862], const 1_i32)
  using: _1@Phi(bb819), _2862@Mir(bb822[1]), _2858@Mir(bb820[1])
  assert(!move (_2870.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).37: [[i32; 258]; 6])[_2858][_2862], const 1_i32) -> bb824
  using: _2870@Entry, _1@Entry, _2862@Entry, _2858@Entry
bb824:
  ((*_1).37: [[i32; 258]; 6])[_2858][_2862] = move (_2870.0: i32)
  using: _1@Phi(bb819), _2862@Mir(bb822[1]), _2858@Mir(bb820[1]), _2870@Mir(bb823[0])
  _2871 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb819)
  assert(!move (_2871.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb825
  using: _2871@Entry, _4@Entry
bb825:
  _4 = move (_2871.0: i32)
  using: _2871@Mir(bb824[1])
  goto -> bb819
  using: 
bb826:
  _2872 = _7
  using: _7@Phi(bb826)
  _2873 = const 1_i32
  using: 
  _2874 = CheckedAdd(_2872, _2873)
  using: _2872@Mir(bb826[0]), _2873@Mir(bb826[1])
  assert(!move (_2874.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2872, move _2873) -> bb827
  using: _2874@Entry, _2872@Entry, _2873@Entry
bb827:
  _6 = move (_2874.0: i32)
  using: _2874@Mir(bb826[2])
  goto -> bb112
  using: 
bb828:
  _2880 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _2879 = (*_2880)
  using: _2880@Mir(bb828[0])
  _2884 = const b"      pass %d: size is %d, grp uses are \x00"
  using: 
  _2883 = &raw const (*_2884)
  using: _2884@Mir(bb828[2])
  _2882 = move _2883 as *const u8 (Pointer(ArrayToPointer))
  using: _2883@Mir(bb828[3])
  _2881 = move _2882 as *const i8 (PtrToPtr)
  using: _2882@Mir(bb828[4])
  _2886 = _11
  using: _11@Phi(bb78)
  _2887 = const 1_i32
  using: 
  _2888 = CheckedAdd(_2886, _2887)
  using: _2886@Mir(bb828[6]), _2887@Mir(bb828[7])
  assert(!move (_2888.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2886, move _2887) -> bb829
  using: _2888@Entry, _2886@Entry, _2887@Entry
bb829:
  _2885 = move (_2888.0: i32)
  using: _2888@Mir(bb828[8])
  _2890 = _8
  using: _8@Phi(bb112)
  _2891 = const 8_i32
  using: 
  _2892 = const false
  using: 
  _2893 = Eq(_2890, const i32::MIN)
  using: _2890@Mir(bb829[1])
  _2894 = BitAnd(move _2892, move _2893)
  using: _2892@Mir(bb829[3]), _2893@Mir(bb829[4])
  assert(!move _2894, "attempt to compute `{} / {}`, which would overflow", _2890, _2891) -> bb830
  using: _2894@Entry, _2890@Entry, _2891@Entry
bb830:
  _2889 = Div(move _2890, move _2891)
  using: _2890@Mir(bb829[1]), _2891@Mir(bb829[2])
  _2878 = compress::fprintf(move _2879, move _2881, move _2885, move _2889) -> bb831
  using: _2879@Mir(bb828[1]), _2881@Mir(bb828[5]), _2885@Mir(bb829[0]), _2889@Mir(bb830[0])
bb831:
  _3 = const 0_i32
  using: 
  goto -> bb832
  using: 
bb832:
  _2896 = _3
  using: _3@Phi(bb832)
  _2897 = _17
  using: _17@Phi(bb112)
  _2895 = Lt(move _2896, move _2897)
  using: _2896@Mir(bb832[0]), _2897@Mir(bb832[1])
  switchInt(move _2895) -> [0: bb837, otherwise: bb833]
  using: _2895@Mir(bb832[2])
bb833:
  _2900 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _2899 = (*_2900)
  using: _2900@Mir(bb833[0])
  _2904 = const b"%d \x00"
  using: 
  _2903 = &raw const (*_2904)
  using: _2904@Mir(bb833[2])
  _2902 = move _2903 as *const u8 (Pointer(ArrayToPointer))
  using: _2903@Mir(bb833[3])
  _2901 = move _2902 as *const i8 (PtrToPtr)
  using: _2902@Mir(bb833[4])
  _2907 = _3
  using: _3@Phi(bb832)
  _2906 = move _2907 as usize (IntToInt)
  using: _2907@Mir(bb833[6])
  _2908 = const 6_usize
  using: 
  _2909 = Lt(_2906, _2908)
  using: _2906@Mir(bb833[7]), _2908@Mir(bb833[8])
  assert(move _2909, "index out of bounds: the length is {} but the index is {}", move _2908, _2906) -> bb834
  using: _2909@Entry, _2908@Entry, _2906@Entry
bb834:
  _2905 = _20[_2906]
  using: _20@Phi(bb832), _2906@Mir(bb833[7])
  _2898 = compress::fprintf(move _2899, move _2901, move _2905) -> bb835
  using: _2899@Mir(bb833[1]), _2901@Mir(bb833[5]), _2905@Mir(bb834[0])
bb835:
  _2910 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb832)
  assert(!move (_2910.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb836
  using: _2910@Entry, _3@Entry
bb836:
  _3 = move (_2910.0: i32)
  using: _2910@Mir(bb835[0])
  goto -> bb832
  using: 
bb837:
  _2913 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _2912 = (*_2913)
  using: _2913@Mir(bb837[0])
  _2917 = const b"\n\x00"
  using: 
  _2916 = &raw const (*_2917)
  using: _2917@Mir(bb837[2])
  _2915 = move _2916 as *const u8 (Pointer(ArrayToPointer))
  using: _2916@Mir(bb837[3])
  _2914 = move _2915 as *const i8 (PtrToPtr)
  using: _2915@Mir(bb837[4])
  _2911 = compress::fprintf(move _2912, move _2914) -> bb838
  using: _2912@Mir(bb837[1]), _2914@Mir(bb837[5])
bb838:
  _3 = const 0_i32
  using: 
  goto -> bb839
  using: 
bb839:
  _2919 = _3
  using: _3@Phi(bb839)
  _2920 = _17
  using: _17@Phi(bb838)
  _2918 = Lt(move _2919, move _2920)
  using: _2919@Mir(bb839[0]), _2920@Mir(bb839[1])
  switchInt(move _2918) -> [0: bb851, otherwise: bb840]
  using: _2918@Mir(bb839[2])
bb840:
  _2931 = &mut ((*_1).35: [[u8; 258]; 6])
  using: _1@Phi(bb839)
  _2930 = move _2931 as &mut [[u8; 258]] (Pointer(Unsize))
  using: _2931@Mir(bb840[0])
  _2929 = core::slice::<impl [[u8; 258]]>::as_mut_ptr(move _2930) -> bb841
  using: _2930@Mir(bb840[1])
bb841:
  _2933 = _3
  using: _3@Phi(bb839)
  _2932 = move _2933 as isize (IntToInt)
  using: _2933@Mir(bb841[0])
  _2928 = std::ptr::mut_ptr::<impl *mut [u8; 258]>::offset(move _2929, move _2932) -> bb842
  using: _2929@Mir(bb840[2]), _2932@Mir(bb841[1])
bb842:
  _2927 = &mut (*_2928)
  using: _2928@Mir(bb841[2])
  _2926 = move _2927 as &mut [u8] (Pointer(Unsize))
  using: _2927@Mir(bb842[0])
  _2925 = core::slice::<impl [u8]>::as_mut_ptr(move _2926) -> bb843
  using: _2926@Mir(bb842[1])
bb843:
  _2934 = const 0_isize
  using: 
  _2924 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2925, move _2934) -> bb844
  using: _2925@Mir(bb842[2]), _2934@Mir(bb843[0])
bb844:
  _2923 = &mut (*_2924)
  using: _2924@Mir(bb843[1])
  _2922 = &raw mut (*_2923)
  using: _2923@Mir(bb844[0])
  _2944 = &mut ((*_1).37: [[i32; 258]; 6])
  using: _1@Phi(bb839)
  _2943 = move _2944 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _2944@Mir(bb844[2])
  _2942 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _2943) -> bb845
  using: _2943@Mir(bb844[3])
bb845:
  _2946 = _3
  using: _3@Phi(bb839)
  _2945 = move _2946 as isize (IntToInt)
  using: _2946@Mir(bb845[0])
  _2941 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _2942, move _2945) -> bb846
  using: _2942@Mir(bb844[4]), _2945@Mir(bb845[1])
bb846:
  _2940 = &mut (*_2941)
  using: _2941@Mir(bb845[2])
  _2939 = move _2940 as &mut [i32] (Pointer(Unsize))
  using: _2940@Mir(bb846[0])
  _2938 = core::slice::<impl [i32]>::as_mut_ptr(move _2939) -> bb847
  using: _2939@Mir(bb846[1])
bb847:
  _2947 = const 0_isize
  using: 
  _2937 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2938, move _2947) -> bb848
  using: _2938@Mir(bb846[2]), _2947@Mir(bb847[0])
bb848:
  _2936 = &mut (*_2937)
  using: _2937@Mir(bb847[1])
  _2935 = &raw mut (*_2936)
  using: _2936@Mir(bb848[0])
  _2948 = _13
  using: _13@Phi(bb839)
  _2949 = const 17_i32
  using: 
  _2921 = huffman::BZ2_hbMakeCodeLengths(move _2922, move _2935, move _2948, move _2949) -> bb849
  using: _2922@Mir(bb844[1]), _2935@Mir(bb848[1]), _2948@Mir(bb848[2]), _2949@Mir(bb848[3])
bb849:
  _2950 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb839)
  assert(!move (_2950.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb850
  using: _2950@Entry, _3@Entry
bb850:
  _3 = move (_2950.0: i32)
  using: _2950@Mir(bb849[0])
  goto -> bb839
  using: 
bb851:
  _2951 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb838)
  assert(!move (_2951.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb852
  using: _2951@Entry, _11@Entry
bb852:
  _11 = move (_2951.0: i32)
  using: _2951@Mir(bb851[0])
  goto -> bb78
  using: 
bb853:
  _2954 = _17
  using: _17@Phi(bb548)
  _2955 = const 8_i32
  using: 
  _2953 = Lt(move _2954, move _2955)
  using: _2954@Mir(bb853[0]), _2955@Mir(bb853[1])
  _2952 = Not(move _2953)
  using: _2953@Mir(bb853[2])
  switchInt(move _2952) -> [0: bb855, otherwise: bb854]
  using: _2952@Mir(bb853[3])
bb854:
  _2957 = const 3002_i32
  using: 
  _2956 = bzlib::BZ2_bz__AssertH__fail(move _2957) -> bb855
  using: _2957@Mir(bb854[0])
bb855:
  _2961 = _12
  using: _12@Mir(bb111[0])
  _2962 = const 32768_i32
  using: 
  _2960 = Lt(move _2961, move _2962)
  using: _2961@Mir(bb855[0]), _2962@Mir(bb855[1])
  switchInt(move _2960) -> [0: bb856, otherwise: bb857]
  using: _2960@Mir(bb855[2])
bb856:
  _2959 = const false
  using: 
  goto -> bb858
  using: 
bb857:
  _2964 = _12
  using: _12@Mir(bb111[0])
  _2965 = const 18002_i32
  using: 
  _2963 = Le(move _2964, move _2965)
  using: _2964@Mir(bb857[0]), _2965@Mir(bb857[1])
  _2959 = move _2963
  using: _2963@Mir(bb857[2])
  goto -> bb858
  using: 
bb858:
  _2958 = Not(move _2959)
  using: _2959@Phi(bb858)
  switchInt(move _2958) -> [0: bb860, otherwise: bb859]
  using: _2958@Mir(bb858[0])
bb859:
  _2967 = const 3003_i32
  using: 
  _2966 = bzlib::BZ2_bz__AssertH__fail(move _2967) -> bb860
  using: _2967@Mir(bb859[0])
bb860:
  _2968 = [const 0_u8; 6]
  using: 
  _2969 = const 0_u8
  using: 
  _2970 = const 0_u8
  using: 
  _2971 = const 0_u8
  using: 
  _4 = const 0_i32
  using: 
  goto -> bb861
  using: 
bb861:
  _2973 = _4
  using: _4@Phi(bb861)
  _2974 = _17
  using: _17@Phi(bb548)
  _2972 = Lt(move _2973, move _2974)
  using: _2973@Mir(bb861[0]), _2974@Mir(bb861[1])
  switchInt(move _2972) -> [0: bb865, otherwise: bb862]
  using: _2972@Mir(bb861[2])
bb862:
  _2975 = _4
  using: _4@Phi(bb861)
  _2977 = _4
  using: _4@Phi(bb861)
  _2976 = move _2977 as usize (IntToInt)
  using: _2977@Mir(bb862[1])
  _2978 = const 6_usize
  using: 
  _2979 = Lt(_2976, _2978)
  using: _2976@Mir(bb862[2]), _2978@Mir(bb862[3])
  assert(move _2979, "index out of bounds: the length is {} but the index is {}", move _2978, _2976) -> bb863
  using: _2979@Entry, _2978@Entry, _2976@Entry
bb863:
  _2968[_2976] = move _2975 as u8 (IntToInt)
  using: _2976@Mir(bb862[2]), _2975@Mir(bb862[0])
  _2980 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb861)
  assert(!move (_2980.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb864
  using: _2980@Entry, _4@Entry
bb864:
  _4 = move (_2980.0: i32)
  using: _2980@Mir(bb863[1])
  goto -> bb861
  using: 
bb865:
  _4 = const 0_i32
  using: 
  goto -> bb866
  using: 
bb866:
  _2982 = _4
  using: _4@Phi(bb866)
  _2983 = _12
  using: _12@Phi(bb858)
  _2981 = Lt(move _2982, move _2983)
  using: _2982@Mir(bb866[0]), _2983@Mir(bb866[1])
  switchInt(move _2981) -> [0: bb877, otherwise: bb867]
  using: _2981@Mir(bb866[2])
bb867:
  _2986 = _4
  using: _4@Phi(bb866)
  _2985 = move _2986 as usize (IntToInt)
  using: _2986@Mir(bb867[0])
  _2987 = const 18002_usize
  using: 
  _2988 = Lt(_2985, _2987)
  using: _2985@Mir(bb867[1]), _2987@Mir(bb867[2])
  assert(move _2988, "index out of bounds: the length is {} but the index is {}", move _2987, _2985) -> bb868
  using: _2988@Entry, _2987@Entry, _2985@Entry
bb868:
  _2984 = ((*_1).33: [u8; 18002])[_2985]
  using: _1@Phi(bb866), _2985@Mir(bb867[1])
  _2969 = move _2984
  using: _2984@Mir(bb868[0])
  _5 = const 0_i32
  using: 
  _2990 = const 0_usize
  using: 
  _2989 = _2968[_2990]
  using: _2968@Phi(bb866), _2990@Mir(bb868[3])
  _2971 = move _2989
  using: _2989@Mir(bb868[4])
  goto -> bb869
  using: 
bb869:
  _2993 = _2969
  using: _2969@Mir(bb868[1])
  _2992 = move _2993 as i32 (IntToInt)
  using: _2993@Mir(bb869[0])
  _2995 = _2971
  using: _2971@Phi(bb869)
  _2994 = move _2995 as i32 (IntToInt)
  using: _2995@Mir(bb869[2])
  _2991 = Ne(move _2992, move _2994)
  using: _2992@Mir(bb869[1]), _2994@Mir(bb869[3])
  switchInt(move _2991) -> [0: bb874, otherwise: bb870]
  using: _2991@Mir(bb869[4])
bb870:
  _2996 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb869)
  assert(!move (_2996.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb871
  using: _2996@Entry, _5@Entry
bb871:
  _5 = move (_2996.0: i32)
  using: _2996@Mir(bb870[0])
  _2997 = _2971
  using: _2971@Phi(bb869)
  _2970 = move _2997
  using: _2997@Mir(bb871[1])
  _3000 = _5
  using: _5@Mir(bb871[0])
  _2999 = move _3000 as usize (IntToInt)
  using: _3000@Mir(bb871[3])
  _3001 = const 6_usize
  using: 
  _3002 = Lt(_2999, _3001)
  using: _2999@Mir(bb871[4]), _3001@Mir(bb871[5])
  assert(move _3002, "index out of bounds: the length is {} but the index is {}", move _3001, _2999) -> bb872
  using: _3002@Entry, _3001@Entry, _2999@Entry
bb872:
  _2998 = _2968[_2999]
  using: _2968@Phi(bb869), _2999@Mir(bb871[4])
  _2971 = move _2998
  using: _2998@Mir(bb872[0])
  _3003 = _2970
  using: _2970@Mir(bb871[2])
  _3005 = _5
  using: _5@Mir(bb871[0])
  _3004 = move _3005 as usize (IntToInt)
  using: _3005@Mir(bb872[3])
  _3006 = const 6_usize
  using: 
  _3007 = Lt(_3004, _3006)
  using: _3004@Mir(bb872[4]), _3006@Mir(bb872[5])
  assert(move _3007, "index out of bounds: the length is {} but the index is {}", move _3006, _3004) -> bb873
  using: _3007@Entry, _3006@Entry, _3004@Entry
bb873:
  _2968[_3004] = move _3003
  using: _3004@Mir(bb872[4]), _3003@Mir(bb872[2])
  goto -> bb869
  using: 
bb874:
  _3008 = _2971
  using: _2971@Phi(bb869)
  _3009 = const 0_usize
  using: 
  _2968[_3009] = move _3008
  using: _3009@Mir(bb874[1]), _3008@Mir(bb874[0])
  _3010 = _5
  using: _5@Phi(bb869)
  _3012 = _4
  using: _4@Phi(bb866)
  _3011 = move _3012 as usize (IntToInt)
  using: _3012@Mir(bb874[4])
  _3013 = const 18002_usize
  using: 
  _3014 = Lt(_3011, _3013)
  using: _3011@Mir(bb874[5]), _3013@Mir(bb874[6])
  assert(move _3014, "index out of bounds: the length is {} but the index is {}", move _3013, _3011) -> bb875
  using: _3014@Entry, _3013@Entry, _3011@Entry
bb875:
  ((*_1).34: [u8; 18002])[_3011] = move _3010 as u8 (IntToInt)
  using: _1@Phi(bb866), _3011@Mir(bb874[5]), _3010@Mir(bb874[3])
  _3015 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb866)
  assert(!move (_3015.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb876
  using: _3015@Entry, _4@Entry
bb876:
  _4 = move (_3015.0: i32)
  using: _3015@Mir(bb875[1])
  goto -> bb866
  using: 
bb877:
  _3 = const 0_i32
  using: 
  goto -> bb878
  using: 
bb878:
  _3017 = _3
  using: _3@Phi(bb878)
  _3018 = _17
  using: _17@Phi(bb548)
  _3016 = Lt(move _3017, move _3018)
  using: _3017@Mir(bb878[0]), _3018@Mir(bb878[1])
  switchInt(move _3016) -> [0: bb910, otherwise: bb879]
  using: _3016@Mir(bb878[2])
bb879:
  _14 = const 32_i32
  using: 
  _15 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  goto -> bb880
  using: 
bb880:
  _3020 = _4
  using: _4@Phi(bb880)
  _3021 = _13
  using: _13@Phi(bb878)
  _3019 = Lt(move _3020, move _3021)
  using: _3020@Mir(bb880[0]), _3021@Mir(bb880[1])
  switchInt(move _3019) -> [0: bb895, otherwise: bb881]
  using: _3019@Mir(bb880[2])
bb881:
  _3026 = _3
  using: _3@Phi(bb880)
  _3025 = move _3026 as usize (IntToInt)
  using: _3026@Mir(bb881[0])
  _3027 = const 6_usize
  using: 
  _3028 = Lt(_3025, _3027)
  using: _3025@Mir(bb881[1]), _3027@Mir(bb881[2])
  assert(move _3028, "index out of bounds: the length is {} but the index is {}", move _3027, _3025) -> bb882
  using: _3028@Entry, _3027@Entry, _3025@Entry
bb882:
  _3030 = _4
  using: _4@Phi(bb880)
  _3029 = move _3030 as usize (IntToInt)
  using: _3030@Mir(bb882[0])
  _3031 = const 258_usize
  using: 
  _3032 = Lt(_3029, _3031)
  using: _3029@Mir(bb882[1]), _3031@Mir(bb882[2])
  assert(move _3032, "index out of bounds: the length is {} but the index is {}", move _3031, _3029) -> bb883
  using: _3032@Entry, _3031@Entry, _3029@Entry
bb883:
  _3024 = ((*_1).35: [[u8; 258]; 6])[_3025][_3029]
  using: _1@Phi(bb880), _3029@Mir(bb882[1]), _3025@Mir(bb881[1])
  _3023 = move _3024 as i32 (IntToInt)
  using: _3024@Mir(bb883[0])
  _3033 = _15
  using: _15@Phi(bb880)
  _3022 = Gt(move _3023, move _3033)
  using: _3023@Mir(bb883[1]), _3033@Mir(bb883[2])
  switchInt(move _3022) -> [0: bb887, otherwise: bb884]
  using: _3022@Mir(bb883[3])
bb884:
  _3036 = _3
  using: _3@Phi(bb880)
  _3035 = move _3036 as usize (IntToInt)
  using: _3036@Mir(bb884[0])
  _3037 = const 6_usize
  using: 
  _3038 = Lt(_3035, _3037)
  using: _3035@Mir(bb884[1]), _3037@Mir(bb884[2])
  assert(move _3038, "index out of bounds: the length is {} but the index is {}", move _3037, _3035) -> bb885
  using: _3038@Entry, _3037@Entry, _3035@Entry
bb885:
  _3040 = _4
  using: _4@Phi(bb880)
  _3039 = move _3040 as usize (IntToInt)
  using: _3040@Mir(bb885[0])
  _3041 = const 258_usize
  using: 
  _3042 = Lt(_3039, _3041)
  using: _3039@Mir(bb885[1]), _3041@Mir(bb885[2])
  assert(move _3042, "index out of bounds: the length is {} but the index is {}", move _3041, _3039) -> bb886
  using: _3042@Entry, _3041@Entry, _3039@Entry
bb886:
  _3034 = ((*_1).35: [[u8; 258]; 6])[_3035][_3039]
  using: _1@Phi(bb880), _3039@Mir(bb885[1]), _3035@Mir(bb884[1])
  _15 = move _3034 as i32 (IntToInt)
  using: _3034@Mir(bb886[0])
  goto -> bb887
  using: 
bb887:
  _3047 = _3
  using: _3@Phi(bb887)
  _3046 = move _3047 as usize (IntToInt)
  using: _3047@Mir(bb887[0])
  _3048 = const 6_usize
  using: 
  _3049 = Lt(_3046, _3048)
  using: _3046@Mir(bb887[1]), _3048@Mir(bb887[2])
  assert(move _3049, "index out of bounds: the length is {} but the index is {}", move _3048, _3046) -> bb888
  using: _3049@Entry, _3048@Entry, _3046@Entry
bb888:
  _3051 = _4
  using: _4@Phi(bb887)
  _3050 = move _3051 as usize (IntToInt)
  using: _3051@Mir(bb888[0])
  _3052 = const 258_usize
  using: 
  _3053 = Lt(_3050, _3052)
  using: _3050@Mir(bb888[1]), _3052@Mir(bb888[2])
  assert(move _3053, "index out of bounds: the length is {} but the index is {}", move _3052, _3050) -> bb889
  using: _3053@Entry, _3052@Entry, _3050@Entry
bb889:
  _3045 = ((*_1).35: [[u8; 258]; 6])[_3046][_3050]
  using: _1@Phi(bb887), _3050@Mir(bb888[1]), _3046@Mir(bb887[1])
  _3044 = move _3045 as i32 (IntToInt)
  using: _3045@Mir(bb889[0])
  _3054 = _14
  using: _14@Phi(bb880)
  _3043 = Lt(move _3044, move _3054)
  using: _3044@Mir(bb889[1]), _3054@Mir(bb889[2])
  switchInt(move _3043) -> [0: bb893, otherwise: bb890]
  using: _3043@Mir(bb889[3])
bb890:
  _3057 = _3
  using: _3@Phi(bb887)
  _3056 = move _3057 as usize (IntToInt)
  using: _3057@Mir(bb890[0])
  _3058 = const 6_usize
  using: 
  _3059 = Lt(_3056, _3058)
  using: _3056@Mir(bb890[1]), _3058@Mir(bb890[2])
  assert(move _3059, "index out of bounds: the length is {} but the index is {}", move _3058, _3056) -> bb891
  using: _3059@Entry, _3058@Entry, _3056@Entry
bb891:
  _3061 = _4
  using: _4@Phi(bb887)
  _3060 = move _3061 as usize (IntToInt)
  using: _3061@Mir(bb891[0])
  _3062 = const 258_usize
  using: 
  _3063 = Lt(_3060, _3062)
  using: _3060@Mir(bb891[1]), _3062@Mir(bb891[2])
  assert(move _3063, "index out of bounds: the length is {} but the index is {}", move _3062, _3060) -> bb892
  using: _3063@Entry, _3062@Entry, _3060@Entry
bb892:
  _3055 = ((*_1).35: [[u8; 258]; 6])[_3056][_3060]
  using: _1@Phi(bb887), _3060@Mir(bb891[1]), _3056@Mir(bb890[1])
  _14 = move _3055 as i32 (IntToInt)
  using: _3055@Mir(bb892[0])
  goto -> bb893
  using: 
bb893:
  _3064 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb893)
  assert(!move (_3064.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb894
  using: _3064@Entry, _4@Entry
bb894:
  _4 = move (_3064.0: i32)
  using: _3064@Mir(bb893[0])
  goto -> bb880
  using: 
bb895:
  _3066 = _15
  using: _15@Phi(bb887)
  _3067 = const 17_i32
  using: 
  _3065 = Gt(move _3066, move _3067)
  using: _3066@Mir(bb895[0]), _3067@Mir(bb895[1])
  switchInt(move _3065) -> [0: bb897, otherwise: bb896]
  using: _3065@Mir(bb895[2])
bb896:
  _3069 = const 3004_i32
  using: 
  _3068 = bzlib::BZ2_bz__AssertH__fail(move _3069) -> bb897
  using: _3069@Mir(bb896[0])
bb897:
  _3071 = _14
  using: _14@Phi(bb893)
  _3072 = const 1_i32
  using: 
  _3070 = Lt(move _3071, move _3072)
  using: _3071@Mir(bb897[0]), _3072@Mir(bb897[1])
  switchInt(move _3070) -> [0: bb899, otherwise: bb898]
  using: _3070@Mir(bb897[2])
bb898:
  _3074 = const 3005_i32
  using: 
  _3073 = bzlib::BZ2_bz__AssertH__fail(move _3074) -> bb899
  using: _3074@Mir(bb898[0])
bb899:
  _3085 = &mut ((*_1).36: [[i32; 258]; 6])
  using: _1@Phi(bb893)
  _3084 = move _3085 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3085@Mir(bb899[0])
  _3083 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3084) -> bb900
  using: _3084@Mir(bb899[1])
bb900:
  _3087 = _3
  using: _3@Phi(bb893)
  _3086 = move _3087 as isize (IntToInt)
  using: _3087@Mir(bb900[0])
  _3082 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3083, move _3086) -> bb901
  using: _3083@Mir(bb899[2]), _3086@Mir(bb900[1])
bb901:
  _3081 = &mut (*_3082)
  using: _3082@Mir(bb900[2])
  _3080 = move _3081 as &mut [i32] (Pointer(Unsize))
  using: _3081@Mir(bb901[0])
  _3079 = core::slice::<impl [i32]>::as_mut_ptr(move _3080) -> bb902
  using: _3080@Mir(bb901[1])
bb902:
  _3088 = const 0_isize
  using: 
  _3078 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3079, move _3088) -> bb903
  using: _3079@Mir(bb901[2]), _3088@Mir(bb902[0])
bb903:
  _3077 = &mut (*_3078)
  using: _3078@Mir(bb902[1])
  _3076 = &raw mut (*_3077)
  using: _3077@Mir(bb903[0])
  _3098 = &mut ((*_1).35: [[u8; 258]; 6])
  using: _1@Phi(bb893)
  _3097 = move _3098 as &mut [[u8; 258]] (Pointer(Unsize))
  using: _3098@Mir(bb903[2])
  _3096 = core::slice::<impl [[u8; 258]]>::as_mut_ptr(move _3097) -> bb904
  using: _3097@Mir(bb903[3])
bb904:
  _3100 = _3
  using: _3@Phi(bb893)
  _3099 = move _3100 as isize (IntToInt)
  using: _3100@Mir(bb904[0])
  _3095 = std::ptr::mut_ptr::<impl *mut [u8; 258]>::offset(move _3096, move _3099) -> bb905
  using: _3096@Mir(bb903[4]), _3099@Mir(bb904[1])
bb905:
  _3094 = &mut (*_3095)
  using: _3095@Mir(bb904[2])
  _3093 = move _3094 as &mut [u8] (Pointer(Unsize))
  using: _3094@Mir(bb905[0])
  _3092 = core::slice::<impl [u8]>::as_mut_ptr(move _3093) -> bb906
  using: _3093@Mir(bb905[1])
bb906:
  _3101 = const 0_isize
  using: 
  _3091 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3092, move _3101) -> bb907
  using: _3092@Mir(bb905[2]), _3101@Mir(bb906[0])
bb907:
  _3090 = &mut (*_3091)
  using: _3091@Mir(bb906[1])
  _3089 = &raw mut (*_3090)
  using: _3090@Mir(bb907[0])
  _3102 = _14
  using: _14@Phi(bb893)
  _3103 = _15
  using: _15@Phi(bb887)
  _3104 = _13
  using: _13@Phi(bb878)
  _3075 = huffman::BZ2_hbAssignCodes(move _3076, move _3089, move _3102, move _3103, move _3104) -> bb908
  using: _3076@Mir(bb903[1]), _3089@Mir(bb907[1]), _3102@Mir(bb907[2]), _3103@Mir(bb907[3]), _3104@Mir(bb907[4])
bb908:
  _3105 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb893)
  assert(!move (_3105.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb909
  using: _3105@Entry, _3@Entry
bb909:
  _3 = move (_3105.0: i32)
  using: _3105@Mir(bb908[0])
  goto -> bb878
  using: 
bb910:
  _3106 = [const 0_u8; 16]
  using: 
  _4 = const 0_i32
  using: 
  goto -> bb911
  using: 
bb911:
  _3108 = _4
  using: _4@Phi(bb911)
  _3109 = const 16_i32
  using: 
  _3107 = Lt(move _3108, move _3109)
  using: _3108@Mir(bb911[0]), _3109@Mir(bb911[1])
  switchInt(move _3107) -> [0: bb925, otherwise: bb912]
  using: _3107@Mir(bb911[2])
bb912:
  _3110 = const 0_i32
  using: 
  _3112 = _4
  using: _4@Phi(bb911)
  _3111 = move _3112 as usize (IntToInt)
  using: _3112@Mir(bb912[1])
  _3113 = const 16_usize
  using: 
  _3114 = Lt(_3111, _3113)
  using: _3111@Mir(bb912[2]), _3113@Mir(bb912[3])
  assert(move _3114, "index out of bounds: the length is {} but the index is {}", move _3113, _3111) -> bb913
  using: _3114@Entry, _3113@Entry, _3111@Entry
bb913:
  _3106[_3111] = move _3110 as u8 (IntToInt)
  using: _3111@Mir(bb912[2]), _3110@Mir(bb912[0])
  _5 = const 0_i32
  using: 
  goto -> bb914
  using: 
bb914:
  _3116 = _5
  using: _5@Phi(bb914)
  _3117 = const 16_i32
  using: 
  _3115 = Lt(move _3116, move _3117)
  using: _3116@Mir(bb914[0]), _3117@Mir(bb914[1])
  switchInt(move _3115) -> [0: bb923, otherwise: bb915]
  using: _3115@Mir(bb914[2])
bb915:
  _3122 = _4
  using: _4@Phi(bb914)
  _3123 = const 16_i32
  using: 
  _3124 = CheckedMul(_3122, _3123)
  using: _3122@Mir(bb915[0]), _3123@Mir(bb915[1])
  assert(!move (_3124.1: bool), "attempt to compute `{} * {}`, which would overflow", move _3122, move _3123) -> bb916
  using: _3124@Entry, _3122@Entry, _3123@Entry
bb916:
  _3121 = move (_3124.0: i32)
  using: _3124@Mir(bb915[2])
  _3125 = _5
  using: _5@Phi(bb914)
  _3126 = CheckedAdd(_3121, _3125)
  using: _3121@Mir(bb916[0]), _3125@Mir(bb916[1])
  assert(!move (_3126.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3121, move _3125) -> bb917
  using: _3126@Entry, _3121@Entry, _3125@Entry
bb917:
  _3120 = move (_3126.0: i32)
  using: _3126@Mir(bb916[2])
  _3119 = move _3120 as usize (IntToInt)
  using: _3120@Mir(bb917[0])
  _3127 = const 256_usize
  using: 
  _3128 = Lt(_3119, _3127)
  using: _3119@Mir(bb917[1]), _3127@Mir(bb917[2])
  assert(move _3128, "index out of bounds: the length is {} but the index is {}", move _3127, _3119) -> bb918
  using: _3128@Entry, _3127@Entry, _3119@Entry
bb918:
  _3118 = ((*_1).22: [u8; 256])[_3119]
  using: _1@Phi(bb914), _3119@Mir(bb917[1])
  switchInt(move _3118) -> [0: bb921, otherwise: bb919]
  using: _3118@Mir(bb918[0])
bb919:
  _3129 = const 1_i32
  using: 
  _3131 = _4
  using: _4@Phi(bb914)
  _3130 = move _3131 as usize (IntToInt)
  using: _3131@Mir(bb919[1])
  _3132 = const 16_usize
  using: 
  _3133 = Lt(_3130, _3132)
  using: _3130@Mir(bb919[2]), _3132@Mir(bb919[3])
  assert(move _3133, "index out of bounds: the length is {} but the index is {}", move _3132, _3130) -> bb920
  using: _3133@Entry, _3132@Entry, _3130@Entry
bb920:
  _3106[_3130] = move _3129 as u8 (IntToInt)
  using: _3130@Mir(bb919[2]), _3129@Mir(bb919[0])
  goto -> bb921
  using: 
bb921:
  _3134 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb914)
  assert(!move (_3134.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb922
  using: _3134@Entry, _5@Entry
bb922:
  _5 = move (_3134.0: i32)
  using: _3134@Mir(bb921[0])
  goto -> bb914
  using: 
bb923:
  _3135 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb921)
  assert(!move (_3135.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb924
  using: _3135@Entry, _4@Entry
bb924:
  _4 = move (_3135.0: i32)
  using: _3135@Mir(bb923[0])
  goto -> bb911
  using: 
bb925:
  _3136 = ((*_1).19: i32)
  using: _1@Phi(bb914)
  _18 = move _3136
  using: _3136@Mir(bb925[0])
  _4 = const 0_i32
  using: 
  goto -> bb926
  using: 
bb926:
  _3138 = _4
  using: _4@Phi(bb926)
  _3139 = const 16_i32
  using: 
  _3137 = Lt(move _3138, move _3139)
  using: _3138@Mir(bb926[0]), _3139@Mir(bb926[1])
  switchInt(move _3137) -> [0: bb933, otherwise: bb927]
  using: _3137@Mir(bb926[2])
bb927:
  _3142 = _4
  using: _4@Phi(bb926)
  _3141 = move _3142 as usize (IntToInt)
  using: _3142@Mir(bb927[0])
  _3143 = const 16_usize
  using: 
  _3144 = Lt(_3141, _3143)
  using: _3141@Mir(bb927[1]), _3143@Mir(bb927[2])
  assert(move _3144, "index out of bounds: the length is {} but the index is {}", move _3143, _3141) -> bb928
  using: _3144@Entry, _3143@Entry, _3141@Entry
bb928:
  _3140 = _3106[_3141]
  using: _3106@Phi(bb926), _3141@Mir(bb927[1])
  switchInt(move _3140) -> [0: bb930, otherwise: bb929]
  using: _3140@Mir(bb928[0])
bb929:
  _3146 = _1
  using: _1@Phi(bb926)
  _3147 = const 1_i32
  using: 
  _3148 = const 1_u32
  using: 
  _3145 = compress::bsW(move _3146, move _3147, move _3148) -> bb931
  using: _3146@Mir(bb929[0]), _3147@Mir(bb929[1]), _3148@Mir(bb929[2])
bb930:
  _3150 = _1
  using: _1@Phi(bb926)
  _3151 = const 1_i32
  using: 
  _3152 = const 0_u32
  using: 
  _3149 = compress::bsW(move _3150, move _3151, move _3152) -> bb931
  using: _3150@Mir(bb930[0]), _3151@Mir(bb930[1]), _3152@Mir(bb930[2])
bb931:
  _3153 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb926)
  assert(!move (_3153.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb932
  using: _3153@Entry, _4@Entry
bb932:
  _4 = move (_3153.0: i32)
  using: _3153@Mir(bb931[0])
  goto -> bb926
  using: 
bb933:
  _4 = const 0_i32
  using: 
  goto -> bb934
  using: 
bb934:
  _3155 = _4
  using: _4@Phi(bb934)
  _3156 = const 16_i32
  using: 
  _3154 = Lt(move _3155, move _3156)
  using: _3155@Mir(bb934[0]), _3156@Mir(bb934[1])
  switchInt(move _3154) -> [0: bb949, otherwise: bb935]
  using: _3154@Mir(bb934[2])
bb935:
  _3159 = _4
  using: _4@Phi(bb934)
  _3158 = move _3159 as usize (IntToInt)
  using: _3159@Mir(bb935[0])
  _3160 = const 16_usize
  using: 
  _3161 = Lt(_3158, _3160)
  using: _3158@Mir(bb935[1]), _3160@Mir(bb935[2])
  assert(move _3161, "index out of bounds: the length is {} but the index is {}", move _3160, _3158) -> bb936
  using: _3161@Entry, _3160@Entry, _3158@Entry
bb936:
  _3157 = _3106[_3158]
  using: _3106@Phi(bb934), _3158@Mir(bb935[1])
  switchInt(move _3157) -> [0: bb947, otherwise: bb937]
  using: _3157@Mir(bb936[0])
bb937:
  _5 = const 0_i32
  using: 
  goto -> bb938
  using: 
bb938:
  _3163 = _5
  using: _5@Phi(bb938)
  _3164 = const 16_i32
  using: 
  _3162 = Lt(move _3163, move _3164)
  using: _3163@Mir(bb938[0]), _3164@Mir(bb938[1])
  switchInt(move _3162) -> [0: bb947, otherwise: bb939]
  using: _3162@Mir(bb938[2])
bb939:
  _3169 = _4
  using: _4@Phi(bb938)
  _3170 = const 16_i32
  using: 
  _3171 = CheckedMul(_3169, _3170)
  using: _3169@Mir(bb939[0]), _3170@Mir(bb939[1])
  assert(!move (_3171.1: bool), "attempt to compute `{} * {}`, which would overflow", move _3169, move _3170) -> bb940
  using: _3171@Entry, _3169@Entry, _3170@Entry
bb940:
  _3168 = move (_3171.0: i32)
  using: _3171@Mir(bb939[2])
  _3172 = _5
  using: _5@Phi(bb938)
  _3173 = CheckedAdd(_3168, _3172)
  using: _3168@Mir(bb940[0]), _3172@Mir(bb940[1])
  assert(!move (_3173.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3168, move _3172) -> bb941
  using: _3173@Entry, _3168@Entry, _3172@Entry
bb941:
  _3167 = move (_3173.0: i32)
  using: _3173@Mir(bb940[2])
  _3166 = move _3167 as usize (IntToInt)
  using: _3167@Mir(bb941[0])
  _3174 = const 256_usize
  using: 
  _3175 = Lt(_3166, _3174)
  using: _3166@Mir(bb941[1]), _3174@Mir(bb941[2])
  assert(move _3175, "index out of bounds: the length is {} but the index is {}", move _3174, _3166) -> bb942
  using: _3175@Entry, _3174@Entry, _3166@Entry
bb942:
  _3165 = ((*_1).22: [u8; 256])[_3166]
  using: _1@Phi(bb938), _3166@Mir(bb941[1])
  switchInt(move _3165) -> [0: bb944, otherwise: bb943]
  using: _3165@Mir(bb942[0])
bb943:
  _3177 = _1
  using: _1@Phi(bb938)
  _3178 = const 1_i32
  using: 
  _3179 = const 1_u32
  using: 
  _3176 = compress::bsW(move _3177, move _3178, move _3179) -> bb945
  using: _3177@Mir(bb943[0]), _3178@Mir(bb943[1]), _3179@Mir(bb943[2])
bb944:
  _3181 = _1
  using: _1@Phi(bb938)
  _3182 = const 1_i32
  using: 
  _3183 = const 0_u32
  using: 
  _3180 = compress::bsW(move _3181, move _3182, move _3183) -> bb945
  using: _3181@Mir(bb944[0]), _3182@Mir(bb944[1]), _3183@Mir(bb944[2])
bb945:
  _3184 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb938)
  assert(!move (_3184.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb946
  using: _3184@Entry, _5@Entry
bb946:
  _5 = move (_3184.0: i32)
  using: _3184@Mir(bb945[0])
  goto -> bb938
  using: 
bb947:
  _3185 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb947)
  assert(!move (_3185.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb948
  using: _3185@Entry, _4@Entry
bb948:
  _4 = move (_3185.0: i32)
  using: _3185@Mir(bb947[0])
  goto -> bb934
  using: 
bb949:
  _3187 = ((*_1).28: i32)
  using: _1@Phi(bb947)
  _3188 = const 3_i32
  using: 
  _3186 = Ge(move _3187, move _3188)
  using: _3187@Mir(bb949[0]), _3188@Mir(bb949[1])
  switchInt(move _3186) -> [0: bb952, otherwise: bb950]
  using: _3186@Mir(bb949[2])
bb950:
  _3191 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _3190 = (*_3191)
  using: _3191@Mir(bb950[0])
  _3195 = const b"      bytes: mapping %d, \x00"
  using: 
  _3194 = &raw const (*_3195)
  using: _3195@Mir(bb950[2])
  _3193 = move _3194 as *const u8 (Pointer(ArrayToPointer))
  using: _3194@Mir(bb950[3])
  _3192 = move _3193 as *const i8 (PtrToPtr)
  using: _3193@Mir(bb950[4])
  _3197 = ((*_1).19: i32)
  using: _1@Phi(bb947)
  _3198 = _18
  using: _18@Mir(bb925[1])
  _3199 = CheckedSub(_3197, _3198)
  using: _3197@Mir(bb950[6]), _3198@Mir(bb950[7])
  assert(!move (_3199.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3197, move _3198) -> bb951
  using: _3199@Entry, _3197@Entry, _3198@Entry
bb951:
  _3196 = move (_3199.0: i32)
  using: _3199@Mir(bb950[8])
  _3189 = compress::fprintf(move _3190, move _3192, move _3196) -> bb952
  using: _3190@Mir(bb950[1]), _3192@Mir(bb950[5]), _3196@Mir(bb951[0])
bb952:
  _3200 = ((*_1).19: i32)
  using: _1@Phi(bb952)
  _18 = move _3200
  using: _3200@Mir(bb952[0])
  _3202 = _1
  using: _1@Phi(bb952)
  _3203 = const 3_i32
  using: 
  _3205 = _17
  using: _17@Phi(bb548)
  _3204 = move _3205 as u32 (IntToInt)
  using: _3205@Mir(bb952[4])
  _3201 = compress::bsW(move _3202, move _3203, move _3204) -> bb953
  using: _3202@Mir(bb952[2]), _3203@Mir(bb952[3]), _3204@Mir(bb952[5])
bb953:
  _3207 = _1
  using: _1@Phi(bb952)
  _3208 = const 15_i32
  using: 
  _3210 = _12
  using: _12@Phi(bb858)
  _3209 = move _3210 as u32 (IntToInt)
  using: _3210@Mir(bb953[2])
  _3206 = compress::bsW(move _3207, move _3208, move _3209) -> bb954
  using: _3207@Mir(bb953[0]), _3208@Mir(bb953[1]), _3209@Mir(bb953[3])
bb954:
  _4 = const 0_i32
  using: 
  goto -> bb955
  using: 
bb955:
  _3212 = _4
  using: _4@Phi(bb955)
  _3213 = _12
  using: _12@Phi(bb858)
  _3211 = Lt(move _3212, move _3213)
  using: _3212@Mir(bb955[0]), _3213@Mir(bb955[1])
  switchInt(move _3211) -> [0: bb965, otherwise: bb956]
  using: _3211@Mir(bb955[2])
bb956:
  _5 = const 0_i32
  using: 
  goto -> bb957
  using: 
bb957:
  _3215 = _5
  using: _5@Phi(bb957)
  _3219 = _4
  using: _4@Phi(bb955)
  _3218 = move _3219 as usize (IntToInt)
  using: _3219@Mir(bb957[1])
  _3220 = const 18002_usize
  using: 
  _3221 = Lt(_3218, _3220)
  using: _3218@Mir(bb957[2]), _3220@Mir(bb957[3])
  assert(move _3221, "index out of bounds: the length is {} but the index is {}", move _3220, _3218) -> bb958
  using: _3221@Entry, _3220@Entry, _3218@Entry
bb958:
  _3217 = ((*_1).34: [u8; 18002])[_3218]
  using: _1@Phi(bb957), _3218@Mir(bb957[2])
  _3216 = move _3217 as i32 (IntToInt)
  using: _3217@Mir(bb958[0])
  _3214 = Lt(move _3215, move _3216)
  using: _3215@Mir(bb957[0]), _3216@Mir(bb958[1])
  switchInt(move _3214) -> [0: bb962, otherwise: bb959]
  using: _3214@Mir(bb958[2])
bb959:
  _3223 = _1
  using: _1@Phi(bb957)
  _3224 = const 1_i32
  using: 
  _3225 = const 1_u32
  using: 
  _3222 = compress::bsW(move _3223, move _3224, move _3225) -> bb960
  using: _3223@Mir(bb959[0]), _3224@Mir(bb959[1]), _3225@Mir(bb959[2])
bb960:
  _3226 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb957)
  assert(!move (_3226.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb961
  using: _3226@Entry, _5@Entry
bb961:
  _5 = move (_3226.0: i32)
  using: _3226@Mir(bb960[0])
  goto -> bb957
  using: 
bb962:
  _3228 = _1
  using: _1@Phi(bb957)
  _3229 = const 1_i32
  using: 
  _3230 = const 0_u32
  using: 
  _3227 = compress::bsW(move _3228, move _3229, move _3230) -> bb963
  using: _3228@Mir(bb962[0]), _3229@Mir(bb962[1]), _3230@Mir(bb962[2])
bb963:
  _3231 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb955)
  assert(!move (_3231.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb964
  using: _3231@Entry, _4@Entry
bb964:
  _4 = move (_3231.0: i32)
  using: _3231@Mir(bb963[0])
  goto -> bb955
  using: 
bb965:
  _3233 = ((*_1).28: i32)
  using: _1@Phi(bb957)
  _3234 = const 3_i32
  using: 
  _3232 = Ge(move _3233, move _3234)
  using: _3233@Mir(bb965[0]), _3234@Mir(bb965[1])
  switchInt(move _3232) -> [0: bb968, otherwise: bb966]
  using: _3232@Mir(bb965[2])
bb966:
  _3237 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _3236 = (*_3237)
  using: _3237@Mir(bb966[0])
  _3241 = const b"selectors %d, \x00"
  using: 
  _3240 = &raw const (*_3241)
  using: _3241@Mir(bb966[2])
  _3239 = move _3240 as *const u8 (Pointer(ArrayToPointer))
  using: _3240@Mir(bb966[3])
  _3238 = move _3239 as *const i8 (PtrToPtr)
  using: _3239@Mir(bb966[4])
  _3243 = ((*_1).19: i32)
  using: _1@Phi(bb957)
  _3244 = _18
  using: _18@Mir(bb952[1])
  _3245 = CheckedSub(_3243, _3244)
  using: _3243@Mir(bb966[6]), _3244@Mir(bb966[7])
  assert(!move (_3245.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3243, move _3244) -> bb967
  using: _3245@Entry, _3243@Entry, _3244@Entry
bb967:
  _3242 = move (_3245.0: i32)
  using: _3245@Mir(bb966[8])
  _3235 = compress::fprintf(move _3236, move _3238, move _3242) -> bb968
  using: _3236@Mir(bb966[1]), _3238@Mir(bb966[5]), _3242@Mir(bb967[0])
bb968:
  _3246 = ((*_1).19: i32)
  using: _1@Phi(bb968)
  _18 = move _3246
  using: _3246@Mir(bb968[0])
  _3 = const 0_i32
  using: 
  goto -> bb969
  using: 
bb969:
  _3248 = _3
  using: _3@Phi(bb969)
  _3249 = _17
  using: _17@Phi(bb548)
  _3247 = Lt(move _3248, move _3249)
  using: _3248@Mir(bb969[0]), _3249@Mir(bb969[1])
  switchInt(move _3247) -> [0: bb991, otherwise: bb970]
  using: _3247@Mir(bb969[2])
bb970:
  _3253 = _3
  using: _3@Phi(bb969)
  _3252 = move _3253 as usize (IntToInt)
  using: _3253@Mir(bb970[0])
  _3254 = const 6_usize
  using: 
  _3255 = Lt(_3252, _3254)
  using: _3252@Mir(bb970[1]), _3254@Mir(bb970[2])
  assert(move _3255, "index out of bounds: the length is {} but the index is {}", move _3254, _3252) -> bb971
  using: _3255@Entry, _3254@Entry, _3252@Entry
bb971:
  _3256 = const 0_usize
  using: 
  _3251 = ((*_1).35: [[u8; 258]; 6])[_3252][_3256]
  using: _1@Phi(bb969), _3256@Mir(bb971[0]), _3252@Mir(bb970[1])
  _3250 = move _3251 as i32 (IntToInt)
  using: _3251@Mir(bb971[1])
  _3258 = _1
  using: _1@Phi(bb969)
  _3259 = const 5_i32
  using: 
  _3261 = _3250
  using: _3250@Mir(bb971[2])
  _3260 = move _3261 as u32 (IntToInt)
  using: _3261@Mir(bb971[5])
  _3257 = compress::bsW(move _3258, move _3259, move _3260) -> bb972
  using: _3258@Mir(bb971[3]), _3259@Mir(bb971[4]), _3260@Mir(bb971[6])
bb972:
  _4 = const 0_i32
  using: 
  goto -> bb973
  using: 
bb973:
  _3263 = _4
  using: _4@Phi(bb973)
  _3264 = _13
  using: _13@Phi(bb969)
  _3262 = Lt(move _3263, move _3264)
  using: _3263@Mir(bb973[0]), _3264@Mir(bb973[1])
  switchInt(move _3262) -> [0: bb989, otherwise: bb974]
  using: _3262@Mir(bb973[2])
bb974:
  _3266 = _3250
  using: _3250@Phi(bb974)
  _3270 = _3
  using: _3@Phi(bb973)
  _3269 = move _3270 as usize (IntToInt)
  using: _3270@Mir(bb974[1])
  _3271 = const 6_usize
  using: 
  _3272 = Lt(_3269, _3271)
  using: _3269@Mir(bb974[2]), _3271@Mir(bb974[3])
  assert(move _3272, "index out of bounds: the length is {} but the index is {}", move _3271, _3269) -> bb975
  using: _3272@Entry, _3271@Entry, _3269@Entry
bb975:
  _3274 = _4
  using: _4@Phi(bb974)
  _3273 = move _3274 as usize (IntToInt)
  using: _3274@Mir(bb975[0])
  _3275 = const 258_usize
  using: 
  _3276 = Lt(_3273, _3275)
  using: _3273@Mir(bb975[1]), _3275@Mir(bb975[2])
  assert(move _3276, "index out of bounds: the length is {} but the index is {}", move _3275, _3273) -> bb976
  using: _3276@Entry, _3275@Entry, _3273@Entry
bb976:
  _3268 = ((*_1).35: [[u8; 258]; 6])[_3269][_3273]
  using: _1@Phi(bb974), _3273@Mir(bb975[1]), _3269@Mir(bb974[2])
  _3267 = move _3268 as i32 (IntToInt)
  using: _3268@Mir(bb976[0])
  _3265 = Lt(move _3266, move _3267)
  using: _3266@Mir(bb974[0]), _3267@Mir(bb976[1])
  switchInt(move _3265) -> [0: bb980, otherwise: bb977]
  using: _3265@Mir(bb976[2])
bb977:
  _3278 = _1
  using: _1@Phi(bb974)
  _3279 = const 2_i32
  using: 
  _3280 = const 2_u32
  using: 
  _3277 = compress::bsW(move _3278, move _3279, move _3280) -> bb978
  using: _3278@Mir(bb977[0]), _3279@Mir(bb977[1]), _3280@Mir(bb977[2])
bb978:
  _3281 = CheckedAdd(_3250, const 1_i32)
  using: _3250@Phi(bb974)
  assert(!move (_3281.1: bool), "attempt to compute `{} + {}`, which would overflow", _3250, const 1_i32) -> bb979
  using: _3281@Entry, _3250@Entry
bb979:
  _3250 = move (_3281.0: i32)
  using: _3281@Mir(bb978[0])
  goto -> bb974
  using: 
bb980:
  _3283 = _3250
  using: _3250@Phi(bb980)
  _3287 = _3
  using: _3@Phi(bb973)
  _3286 = move _3287 as usize (IntToInt)
  using: _3287@Mir(bb980[1])
  _3288 = const 6_usize
  using: 
  _3289 = Lt(_3286, _3288)
  using: _3286@Mir(bb980[2]), _3288@Mir(bb980[3])
  assert(move _3289, "index out of bounds: the length is {} but the index is {}", move _3288, _3286) -> bb981
  using: _3289@Entry, _3288@Entry, _3286@Entry
bb981:
  _3291 = _4
  using: _4@Phi(bb980)
  _3290 = move _3291 as usize (IntToInt)
  using: _3291@Mir(bb981[0])
  _3292 = const 258_usize
  using: 
  _3293 = Lt(_3290, _3292)
  using: _3290@Mir(bb981[1]), _3292@Mir(bb981[2])
  assert(move _3293, "index out of bounds: the length is {} but the index is {}", move _3292, _3290) -> bb982
  using: _3293@Entry, _3292@Entry, _3290@Entry
bb982:
  _3285 = ((*_1).35: [[u8; 258]; 6])[_3286][_3290]
  using: _1@Phi(bb980), _3290@Mir(bb981[1]), _3286@Mir(bb980[2])
  _3284 = move _3285 as i32 (IntToInt)
  using: _3285@Mir(bb982[0])
  _3282 = Gt(move _3283, move _3284)
  using: _3283@Mir(bb980[0]), _3284@Mir(bb982[1])
  switchInt(move _3282) -> [0: bb986, otherwise: bb983]
  using: _3282@Mir(bb982[2])
bb983:
  _3295 = _1
  using: _1@Phi(bb980)
  _3296 = const 2_i32
  using: 
  _3297 = const 3_u32
  using: 
  _3294 = compress::bsW(move _3295, move _3296, move _3297) -> bb984
  using: _3295@Mir(bb983[0]), _3296@Mir(bb983[1]), _3297@Mir(bb983[2])
bb984:
  _3298 = CheckedSub(_3250, const 1_i32)
  using: _3250@Phi(bb980)
  assert(!move (_3298.1: bool), "attempt to compute `{} - {}`, which would overflow", _3250, const 1_i32) -> bb985
  using: _3298@Entry, _3250@Entry
bb985:
  _3250 = move (_3298.0: i32)
  using: _3298@Mir(bb984[0])
  goto -> bb980
  using: 
bb986:
  _3300 = _1
  using: _1@Phi(bb980)
  _3301 = const 1_i32
  using: 
  _3302 = const 0_u32
  using: 
  _3299 = compress::bsW(move _3300, move _3301, move _3302) -> bb987
  using: _3300@Mir(bb986[0]), _3301@Mir(bb986[1]), _3302@Mir(bb986[2])
bb987:
  _3303 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb980)
  assert(!move (_3303.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb988
  using: _3303@Entry, _4@Entry
bb988:
  _4 = move (_3303.0: i32)
  using: _3303@Mir(bb987[0])
  goto -> bb973
  using: 
bb989:
  _3304 = CheckedAdd(_3, const 1_i32)
  using: _3@Phi(bb973)
  assert(!move (_3304.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_i32) -> bb990
  using: _3304@Entry, _3@Entry
bb990:
  _3 = move (_3304.0: i32)
  using: _3304@Mir(bb989[0])
  goto -> bb969
  using: 
bb991:
  _3306 = ((*_1).28: i32)
  using: _1@Phi(bb980)
  _3307 = const 3_i32
  using: 
  _3305 = Ge(move _3306, move _3307)
  using: _3306@Mir(bb991[0]), _3307@Mir(bb991[1])
  switchInt(move _3305) -> [0: bb994, otherwise: bb992]
  using: _3305@Mir(bb991[2])
bb992:
  _3310 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _3309 = (*_3310)
  using: _3310@Mir(bb992[0])
  _3314 = const b"code lengths %d, \x00"
  using: 
  _3313 = &raw const (*_3314)
  using: _3314@Mir(bb992[2])
  _3312 = move _3313 as *const u8 (Pointer(ArrayToPointer))
  using: _3313@Mir(bb992[3])
  _3311 = move _3312 as *const i8 (PtrToPtr)
  using: _3312@Mir(bb992[4])
  _3316 = ((*_1).19: i32)
  using: _1@Phi(bb980)
  _3317 = _18
  using: _18@Mir(bb968[1])
  _3318 = CheckedSub(_3316, _3317)
  using: _3316@Mir(bb992[6]), _3317@Mir(bb992[7])
  assert(!move (_3318.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3316, move _3317) -> bb993
  using: _3318@Entry, _3316@Entry, _3317@Entry
bb993:
  _3315 = move (_3318.0: i32)
  using: _3318@Mir(bb992[8])
  _3308 = compress::fprintf(move _3309, move _3311, move _3315) -> bb994
  using: _3309@Mir(bb992[1]), _3311@Mir(bb992[5]), _3315@Mir(bb993[0])
bb994:
  _3319 = ((*_1).19: i32)
  using: _1@Phi(bb994)
  _18 = move _3319
  using: _3319@Mir(bb994[0])
  _16 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  goto -> bb995
  using: 
bb995:
  _3321 = _6
  using: _6@Phi(bb995)
  _3322 = ((*_1).31: i32)
  using: _1@Phi(bb995)
  _3320 = Ge(move _3321, move _3322)
  using: _3321@Mir(bb995[0]), _3322@Mir(bb995[1])
  switchInt(move _3320) -> [0: bb997, otherwise: bb996]
  using: _3320@Mir(bb995[2])
bb996:
  _4547 = _16
  using: _16@Phi(bb995)
  _4548 = _12
  using: _12@Phi(bb858)
  _4546 = Eq(move _4547, move _4548)
  using: _4547@Mir(bb996[0]), _4548@Mir(bb996[1])
  _4545 = Not(move _4546)
  using: _4546@Mir(bb996[2])
  switchInt(move _4545) -> [0: bb1290, otherwise: bb1289]
  using: _4545@Mir(bb996[3])
bb997:
  _3324 = _6
  using: _6@Phi(bb995)
  _3325 = const 50_i32
  using: 
  _3326 = CheckedAdd(_3324, _3325)
  using: _3324@Mir(bb997[0]), _3325@Mir(bb997[1])
  assert(!move (_3326.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3324, move _3325) -> bb998
  using: _3326@Entry, _3324@Entry, _3325@Entry
bb998:
  _3323 = move (_3326.0: i32)
  using: _3326@Mir(bb997[2])
  _3327 = const 1_i32
  using: 
  _3328 = CheckedSub(_3323, _3327)
  using: _3323@Mir(bb998[0]), _3327@Mir(bb998[1])
  assert(!move (_3328.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3323, move _3327) -> bb999
  using: _3328@Entry, _3323@Entry, _3327@Entry
bb999:
  _7 = move (_3328.0: i32)
  using: _3328@Mir(bb998[2])
  _3330 = _7
  using: _7@Mir(bb999[0])
  _3331 = ((*_1).31: i32)
  using: _1@Phi(bb1293)
  _3329 = Ge(move _3330, move _3331)
  using: _3330@Mir(bb999[1]), _3331@Mir(bb999[2])
  switchInt(move _3329) -> [0: bb1002, otherwise: bb1000]
  using: _3329@Mir(bb999[3])
bb1000:
  _3332 = ((*_1).31: i32)
  using: _1@Phi(bb1293)
  _3333 = const 1_i32
  using: 
  _3334 = CheckedSub(_3332, _3333)
  using: _3332@Mir(bb1000[0]), _3333@Mir(bb1000[1])
  assert(!move (_3334.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3332, move _3333) -> bb1001
  using: _3334@Entry, _3332@Entry, _3333@Entry
bb1001:
  _7 = move (_3334.0: i32)
  using: _3334@Mir(bb1000[2])
  goto -> bb1002
  using: 
bb1002:
  _3340 = _16
  using: _16@Phi(bb995)
  _3339 = move _3340 as usize (IntToInt)
  using: _3340@Mir(bb1002[0])
  _3341 = const 18002_usize
  using: 
  _3342 = Lt(_3339, _3341)
  using: _3339@Mir(bb1002[1]), _3341@Mir(bb1002[2])
  assert(move _3342, "index out of bounds: the length is {} but the index is {}", move _3341, _3339) -> bb1003
  using: _3342@Entry, _3341@Entry, _3339@Entry
bb1003:
  _3338 = ((*_1).33: [u8; 18002])[_3339]
  using: _1@Phi(bb1002), _3339@Mir(bb1002[1])
  _3337 = move _3338 as i32 (IntToInt)
  using: _3338@Mir(bb1003[0])
  _3343 = _17
  using: _17@Phi(bb995)
  _3336 = Lt(move _3337, move _3343)
  using: _3337@Mir(bb1003[1]), _3343@Mir(bb1003[2])
  _3335 = Not(move _3336)
  using: _3336@Mir(bb1003[3])
  switchInt(move _3335) -> [0: bb1005, otherwise: bb1004]
  using: _3335@Mir(bb1003[4])
bb1004:
  _3345 = const 3006_i32
  using: 
  _3344 = bzlib::BZ2_bz__AssertH__fail(move _3345) -> bb1005
  using: _3345@Mir(bb1004[0])
bb1005:
  _3348 = _17
  using: _17@Phi(bb995)
  _3349 = const 6_i32
  using: 
  _3347 = Eq(move _3348, move _3349)
  using: _3348@Mir(bb1005[0]), _3349@Mir(bb1005[1])
  switchInt(move _3347) -> [0: bb1006, otherwise: bb1007]
  using: _3347@Mir(bb1005[2])
bb1006:
  _3346 = const false
  using: 
  goto -> bb1008
  using: 
bb1007:
  _3351 = const 50_i32
  using: 
  _3354 = _7
  using: _7@Phi(bb1002)
  _3355 = _6
  using: _6@Phi(bb995)
  _3356 = CheckedSub(_3354, _3355)
  using: _3354@Mir(bb1007[1]), _3355@Mir(bb1007[2])
  assert(!move (_3356.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3354, move _3355) -> bb1009
  using: _3356@Entry, _3354@Entry, _3355@Entry
bb1008:
  switchInt(move _3346) -> [0: bb1273, otherwise: bb1011]
  using: _3346@Phi(bb1008)
bb1009:
  _3353 = move (_3356.0: i32)
  using: _3356@Mir(bb1007[3])
  _3357 = const 1_i32
  using: 
  _3358 = CheckedAdd(_3353, _3357)
  using: _3353@Mir(bb1009[0]), _3357@Mir(bb1009[1])
  assert(!move (_3358.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3353, move _3357) -> bb1010
  using: _3358@Entry, _3353@Entry, _3357@Entry
bb1010:
  _3352 = move (_3358.0: i32)
  using: _3358@Mir(bb1009[2])
  _3350 = Eq(move _3351, move _3352)
  using: _3351@Mir(bb1007[0]), _3352@Mir(bb1010[0])
  _3346 = move _3350
  using: _3350@Mir(bb1010[1])
  goto -> bb1008
  using: 
bb1011:
  _3359 = const 0_u16
  using: 
  _3369 = &mut ((*_1).35: [[u8; 258]; 6])
  using: _1@Phi(bb1002)
  _3368 = move _3369 as &mut [[u8; 258]] (Pointer(Unsize))
  using: _3369@Mir(bb1011[1])
  _3367 = core::slice::<impl [[u8; 258]]>::as_mut_ptr(move _3368) -> bb1012
  using: _3368@Mir(bb1011[2])
bb1012:
  _3375 = &mut ((*_1).33: [u8; 18002])
  using: _1@Phi(bb1002)
  _3374 = move _3375 as &mut [u8] (Pointer(Unsize))
  using: _3375@Mir(bb1012[0])
  _3373 = core::slice::<impl [u8]>::as_mut_ptr(move _3374) -> bb1013
  using: _3374@Mir(bb1012[1])
bb1013:
  _3377 = _16
  using: _16@Phi(bb995)
  _3376 = move _3377 as isize (IntToInt)
  using: _3377@Mir(bb1013[0])
  _3372 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3373, move _3376) -> bb1014
  using: _3373@Mir(bb1012[2]), _3376@Mir(bb1013[1])
bb1014:
  _3371 = (*_3372)
  using: _3372@Mir(bb1013[2])
  _3370 = move _3371 as isize (IntToInt)
  using: _3371@Mir(bb1014[0])
  _3366 = std::ptr::mut_ptr::<impl *mut [u8; 258]>::offset(move _3367, move _3370) -> bb1015
  using: _3367@Mir(bb1011[3]), _3370@Mir(bb1014[1])
bb1015:
  _3365 = &mut (*_3366)
  using: _3366@Mir(bb1014[2])
  _3364 = move _3365 as &mut [u8] (Pointer(Unsize))
  using: _3365@Mir(bb1015[0])
  _3363 = core::slice::<impl [u8]>::as_mut_ptr(move _3364) -> bb1016
  using: _3364@Mir(bb1015[1])
bb1016:
  _3378 = const 0_isize
  using: 
  _3362 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3363, move _3378) -> bb1017
  using: _3363@Mir(bb1015[2]), _3378@Mir(bb1016[0])
bb1017:
  _3361 = &mut (*_3362)
  using: _3362@Mir(bb1016[1])
  _3360 = &raw mut (*_3361)
  using: _3361@Mir(bb1017[0])
  _3388 = &mut ((*_1).36: [[i32; 258]; 6])
  using: _1@Phi(bb1002)
  _3387 = move _3388 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3388@Mir(bb1017[2])
  _3386 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3387) -> bb1018
  using: _3387@Mir(bb1017[3])
bb1018:
  _3394 = &mut ((*_1).33: [u8; 18002])
  using: _1@Phi(bb1002)
  _3393 = move _3394 as &mut [u8] (Pointer(Unsize))
  using: _3394@Mir(bb1018[0])
  _3392 = core::slice::<impl [u8]>::as_mut_ptr(move _3393) -> bb1019
  using: _3393@Mir(bb1018[1])
bb1019:
  _3396 = _16
  using: _16@Phi(bb995)
  _3395 = move _3396 as isize (IntToInt)
  using: _3396@Mir(bb1019[0])
  _3391 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3392, move _3395) -> bb1020
  using: _3392@Mir(bb1018[2]), _3395@Mir(bb1019[1])
bb1020:
  _3390 = (*_3391)
  using: _3391@Mir(bb1019[2])
  _3389 = move _3390 as isize (IntToInt)
  using: _3390@Mir(bb1020[0])
  _3385 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3386, move _3389) -> bb1021
  using: _3386@Mir(bb1017[4]), _3389@Mir(bb1020[1])
bb1021:
  _3384 = &mut (*_3385)
  using: _3385@Mir(bb1020[2])
  _3383 = move _3384 as &mut [i32] (Pointer(Unsize))
  using: _3384@Mir(bb1021[0])
  _3382 = core::slice::<impl [i32]>::as_mut_ptr(move _3383) -> bb1022
  using: _3383@Mir(bb1021[1])
bb1022:
  _3397 = const 0_isize
  using: 
  _3381 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3382, move _3397) -> bb1023
  using: _3382@Mir(bb1021[2]), _3397@Mir(bb1022[0])
bb1023:
  _3380 = &mut (*_3381)
  using: _3381@Mir(bb1022[1])
  _3379 = &raw mut (*_3380)
  using: _3380@Mir(bb1023[0])
  _3400 = _21
  using: _21@Phi(bb995)
  _3403 = _6
  using: _6@Phi(bb1008)
  _3404 = const 0_i32
  using: 
  _3405 = CheckedAdd(_3403, _3404)
  using: _3403@Mir(bb1023[3]), _3404@Mir(bb1023[4])
  assert(!move (_3405.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3403, move _3404) -> bb1024
  using: _3405@Entry, _3403@Entry, _3404@Entry
bb1024:
  _3402 = move (_3405.0: i32)
  using: _3405@Mir(bb1023[5])
  _3401 = move _3402 as isize (IntToInt)
  using: _3402@Mir(bb1024[0])
  _3399 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3400, move _3401) -> bb1025
  using: _3400@Mir(bb1023[2]), _3401@Mir(bb1024[1])
bb1025:
  _3398 = (*_3399)
  using: _3399@Mir(bb1024[2])
  _3359 = move _3398
  using: _3398@Mir(bb1025[0])
  _3407 = _1
  using: _1@Phi(bb1002)
  _3411 = _3360
  using: _3360@Mir(bb1017[1])
  _3413 = _3359
  using: _3359@Mir(bb1025[1])
  _3412 = move _3413 as isize (IntToInt)
  using: _3413@Mir(bb1025[4])
  _3410 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3411, move _3412) -> bb1026
  using: _3411@Mir(bb1025[3]), _3412@Mir(bb1025[5])
bb1026:
  _3409 = (*_3410)
  using: _3410@Mir(bb1025[6])
  _3408 = move _3409 as i32 (IntToInt)
  using: _3409@Mir(bb1026[0])
  _3417 = _3379
  using: _3379@Mir(bb1023[1])
  _3419 = _3359
  using: _3359@Mir(bb1025[1])
  _3418 = move _3419 as isize (IntToInt)
  using: _3419@Mir(bb1026[3])
  _3416 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3417, move _3418) -> bb1027
  using: _3417@Mir(bb1026[2]), _3418@Mir(bb1026[4])
bb1027:
  _3415 = (*_3416)
  using: _3416@Mir(bb1026[5])
  _3414 = move _3415 as u32 (IntToInt)
  using: _3415@Mir(bb1027[0])
  _3406 = compress::bsW(move _3407, move _3408, move _3414) -> bb1028
  using: _3407@Mir(bb1025[2]), _3408@Mir(bb1026[1]), _3414@Mir(bb1027[1])
bb1028:
  _3422 = _21
  using: _21@Phi(bb995)
  _3425 = _6
  using: _6@Phi(bb1008)
  _3426 = const 1_i32
  using: 
  _3427 = CheckedAdd(_3425, _3426)
  using: _3425@Mir(bb1028[1]), _3426@Mir(bb1028[2])
  assert(!move (_3427.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3425, move _3426) -> bb1029
  using: _3427@Entry, _3425@Entry, _3426@Entry
bb1029:
  _3424 = move (_3427.0: i32)
  using: _3427@Mir(bb1028[3])
  _3423 = move _3424 as isize (IntToInt)
  using: _3424@Mir(bb1029[0])
  _3421 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3422, move _3423) -> bb1030
  using: _3422@Mir(bb1028[0]), _3423@Mir(bb1029[1])
bb1030:
  _3420 = (*_3421)
  using: _3421@Mir(bb1029[2])
  _3359 = move _3420
  using: _3420@Mir(bb1030[0])
  _3429 = _1
  using: _1@Phi(bb1002)
  _3433 = _3360
  using: _3360@Mir(bb1017[1])
  _3435 = _3359
  using: _3359@Mir(bb1030[1])
  _3434 = move _3435 as isize (IntToInt)
  using: _3435@Mir(bb1030[4])
  _3432 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3433, move _3434) -> bb1031
  using: _3433@Mir(bb1030[3]), _3434@Mir(bb1030[5])
bb1031:
  _3431 = (*_3432)
  using: _3432@Mir(bb1030[6])
  _3430 = move _3431 as i32 (IntToInt)
  using: _3431@Mir(bb1031[0])
  _3439 = _3379
  using: _3379@Mir(bb1023[1])
  _3441 = _3359
  using: _3359@Mir(bb1030[1])
  _3440 = move _3441 as isize (IntToInt)
  using: _3441@Mir(bb1031[3])
  _3438 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3439, move _3440) -> bb1032
  using: _3439@Mir(bb1031[2]), _3440@Mir(bb1031[4])
bb1032:
  _3437 = (*_3438)
  using: _3438@Mir(bb1031[5])
  _3436 = move _3437 as u32 (IntToInt)
  using: _3437@Mir(bb1032[0])
  _3428 = compress::bsW(move _3429, move _3430, move _3436) -> bb1033
  using: _3429@Mir(bb1030[2]), _3430@Mir(bb1031[1]), _3436@Mir(bb1032[1])
bb1033:
  _3444 = _21
  using: _21@Phi(bb995)
  _3447 = _6
  using: _6@Phi(bb1008)
  _3448 = const 2_i32
  using: 
  _3449 = CheckedAdd(_3447, _3448)
  using: _3447@Mir(bb1033[1]), _3448@Mir(bb1033[2])
  assert(!move (_3449.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3447, move _3448) -> bb1034
  using: _3449@Entry, _3447@Entry, _3448@Entry
bb1034:
  _3446 = move (_3449.0: i32)
  using: _3449@Mir(bb1033[3])
  _3445 = move _3446 as isize (IntToInt)
  using: _3446@Mir(bb1034[0])
  _3443 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3444, move _3445) -> bb1035
  using: _3444@Mir(bb1033[0]), _3445@Mir(bb1034[1])
bb1035:
  _3442 = (*_3443)
  using: _3443@Mir(bb1034[2])
  _3359 = move _3442
  using: _3442@Mir(bb1035[0])
  _3451 = _1
  using: _1@Phi(bb1002)
  _3455 = _3360
  using: _3360@Mir(bb1017[1])
  _3457 = _3359
  using: _3359@Mir(bb1035[1])
  _3456 = move _3457 as isize (IntToInt)
  using: _3457@Mir(bb1035[4])
  _3454 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3455, move _3456) -> bb1036
  using: _3455@Mir(bb1035[3]), _3456@Mir(bb1035[5])
bb1036:
  _3453 = (*_3454)
  using: _3454@Mir(bb1035[6])
  _3452 = move _3453 as i32 (IntToInt)
  using: _3453@Mir(bb1036[0])
  _3461 = _3379
  using: _3379@Mir(bb1023[1])
  _3463 = _3359
  using: _3359@Mir(bb1035[1])
  _3462 = move _3463 as isize (IntToInt)
  using: _3463@Mir(bb1036[3])
  _3460 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3461, move _3462) -> bb1037
  using: _3461@Mir(bb1036[2]), _3462@Mir(bb1036[4])
bb1037:
  _3459 = (*_3460)
  using: _3460@Mir(bb1036[5])
  _3458 = move _3459 as u32 (IntToInt)
  using: _3459@Mir(bb1037[0])
  _3450 = compress::bsW(move _3451, move _3452, move _3458) -> bb1038
  using: _3451@Mir(bb1035[2]), _3452@Mir(bb1036[1]), _3458@Mir(bb1037[1])
bb1038:
  _3466 = _21
  using: _21@Phi(bb995)
  _3469 = _6
  using: _6@Phi(bb1008)
  _3470 = const 3_i32
  using: 
  _3471 = CheckedAdd(_3469, _3470)
  using: _3469@Mir(bb1038[1]), _3470@Mir(bb1038[2])
  assert(!move (_3471.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3469, move _3470) -> bb1039
  using: _3471@Entry, _3469@Entry, _3470@Entry
bb1039:
  _3468 = move (_3471.0: i32)
  using: _3471@Mir(bb1038[3])
  _3467 = move _3468 as isize (IntToInt)
  using: _3468@Mir(bb1039[0])
  _3465 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3466, move _3467) -> bb1040
  using: _3466@Mir(bb1038[0]), _3467@Mir(bb1039[1])
bb1040:
  _3464 = (*_3465)
  using: _3465@Mir(bb1039[2])
  _3359 = move _3464
  using: _3464@Mir(bb1040[0])
  _3473 = _1
  using: _1@Phi(bb1002)
  _3477 = _3360
  using: _3360@Mir(bb1017[1])
  _3479 = _3359
  using: _3359@Mir(bb1040[1])
  _3478 = move _3479 as isize (IntToInt)
  using: _3479@Mir(bb1040[4])
  _3476 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3477, move _3478) -> bb1041
  using: _3477@Mir(bb1040[3]), _3478@Mir(bb1040[5])
bb1041:
  _3475 = (*_3476)
  using: _3476@Mir(bb1040[6])
  _3474 = move _3475 as i32 (IntToInt)
  using: _3475@Mir(bb1041[0])
  _3483 = _3379
  using: _3379@Mir(bb1023[1])
  _3485 = _3359
  using: _3359@Mir(bb1040[1])
  _3484 = move _3485 as isize (IntToInt)
  using: _3485@Mir(bb1041[3])
  _3482 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3483, move _3484) -> bb1042
  using: _3483@Mir(bb1041[2]), _3484@Mir(bb1041[4])
bb1042:
  _3481 = (*_3482)
  using: _3482@Mir(bb1041[5])
  _3480 = move _3481 as u32 (IntToInt)
  using: _3481@Mir(bb1042[0])
  _3472 = compress::bsW(move _3473, move _3474, move _3480) -> bb1043
  using: _3473@Mir(bb1040[2]), _3474@Mir(bb1041[1]), _3480@Mir(bb1042[1])
bb1043:
  _3488 = _21
  using: _21@Phi(bb995)
  _3491 = _6
  using: _6@Phi(bb1008)
  _3492 = const 4_i32
  using: 
  _3493 = CheckedAdd(_3491, _3492)
  using: _3491@Mir(bb1043[1]), _3492@Mir(bb1043[2])
  assert(!move (_3493.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3491, move _3492) -> bb1044
  using: _3493@Entry, _3491@Entry, _3492@Entry
bb1044:
  _3490 = move (_3493.0: i32)
  using: _3493@Mir(bb1043[3])
  _3489 = move _3490 as isize (IntToInt)
  using: _3490@Mir(bb1044[0])
  _3487 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3488, move _3489) -> bb1045
  using: _3488@Mir(bb1043[0]), _3489@Mir(bb1044[1])
bb1045:
  _3486 = (*_3487)
  using: _3487@Mir(bb1044[2])
  _3359 = move _3486
  using: _3486@Mir(bb1045[0])
  _3495 = _1
  using: _1@Phi(bb1002)
  _3499 = _3360
  using: _3360@Mir(bb1017[1])
  _3501 = _3359
  using: _3359@Mir(bb1045[1])
  _3500 = move _3501 as isize (IntToInt)
  using: _3501@Mir(bb1045[4])
  _3498 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3499, move _3500) -> bb1046
  using: _3499@Mir(bb1045[3]), _3500@Mir(bb1045[5])
bb1046:
  _3497 = (*_3498)
  using: _3498@Mir(bb1045[6])
  _3496 = move _3497 as i32 (IntToInt)
  using: _3497@Mir(bb1046[0])
  _3505 = _3379
  using: _3379@Mir(bb1023[1])
  _3507 = _3359
  using: _3359@Mir(bb1045[1])
  _3506 = move _3507 as isize (IntToInt)
  using: _3507@Mir(bb1046[3])
  _3504 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3505, move _3506) -> bb1047
  using: _3505@Mir(bb1046[2]), _3506@Mir(bb1046[4])
bb1047:
  _3503 = (*_3504)
  using: _3504@Mir(bb1046[5])
  _3502 = move _3503 as u32 (IntToInt)
  using: _3503@Mir(bb1047[0])
  _3494 = compress::bsW(move _3495, move _3496, move _3502) -> bb1048
  using: _3495@Mir(bb1045[2]), _3496@Mir(bb1046[1]), _3502@Mir(bb1047[1])
bb1048:
  _3510 = _21
  using: _21@Phi(bb995)
  _3513 = _6
  using: _6@Phi(bb1008)
  _3514 = const 5_i32
  using: 
  _3515 = CheckedAdd(_3513, _3514)
  using: _3513@Mir(bb1048[1]), _3514@Mir(bb1048[2])
  assert(!move (_3515.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3513, move _3514) -> bb1049
  using: _3515@Entry, _3513@Entry, _3514@Entry
bb1049:
  _3512 = move (_3515.0: i32)
  using: _3515@Mir(bb1048[3])
  _3511 = move _3512 as isize (IntToInt)
  using: _3512@Mir(bb1049[0])
  _3509 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3510, move _3511) -> bb1050
  using: _3510@Mir(bb1048[0]), _3511@Mir(bb1049[1])
bb1050:
  _3508 = (*_3509)
  using: _3509@Mir(bb1049[2])
  _3359 = move _3508
  using: _3508@Mir(bb1050[0])
  _3517 = _1
  using: _1@Phi(bb1002)
  _3521 = _3360
  using: _3360@Mir(bb1017[1])
  _3523 = _3359
  using: _3359@Mir(bb1050[1])
  _3522 = move _3523 as isize (IntToInt)
  using: _3523@Mir(bb1050[4])
  _3520 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3521, move _3522) -> bb1051
  using: _3521@Mir(bb1050[3]), _3522@Mir(bb1050[5])
bb1051:
  _3519 = (*_3520)
  using: _3520@Mir(bb1050[6])
  _3518 = move _3519 as i32 (IntToInt)
  using: _3519@Mir(bb1051[0])
  _3527 = _3379
  using: _3379@Mir(bb1023[1])
  _3529 = _3359
  using: _3359@Mir(bb1050[1])
  _3528 = move _3529 as isize (IntToInt)
  using: _3529@Mir(bb1051[3])
  _3526 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3527, move _3528) -> bb1052
  using: _3527@Mir(bb1051[2]), _3528@Mir(bb1051[4])
bb1052:
  _3525 = (*_3526)
  using: _3526@Mir(bb1051[5])
  _3524 = move _3525 as u32 (IntToInt)
  using: _3525@Mir(bb1052[0])
  _3516 = compress::bsW(move _3517, move _3518, move _3524) -> bb1053
  using: _3517@Mir(bb1050[2]), _3518@Mir(bb1051[1]), _3524@Mir(bb1052[1])
bb1053:
  _3532 = _21
  using: _21@Phi(bb995)
  _3535 = _6
  using: _6@Phi(bb1008)
  _3536 = const 6_i32
  using: 
  _3537 = CheckedAdd(_3535, _3536)
  using: _3535@Mir(bb1053[1]), _3536@Mir(bb1053[2])
  assert(!move (_3537.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3535, move _3536) -> bb1054
  using: _3537@Entry, _3535@Entry, _3536@Entry
bb1054:
  _3534 = move (_3537.0: i32)
  using: _3537@Mir(bb1053[3])
  _3533 = move _3534 as isize (IntToInt)
  using: _3534@Mir(bb1054[0])
  _3531 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3532, move _3533) -> bb1055
  using: _3532@Mir(bb1053[0]), _3533@Mir(bb1054[1])
bb1055:
  _3530 = (*_3531)
  using: _3531@Mir(bb1054[2])
  _3359 = move _3530
  using: _3530@Mir(bb1055[0])
  _3539 = _1
  using: _1@Phi(bb1002)
  _3543 = _3360
  using: _3360@Mir(bb1017[1])
  _3545 = _3359
  using: _3359@Mir(bb1055[1])
  _3544 = move _3545 as isize (IntToInt)
  using: _3545@Mir(bb1055[4])
  _3542 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3543, move _3544) -> bb1056
  using: _3543@Mir(bb1055[3]), _3544@Mir(bb1055[5])
bb1056:
  _3541 = (*_3542)
  using: _3542@Mir(bb1055[6])
  _3540 = move _3541 as i32 (IntToInt)
  using: _3541@Mir(bb1056[0])
  _3549 = _3379
  using: _3379@Mir(bb1023[1])
  _3551 = _3359
  using: _3359@Mir(bb1055[1])
  _3550 = move _3551 as isize (IntToInt)
  using: _3551@Mir(bb1056[3])
  _3548 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3549, move _3550) -> bb1057
  using: _3549@Mir(bb1056[2]), _3550@Mir(bb1056[4])
bb1057:
  _3547 = (*_3548)
  using: _3548@Mir(bb1056[5])
  _3546 = move _3547 as u32 (IntToInt)
  using: _3547@Mir(bb1057[0])
  _3538 = compress::bsW(move _3539, move _3540, move _3546) -> bb1058
  using: _3539@Mir(bb1055[2]), _3540@Mir(bb1056[1]), _3546@Mir(bb1057[1])
bb1058:
  _3554 = _21
  using: _21@Phi(bb995)
  _3557 = _6
  using: _6@Phi(bb1008)
  _3558 = const 7_i32
  using: 
  _3559 = CheckedAdd(_3557, _3558)
  using: _3557@Mir(bb1058[1]), _3558@Mir(bb1058[2])
  assert(!move (_3559.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3557, move _3558) -> bb1059
  using: _3559@Entry, _3557@Entry, _3558@Entry
bb1059:
  _3556 = move (_3559.0: i32)
  using: _3559@Mir(bb1058[3])
  _3555 = move _3556 as isize (IntToInt)
  using: _3556@Mir(bb1059[0])
  _3553 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3554, move _3555) -> bb1060
  using: _3554@Mir(bb1058[0]), _3555@Mir(bb1059[1])
bb1060:
  _3552 = (*_3553)
  using: _3553@Mir(bb1059[2])
  _3359 = move _3552
  using: _3552@Mir(bb1060[0])
  _3561 = _1
  using: _1@Phi(bb1002)
  _3565 = _3360
  using: _3360@Mir(bb1017[1])
  _3567 = _3359
  using: _3359@Mir(bb1060[1])
  _3566 = move _3567 as isize (IntToInt)
  using: _3567@Mir(bb1060[4])
  _3564 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3565, move _3566) -> bb1061
  using: _3565@Mir(bb1060[3]), _3566@Mir(bb1060[5])
bb1061:
  _3563 = (*_3564)
  using: _3564@Mir(bb1060[6])
  _3562 = move _3563 as i32 (IntToInt)
  using: _3563@Mir(bb1061[0])
  _3571 = _3379
  using: _3379@Mir(bb1023[1])
  _3573 = _3359
  using: _3359@Mir(bb1060[1])
  _3572 = move _3573 as isize (IntToInt)
  using: _3573@Mir(bb1061[3])
  _3570 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3571, move _3572) -> bb1062
  using: _3571@Mir(bb1061[2]), _3572@Mir(bb1061[4])
bb1062:
  _3569 = (*_3570)
  using: _3570@Mir(bb1061[5])
  _3568 = move _3569 as u32 (IntToInt)
  using: _3569@Mir(bb1062[0])
  _3560 = compress::bsW(move _3561, move _3562, move _3568) -> bb1063
  using: _3561@Mir(bb1060[2]), _3562@Mir(bb1061[1]), _3568@Mir(bb1062[1])
bb1063:
  _3576 = _21
  using: _21@Phi(bb995)
  _3579 = _6
  using: _6@Phi(bb1008)
  _3580 = const 8_i32
  using: 
  _3581 = CheckedAdd(_3579, _3580)
  using: _3579@Mir(bb1063[1]), _3580@Mir(bb1063[2])
  assert(!move (_3581.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3579, move _3580) -> bb1064
  using: _3581@Entry, _3579@Entry, _3580@Entry
bb1064:
  _3578 = move (_3581.0: i32)
  using: _3581@Mir(bb1063[3])
  _3577 = move _3578 as isize (IntToInt)
  using: _3578@Mir(bb1064[0])
  _3575 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3576, move _3577) -> bb1065
  using: _3576@Mir(bb1063[0]), _3577@Mir(bb1064[1])
bb1065:
  _3574 = (*_3575)
  using: _3575@Mir(bb1064[2])
  _3359 = move _3574
  using: _3574@Mir(bb1065[0])
  _3583 = _1
  using: _1@Phi(bb1002)
  _3587 = _3360
  using: _3360@Mir(bb1017[1])
  _3589 = _3359
  using: _3359@Mir(bb1065[1])
  _3588 = move _3589 as isize (IntToInt)
  using: _3589@Mir(bb1065[4])
  _3586 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3587, move _3588) -> bb1066
  using: _3587@Mir(bb1065[3]), _3588@Mir(bb1065[5])
bb1066:
  _3585 = (*_3586)
  using: _3586@Mir(bb1065[6])
  _3584 = move _3585 as i32 (IntToInt)
  using: _3585@Mir(bb1066[0])
  _3593 = _3379
  using: _3379@Mir(bb1023[1])
  _3595 = _3359
  using: _3359@Mir(bb1065[1])
  _3594 = move _3595 as isize (IntToInt)
  using: _3595@Mir(bb1066[3])
  _3592 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3593, move _3594) -> bb1067
  using: _3593@Mir(bb1066[2]), _3594@Mir(bb1066[4])
bb1067:
  _3591 = (*_3592)
  using: _3592@Mir(bb1066[5])
  _3590 = move _3591 as u32 (IntToInt)
  using: _3591@Mir(bb1067[0])
  _3582 = compress::bsW(move _3583, move _3584, move _3590) -> bb1068
  using: _3583@Mir(bb1065[2]), _3584@Mir(bb1066[1]), _3590@Mir(bb1067[1])
bb1068:
  _3598 = _21
  using: _21@Phi(bb995)
  _3601 = _6
  using: _6@Phi(bb1008)
  _3602 = const 9_i32
  using: 
  _3603 = CheckedAdd(_3601, _3602)
  using: _3601@Mir(bb1068[1]), _3602@Mir(bb1068[2])
  assert(!move (_3603.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3601, move _3602) -> bb1069
  using: _3603@Entry, _3601@Entry, _3602@Entry
bb1069:
  _3600 = move (_3603.0: i32)
  using: _3603@Mir(bb1068[3])
  _3599 = move _3600 as isize (IntToInt)
  using: _3600@Mir(bb1069[0])
  _3597 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3598, move _3599) -> bb1070
  using: _3598@Mir(bb1068[0]), _3599@Mir(bb1069[1])
bb1070:
  _3596 = (*_3597)
  using: _3597@Mir(bb1069[2])
  _3359 = move _3596
  using: _3596@Mir(bb1070[0])
  _3605 = _1
  using: _1@Phi(bb1002)
  _3609 = _3360
  using: _3360@Mir(bb1017[1])
  _3611 = _3359
  using: _3359@Mir(bb1070[1])
  _3610 = move _3611 as isize (IntToInt)
  using: _3611@Mir(bb1070[4])
  _3608 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3609, move _3610) -> bb1071
  using: _3609@Mir(bb1070[3]), _3610@Mir(bb1070[5])
bb1071:
  _3607 = (*_3608)
  using: _3608@Mir(bb1070[6])
  _3606 = move _3607 as i32 (IntToInt)
  using: _3607@Mir(bb1071[0])
  _3615 = _3379
  using: _3379@Mir(bb1023[1])
  _3617 = _3359
  using: _3359@Mir(bb1070[1])
  _3616 = move _3617 as isize (IntToInt)
  using: _3617@Mir(bb1071[3])
  _3614 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3615, move _3616) -> bb1072
  using: _3615@Mir(bb1071[2]), _3616@Mir(bb1071[4])
bb1072:
  _3613 = (*_3614)
  using: _3614@Mir(bb1071[5])
  _3612 = move _3613 as u32 (IntToInt)
  using: _3613@Mir(bb1072[0])
  _3604 = compress::bsW(move _3605, move _3606, move _3612) -> bb1073
  using: _3605@Mir(bb1070[2]), _3606@Mir(bb1071[1]), _3612@Mir(bb1072[1])
bb1073:
  _3620 = _21
  using: _21@Phi(bb995)
  _3623 = _6
  using: _6@Phi(bb1008)
  _3624 = const 10_i32
  using: 
  _3625 = CheckedAdd(_3623, _3624)
  using: _3623@Mir(bb1073[1]), _3624@Mir(bb1073[2])
  assert(!move (_3625.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3623, move _3624) -> bb1074
  using: _3625@Entry, _3623@Entry, _3624@Entry
bb1074:
  _3622 = move (_3625.0: i32)
  using: _3625@Mir(bb1073[3])
  _3621 = move _3622 as isize (IntToInt)
  using: _3622@Mir(bb1074[0])
  _3619 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3620, move _3621) -> bb1075
  using: _3620@Mir(bb1073[0]), _3621@Mir(bb1074[1])
bb1075:
  _3618 = (*_3619)
  using: _3619@Mir(bb1074[2])
  _3359 = move _3618
  using: _3618@Mir(bb1075[0])
  _3627 = _1
  using: _1@Phi(bb1002)
  _3631 = _3360
  using: _3360@Mir(bb1017[1])
  _3633 = _3359
  using: _3359@Mir(bb1075[1])
  _3632 = move _3633 as isize (IntToInt)
  using: _3633@Mir(bb1075[4])
  _3630 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3631, move _3632) -> bb1076
  using: _3631@Mir(bb1075[3]), _3632@Mir(bb1075[5])
bb1076:
  _3629 = (*_3630)
  using: _3630@Mir(bb1075[6])
  _3628 = move _3629 as i32 (IntToInt)
  using: _3629@Mir(bb1076[0])
  _3637 = _3379
  using: _3379@Mir(bb1023[1])
  _3639 = _3359
  using: _3359@Mir(bb1075[1])
  _3638 = move _3639 as isize (IntToInt)
  using: _3639@Mir(bb1076[3])
  _3636 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3637, move _3638) -> bb1077
  using: _3637@Mir(bb1076[2]), _3638@Mir(bb1076[4])
bb1077:
  _3635 = (*_3636)
  using: _3636@Mir(bb1076[5])
  _3634 = move _3635 as u32 (IntToInt)
  using: _3635@Mir(bb1077[0])
  _3626 = compress::bsW(move _3627, move _3628, move _3634) -> bb1078
  using: _3627@Mir(bb1075[2]), _3628@Mir(bb1076[1]), _3634@Mir(bb1077[1])
bb1078:
  _3642 = _21
  using: _21@Phi(bb995)
  _3645 = _6
  using: _6@Phi(bb1008)
  _3646 = const 11_i32
  using: 
  _3647 = CheckedAdd(_3645, _3646)
  using: _3645@Mir(bb1078[1]), _3646@Mir(bb1078[2])
  assert(!move (_3647.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3645, move _3646) -> bb1079
  using: _3647@Entry, _3645@Entry, _3646@Entry
bb1079:
  _3644 = move (_3647.0: i32)
  using: _3647@Mir(bb1078[3])
  _3643 = move _3644 as isize (IntToInt)
  using: _3644@Mir(bb1079[0])
  _3641 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3642, move _3643) -> bb1080
  using: _3642@Mir(bb1078[0]), _3643@Mir(bb1079[1])
bb1080:
  _3640 = (*_3641)
  using: _3641@Mir(bb1079[2])
  _3359 = move _3640
  using: _3640@Mir(bb1080[0])
  _3649 = _1
  using: _1@Phi(bb1002)
  _3653 = _3360
  using: _3360@Mir(bb1017[1])
  _3655 = _3359
  using: _3359@Mir(bb1080[1])
  _3654 = move _3655 as isize (IntToInt)
  using: _3655@Mir(bb1080[4])
  _3652 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3653, move _3654) -> bb1081
  using: _3653@Mir(bb1080[3]), _3654@Mir(bb1080[5])
bb1081:
  _3651 = (*_3652)
  using: _3652@Mir(bb1080[6])
  _3650 = move _3651 as i32 (IntToInt)
  using: _3651@Mir(bb1081[0])
  _3659 = _3379
  using: _3379@Mir(bb1023[1])
  _3661 = _3359
  using: _3359@Mir(bb1080[1])
  _3660 = move _3661 as isize (IntToInt)
  using: _3661@Mir(bb1081[3])
  _3658 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3659, move _3660) -> bb1082
  using: _3659@Mir(bb1081[2]), _3660@Mir(bb1081[4])
bb1082:
  _3657 = (*_3658)
  using: _3658@Mir(bb1081[5])
  _3656 = move _3657 as u32 (IntToInt)
  using: _3657@Mir(bb1082[0])
  _3648 = compress::bsW(move _3649, move _3650, move _3656) -> bb1083
  using: _3649@Mir(bb1080[2]), _3650@Mir(bb1081[1]), _3656@Mir(bb1082[1])
bb1083:
  _3664 = _21
  using: _21@Phi(bb995)
  _3667 = _6
  using: _6@Phi(bb1008)
  _3668 = const 12_i32
  using: 
  _3669 = CheckedAdd(_3667, _3668)
  using: _3667@Mir(bb1083[1]), _3668@Mir(bb1083[2])
  assert(!move (_3669.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3667, move _3668) -> bb1084
  using: _3669@Entry, _3667@Entry, _3668@Entry
bb1084:
  _3666 = move (_3669.0: i32)
  using: _3669@Mir(bb1083[3])
  _3665 = move _3666 as isize (IntToInt)
  using: _3666@Mir(bb1084[0])
  _3663 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3664, move _3665) -> bb1085
  using: _3664@Mir(bb1083[0]), _3665@Mir(bb1084[1])
bb1085:
  _3662 = (*_3663)
  using: _3663@Mir(bb1084[2])
  _3359 = move _3662
  using: _3662@Mir(bb1085[0])
  _3671 = _1
  using: _1@Phi(bb1002)
  _3675 = _3360
  using: _3360@Mir(bb1017[1])
  _3677 = _3359
  using: _3359@Mir(bb1085[1])
  _3676 = move _3677 as isize (IntToInt)
  using: _3677@Mir(bb1085[4])
  _3674 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3675, move _3676) -> bb1086
  using: _3675@Mir(bb1085[3]), _3676@Mir(bb1085[5])
bb1086:
  _3673 = (*_3674)
  using: _3674@Mir(bb1085[6])
  _3672 = move _3673 as i32 (IntToInt)
  using: _3673@Mir(bb1086[0])
  _3681 = _3379
  using: _3379@Mir(bb1023[1])
  _3683 = _3359
  using: _3359@Mir(bb1085[1])
  _3682 = move _3683 as isize (IntToInt)
  using: _3683@Mir(bb1086[3])
  _3680 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3681, move _3682) -> bb1087
  using: _3681@Mir(bb1086[2]), _3682@Mir(bb1086[4])
bb1087:
  _3679 = (*_3680)
  using: _3680@Mir(bb1086[5])
  _3678 = move _3679 as u32 (IntToInt)
  using: _3679@Mir(bb1087[0])
  _3670 = compress::bsW(move _3671, move _3672, move _3678) -> bb1088
  using: _3671@Mir(bb1085[2]), _3672@Mir(bb1086[1]), _3678@Mir(bb1087[1])
bb1088:
  _3686 = _21
  using: _21@Phi(bb995)
  _3689 = _6
  using: _6@Phi(bb1008)
  _3690 = const 13_i32
  using: 
  _3691 = CheckedAdd(_3689, _3690)
  using: _3689@Mir(bb1088[1]), _3690@Mir(bb1088[2])
  assert(!move (_3691.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3689, move _3690) -> bb1089
  using: _3691@Entry, _3689@Entry, _3690@Entry
bb1089:
  _3688 = move (_3691.0: i32)
  using: _3691@Mir(bb1088[3])
  _3687 = move _3688 as isize (IntToInt)
  using: _3688@Mir(bb1089[0])
  _3685 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3686, move _3687) -> bb1090
  using: _3686@Mir(bb1088[0]), _3687@Mir(bb1089[1])
bb1090:
  _3684 = (*_3685)
  using: _3685@Mir(bb1089[2])
  _3359 = move _3684
  using: _3684@Mir(bb1090[0])
  _3693 = _1
  using: _1@Phi(bb1002)
  _3697 = _3360
  using: _3360@Mir(bb1017[1])
  _3699 = _3359
  using: _3359@Mir(bb1090[1])
  _3698 = move _3699 as isize (IntToInt)
  using: _3699@Mir(bb1090[4])
  _3696 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3697, move _3698) -> bb1091
  using: _3697@Mir(bb1090[3]), _3698@Mir(bb1090[5])
bb1091:
  _3695 = (*_3696)
  using: _3696@Mir(bb1090[6])
  _3694 = move _3695 as i32 (IntToInt)
  using: _3695@Mir(bb1091[0])
  _3703 = _3379
  using: _3379@Mir(bb1023[1])
  _3705 = _3359
  using: _3359@Mir(bb1090[1])
  _3704 = move _3705 as isize (IntToInt)
  using: _3705@Mir(bb1091[3])
  _3702 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3703, move _3704) -> bb1092
  using: _3703@Mir(bb1091[2]), _3704@Mir(bb1091[4])
bb1092:
  _3701 = (*_3702)
  using: _3702@Mir(bb1091[5])
  _3700 = move _3701 as u32 (IntToInt)
  using: _3701@Mir(bb1092[0])
  _3692 = compress::bsW(move _3693, move _3694, move _3700) -> bb1093
  using: _3693@Mir(bb1090[2]), _3694@Mir(bb1091[1]), _3700@Mir(bb1092[1])
bb1093:
  _3708 = _21
  using: _21@Phi(bb995)
  _3711 = _6
  using: _6@Phi(bb1008)
  _3712 = const 14_i32
  using: 
  _3713 = CheckedAdd(_3711, _3712)
  using: _3711@Mir(bb1093[1]), _3712@Mir(bb1093[2])
  assert(!move (_3713.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3711, move _3712) -> bb1094
  using: _3713@Entry, _3711@Entry, _3712@Entry
bb1094:
  _3710 = move (_3713.0: i32)
  using: _3713@Mir(bb1093[3])
  _3709 = move _3710 as isize (IntToInt)
  using: _3710@Mir(bb1094[0])
  _3707 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3708, move _3709) -> bb1095
  using: _3708@Mir(bb1093[0]), _3709@Mir(bb1094[1])
bb1095:
  _3706 = (*_3707)
  using: _3707@Mir(bb1094[2])
  _3359 = move _3706
  using: _3706@Mir(bb1095[0])
  _3715 = _1
  using: _1@Phi(bb1002)
  _3719 = _3360
  using: _3360@Mir(bb1017[1])
  _3721 = _3359
  using: _3359@Mir(bb1095[1])
  _3720 = move _3721 as isize (IntToInt)
  using: _3721@Mir(bb1095[4])
  _3718 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3719, move _3720) -> bb1096
  using: _3719@Mir(bb1095[3]), _3720@Mir(bb1095[5])
bb1096:
  _3717 = (*_3718)
  using: _3718@Mir(bb1095[6])
  _3716 = move _3717 as i32 (IntToInt)
  using: _3717@Mir(bb1096[0])
  _3725 = _3379
  using: _3379@Mir(bb1023[1])
  _3727 = _3359
  using: _3359@Mir(bb1095[1])
  _3726 = move _3727 as isize (IntToInt)
  using: _3727@Mir(bb1096[3])
  _3724 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3725, move _3726) -> bb1097
  using: _3725@Mir(bb1096[2]), _3726@Mir(bb1096[4])
bb1097:
  _3723 = (*_3724)
  using: _3724@Mir(bb1096[5])
  _3722 = move _3723 as u32 (IntToInt)
  using: _3723@Mir(bb1097[0])
  _3714 = compress::bsW(move _3715, move _3716, move _3722) -> bb1098
  using: _3715@Mir(bb1095[2]), _3716@Mir(bb1096[1]), _3722@Mir(bb1097[1])
bb1098:
  _3730 = _21
  using: _21@Phi(bb995)
  _3733 = _6
  using: _6@Phi(bb1008)
  _3734 = const 15_i32
  using: 
  _3735 = CheckedAdd(_3733, _3734)
  using: _3733@Mir(bb1098[1]), _3734@Mir(bb1098[2])
  assert(!move (_3735.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3733, move _3734) -> bb1099
  using: _3735@Entry, _3733@Entry, _3734@Entry
bb1099:
  _3732 = move (_3735.0: i32)
  using: _3735@Mir(bb1098[3])
  _3731 = move _3732 as isize (IntToInt)
  using: _3732@Mir(bb1099[0])
  _3729 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3730, move _3731) -> bb1100
  using: _3730@Mir(bb1098[0]), _3731@Mir(bb1099[1])
bb1100:
  _3728 = (*_3729)
  using: _3729@Mir(bb1099[2])
  _3359 = move _3728
  using: _3728@Mir(bb1100[0])
  _3737 = _1
  using: _1@Phi(bb1002)
  _3741 = _3360
  using: _3360@Mir(bb1017[1])
  _3743 = _3359
  using: _3359@Mir(bb1100[1])
  _3742 = move _3743 as isize (IntToInt)
  using: _3743@Mir(bb1100[4])
  _3740 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3741, move _3742) -> bb1101
  using: _3741@Mir(bb1100[3]), _3742@Mir(bb1100[5])
bb1101:
  _3739 = (*_3740)
  using: _3740@Mir(bb1100[6])
  _3738 = move _3739 as i32 (IntToInt)
  using: _3739@Mir(bb1101[0])
  _3747 = _3379
  using: _3379@Mir(bb1023[1])
  _3749 = _3359
  using: _3359@Mir(bb1100[1])
  _3748 = move _3749 as isize (IntToInt)
  using: _3749@Mir(bb1101[3])
  _3746 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3747, move _3748) -> bb1102
  using: _3747@Mir(bb1101[2]), _3748@Mir(bb1101[4])
bb1102:
  _3745 = (*_3746)
  using: _3746@Mir(bb1101[5])
  _3744 = move _3745 as u32 (IntToInt)
  using: _3745@Mir(bb1102[0])
  _3736 = compress::bsW(move _3737, move _3738, move _3744) -> bb1103
  using: _3737@Mir(bb1100[2]), _3738@Mir(bb1101[1]), _3744@Mir(bb1102[1])
bb1103:
  _3752 = _21
  using: _21@Phi(bb995)
  _3755 = _6
  using: _6@Phi(bb1008)
  _3756 = const 16_i32
  using: 
  _3757 = CheckedAdd(_3755, _3756)
  using: _3755@Mir(bb1103[1]), _3756@Mir(bb1103[2])
  assert(!move (_3757.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3755, move _3756) -> bb1104
  using: _3757@Entry, _3755@Entry, _3756@Entry
bb1104:
  _3754 = move (_3757.0: i32)
  using: _3757@Mir(bb1103[3])
  _3753 = move _3754 as isize (IntToInt)
  using: _3754@Mir(bb1104[0])
  _3751 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3752, move _3753) -> bb1105
  using: _3752@Mir(bb1103[0]), _3753@Mir(bb1104[1])
bb1105:
  _3750 = (*_3751)
  using: _3751@Mir(bb1104[2])
  _3359 = move _3750
  using: _3750@Mir(bb1105[0])
  _3759 = _1
  using: _1@Phi(bb1002)
  _3763 = _3360
  using: _3360@Mir(bb1017[1])
  _3765 = _3359
  using: _3359@Mir(bb1105[1])
  _3764 = move _3765 as isize (IntToInt)
  using: _3765@Mir(bb1105[4])
  _3762 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3763, move _3764) -> bb1106
  using: _3763@Mir(bb1105[3]), _3764@Mir(bb1105[5])
bb1106:
  _3761 = (*_3762)
  using: _3762@Mir(bb1105[6])
  _3760 = move _3761 as i32 (IntToInt)
  using: _3761@Mir(bb1106[0])
  _3769 = _3379
  using: _3379@Mir(bb1023[1])
  _3771 = _3359
  using: _3359@Mir(bb1105[1])
  _3770 = move _3771 as isize (IntToInt)
  using: _3771@Mir(bb1106[3])
  _3768 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3769, move _3770) -> bb1107
  using: _3769@Mir(bb1106[2]), _3770@Mir(bb1106[4])
bb1107:
  _3767 = (*_3768)
  using: _3768@Mir(bb1106[5])
  _3766 = move _3767 as u32 (IntToInt)
  using: _3767@Mir(bb1107[0])
  _3758 = compress::bsW(move _3759, move _3760, move _3766) -> bb1108
  using: _3759@Mir(bb1105[2]), _3760@Mir(bb1106[1]), _3766@Mir(bb1107[1])
bb1108:
  _3774 = _21
  using: _21@Phi(bb995)
  _3777 = _6
  using: _6@Phi(bb1008)
  _3778 = const 17_i32
  using: 
  _3779 = CheckedAdd(_3777, _3778)
  using: _3777@Mir(bb1108[1]), _3778@Mir(bb1108[2])
  assert(!move (_3779.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3777, move _3778) -> bb1109
  using: _3779@Entry, _3777@Entry, _3778@Entry
bb1109:
  _3776 = move (_3779.0: i32)
  using: _3779@Mir(bb1108[3])
  _3775 = move _3776 as isize (IntToInt)
  using: _3776@Mir(bb1109[0])
  _3773 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3774, move _3775) -> bb1110
  using: _3774@Mir(bb1108[0]), _3775@Mir(bb1109[1])
bb1110:
  _3772 = (*_3773)
  using: _3773@Mir(bb1109[2])
  _3359 = move _3772
  using: _3772@Mir(bb1110[0])
  _3781 = _1
  using: _1@Phi(bb1002)
  _3785 = _3360
  using: _3360@Mir(bb1017[1])
  _3787 = _3359
  using: _3359@Mir(bb1110[1])
  _3786 = move _3787 as isize (IntToInt)
  using: _3787@Mir(bb1110[4])
  _3784 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3785, move _3786) -> bb1111
  using: _3785@Mir(bb1110[3]), _3786@Mir(bb1110[5])
bb1111:
  _3783 = (*_3784)
  using: _3784@Mir(bb1110[6])
  _3782 = move _3783 as i32 (IntToInt)
  using: _3783@Mir(bb1111[0])
  _3791 = _3379
  using: _3379@Mir(bb1023[1])
  _3793 = _3359
  using: _3359@Mir(bb1110[1])
  _3792 = move _3793 as isize (IntToInt)
  using: _3793@Mir(bb1111[3])
  _3790 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3791, move _3792) -> bb1112
  using: _3791@Mir(bb1111[2]), _3792@Mir(bb1111[4])
bb1112:
  _3789 = (*_3790)
  using: _3790@Mir(bb1111[5])
  _3788 = move _3789 as u32 (IntToInt)
  using: _3789@Mir(bb1112[0])
  _3780 = compress::bsW(move _3781, move _3782, move _3788) -> bb1113
  using: _3781@Mir(bb1110[2]), _3782@Mir(bb1111[1]), _3788@Mir(bb1112[1])
bb1113:
  _3796 = _21
  using: _21@Phi(bb995)
  _3799 = _6
  using: _6@Phi(bb1008)
  _3800 = const 18_i32
  using: 
  _3801 = CheckedAdd(_3799, _3800)
  using: _3799@Mir(bb1113[1]), _3800@Mir(bb1113[2])
  assert(!move (_3801.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3799, move _3800) -> bb1114
  using: _3801@Entry, _3799@Entry, _3800@Entry
bb1114:
  _3798 = move (_3801.0: i32)
  using: _3801@Mir(bb1113[3])
  _3797 = move _3798 as isize (IntToInt)
  using: _3798@Mir(bb1114[0])
  _3795 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3796, move _3797) -> bb1115
  using: _3796@Mir(bb1113[0]), _3797@Mir(bb1114[1])
bb1115:
  _3794 = (*_3795)
  using: _3795@Mir(bb1114[2])
  _3359 = move _3794
  using: _3794@Mir(bb1115[0])
  _3803 = _1
  using: _1@Phi(bb1002)
  _3807 = _3360
  using: _3360@Mir(bb1017[1])
  _3809 = _3359
  using: _3359@Mir(bb1115[1])
  _3808 = move _3809 as isize (IntToInt)
  using: _3809@Mir(bb1115[4])
  _3806 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3807, move _3808) -> bb1116
  using: _3807@Mir(bb1115[3]), _3808@Mir(bb1115[5])
bb1116:
  _3805 = (*_3806)
  using: _3806@Mir(bb1115[6])
  _3804 = move _3805 as i32 (IntToInt)
  using: _3805@Mir(bb1116[0])
  _3813 = _3379
  using: _3379@Mir(bb1023[1])
  _3815 = _3359
  using: _3359@Mir(bb1115[1])
  _3814 = move _3815 as isize (IntToInt)
  using: _3815@Mir(bb1116[3])
  _3812 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3813, move _3814) -> bb1117
  using: _3813@Mir(bb1116[2]), _3814@Mir(bb1116[4])
bb1117:
  _3811 = (*_3812)
  using: _3812@Mir(bb1116[5])
  _3810 = move _3811 as u32 (IntToInt)
  using: _3811@Mir(bb1117[0])
  _3802 = compress::bsW(move _3803, move _3804, move _3810) -> bb1118
  using: _3803@Mir(bb1115[2]), _3804@Mir(bb1116[1]), _3810@Mir(bb1117[1])
bb1118:
  _3818 = _21
  using: _21@Phi(bb995)
  _3821 = _6
  using: _6@Phi(bb1008)
  _3822 = const 19_i32
  using: 
  _3823 = CheckedAdd(_3821, _3822)
  using: _3821@Mir(bb1118[1]), _3822@Mir(bb1118[2])
  assert(!move (_3823.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3821, move _3822) -> bb1119
  using: _3823@Entry, _3821@Entry, _3822@Entry
bb1119:
  _3820 = move (_3823.0: i32)
  using: _3823@Mir(bb1118[3])
  _3819 = move _3820 as isize (IntToInt)
  using: _3820@Mir(bb1119[0])
  _3817 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3818, move _3819) -> bb1120
  using: _3818@Mir(bb1118[0]), _3819@Mir(bb1119[1])
bb1120:
  _3816 = (*_3817)
  using: _3817@Mir(bb1119[2])
  _3359 = move _3816
  using: _3816@Mir(bb1120[0])
  _3825 = _1
  using: _1@Phi(bb1002)
  _3829 = _3360
  using: _3360@Mir(bb1017[1])
  _3831 = _3359
  using: _3359@Mir(bb1120[1])
  _3830 = move _3831 as isize (IntToInt)
  using: _3831@Mir(bb1120[4])
  _3828 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3829, move _3830) -> bb1121
  using: _3829@Mir(bb1120[3]), _3830@Mir(bb1120[5])
bb1121:
  _3827 = (*_3828)
  using: _3828@Mir(bb1120[6])
  _3826 = move _3827 as i32 (IntToInt)
  using: _3827@Mir(bb1121[0])
  _3835 = _3379
  using: _3379@Mir(bb1023[1])
  _3837 = _3359
  using: _3359@Mir(bb1120[1])
  _3836 = move _3837 as isize (IntToInt)
  using: _3837@Mir(bb1121[3])
  _3834 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3835, move _3836) -> bb1122
  using: _3835@Mir(bb1121[2]), _3836@Mir(bb1121[4])
bb1122:
  _3833 = (*_3834)
  using: _3834@Mir(bb1121[5])
  _3832 = move _3833 as u32 (IntToInt)
  using: _3833@Mir(bb1122[0])
  _3824 = compress::bsW(move _3825, move _3826, move _3832) -> bb1123
  using: _3825@Mir(bb1120[2]), _3826@Mir(bb1121[1]), _3832@Mir(bb1122[1])
bb1123:
  _3840 = _21
  using: _21@Phi(bb995)
  _3843 = _6
  using: _6@Phi(bb1008)
  _3844 = const 20_i32
  using: 
  _3845 = CheckedAdd(_3843, _3844)
  using: _3843@Mir(bb1123[1]), _3844@Mir(bb1123[2])
  assert(!move (_3845.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3843, move _3844) -> bb1124
  using: _3845@Entry, _3843@Entry, _3844@Entry
bb1124:
  _3842 = move (_3845.0: i32)
  using: _3845@Mir(bb1123[3])
  _3841 = move _3842 as isize (IntToInt)
  using: _3842@Mir(bb1124[0])
  _3839 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3840, move _3841) -> bb1125
  using: _3840@Mir(bb1123[0]), _3841@Mir(bb1124[1])
bb1125:
  _3838 = (*_3839)
  using: _3839@Mir(bb1124[2])
  _3359 = move _3838
  using: _3838@Mir(bb1125[0])
  _3847 = _1
  using: _1@Phi(bb1002)
  _3851 = _3360
  using: _3360@Mir(bb1017[1])
  _3853 = _3359
  using: _3359@Mir(bb1125[1])
  _3852 = move _3853 as isize (IntToInt)
  using: _3853@Mir(bb1125[4])
  _3850 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3851, move _3852) -> bb1126
  using: _3851@Mir(bb1125[3]), _3852@Mir(bb1125[5])
bb1126:
  _3849 = (*_3850)
  using: _3850@Mir(bb1125[6])
  _3848 = move _3849 as i32 (IntToInt)
  using: _3849@Mir(bb1126[0])
  _3857 = _3379
  using: _3379@Mir(bb1023[1])
  _3859 = _3359
  using: _3359@Mir(bb1125[1])
  _3858 = move _3859 as isize (IntToInt)
  using: _3859@Mir(bb1126[3])
  _3856 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3857, move _3858) -> bb1127
  using: _3857@Mir(bb1126[2]), _3858@Mir(bb1126[4])
bb1127:
  _3855 = (*_3856)
  using: _3856@Mir(bb1126[5])
  _3854 = move _3855 as u32 (IntToInt)
  using: _3855@Mir(bb1127[0])
  _3846 = compress::bsW(move _3847, move _3848, move _3854) -> bb1128
  using: _3847@Mir(bb1125[2]), _3848@Mir(bb1126[1]), _3854@Mir(bb1127[1])
bb1128:
  _3862 = _21
  using: _21@Phi(bb995)
  _3865 = _6
  using: _6@Phi(bb1008)
  _3866 = const 21_i32
  using: 
  _3867 = CheckedAdd(_3865, _3866)
  using: _3865@Mir(bb1128[1]), _3866@Mir(bb1128[2])
  assert(!move (_3867.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3865, move _3866) -> bb1129
  using: _3867@Entry, _3865@Entry, _3866@Entry
bb1129:
  _3864 = move (_3867.0: i32)
  using: _3867@Mir(bb1128[3])
  _3863 = move _3864 as isize (IntToInt)
  using: _3864@Mir(bb1129[0])
  _3861 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3862, move _3863) -> bb1130
  using: _3862@Mir(bb1128[0]), _3863@Mir(bb1129[1])
bb1130:
  _3860 = (*_3861)
  using: _3861@Mir(bb1129[2])
  _3359 = move _3860
  using: _3860@Mir(bb1130[0])
  _3869 = _1
  using: _1@Phi(bb1002)
  _3873 = _3360
  using: _3360@Mir(bb1017[1])
  _3875 = _3359
  using: _3359@Mir(bb1130[1])
  _3874 = move _3875 as isize (IntToInt)
  using: _3875@Mir(bb1130[4])
  _3872 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3873, move _3874) -> bb1131
  using: _3873@Mir(bb1130[3]), _3874@Mir(bb1130[5])
bb1131:
  _3871 = (*_3872)
  using: _3872@Mir(bb1130[6])
  _3870 = move _3871 as i32 (IntToInt)
  using: _3871@Mir(bb1131[0])
  _3879 = _3379
  using: _3379@Mir(bb1023[1])
  _3881 = _3359
  using: _3359@Mir(bb1130[1])
  _3880 = move _3881 as isize (IntToInt)
  using: _3881@Mir(bb1131[3])
  _3878 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3879, move _3880) -> bb1132
  using: _3879@Mir(bb1131[2]), _3880@Mir(bb1131[4])
bb1132:
  _3877 = (*_3878)
  using: _3878@Mir(bb1131[5])
  _3876 = move _3877 as u32 (IntToInt)
  using: _3877@Mir(bb1132[0])
  _3868 = compress::bsW(move _3869, move _3870, move _3876) -> bb1133
  using: _3869@Mir(bb1130[2]), _3870@Mir(bb1131[1]), _3876@Mir(bb1132[1])
bb1133:
  _3884 = _21
  using: _21@Phi(bb995)
  _3887 = _6
  using: _6@Phi(bb1008)
  _3888 = const 22_i32
  using: 
  _3889 = CheckedAdd(_3887, _3888)
  using: _3887@Mir(bb1133[1]), _3888@Mir(bb1133[2])
  assert(!move (_3889.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3887, move _3888) -> bb1134
  using: _3889@Entry, _3887@Entry, _3888@Entry
bb1134:
  _3886 = move (_3889.0: i32)
  using: _3889@Mir(bb1133[3])
  _3885 = move _3886 as isize (IntToInt)
  using: _3886@Mir(bb1134[0])
  _3883 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3884, move _3885) -> bb1135
  using: _3884@Mir(bb1133[0]), _3885@Mir(bb1134[1])
bb1135:
  _3882 = (*_3883)
  using: _3883@Mir(bb1134[2])
  _3359 = move _3882
  using: _3882@Mir(bb1135[0])
  _3891 = _1
  using: _1@Phi(bb1002)
  _3895 = _3360
  using: _3360@Mir(bb1017[1])
  _3897 = _3359
  using: _3359@Mir(bb1135[1])
  _3896 = move _3897 as isize (IntToInt)
  using: _3897@Mir(bb1135[4])
  _3894 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3895, move _3896) -> bb1136
  using: _3895@Mir(bb1135[3]), _3896@Mir(bb1135[5])
bb1136:
  _3893 = (*_3894)
  using: _3894@Mir(bb1135[6])
  _3892 = move _3893 as i32 (IntToInt)
  using: _3893@Mir(bb1136[0])
  _3901 = _3379
  using: _3379@Mir(bb1023[1])
  _3903 = _3359
  using: _3359@Mir(bb1135[1])
  _3902 = move _3903 as isize (IntToInt)
  using: _3903@Mir(bb1136[3])
  _3900 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3901, move _3902) -> bb1137
  using: _3901@Mir(bb1136[2]), _3902@Mir(bb1136[4])
bb1137:
  _3899 = (*_3900)
  using: _3900@Mir(bb1136[5])
  _3898 = move _3899 as u32 (IntToInt)
  using: _3899@Mir(bb1137[0])
  _3890 = compress::bsW(move _3891, move _3892, move _3898) -> bb1138
  using: _3891@Mir(bb1135[2]), _3892@Mir(bb1136[1]), _3898@Mir(bb1137[1])
bb1138:
  _3906 = _21
  using: _21@Phi(bb995)
  _3909 = _6
  using: _6@Phi(bb1008)
  _3910 = const 23_i32
  using: 
  _3911 = CheckedAdd(_3909, _3910)
  using: _3909@Mir(bb1138[1]), _3910@Mir(bb1138[2])
  assert(!move (_3911.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3909, move _3910) -> bb1139
  using: _3911@Entry, _3909@Entry, _3910@Entry
bb1139:
  _3908 = move (_3911.0: i32)
  using: _3911@Mir(bb1138[3])
  _3907 = move _3908 as isize (IntToInt)
  using: _3908@Mir(bb1139[0])
  _3905 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3906, move _3907) -> bb1140
  using: _3906@Mir(bb1138[0]), _3907@Mir(bb1139[1])
bb1140:
  _3904 = (*_3905)
  using: _3905@Mir(bb1139[2])
  _3359 = move _3904
  using: _3904@Mir(bb1140[0])
  _3913 = _1
  using: _1@Phi(bb1002)
  _3917 = _3360
  using: _3360@Mir(bb1017[1])
  _3919 = _3359
  using: _3359@Mir(bb1140[1])
  _3918 = move _3919 as isize (IntToInt)
  using: _3919@Mir(bb1140[4])
  _3916 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3917, move _3918) -> bb1141
  using: _3917@Mir(bb1140[3]), _3918@Mir(bb1140[5])
bb1141:
  _3915 = (*_3916)
  using: _3916@Mir(bb1140[6])
  _3914 = move _3915 as i32 (IntToInt)
  using: _3915@Mir(bb1141[0])
  _3923 = _3379
  using: _3379@Mir(bb1023[1])
  _3925 = _3359
  using: _3359@Mir(bb1140[1])
  _3924 = move _3925 as isize (IntToInt)
  using: _3925@Mir(bb1141[3])
  _3922 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3923, move _3924) -> bb1142
  using: _3923@Mir(bb1141[2]), _3924@Mir(bb1141[4])
bb1142:
  _3921 = (*_3922)
  using: _3922@Mir(bb1141[5])
  _3920 = move _3921 as u32 (IntToInt)
  using: _3921@Mir(bb1142[0])
  _3912 = compress::bsW(move _3913, move _3914, move _3920) -> bb1143
  using: _3913@Mir(bb1140[2]), _3914@Mir(bb1141[1]), _3920@Mir(bb1142[1])
bb1143:
  _3928 = _21
  using: _21@Phi(bb995)
  _3931 = _6
  using: _6@Phi(bb1008)
  _3932 = const 24_i32
  using: 
  _3933 = CheckedAdd(_3931, _3932)
  using: _3931@Mir(bb1143[1]), _3932@Mir(bb1143[2])
  assert(!move (_3933.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3931, move _3932) -> bb1144
  using: _3933@Entry, _3931@Entry, _3932@Entry
bb1144:
  _3930 = move (_3933.0: i32)
  using: _3933@Mir(bb1143[3])
  _3929 = move _3930 as isize (IntToInt)
  using: _3930@Mir(bb1144[0])
  _3927 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3928, move _3929) -> bb1145
  using: _3928@Mir(bb1143[0]), _3929@Mir(bb1144[1])
bb1145:
  _3926 = (*_3927)
  using: _3927@Mir(bb1144[2])
  _3359 = move _3926
  using: _3926@Mir(bb1145[0])
  _3935 = _1
  using: _1@Phi(bb1002)
  _3939 = _3360
  using: _3360@Mir(bb1017[1])
  _3941 = _3359
  using: _3359@Mir(bb1145[1])
  _3940 = move _3941 as isize (IntToInt)
  using: _3941@Mir(bb1145[4])
  _3938 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3939, move _3940) -> bb1146
  using: _3939@Mir(bb1145[3]), _3940@Mir(bb1145[5])
bb1146:
  _3937 = (*_3938)
  using: _3938@Mir(bb1145[6])
  _3936 = move _3937 as i32 (IntToInt)
  using: _3937@Mir(bb1146[0])
  _3945 = _3379
  using: _3379@Mir(bb1023[1])
  _3947 = _3359
  using: _3359@Mir(bb1145[1])
  _3946 = move _3947 as isize (IntToInt)
  using: _3947@Mir(bb1146[3])
  _3944 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3945, move _3946) -> bb1147
  using: _3945@Mir(bb1146[2]), _3946@Mir(bb1146[4])
bb1147:
  _3943 = (*_3944)
  using: _3944@Mir(bb1146[5])
  _3942 = move _3943 as u32 (IntToInt)
  using: _3943@Mir(bb1147[0])
  _3934 = compress::bsW(move _3935, move _3936, move _3942) -> bb1148
  using: _3935@Mir(bb1145[2]), _3936@Mir(bb1146[1]), _3942@Mir(bb1147[1])
bb1148:
  _3950 = _21
  using: _21@Phi(bb995)
  _3953 = _6
  using: _6@Phi(bb1008)
  _3954 = const 25_i32
  using: 
  _3955 = CheckedAdd(_3953, _3954)
  using: _3953@Mir(bb1148[1]), _3954@Mir(bb1148[2])
  assert(!move (_3955.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3953, move _3954) -> bb1149
  using: _3955@Entry, _3953@Entry, _3954@Entry
bb1149:
  _3952 = move (_3955.0: i32)
  using: _3955@Mir(bb1148[3])
  _3951 = move _3952 as isize (IntToInt)
  using: _3952@Mir(bb1149[0])
  _3949 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3950, move _3951) -> bb1150
  using: _3950@Mir(bb1148[0]), _3951@Mir(bb1149[1])
bb1150:
  _3948 = (*_3949)
  using: _3949@Mir(bb1149[2])
  _3359 = move _3948
  using: _3948@Mir(bb1150[0])
  _3957 = _1
  using: _1@Phi(bb1002)
  _3961 = _3360
  using: _3360@Mir(bb1017[1])
  _3963 = _3359
  using: _3359@Mir(bb1150[1])
  _3962 = move _3963 as isize (IntToInt)
  using: _3963@Mir(bb1150[4])
  _3960 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3961, move _3962) -> bb1151
  using: _3961@Mir(bb1150[3]), _3962@Mir(bb1150[5])
bb1151:
  _3959 = (*_3960)
  using: _3960@Mir(bb1150[6])
  _3958 = move _3959 as i32 (IntToInt)
  using: _3959@Mir(bb1151[0])
  _3967 = _3379
  using: _3379@Mir(bb1023[1])
  _3969 = _3359
  using: _3359@Mir(bb1150[1])
  _3968 = move _3969 as isize (IntToInt)
  using: _3969@Mir(bb1151[3])
  _3966 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3967, move _3968) -> bb1152
  using: _3967@Mir(bb1151[2]), _3968@Mir(bb1151[4])
bb1152:
  _3965 = (*_3966)
  using: _3966@Mir(bb1151[5])
  _3964 = move _3965 as u32 (IntToInt)
  using: _3965@Mir(bb1152[0])
  _3956 = compress::bsW(move _3957, move _3958, move _3964) -> bb1153
  using: _3957@Mir(bb1150[2]), _3958@Mir(bb1151[1]), _3964@Mir(bb1152[1])
bb1153:
  _3972 = _21
  using: _21@Phi(bb995)
  _3975 = _6
  using: _6@Phi(bb1008)
  _3976 = const 26_i32
  using: 
  _3977 = CheckedAdd(_3975, _3976)
  using: _3975@Mir(bb1153[1]), _3976@Mir(bb1153[2])
  assert(!move (_3977.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3975, move _3976) -> bb1154
  using: _3977@Entry, _3975@Entry, _3976@Entry
bb1154:
  _3974 = move (_3977.0: i32)
  using: _3977@Mir(bb1153[3])
  _3973 = move _3974 as isize (IntToInt)
  using: _3974@Mir(bb1154[0])
  _3971 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3972, move _3973) -> bb1155
  using: _3972@Mir(bb1153[0]), _3973@Mir(bb1154[1])
bb1155:
  _3970 = (*_3971)
  using: _3971@Mir(bb1154[2])
  _3359 = move _3970
  using: _3970@Mir(bb1155[0])
  _3979 = _1
  using: _1@Phi(bb1002)
  _3983 = _3360
  using: _3360@Mir(bb1017[1])
  _3985 = _3359
  using: _3359@Mir(bb1155[1])
  _3984 = move _3985 as isize (IntToInt)
  using: _3985@Mir(bb1155[4])
  _3982 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3983, move _3984) -> bb1156
  using: _3983@Mir(bb1155[3]), _3984@Mir(bb1155[5])
bb1156:
  _3981 = (*_3982)
  using: _3982@Mir(bb1155[6])
  _3980 = move _3981 as i32 (IntToInt)
  using: _3981@Mir(bb1156[0])
  _3989 = _3379
  using: _3379@Mir(bb1023[1])
  _3991 = _3359
  using: _3359@Mir(bb1155[1])
  _3990 = move _3991 as isize (IntToInt)
  using: _3991@Mir(bb1156[3])
  _3988 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3989, move _3990) -> bb1157
  using: _3989@Mir(bb1156[2]), _3990@Mir(bb1156[4])
bb1157:
  _3987 = (*_3988)
  using: _3988@Mir(bb1156[5])
  _3986 = move _3987 as u32 (IntToInt)
  using: _3987@Mir(bb1157[0])
  _3978 = compress::bsW(move _3979, move _3980, move _3986) -> bb1158
  using: _3979@Mir(bb1155[2]), _3980@Mir(bb1156[1]), _3986@Mir(bb1157[1])
bb1158:
  _3994 = _21
  using: _21@Phi(bb995)
  _3997 = _6
  using: _6@Phi(bb1008)
  _3998 = const 27_i32
  using: 
  _3999 = CheckedAdd(_3997, _3998)
  using: _3997@Mir(bb1158[1]), _3998@Mir(bb1158[2])
  assert(!move (_3999.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3997, move _3998) -> bb1159
  using: _3999@Entry, _3997@Entry, _3998@Entry
bb1159:
  _3996 = move (_3999.0: i32)
  using: _3999@Mir(bb1158[3])
  _3995 = move _3996 as isize (IntToInt)
  using: _3996@Mir(bb1159[0])
  _3993 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3994, move _3995) -> bb1160
  using: _3994@Mir(bb1158[0]), _3995@Mir(bb1159[1])
bb1160:
  _3992 = (*_3993)
  using: _3993@Mir(bb1159[2])
  _3359 = move _3992
  using: _3992@Mir(bb1160[0])
  _4001 = _1
  using: _1@Phi(bb1002)
  _4005 = _3360
  using: _3360@Mir(bb1017[1])
  _4007 = _3359
  using: _3359@Mir(bb1160[1])
  _4006 = move _4007 as isize (IntToInt)
  using: _4007@Mir(bb1160[4])
  _4004 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4005, move _4006) -> bb1161
  using: _4005@Mir(bb1160[3]), _4006@Mir(bb1160[5])
bb1161:
  _4003 = (*_4004)
  using: _4004@Mir(bb1160[6])
  _4002 = move _4003 as i32 (IntToInt)
  using: _4003@Mir(bb1161[0])
  _4011 = _3379
  using: _3379@Mir(bb1023[1])
  _4013 = _3359
  using: _3359@Mir(bb1160[1])
  _4012 = move _4013 as isize (IntToInt)
  using: _4013@Mir(bb1161[3])
  _4010 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4011, move _4012) -> bb1162
  using: _4011@Mir(bb1161[2]), _4012@Mir(bb1161[4])
bb1162:
  _4009 = (*_4010)
  using: _4010@Mir(bb1161[5])
  _4008 = move _4009 as u32 (IntToInt)
  using: _4009@Mir(bb1162[0])
  _4000 = compress::bsW(move _4001, move _4002, move _4008) -> bb1163
  using: _4001@Mir(bb1160[2]), _4002@Mir(bb1161[1]), _4008@Mir(bb1162[1])
bb1163:
  _4016 = _21
  using: _21@Phi(bb995)
  _4019 = _6
  using: _6@Phi(bb1008)
  _4020 = const 28_i32
  using: 
  _4021 = CheckedAdd(_4019, _4020)
  using: _4019@Mir(bb1163[1]), _4020@Mir(bb1163[2])
  assert(!move (_4021.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4019, move _4020) -> bb1164
  using: _4021@Entry, _4019@Entry, _4020@Entry
bb1164:
  _4018 = move (_4021.0: i32)
  using: _4021@Mir(bb1163[3])
  _4017 = move _4018 as isize (IntToInt)
  using: _4018@Mir(bb1164[0])
  _4015 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4016, move _4017) -> bb1165
  using: _4016@Mir(bb1163[0]), _4017@Mir(bb1164[1])
bb1165:
  _4014 = (*_4015)
  using: _4015@Mir(bb1164[2])
  _3359 = move _4014
  using: _4014@Mir(bb1165[0])
  _4023 = _1
  using: _1@Phi(bb1002)
  _4027 = _3360
  using: _3360@Mir(bb1017[1])
  _4029 = _3359
  using: _3359@Mir(bb1165[1])
  _4028 = move _4029 as isize (IntToInt)
  using: _4029@Mir(bb1165[4])
  _4026 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4027, move _4028) -> bb1166
  using: _4027@Mir(bb1165[3]), _4028@Mir(bb1165[5])
bb1166:
  _4025 = (*_4026)
  using: _4026@Mir(bb1165[6])
  _4024 = move _4025 as i32 (IntToInt)
  using: _4025@Mir(bb1166[0])
  _4033 = _3379
  using: _3379@Mir(bb1023[1])
  _4035 = _3359
  using: _3359@Mir(bb1165[1])
  _4034 = move _4035 as isize (IntToInt)
  using: _4035@Mir(bb1166[3])
  _4032 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4033, move _4034) -> bb1167
  using: _4033@Mir(bb1166[2]), _4034@Mir(bb1166[4])
bb1167:
  _4031 = (*_4032)
  using: _4032@Mir(bb1166[5])
  _4030 = move _4031 as u32 (IntToInt)
  using: _4031@Mir(bb1167[0])
  _4022 = compress::bsW(move _4023, move _4024, move _4030) -> bb1168
  using: _4023@Mir(bb1165[2]), _4024@Mir(bb1166[1]), _4030@Mir(bb1167[1])
bb1168:
  _4038 = _21
  using: _21@Phi(bb995)
  _4041 = _6
  using: _6@Phi(bb1008)
  _4042 = const 29_i32
  using: 
  _4043 = CheckedAdd(_4041, _4042)
  using: _4041@Mir(bb1168[1]), _4042@Mir(bb1168[2])
  assert(!move (_4043.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4041, move _4042) -> bb1169
  using: _4043@Entry, _4041@Entry, _4042@Entry
bb1169:
  _4040 = move (_4043.0: i32)
  using: _4043@Mir(bb1168[3])
  _4039 = move _4040 as isize (IntToInt)
  using: _4040@Mir(bb1169[0])
  _4037 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4038, move _4039) -> bb1170
  using: _4038@Mir(bb1168[0]), _4039@Mir(bb1169[1])
bb1170:
  _4036 = (*_4037)
  using: _4037@Mir(bb1169[2])
  _3359 = move _4036
  using: _4036@Mir(bb1170[0])
  _4045 = _1
  using: _1@Phi(bb1002)
  _4049 = _3360
  using: _3360@Mir(bb1017[1])
  _4051 = _3359
  using: _3359@Mir(bb1170[1])
  _4050 = move _4051 as isize (IntToInt)
  using: _4051@Mir(bb1170[4])
  _4048 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4049, move _4050) -> bb1171
  using: _4049@Mir(bb1170[3]), _4050@Mir(bb1170[5])
bb1171:
  _4047 = (*_4048)
  using: _4048@Mir(bb1170[6])
  _4046 = move _4047 as i32 (IntToInt)
  using: _4047@Mir(bb1171[0])
  _4055 = _3379
  using: _3379@Mir(bb1023[1])
  _4057 = _3359
  using: _3359@Mir(bb1170[1])
  _4056 = move _4057 as isize (IntToInt)
  using: _4057@Mir(bb1171[3])
  _4054 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4055, move _4056) -> bb1172
  using: _4055@Mir(bb1171[2]), _4056@Mir(bb1171[4])
bb1172:
  _4053 = (*_4054)
  using: _4054@Mir(bb1171[5])
  _4052 = move _4053 as u32 (IntToInt)
  using: _4053@Mir(bb1172[0])
  _4044 = compress::bsW(move _4045, move _4046, move _4052) -> bb1173
  using: _4045@Mir(bb1170[2]), _4046@Mir(bb1171[1]), _4052@Mir(bb1172[1])
bb1173:
  _4060 = _21
  using: _21@Phi(bb995)
  _4063 = _6
  using: _6@Phi(bb1008)
  _4064 = const 30_i32
  using: 
  _4065 = CheckedAdd(_4063, _4064)
  using: _4063@Mir(bb1173[1]), _4064@Mir(bb1173[2])
  assert(!move (_4065.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4063, move _4064) -> bb1174
  using: _4065@Entry, _4063@Entry, _4064@Entry
bb1174:
  _4062 = move (_4065.0: i32)
  using: _4065@Mir(bb1173[3])
  _4061 = move _4062 as isize (IntToInt)
  using: _4062@Mir(bb1174[0])
  _4059 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4060, move _4061) -> bb1175
  using: _4060@Mir(bb1173[0]), _4061@Mir(bb1174[1])
bb1175:
  _4058 = (*_4059)
  using: _4059@Mir(bb1174[2])
  _3359 = move _4058
  using: _4058@Mir(bb1175[0])
  _4067 = _1
  using: _1@Phi(bb1002)
  _4071 = _3360
  using: _3360@Mir(bb1017[1])
  _4073 = _3359
  using: _3359@Mir(bb1175[1])
  _4072 = move _4073 as isize (IntToInt)
  using: _4073@Mir(bb1175[4])
  _4070 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4071, move _4072) -> bb1176
  using: _4071@Mir(bb1175[3]), _4072@Mir(bb1175[5])
bb1176:
  _4069 = (*_4070)
  using: _4070@Mir(bb1175[6])
  _4068 = move _4069 as i32 (IntToInt)
  using: _4069@Mir(bb1176[0])
  _4077 = _3379
  using: _3379@Mir(bb1023[1])
  _4079 = _3359
  using: _3359@Mir(bb1175[1])
  _4078 = move _4079 as isize (IntToInt)
  using: _4079@Mir(bb1176[3])
  _4076 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4077, move _4078) -> bb1177
  using: _4077@Mir(bb1176[2]), _4078@Mir(bb1176[4])
bb1177:
  _4075 = (*_4076)
  using: _4076@Mir(bb1176[5])
  _4074 = move _4075 as u32 (IntToInt)
  using: _4075@Mir(bb1177[0])
  _4066 = compress::bsW(move _4067, move _4068, move _4074) -> bb1178
  using: _4067@Mir(bb1175[2]), _4068@Mir(bb1176[1]), _4074@Mir(bb1177[1])
bb1178:
  _4082 = _21
  using: _21@Phi(bb995)
  _4085 = _6
  using: _6@Phi(bb1008)
  _4086 = const 31_i32
  using: 
  _4087 = CheckedAdd(_4085, _4086)
  using: _4085@Mir(bb1178[1]), _4086@Mir(bb1178[2])
  assert(!move (_4087.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4085, move _4086) -> bb1179
  using: _4087@Entry, _4085@Entry, _4086@Entry
bb1179:
  _4084 = move (_4087.0: i32)
  using: _4087@Mir(bb1178[3])
  _4083 = move _4084 as isize (IntToInt)
  using: _4084@Mir(bb1179[0])
  _4081 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4082, move _4083) -> bb1180
  using: _4082@Mir(bb1178[0]), _4083@Mir(bb1179[1])
bb1180:
  _4080 = (*_4081)
  using: _4081@Mir(bb1179[2])
  _3359 = move _4080
  using: _4080@Mir(bb1180[0])
  _4089 = _1
  using: _1@Phi(bb1002)
  _4093 = _3360
  using: _3360@Mir(bb1017[1])
  _4095 = _3359
  using: _3359@Mir(bb1180[1])
  _4094 = move _4095 as isize (IntToInt)
  using: _4095@Mir(bb1180[4])
  _4092 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4093, move _4094) -> bb1181
  using: _4093@Mir(bb1180[3]), _4094@Mir(bb1180[5])
bb1181:
  _4091 = (*_4092)
  using: _4092@Mir(bb1180[6])
  _4090 = move _4091 as i32 (IntToInt)
  using: _4091@Mir(bb1181[0])
  _4099 = _3379
  using: _3379@Mir(bb1023[1])
  _4101 = _3359
  using: _3359@Mir(bb1180[1])
  _4100 = move _4101 as isize (IntToInt)
  using: _4101@Mir(bb1181[3])
  _4098 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4099, move _4100) -> bb1182
  using: _4099@Mir(bb1181[2]), _4100@Mir(bb1181[4])
bb1182:
  _4097 = (*_4098)
  using: _4098@Mir(bb1181[5])
  _4096 = move _4097 as u32 (IntToInt)
  using: _4097@Mir(bb1182[0])
  _4088 = compress::bsW(move _4089, move _4090, move _4096) -> bb1183
  using: _4089@Mir(bb1180[2]), _4090@Mir(bb1181[1]), _4096@Mir(bb1182[1])
bb1183:
  _4104 = _21
  using: _21@Phi(bb995)
  _4107 = _6
  using: _6@Phi(bb1008)
  _4108 = const 32_i32
  using: 
  _4109 = CheckedAdd(_4107, _4108)
  using: _4107@Mir(bb1183[1]), _4108@Mir(bb1183[2])
  assert(!move (_4109.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4107, move _4108) -> bb1184
  using: _4109@Entry, _4107@Entry, _4108@Entry
bb1184:
  _4106 = move (_4109.0: i32)
  using: _4109@Mir(bb1183[3])
  _4105 = move _4106 as isize (IntToInt)
  using: _4106@Mir(bb1184[0])
  _4103 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4104, move _4105) -> bb1185
  using: _4104@Mir(bb1183[0]), _4105@Mir(bb1184[1])
bb1185:
  _4102 = (*_4103)
  using: _4103@Mir(bb1184[2])
  _3359 = move _4102
  using: _4102@Mir(bb1185[0])
  _4111 = _1
  using: _1@Phi(bb1002)
  _4115 = _3360
  using: _3360@Mir(bb1017[1])
  _4117 = _3359
  using: _3359@Mir(bb1185[1])
  _4116 = move _4117 as isize (IntToInt)
  using: _4117@Mir(bb1185[4])
  _4114 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4115, move _4116) -> bb1186
  using: _4115@Mir(bb1185[3]), _4116@Mir(bb1185[5])
bb1186:
  _4113 = (*_4114)
  using: _4114@Mir(bb1185[6])
  _4112 = move _4113 as i32 (IntToInt)
  using: _4113@Mir(bb1186[0])
  _4121 = _3379
  using: _3379@Mir(bb1023[1])
  _4123 = _3359
  using: _3359@Mir(bb1185[1])
  _4122 = move _4123 as isize (IntToInt)
  using: _4123@Mir(bb1186[3])
  _4120 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4121, move _4122) -> bb1187
  using: _4121@Mir(bb1186[2]), _4122@Mir(bb1186[4])
bb1187:
  _4119 = (*_4120)
  using: _4120@Mir(bb1186[5])
  _4118 = move _4119 as u32 (IntToInt)
  using: _4119@Mir(bb1187[0])
  _4110 = compress::bsW(move _4111, move _4112, move _4118) -> bb1188
  using: _4111@Mir(bb1185[2]), _4112@Mir(bb1186[1]), _4118@Mir(bb1187[1])
bb1188:
  _4126 = _21
  using: _21@Phi(bb995)
  _4129 = _6
  using: _6@Phi(bb1008)
  _4130 = const 33_i32
  using: 
  _4131 = CheckedAdd(_4129, _4130)
  using: _4129@Mir(bb1188[1]), _4130@Mir(bb1188[2])
  assert(!move (_4131.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4129, move _4130) -> bb1189
  using: _4131@Entry, _4129@Entry, _4130@Entry
bb1189:
  _4128 = move (_4131.0: i32)
  using: _4131@Mir(bb1188[3])
  _4127 = move _4128 as isize (IntToInt)
  using: _4128@Mir(bb1189[0])
  _4125 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4126, move _4127) -> bb1190
  using: _4126@Mir(bb1188[0]), _4127@Mir(bb1189[1])
bb1190:
  _4124 = (*_4125)
  using: _4125@Mir(bb1189[2])
  _3359 = move _4124
  using: _4124@Mir(bb1190[0])
  _4133 = _1
  using: _1@Phi(bb1002)
  _4137 = _3360
  using: _3360@Mir(bb1017[1])
  _4139 = _3359
  using: _3359@Mir(bb1190[1])
  _4138 = move _4139 as isize (IntToInt)
  using: _4139@Mir(bb1190[4])
  _4136 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4137, move _4138) -> bb1191
  using: _4137@Mir(bb1190[3]), _4138@Mir(bb1190[5])
bb1191:
  _4135 = (*_4136)
  using: _4136@Mir(bb1190[6])
  _4134 = move _4135 as i32 (IntToInt)
  using: _4135@Mir(bb1191[0])
  _4143 = _3379
  using: _3379@Mir(bb1023[1])
  _4145 = _3359
  using: _3359@Mir(bb1190[1])
  _4144 = move _4145 as isize (IntToInt)
  using: _4145@Mir(bb1191[3])
  _4142 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4143, move _4144) -> bb1192
  using: _4143@Mir(bb1191[2]), _4144@Mir(bb1191[4])
bb1192:
  _4141 = (*_4142)
  using: _4142@Mir(bb1191[5])
  _4140 = move _4141 as u32 (IntToInt)
  using: _4141@Mir(bb1192[0])
  _4132 = compress::bsW(move _4133, move _4134, move _4140) -> bb1193
  using: _4133@Mir(bb1190[2]), _4134@Mir(bb1191[1]), _4140@Mir(bb1192[1])
bb1193:
  _4148 = _21
  using: _21@Phi(bb995)
  _4151 = _6
  using: _6@Phi(bb1008)
  _4152 = const 34_i32
  using: 
  _4153 = CheckedAdd(_4151, _4152)
  using: _4151@Mir(bb1193[1]), _4152@Mir(bb1193[2])
  assert(!move (_4153.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4151, move _4152) -> bb1194
  using: _4153@Entry, _4151@Entry, _4152@Entry
bb1194:
  _4150 = move (_4153.0: i32)
  using: _4153@Mir(bb1193[3])
  _4149 = move _4150 as isize (IntToInt)
  using: _4150@Mir(bb1194[0])
  _4147 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4148, move _4149) -> bb1195
  using: _4148@Mir(bb1193[0]), _4149@Mir(bb1194[1])
bb1195:
  _4146 = (*_4147)
  using: _4147@Mir(bb1194[2])
  _3359 = move _4146
  using: _4146@Mir(bb1195[0])
  _4155 = _1
  using: _1@Phi(bb1002)
  _4159 = _3360
  using: _3360@Mir(bb1017[1])
  _4161 = _3359
  using: _3359@Mir(bb1195[1])
  _4160 = move _4161 as isize (IntToInt)
  using: _4161@Mir(bb1195[4])
  _4158 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4159, move _4160) -> bb1196
  using: _4159@Mir(bb1195[3]), _4160@Mir(bb1195[5])
bb1196:
  _4157 = (*_4158)
  using: _4158@Mir(bb1195[6])
  _4156 = move _4157 as i32 (IntToInt)
  using: _4157@Mir(bb1196[0])
  _4165 = _3379
  using: _3379@Mir(bb1023[1])
  _4167 = _3359
  using: _3359@Mir(bb1195[1])
  _4166 = move _4167 as isize (IntToInt)
  using: _4167@Mir(bb1196[3])
  _4164 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4165, move _4166) -> bb1197
  using: _4165@Mir(bb1196[2]), _4166@Mir(bb1196[4])
bb1197:
  _4163 = (*_4164)
  using: _4164@Mir(bb1196[5])
  _4162 = move _4163 as u32 (IntToInt)
  using: _4163@Mir(bb1197[0])
  _4154 = compress::bsW(move _4155, move _4156, move _4162) -> bb1198
  using: _4155@Mir(bb1195[2]), _4156@Mir(bb1196[1]), _4162@Mir(bb1197[1])
bb1198:
  _4170 = _21
  using: _21@Phi(bb995)
  _4173 = _6
  using: _6@Phi(bb1008)
  _4174 = const 35_i32
  using: 
  _4175 = CheckedAdd(_4173, _4174)
  using: _4173@Mir(bb1198[1]), _4174@Mir(bb1198[2])
  assert(!move (_4175.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4173, move _4174) -> bb1199
  using: _4175@Entry, _4173@Entry, _4174@Entry
bb1199:
  _4172 = move (_4175.0: i32)
  using: _4175@Mir(bb1198[3])
  _4171 = move _4172 as isize (IntToInt)
  using: _4172@Mir(bb1199[0])
  _4169 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4170, move _4171) -> bb1200
  using: _4170@Mir(bb1198[0]), _4171@Mir(bb1199[1])
bb1200:
  _4168 = (*_4169)
  using: _4169@Mir(bb1199[2])
  _3359 = move _4168
  using: _4168@Mir(bb1200[0])
  _4177 = _1
  using: _1@Phi(bb1002)
  _4181 = _3360
  using: _3360@Mir(bb1017[1])
  _4183 = _3359
  using: _3359@Mir(bb1200[1])
  _4182 = move _4183 as isize (IntToInt)
  using: _4183@Mir(bb1200[4])
  _4180 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4181, move _4182) -> bb1201
  using: _4181@Mir(bb1200[3]), _4182@Mir(bb1200[5])
bb1201:
  _4179 = (*_4180)
  using: _4180@Mir(bb1200[6])
  _4178 = move _4179 as i32 (IntToInt)
  using: _4179@Mir(bb1201[0])
  _4187 = _3379
  using: _3379@Mir(bb1023[1])
  _4189 = _3359
  using: _3359@Mir(bb1200[1])
  _4188 = move _4189 as isize (IntToInt)
  using: _4189@Mir(bb1201[3])
  _4186 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4187, move _4188) -> bb1202
  using: _4187@Mir(bb1201[2]), _4188@Mir(bb1201[4])
bb1202:
  _4185 = (*_4186)
  using: _4186@Mir(bb1201[5])
  _4184 = move _4185 as u32 (IntToInt)
  using: _4185@Mir(bb1202[0])
  _4176 = compress::bsW(move _4177, move _4178, move _4184) -> bb1203
  using: _4177@Mir(bb1200[2]), _4178@Mir(bb1201[1]), _4184@Mir(bb1202[1])
bb1203:
  _4192 = _21
  using: _21@Phi(bb995)
  _4195 = _6
  using: _6@Phi(bb1008)
  _4196 = const 36_i32
  using: 
  _4197 = CheckedAdd(_4195, _4196)
  using: _4195@Mir(bb1203[1]), _4196@Mir(bb1203[2])
  assert(!move (_4197.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4195, move _4196) -> bb1204
  using: _4197@Entry, _4195@Entry, _4196@Entry
bb1204:
  _4194 = move (_4197.0: i32)
  using: _4197@Mir(bb1203[3])
  _4193 = move _4194 as isize (IntToInt)
  using: _4194@Mir(bb1204[0])
  _4191 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4192, move _4193) -> bb1205
  using: _4192@Mir(bb1203[0]), _4193@Mir(bb1204[1])
bb1205:
  _4190 = (*_4191)
  using: _4191@Mir(bb1204[2])
  _3359 = move _4190
  using: _4190@Mir(bb1205[0])
  _4199 = _1
  using: _1@Phi(bb1002)
  _4203 = _3360
  using: _3360@Mir(bb1017[1])
  _4205 = _3359
  using: _3359@Mir(bb1205[1])
  _4204 = move _4205 as isize (IntToInt)
  using: _4205@Mir(bb1205[4])
  _4202 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4203, move _4204) -> bb1206
  using: _4203@Mir(bb1205[3]), _4204@Mir(bb1205[5])
bb1206:
  _4201 = (*_4202)
  using: _4202@Mir(bb1205[6])
  _4200 = move _4201 as i32 (IntToInt)
  using: _4201@Mir(bb1206[0])
  _4209 = _3379
  using: _3379@Mir(bb1023[1])
  _4211 = _3359
  using: _3359@Mir(bb1205[1])
  _4210 = move _4211 as isize (IntToInt)
  using: _4211@Mir(bb1206[3])
  _4208 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4209, move _4210) -> bb1207
  using: _4209@Mir(bb1206[2]), _4210@Mir(bb1206[4])
bb1207:
  _4207 = (*_4208)
  using: _4208@Mir(bb1206[5])
  _4206 = move _4207 as u32 (IntToInt)
  using: _4207@Mir(bb1207[0])
  _4198 = compress::bsW(move _4199, move _4200, move _4206) -> bb1208
  using: _4199@Mir(bb1205[2]), _4200@Mir(bb1206[1]), _4206@Mir(bb1207[1])
bb1208:
  _4214 = _21
  using: _21@Phi(bb995)
  _4217 = _6
  using: _6@Phi(bb1008)
  _4218 = const 37_i32
  using: 
  _4219 = CheckedAdd(_4217, _4218)
  using: _4217@Mir(bb1208[1]), _4218@Mir(bb1208[2])
  assert(!move (_4219.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4217, move _4218) -> bb1209
  using: _4219@Entry, _4217@Entry, _4218@Entry
bb1209:
  _4216 = move (_4219.0: i32)
  using: _4219@Mir(bb1208[3])
  _4215 = move _4216 as isize (IntToInt)
  using: _4216@Mir(bb1209[0])
  _4213 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4214, move _4215) -> bb1210
  using: _4214@Mir(bb1208[0]), _4215@Mir(bb1209[1])
bb1210:
  _4212 = (*_4213)
  using: _4213@Mir(bb1209[2])
  _3359 = move _4212
  using: _4212@Mir(bb1210[0])
  _4221 = _1
  using: _1@Phi(bb1002)
  _4225 = _3360
  using: _3360@Mir(bb1017[1])
  _4227 = _3359
  using: _3359@Mir(bb1210[1])
  _4226 = move _4227 as isize (IntToInt)
  using: _4227@Mir(bb1210[4])
  _4224 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4225, move _4226) -> bb1211
  using: _4225@Mir(bb1210[3]), _4226@Mir(bb1210[5])
bb1211:
  _4223 = (*_4224)
  using: _4224@Mir(bb1210[6])
  _4222 = move _4223 as i32 (IntToInt)
  using: _4223@Mir(bb1211[0])
  _4231 = _3379
  using: _3379@Mir(bb1023[1])
  _4233 = _3359
  using: _3359@Mir(bb1210[1])
  _4232 = move _4233 as isize (IntToInt)
  using: _4233@Mir(bb1211[3])
  _4230 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4231, move _4232) -> bb1212
  using: _4231@Mir(bb1211[2]), _4232@Mir(bb1211[4])
bb1212:
  _4229 = (*_4230)
  using: _4230@Mir(bb1211[5])
  _4228 = move _4229 as u32 (IntToInt)
  using: _4229@Mir(bb1212[0])
  _4220 = compress::bsW(move _4221, move _4222, move _4228) -> bb1213
  using: _4221@Mir(bb1210[2]), _4222@Mir(bb1211[1]), _4228@Mir(bb1212[1])
bb1213:
  _4236 = _21
  using: _21@Phi(bb995)
  _4239 = _6
  using: _6@Phi(bb1008)
  _4240 = const 38_i32
  using: 
  _4241 = CheckedAdd(_4239, _4240)
  using: _4239@Mir(bb1213[1]), _4240@Mir(bb1213[2])
  assert(!move (_4241.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4239, move _4240) -> bb1214
  using: _4241@Entry, _4239@Entry, _4240@Entry
bb1214:
  _4238 = move (_4241.0: i32)
  using: _4241@Mir(bb1213[3])
  _4237 = move _4238 as isize (IntToInt)
  using: _4238@Mir(bb1214[0])
  _4235 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4236, move _4237) -> bb1215
  using: _4236@Mir(bb1213[0]), _4237@Mir(bb1214[1])
bb1215:
  _4234 = (*_4235)
  using: _4235@Mir(bb1214[2])
  _3359 = move _4234
  using: _4234@Mir(bb1215[0])
  _4243 = _1
  using: _1@Phi(bb1002)
  _4247 = _3360
  using: _3360@Mir(bb1017[1])
  _4249 = _3359
  using: _3359@Mir(bb1215[1])
  _4248 = move _4249 as isize (IntToInt)
  using: _4249@Mir(bb1215[4])
  _4246 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4247, move _4248) -> bb1216
  using: _4247@Mir(bb1215[3]), _4248@Mir(bb1215[5])
bb1216:
  _4245 = (*_4246)
  using: _4246@Mir(bb1215[6])
  _4244 = move _4245 as i32 (IntToInt)
  using: _4245@Mir(bb1216[0])
  _4253 = _3379
  using: _3379@Mir(bb1023[1])
  _4255 = _3359
  using: _3359@Mir(bb1215[1])
  _4254 = move _4255 as isize (IntToInt)
  using: _4255@Mir(bb1216[3])
  _4252 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4253, move _4254) -> bb1217
  using: _4253@Mir(bb1216[2]), _4254@Mir(bb1216[4])
bb1217:
  _4251 = (*_4252)
  using: _4252@Mir(bb1216[5])
  _4250 = move _4251 as u32 (IntToInt)
  using: _4251@Mir(bb1217[0])
  _4242 = compress::bsW(move _4243, move _4244, move _4250) -> bb1218
  using: _4243@Mir(bb1215[2]), _4244@Mir(bb1216[1]), _4250@Mir(bb1217[1])
bb1218:
  _4258 = _21
  using: _21@Phi(bb995)
  _4261 = _6
  using: _6@Phi(bb1008)
  _4262 = const 39_i32
  using: 
  _4263 = CheckedAdd(_4261, _4262)
  using: _4261@Mir(bb1218[1]), _4262@Mir(bb1218[2])
  assert(!move (_4263.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4261, move _4262) -> bb1219
  using: _4263@Entry, _4261@Entry, _4262@Entry
bb1219:
  _4260 = move (_4263.0: i32)
  using: _4263@Mir(bb1218[3])
  _4259 = move _4260 as isize (IntToInt)
  using: _4260@Mir(bb1219[0])
  _4257 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4258, move _4259) -> bb1220
  using: _4258@Mir(bb1218[0]), _4259@Mir(bb1219[1])
bb1220:
  _4256 = (*_4257)
  using: _4257@Mir(bb1219[2])
  _3359 = move _4256
  using: _4256@Mir(bb1220[0])
  _4265 = _1
  using: _1@Phi(bb1002)
  _4269 = _3360
  using: _3360@Mir(bb1017[1])
  _4271 = _3359
  using: _3359@Mir(bb1220[1])
  _4270 = move _4271 as isize (IntToInt)
  using: _4271@Mir(bb1220[4])
  _4268 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4269, move _4270) -> bb1221
  using: _4269@Mir(bb1220[3]), _4270@Mir(bb1220[5])
bb1221:
  _4267 = (*_4268)
  using: _4268@Mir(bb1220[6])
  _4266 = move _4267 as i32 (IntToInt)
  using: _4267@Mir(bb1221[0])
  _4275 = _3379
  using: _3379@Mir(bb1023[1])
  _4277 = _3359
  using: _3359@Mir(bb1220[1])
  _4276 = move _4277 as isize (IntToInt)
  using: _4277@Mir(bb1221[3])
  _4274 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4275, move _4276) -> bb1222
  using: _4275@Mir(bb1221[2]), _4276@Mir(bb1221[4])
bb1222:
  _4273 = (*_4274)
  using: _4274@Mir(bb1221[5])
  _4272 = move _4273 as u32 (IntToInt)
  using: _4273@Mir(bb1222[0])
  _4264 = compress::bsW(move _4265, move _4266, move _4272) -> bb1223
  using: _4265@Mir(bb1220[2]), _4266@Mir(bb1221[1]), _4272@Mir(bb1222[1])
bb1223:
  _4280 = _21
  using: _21@Phi(bb995)
  _4283 = _6
  using: _6@Phi(bb1008)
  _4284 = const 40_i32
  using: 
  _4285 = CheckedAdd(_4283, _4284)
  using: _4283@Mir(bb1223[1]), _4284@Mir(bb1223[2])
  assert(!move (_4285.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4283, move _4284) -> bb1224
  using: _4285@Entry, _4283@Entry, _4284@Entry
bb1224:
  _4282 = move (_4285.0: i32)
  using: _4285@Mir(bb1223[3])
  _4281 = move _4282 as isize (IntToInt)
  using: _4282@Mir(bb1224[0])
  _4279 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4280, move _4281) -> bb1225
  using: _4280@Mir(bb1223[0]), _4281@Mir(bb1224[1])
bb1225:
  _4278 = (*_4279)
  using: _4279@Mir(bb1224[2])
  _3359 = move _4278
  using: _4278@Mir(bb1225[0])
  _4287 = _1
  using: _1@Phi(bb1002)
  _4291 = _3360
  using: _3360@Mir(bb1017[1])
  _4293 = _3359
  using: _3359@Mir(bb1225[1])
  _4292 = move _4293 as isize (IntToInt)
  using: _4293@Mir(bb1225[4])
  _4290 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4291, move _4292) -> bb1226
  using: _4291@Mir(bb1225[3]), _4292@Mir(bb1225[5])
bb1226:
  _4289 = (*_4290)
  using: _4290@Mir(bb1225[6])
  _4288 = move _4289 as i32 (IntToInt)
  using: _4289@Mir(bb1226[0])
  _4297 = _3379
  using: _3379@Mir(bb1023[1])
  _4299 = _3359
  using: _3359@Mir(bb1225[1])
  _4298 = move _4299 as isize (IntToInt)
  using: _4299@Mir(bb1226[3])
  _4296 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4297, move _4298) -> bb1227
  using: _4297@Mir(bb1226[2]), _4298@Mir(bb1226[4])
bb1227:
  _4295 = (*_4296)
  using: _4296@Mir(bb1226[5])
  _4294 = move _4295 as u32 (IntToInt)
  using: _4295@Mir(bb1227[0])
  _4286 = compress::bsW(move _4287, move _4288, move _4294) -> bb1228
  using: _4287@Mir(bb1225[2]), _4288@Mir(bb1226[1]), _4294@Mir(bb1227[1])
bb1228:
  _4302 = _21
  using: _21@Phi(bb995)
  _4305 = _6
  using: _6@Phi(bb1008)
  _4306 = const 41_i32
  using: 
  _4307 = CheckedAdd(_4305, _4306)
  using: _4305@Mir(bb1228[1]), _4306@Mir(bb1228[2])
  assert(!move (_4307.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4305, move _4306) -> bb1229
  using: _4307@Entry, _4305@Entry, _4306@Entry
bb1229:
  _4304 = move (_4307.0: i32)
  using: _4307@Mir(bb1228[3])
  _4303 = move _4304 as isize (IntToInt)
  using: _4304@Mir(bb1229[0])
  _4301 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4302, move _4303) -> bb1230
  using: _4302@Mir(bb1228[0]), _4303@Mir(bb1229[1])
bb1230:
  _4300 = (*_4301)
  using: _4301@Mir(bb1229[2])
  _3359 = move _4300
  using: _4300@Mir(bb1230[0])
  _4309 = _1
  using: _1@Phi(bb1002)
  _4313 = _3360
  using: _3360@Mir(bb1017[1])
  _4315 = _3359
  using: _3359@Mir(bb1230[1])
  _4314 = move _4315 as isize (IntToInt)
  using: _4315@Mir(bb1230[4])
  _4312 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4313, move _4314) -> bb1231
  using: _4313@Mir(bb1230[3]), _4314@Mir(bb1230[5])
bb1231:
  _4311 = (*_4312)
  using: _4312@Mir(bb1230[6])
  _4310 = move _4311 as i32 (IntToInt)
  using: _4311@Mir(bb1231[0])
  _4319 = _3379
  using: _3379@Mir(bb1023[1])
  _4321 = _3359
  using: _3359@Mir(bb1230[1])
  _4320 = move _4321 as isize (IntToInt)
  using: _4321@Mir(bb1231[3])
  _4318 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4319, move _4320) -> bb1232
  using: _4319@Mir(bb1231[2]), _4320@Mir(bb1231[4])
bb1232:
  _4317 = (*_4318)
  using: _4318@Mir(bb1231[5])
  _4316 = move _4317 as u32 (IntToInt)
  using: _4317@Mir(bb1232[0])
  _4308 = compress::bsW(move _4309, move _4310, move _4316) -> bb1233
  using: _4309@Mir(bb1230[2]), _4310@Mir(bb1231[1]), _4316@Mir(bb1232[1])
bb1233:
  _4324 = _21
  using: _21@Phi(bb995)
  _4327 = _6
  using: _6@Phi(bb1008)
  _4328 = const 42_i32
  using: 
  _4329 = CheckedAdd(_4327, _4328)
  using: _4327@Mir(bb1233[1]), _4328@Mir(bb1233[2])
  assert(!move (_4329.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4327, move _4328) -> bb1234
  using: _4329@Entry, _4327@Entry, _4328@Entry
bb1234:
  _4326 = move (_4329.0: i32)
  using: _4329@Mir(bb1233[3])
  _4325 = move _4326 as isize (IntToInt)
  using: _4326@Mir(bb1234[0])
  _4323 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4324, move _4325) -> bb1235
  using: _4324@Mir(bb1233[0]), _4325@Mir(bb1234[1])
bb1235:
  _4322 = (*_4323)
  using: _4323@Mir(bb1234[2])
  _3359 = move _4322
  using: _4322@Mir(bb1235[0])
  _4331 = _1
  using: _1@Phi(bb1002)
  _4335 = _3360
  using: _3360@Mir(bb1017[1])
  _4337 = _3359
  using: _3359@Mir(bb1235[1])
  _4336 = move _4337 as isize (IntToInt)
  using: _4337@Mir(bb1235[4])
  _4334 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4335, move _4336) -> bb1236
  using: _4335@Mir(bb1235[3]), _4336@Mir(bb1235[5])
bb1236:
  _4333 = (*_4334)
  using: _4334@Mir(bb1235[6])
  _4332 = move _4333 as i32 (IntToInt)
  using: _4333@Mir(bb1236[0])
  _4341 = _3379
  using: _3379@Mir(bb1023[1])
  _4343 = _3359
  using: _3359@Mir(bb1235[1])
  _4342 = move _4343 as isize (IntToInt)
  using: _4343@Mir(bb1236[3])
  _4340 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4341, move _4342) -> bb1237
  using: _4341@Mir(bb1236[2]), _4342@Mir(bb1236[4])
bb1237:
  _4339 = (*_4340)
  using: _4340@Mir(bb1236[5])
  _4338 = move _4339 as u32 (IntToInt)
  using: _4339@Mir(bb1237[0])
  _4330 = compress::bsW(move _4331, move _4332, move _4338) -> bb1238
  using: _4331@Mir(bb1235[2]), _4332@Mir(bb1236[1]), _4338@Mir(bb1237[1])
bb1238:
  _4346 = _21
  using: _21@Phi(bb995)
  _4349 = _6
  using: _6@Phi(bb1008)
  _4350 = const 43_i32
  using: 
  _4351 = CheckedAdd(_4349, _4350)
  using: _4349@Mir(bb1238[1]), _4350@Mir(bb1238[2])
  assert(!move (_4351.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4349, move _4350) -> bb1239
  using: _4351@Entry, _4349@Entry, _4350@Entry
bb1239:
  _4348 = move (_4351.0: i32)
  using: _4351@Mir(bb1238[3])
  _4347 = move _4348 as isize (IntToInt)
  using: _4348@Mir(bb1239[0])
  _4345 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4346, move _4347) -> bb1240
  using: _4346@Mir(bb1238[0]), _4347@Mir(bb1239[1])
bb1240:
  _4344 = (*_4345)
  using: _4345@Mir(bb1239[2])
  _3359 = move _4344
  using: _4344@Mir(bb1240[0])
  _4353 = _1
  using: _1@Phi(bb1002)
  _4357 = _3360
  using: _3360@Mir(bb1017[1])
  _4359 = _3359
  using: _3359@Mir(bb1240[1])
  _4358 = move _4359 as isize (IntToInt)
  using: _4359@Mir(bb1240[4])
  _4356 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4357, move _4358) -> bb1241
  using: _4357@Mir(bb1240[3]), _4358@Mir(bb1240[5])
bb1241:
  _4355 = (*_4356)
  using: _4356@Mir(bb1240[6])
  _4354 = move _4355 as i32 (IntToInt)
  using: _4355@Mir(bb1241[0])
  _4363 = _3379
  using: _3379@Mir(bb1023[1])
  _4365 = _3359
  using: _3359@Mir(bb1240[1])
  _4364 = move _4365 as isize (IntToInt)
  using: _4365@Mir(bb1241[3])
  _4362 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4363, move _4364) -> bb1242
  using: _4363@Mir(bb1241[2]), _4364@Mir(bb1241[4])
bb1242:
  _4361 = (*_4362)
  using: _4362@Mir(bb1241[5])
  _4360 = move _4361 as u32 (IntToInt)
  using: _4361@Mir(bb1242[0])
  _4352 = compress::bsW(move _4353, move _4354, move _4360) -> bb1243
  using: _4353@Mir(bb1240[2]), _4354@Mir(bb1241[1]), _4360@Mir(bb1242[1])
bb1243:
  _4368 = _21
  using: _21@Phi(bb995)
  _4371 = _6
  using: _6@Phi(bb1008)
  _4372 = const 44_i32
  using: 
  _4373 = CheckedAdd(_4371, _4372)
  using: _4371@Mir(bb1243[1]), _4372@Mir(bb1243[2])
  assert(!move (_4373.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4371, move _4372) -> bb1244
  using: _4373@Entry, _4371@Entry, _4372@Entry
bb1244:
  _4370 = move (_4373.0: i32)
  using: _4373@Mir(bb1243[3])
  _4369 = move _4370 as isize (IntToInt)
  using: _4370@Mir(bb1244[0])
  _4367 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4368, move _4369) -> bb1245
  using: _4368@Mir(bb1243[0]), _4369@Mir(bb1244[1])
bb1245:
  _4366 = (*_4367)
  using: _4367@Mir(bb1244[2])
  _3359 = move _4366
  using: _4366@Mir(bb1245[0])
  _4375 = _1
  using: _1@Phi(bb1002)
  _4379 = _3360
  using: _3360@Mir(bb1017[1])
  _4381 = _3359
  using: _3359@Mir(bb1245[1])
  _4380 = move _4381 as isize (IntToInt)
  using: _4381@Mir(bb1245[4])
  _4378 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4379, move _4380) -> bb1246
  using: _4379@Mir(bb1245[3]), _4380@Mir(bb1245[5])
bb1246:
  _4377 = (*_4378)
  using: _4378@Mir(bb1245[6])
  _4376 = move _4377 as i32 (IntToInt)
  using: _4377@Mir(bb1246[0])
  _4385 = _3379
  using: _3379@Mir(bb1023[1])
  _4387 = _3359
  using: _3359@Mir(bb1245[1])
  _4386 = move _4387 as isize (IntToInt)
  using: _4387@Mir(bb1246[3])
  _4384 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4385, move _4386) -> bb1247
  using: _4385@Mir(bb1246[2]), _4386@Mir(bb1246[4])
bb1247:
  _4383 = (*_4384)
  using: _4384@Mir(bb1246[5])
  _4382 = move _4383 as u32 (IntToInt)
  using: _4383@Mir(bb1247[0])
  _4374 = compress::bsW(move _4375, move _4376, move _4382) -> bb1248
  using: _4375@Mir(bb1245[2]), _4376@Mir(bb1246[1]), _4382@Mir(bb1247[1])
bb1248:
  _4390 = _21
  using: _21@Phi(bb995)
  _4393 = _6
  using: _6@Phi(bb1008)
  _4394 = const 45_i32
  using: 
  _4395 = CheckedAdd(_4393, _4394)
  using: _4393@Mir(bb1248[1]), _4394@Mir(bb1248[2])
  assert(!move (_4395.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4393, move _4394) -> bb1249
  using: _4395@Entry, _4393@Entry, _4394@Entry
bb1249:
  _4392 = move (_4395.0: i32)
  using: _4395@Mir(bb1248[3])
  _4391 = move _4392 as isize (IntToInt)
  using: _4392@Mir(bb1249[0])
  _4389 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4390, move _4391) -> bb1250
  using: _4390@Mir(bb1248[0]), _4391@Mir(bb1249[1])
bb1250:
  _4388 = (*_4389)
  using: _4389@Mir(bb1249[2])
  _3359 = move _4388
  using: _4388@Mir(bb1250[0])
  _4397 = _1
  using: _1@Phi(bb1002)
  _4401 = _3360
  using: _3360@Mir(bb1017[1])
  _4403 = _3359
  using: _3359@Mir(bb1250[1])
  _4402 = move _4403 as isize (IntToInt)
  using: _4403@Mir(bb1250[4])
  _4400 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4401, move _4402) -> bb1251
  using: _4401@Mir(bb1250[3]), _4402@Mir(bb1250[5])
bb1251:
  _4399 = (*_4400)
  using: _4400@Mir(bb1250[6])
  _4398 = move _4399 as i32 (IntToInt)
  using: _4399@Mir(bb1251[0])
  _4407 = _3379
  using: _3379@Mir(bb1023[1])
  _4409 = _3359
  using: _3359@Mir(bb1250[1])
  _4408 = move _4409 as isize (IntToInt)
  using: _4409@Mir(bb1251[3])
  _4406 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4407, move _4408) -> bb1252
  using: _4407@Mir(bb1251[2]), _4408@Mir(bb1251[4])
bb1252:
  _4405 = (*_4406)
  using: _4406@Mir(bb1251[5])
  _4404 = move _4405 as u32 (IntToInt)
  using: _4405@Mir(bb1252[0])
  _4396 = compress::bsW(move _4397, move _4398, move _4404) -> bb1253
  using: _4397@Mir(bb1250[2]), _4398@Mir(bb1251[1]), _4404@Mir(bb1252[1])
bb1253:
  _4412 = _21
  using: _21@Phi(bb995)
  _4415 = _6
  using: _6@Phi(bb1008)
  _4416 = const 46_i32
  using: 
  _4417 = CheckedAdd(_4415, _4416)
  using: _4415@Mir(bb1253[1]), _4416@Mir(bb1253[2])
  assert(!move (_4417.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4415, move _4416) -> bb1254
  using: _4417@Entry, _4415@Entry, _4416@Entry
bb1254:
  _4414 = move (_4417.0: i32)
  using: _4417@Mir(bb1253[3])
  _4413 = move _4414 as isize (IntToInt)
  using: _4414@Mir(bb1254[0])
  _4411 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4412, move _4413) -> bb1255
  using: _4412@Mir(bb1253[0]), _4413@Mir(bb1254[1])
bb1255:
  _4410 = (*_4411)
  using: _4411@Mir(bb1254[2])
  _3359 = move _4410
  using: _4410@Mir(bb1255[0])
  _4419 = _1
  using: _1@Phi(bb1002)
  _4423 = _3360
  using: _3360@Mir(bb1017[1])
  _4425 = _3359
  using: _3359@Mir(bb1255[1])
  _4424 = move _4425 as isize (IntToInt)
  using: _4425@Mir(bb1255[4])
  _4422 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4423, move _4424) -> bb1256
  using: _4423@Mir(bb1255[3]), _4424@Mir(bb1255[5])
bb1256:
  _4421 = (*_4422)
  using: _4422@Mir(bb1255[6])
  _4420 = move _4421 as i32 (IntToInt)
  using: _4421@Mir(bb1256[0])
  _4429 = _3379
  using: _3379@Mir(bb1023[1])
  _4431 = _3359
  using: _3359@Mir(bb1255[1])
  _4430 = move _4431 as isize (IntToInt)
  using: _4431@Mir(bb1256[3])
  _4428 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4429, move _4430) -> bb1257
  using: _4429@Mir(bb1256[2]), _4430@Mir(bb1256[4])
bb1257:
  _4427 = (*_4428)
  using: _4428@Mir(bb1256[5])
  _4426 = move _4427 as u32 (IntToInt)
  using: _4427@Mir(bb1257[0])
  _4418 = compress::bsW(move _4419, move _4420, move _4426) -> bb1258
  using: _4419@Mir(bb1255[2]), _4420@Mir(bb1256[1]), _4426@Mir(bb1257[1])
bb1258:
  _4434 = _21
  using: _21@Phi(bb995)
  _4437 = _6
  using: _6@Phi(bb1008)
  _4438 = const 47_i32
  using: 
  _4439 = CheckedAdd(_4437, _4438)
  using: _4437@Mir(bb1258[1]), _4438@Mir(bb1258[2])
  assert(!move (_4439.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4437, move _4438) -> bb1259
  using: _4439@Entry, _4437@Entry, _4438@Entry
bb1259:
  _4436 = move (_4439.0: i32)
  using: _4439@Mir(bb1258[3])
  _4435 = move _4436 as isize (IntToInt)
  using: _4436@Mir(bb1259[0])
  _4433 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4434, move _4435) -> bb1260
  using: _4434@Mir(bb1258[0]), _4435@Mir(bb1259[1])
bb1260:
  _4432 = (*_4433)
  using: _4433@Mir(bb1259[2])
  _3359 = move _4432
  using: _4432@Mir(bb1260[0])
  _4441 = _1
  using: _1@Phi(bb1002)
  _4445 = _3360
  using: _3360@Mir(bb1017[1])
  _4447 = _3359
  using: _3359@Mir(bb1260[1])
  _4446 = move _4447 as isize (IntToInt)
  using: _4447@Mir(bb1260[4])
  _4444 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4445, move _4446) -> bb1261
  using: _4445@Mir(bb1260[3]), _4446@Mir(bb1260[5])
bb1261:
  _4443 = (*_4444)
  using: _4444@Mir(bb1260[6])
  _4442 = move _4443 as i32 (IntToInt)
  using: _4443@Mir(bb1261[0])
  _4451 = _3379
  using: _3379@Mir(bb1023[1])
  _4453 = _3359
  using: _3359@Mir(bb1260[1])
  _4452 = move _4453 as isize (IntToInt)
  using: _4453@Mir(bb1261[3])
  _4450 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4451, move _4452) -> bb1262
  using: _4451@Mir(bb1261[2]), _4452@Mir(bb1261[4])
bb1262:
  _4449 = (*_4450)
  using: _4450@Mir(bb1261[5])
  _4448 = move _4449 as u32 (IntToInt)
  using: _4449@Mir(bb1262[0])
  _4440 = compress::bsW(move _4441, move _4442, move _4448) -> bb1263
  using: _4441@Mir(bb1260[2]), _4442@Mir(bb1261[1]), _4448@Mir(bb1262[1])
bb1263:
  _4456 = _21
  using: _21@Phi(bb995)
  _4459 = _6
  using: _6@Phi(bb1008)
  _4460 = const 48_i32
  using: 
  _4461 = CheckedAdd(_4459, _4460)
  using: _4459@Mir(bb1263[1]), _4460@Mir(bb1263[2])
  assert(!move (_4461.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4459, move _4460) -> bb1264
  using: _4461@Entry, _4459@Entry, _4460@Entry
bb1264:
  _4458 = move (_4461.0: i32)
  using: _4461@Mir(bb1263[3])
  _4457 = move _4458 as isize (IntToInt)
  using: _4458@Mir(bb1264[0])
  _4455 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4456, move _4457) -> bb1265
  using: _4456@Mir(bb1263[0]), _4457@Mir(bb1264[1])
bb1265:
  _4454 = (*_4455)
  using: _4455@Mir(bb1264[2])
  _3359 = move _4454
  using: _4454@Mir(bb1265[0])
  _4463 = _1
  using: _1@Phi(bb1002)
  _4467 = _3360
  using: _3360@Mir(bb1017[1])
  _4469 = _3359
  using: _3359@Mir(bb1265[1])
  _4468 = move _4469 as isize (IntToInt)
  using: _4469@Mir(bb1265[4])
  _4466 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4467, move _4468) -> bb1266
  using: _4467@Mir(bb1265[3]), _4468@Mir(bb1265[5])
bb1266:
  _4465 = (*_4466)
  using: _4466@Mir(bb1265[6])
  _4464 = move _4465 as i32 (IntToInt)
  using: _4465@Mir(bb1266[0])
  _4473 = _3379
  using: _3379@Mir(bb1023[1])
  _4475 = _3359
  using: _3359@Mir(bb1265[1])
  _4474 = move _4475 as isize (IntToInt)
  using: _4475@Mir(bb1266[3])
  _4472 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4473, move _4474) -> bb1267
  using: _4473@Mir(bb1266[2]), _4474@Mir(bb1266[4])
bb1267:
  _4471 = (*_4472)
  using: _4472@Mir(bb1266[5])
  _4470 = move _4471 as u32 (IntToInt)
  using: _4471@Mir(bb1267[0])
  _4462 = compress::bsW(move _4463, move _4464, move _4470) -> bb1268
  using: _4463@Mir(bb1265[2]), _4464@Mir(bb1266[1]), _4470@Mir(bb1267[1])
bb1268:
  _4478 = _21
  using: _21@Phi(bb995)
  _4481 = _6
  using: _6@Phi(bb1008)
  _4482 = const 49_i32
  using: 
  _4483 = CheckedAdd(_4481, _4482)
  using: _4481@Mir(bb1268[1]), _4482@Mir(bb1268[2])
  assert(!move (_4483.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4481, move _4482) -> bb1269
  using: _4483@Entry, _4481@Entry, _4482@Entry
bb1269:
  _4480 = move (_4483.0: i32)
  using: _4483@Mir(bb1268[3])
  _4479 = move _4480 as isize (IntToInt)
  using: _4480@Mir(bb1269[0])
  _4477 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4478, move _4479) -> bb1270
  using: _4478@Mir(bb1268[0]), _4479@Mir(bb1269[1])
bb1270:
  _4476 = (*_4477)
  using: _4477@Mir(bb1269[2])
  _3359 = move _4476
  using: _4476@Mir(bb1270[0])
  _4485 = _1
  using: _1@Phi(bb1002)
  _4489 = _3360
  using: _3360@Mir(bb1017[1])
  _4491 = _3359
  using: _3359@Mir(bb1270[1])
  _4490 = move _4491 as isize (IntToInt)
  using: _4491@Mir(bb1270[4])
  _4488 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _4489, move _4490) -> bb1271
  using: _4489@Mir(bb1270[3]), _4490@Mir(bb1270[5])
bb1271:
  _4487 = (*_4488)
  using: _4488@Mir(bb1270[6])
  _4486 = move _4487 as i32 (IntToInt)
  using: _4487@Mir(bb1271[0])
  _4495 = _3379
  using: _3379@Mir(bb1023[1])
  _4497 = _3359
  using: _3359@Mir(bb1270[1])
  _4496 = move _4497 as isize (IntToInt)
  using: _4497@Mir(bb1271[3])
  _4494 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _4495, move _4496) -> bb1272
  using: _4495@Mir(bb1271[2]), _4496@Mir(bb1271[4])
bb1272:
  _4493 = (*_4494)
  using: _4494@Mir(bb1271[5])
  _4492 = move _4493 as u32 (IntToInt)
  using: _4493@Mir(bb1272[0])
  _4484 = compress::bsW(move _4485, move _4486, move _4492) -> bb1286
  using: _4485@Mir(bb1270[2]), _4486@Mir(bb1271[1]), _4492@Mir(bb1272[1])
bb1273:
  _4498 = _6
  using: _6@Phi(bb1008)
  _4 = move _4498
  using: _4498@Mir(bb1273[0])
  goto -> bb1274
  using: 
bb1274:
  _4500 = _4
  using: _4@Phi(bb1274)
  _4501 = _7
  using: _7@Phi(bb1008)
  _4499 = Le(move _4500, move _4501)
  using: _4500@Mir(bb1274[0]), _4501@Mir(bb1274[1])
  switchInt(move _4499) -> [0: bb1286, otherwise: bb1275]
  using: _4499@Mir(bb1274[2])
bb1275:
  _4503 = _1
  using: _1@Phi(bb1274)
  _4509 = _16
  using: _16@Phi(bb1274)
  _4508 = move _4509 as usize (IntToInt)
  using: _4509@Mir(bb1275[1])
  _4510 = const 18002_usize
  using: 
  _4511 = Lt(_4508, _4510)
  using: _4508@Mir(bb1275[2]), _4510@Mir(bb1275[3])
  assert(move _4511, "index out of bounds: the length is {} but the index is {}", move _4510, _4508) -> bb1276
  using: _4511@Entry, _4510@Entry, _4508@Entry
bb1276:
  _4507 = ((*_1).33: [u8; 18002])[_4508]
  using: _1@Phi(bb1274), _4508@Mir(bb1275[2])
  _4506 = move _4507 as usize (IntToInt)
  using: _4507@Mir(bb1276[0])
  _4512 = const 6_usize
  using: 
  _4513 = Lt(_4506, _4512)
  using: _4506@Mir(bb1276[1]), _4512@Mir(bb1276[2])
  assert(move _4513, "index out of bounds: the length is {} but the index is {}", move _4512, _4506) -> bb1277
  using: _4513@Entry, _4512@Entry, _4506@Entry
bb1277:
  _4517 = _21
  using: _21@Phi(bb1274)
  _4519 = _4
  using: _4@Phi(bb1274)
  _4518 = move _4519 as isize (IntToInt)
  using: _4519@Mir(bb1277[1])
  _4516 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4517, move _4518) -> bb1278
  using: _4517@Mir(bb1277[0]), _4518@Mir(bb1277[2])
bb1278:
  _4515 = (*_4516)
  using: _4516@Mir(bb1277[3])
  _4514 = move _4515 as usize (IntToInt)
  using: _4515@Mir(bb1278[0])
  _4520 = const 258_usize
  using: 
  _4521 = Lt(_4514, _4520)
  using: _4514@Mir(bb1278[1]), _4520@Mir(bb1278[2])
  assert(move _4521, "index out of bounds: the length is {} but the index is {}", move _4520, _4514) -> bb1279
  using: _4521@Entry, _4520@Entry, _4514@Entry
bb1279:
  _4505 = ((*_1).35: [[u8; 258]; 6])[_4506][_4514]
  using: _1@Phi(bb1274), _4514@Mir(bb1278[1]), _4506@Mir(bb1276[1])
  _4504 = move _4505 as i32 (IntToInt)
  using: _4505@Mir(bb1279[0])
  _4527 = _16
  using: _16@Phi(bb1274)
  _4526 = move _4527 as usize (IntToInt)
  using: _4527@Mir(bb1279[2])
  _4528 = const 18002_usize
  using: 
  _4529 = Lt(_4526, _4528)
  using: _4526@Mir(bb1279[3]), _4528@Mir(bb1279[4])
  assert(move _4529, "index out of bounds: the length is {} but the index is {}", move _4528, _4526) -> bb1280
  using: _4529@Entry, _4528@Entry, _4526@Entry
bb1280:
  _4525 = ((*_1).33: [u8; 18002])[_4526]
  using: _1@Phi(bb1274), _4526@Mir(bb1279[3])
  _4524 = move _4525 as usize (IntToInt)
  using: _4525@Mir(bb1280[0])
  _4530 = const 6_usize
  using: 
  _4531 = Lt(_4524, _4530)
  using: _4524@Mir(bb1280[1]), _4530@Mir(bb1280[2])
  assert(move _4531, "index out of bounds: the length is {} but the index is {}", move _4530, _4524) -> bb1281
  using: _4531@Entry, _4530@Entry, _4524@Entry
bb1281:
  _4535 = _21
  using: _21@Phi(bb1274)
  _4537 = _4
  using: _4@Phi(bb1274)
  _4536 = move _4537 as isize (IntToInt)
  using: _4537@Mir(bb1281[1])
  _4534 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _4535, move _4536) -> bb1282
  using: _4535@Mir(bb1281[0]), _4536@Mir(bb1281[2])
bb1282:
  _4533 = (*_4534)
  using: _4534@Mir(bb1281[3])
  _4532 = move _4533 as usize (IntToInt)
  using: _4533@Mir(bb1282[0])
  _4538 = const 258_usize
  using: 
  _4539 = Lt(_4532, _4538)
  using: _4532@Mir(bb1282[1]), _4538@Mir(bb1282[2])
  assert(move _4539, "index out of bounds: the length is {} but the index is {}", move _4538, _4532) -> bb1283
  using: _4539@Entry, _4538@Entry, _4532@Entry
bb1283:
  _4523 = ((*_1).36: [[i32; 258]; 6])[_4524][_4532]
  using: _1@Phi(bb1274), _4532@Mir(bb1282[1]), _4524@Mir(bb1280[1])
  _4522 = move _4523 as u32 (IntToInt)
  using: _4523@Mir(bb1283[0])
  _4502 = compress::bsW(move _4503, move _4504, move _4522) -> bb1284
  using: _4503@Mir(bb1275[0]), _4504@Mir(bb1279[1]), _4522@Mir(bb1283[1])
bb1284:
  _4540 = CheckedAdd(_4, const 1_i32)
  using: _4@Phi(bb1274)
  assert(!move (_4540.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_i32) -> bb1285
  using: _4540@Entry, _4@Entry
bb1285:
  _4 = move (_4540.0: i32)
  using: _4540@Mir(bb1284[0])
  goto -> bb1274
  using: 
bb1286:
  _4541 = _7
  using: _7@Phi(bb1286)
  _4542 = const 1_i32
  using: 
  _4543 = CheckedAdd(_4541, _4542)
  using: _4541@Mir(bb1286[0]), _4542@Mir(bb1286[1])
  assert(!move (_4543.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4541, move _4542) -> bb1287
  using: _4543@Entry, _4541@Entry, _4542@Entry
bb1287:
  _6 = move (_4543.0: i32)
  using: _4543@Mir(bb1286[2])
  _4544 = CheckedAdd(_16, const 1_i32)
  using: _16@Phi(bb1286)
  assert(!move (_4544.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, const 1_i32) -> bb1288
  using: _4544@Entry, _16@Entry
bb1288:
  _16 = move (_4544.0: i32)
  using: _4544@Mir(bb1287[1])
  goto -> bb995
  using: 
bb1289:
  _4550 = const 3007_i32
  using: 
  _4549 = bzlib::BZ2_bz__AssertH__fail(move _4550) -> bb1290
  using: _4550@Mir(bb1289[0])
bb1290:
  _4552 = ((*_1).28: i32)
  using: _1@Phi(bb995)
  _4553 = const 3_i32
  using: 
  _4551 = Ge(move _4552, move _4553)
  using: _4552@Mir(bb1290[0]), _4553@Mir(bb1290[1])
  switchInt(move _4551) -> [0: bb1293, otherwise: bb1291]
  using: _4551@Mir(bb1290[2])
bb1291:
  _4556 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _4555 = (*_4556)
  using: _4556@Mir(bb1291[0])
  _4560 = const b"codes %d\n\x00"
  using: 
  _4559 = &raw const (*_4560)
  using: _4560@Mir(bb1291[2])
  _4558 = move _4559 as *const u8 (Pointer(ArrayToPointer))
  using: _4559@Mir(bb1291[3])
  _4557 = move _4558 as *const i8 (PtrToPtr)
  using: _4558@Mir(bb1291[4])
  _4562 = ((*_1).19: i32)
  using: _1@Phi(bb995)
  _4563 = _18
  using: _18@Mir(bb994[1])
  _4564 = CheckedSub(_4562, _4563)
  using: _4562@Mir(bb1291[6]), _4563@Mir(bb1291[7])
  assert(!move (_4564.1: bool), "attempt to compute `{} - {}`, which would overflow", move _4562, move _4563) -> bb1292
  using: _4564@Entry, _4562@Entry, _4563@Entry
bb1292:
  _4561 = move (_4564.0: i32)
  using: _4564@Mir(bb1291[8])
  _4554 = compress::fprintf(move _4555, move _4557, move _4561) -> bb1293
  using: _4555@Mir(bb1291[1]), _4557@Mir(bb1291[5]), _4561@Mir(bb1292[0])
bb1293:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u16; 6] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 6] is not supported
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:284:9: 287:40 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:334:13: 339:86 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:424:29: 424:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:427:48: 432:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:436:48: 441:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:445:48: 450:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:452:29: 452:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:455:48: 460:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:464:48: 469:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:473:48: 478:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:480:29: 480:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:483:48: 488:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:492:48: 497:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:501:48: 506:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:508:29: 508:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:511:48: 516:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:520:48: 525:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:529:48: 534:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:536:29: 536:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:539:48: 544:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:548:48: 553:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:557:48: 562:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:564:29: 564:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:567:48: 572:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:576:48: 581:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:585:48: 590:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:592:29: 592:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:595:48: 600:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:604:48: 609:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:613:48: 618:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:620:29: 620:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:623:48: 628:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:632:48: 637:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:641:48: 646:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:648:29: 648:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:651:48: 656:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:660:48: 665:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:669:48: 674:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:676:29: 676:77 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:679:48: 684:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:688:48: 693:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:697:48: 702:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:704:29: 704:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:707:48: 712:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:716:48: 721:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:725:48: 730:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:732:29: 732:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:735:48: 740:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:744:48: 749:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:753:48: 758:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:760:29: 760:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:763:48: 768:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:772:48: 777:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:781:48: 786:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:788:29: 788:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:791:48: 796:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:800:48: 805:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:809:48: 814:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:816:29: 816:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:819:48: 824:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:828:48: 833:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:837:48: 842:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:844:29: 844:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:847:48: 852:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:856:48: 861:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:865:48: 870:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:872:29: 872:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:875:48: 880:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:884:48: 889:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:893:48: 898:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:900:29: 900:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:903:48: 908:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:912:48: 917:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:921:48: 926:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:928:29: 928:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:931:48: 936:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:940:48: 945:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:949:48: 954:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:956:29: 956:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:959:48: 964:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:968:48: 973:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:977:48: 982:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:984:29: 984:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:987:48: 992:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:996:48: 1001:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1005:48: 1010:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1012:29: 1012:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1015:48: 1020:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1024:48: 1029:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1033:48: 1038:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1040:29: 1040:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1043:48: 1048:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1052:48: 1057:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1061:48: 1066:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1068:29: 1068:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1071:48: 1076:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1080:48: 1085:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1089:48: 1094:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1096:29: 1096:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1099:48: 1104:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1108:48: 1113:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1117:48: 1122:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1124:29: 1124:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1127:48: 1132:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1136:48: 1141:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1145:48: 1150:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1152:29: 1152:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1155:48: 1160:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1164:48: 1169:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1173:48: 1178:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1180:29: 1180:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1183:48: 1188:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1192:48: 1197:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1201:48: 1206:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1208:29: 1208:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1211:48: 1216:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1220:48: 1225:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1229:48: 1234:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1236:29: 1236:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1239:48: 1244:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1248:48: 1253:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1257:48: 1262:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1264:29: 1264:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1267:48: 1272:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1276:48: 1281:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1285:48: 1290:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1292:29: 1292:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1295:48: 1300:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1304:48: 1309:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1313:48: 1318:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1320:29: 1320:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1323:48: 1328:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1332:48: 1337:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1341:48: 1346:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1348:29: 1348:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1351:48: 1356:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1360:48: 1365:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1369:48: 1374:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1376:29: 1376:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1379:48: 1384:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1388:48: 1393:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1397:48: 1402:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1404:29: 1404:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1407:48: 1412:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1416:48: 1421:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1425:48: 1430:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1432:29: 1432:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1435:48: 1440:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1444:48: 1449:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1453:48: 1458:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1460:29: 1460:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1463:48: 1468:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1472:48: 1477:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1481:48: 1486:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1488:29: 1488:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1491:48: 1496:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1500:48: 1505:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1509:48: 1514:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1516:29: 1516:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1519:48: 1524:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1528:48: 1533:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1537:48: 1542:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1544:29: 1544:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1547:48: 1552:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1556:48: 1561:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1565:48: 1570:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1572:29: 1572:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1575:48: 1580:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1584:48: 1589:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1593:48: 1598:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1600:29: 1600:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1603:48: 1608:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1612:48: 1617:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1621:48: 1626:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1628:29: 1628:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1631:48: 1636:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1640:48: 1645:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1649:48: 1654:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1656:29: 1656:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1659:48: 1664:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1668:48: 1673:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1677:48: 1682:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1684:29: 1684:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1687:48: 1692:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1696:48: 1701:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1705:48: 1710:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1712:29: 1712:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1715:48: 1720:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1724:48: 1729:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1733:48: 1738:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1740:29: 1740:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1743:48: 1748:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1752:48: 1757:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1761:48: 1766:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1768:29: 1768:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1771:48: 1776:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1780:48: 1785:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1789:48: 1794:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1796:29: 1796:78 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1799:48: 1804:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1808:48: 1813:89 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/compress.rs:1817:48: 1822:89 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1843:51: 1843:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1880:45: 1881:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1883:45: 1884:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1886:45: 1887:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1889:45: 1890:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1892:45: 1893:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1895:45: 1896:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1898:45: 1899:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1901:45: 1902:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1904:45: 1905:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1907:45: 1908:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1910:45: 1911:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1913:45: 1914:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1916:45: 1917:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1919:45: 1920:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1922:45: 1923:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1925:45: 1926:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1928:45: 1929:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1931:45: 1932:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1934:45: 1935:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1937:45: 1938:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1940:45: 1941:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1943:45: 1944:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1946:45: 1947:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1949:45: 1950:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1952:45: 1953:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1955:45: 1956:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1958:45: 1959:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1961:45: 1962:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1964:45: 1965:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1967:45: 1968:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1970:45: 1971:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1973:45: 1974:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1976:45: 1977:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1979:45: 1980:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1982:45: 1983:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1985:45: 1986:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1988:45: 1989:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1991:45: 1992:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1994:45: 1995:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:1997:45: 1998:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2000:45: 2001:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2003:45: 2004:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2006:45: 2007:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2009:45: 2010:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2012:45: 2013:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2015:45: 2016:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2018:45: 2019:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2021:45: 2022:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2024:45: 2025:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2027:45: 2028:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2033:51: 2033:69 (#0) by default
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2041:13: 2044:86 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2047:17: 2049:42 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2052:13: 2052:86 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2061:81: 2062:82 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2062:97: 2066:114 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2067:67: 2068:84 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2068:99: 2072:116 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 6] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2130:74: 2131:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2131:90: 2135:107 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2136:57: 2137:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2137:89: 2141:106 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 16] is not supported
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2183:9: 2185:69 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2202:9: 2204:36 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2231:9: 2233:36 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2251:82: 2253:99 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2251:47: 2255:64 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2255:79: 2259:96 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2262:83: 2264:100 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2262:48: 2266:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2266:80: 2270:97 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2272:28: 2272:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2273:38: 2273:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2274:36: 2274:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2275:28: 2275:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2276:38: 2276:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2277:36: 2277:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2278:28: 2278:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2279:38: 2279:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2280:36: 2280:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2281:28: 2281:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2282:38: 2282:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2283:36: 2283:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2284:28: 2284:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2285:38: 2285:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2286:36: 2286:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2287:28: 2287:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2288:38: 2288:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2289:36: 2289:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2290:28: 2290:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2291:38: 2291:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2292:36: 2292:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2293:28: 2293:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2294:38: 2294:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2295:36: 2295:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2296:28: 2296:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2297:38: 2297:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2298:36: 2298:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2299:28: 2299:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2300:38: 2300:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2301:36: 2301:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2302:28: 2302:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2303:38: 2303:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2304:36: 2304:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2305:28: 2305:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2306:38: 2306:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2307:36: 2307:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2308:28: 2308:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2309:38: 2309:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2310:36: 2310:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2311:28: 2311:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2312:38: 2312:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2313:36: 2313:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2314:28: 2314:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2315:38: 2315:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2316:36: 2316:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2317:28: 2317:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2318:38: 2318:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2319:36: 2319:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2320:28: 2320:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2321:38: 2321:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2322:36: 2322:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2323:28: 2323:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2324:38: 2324:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2325:36: 2325:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2326:28: 2326:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2327:38: 2327:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2328:36: 2328:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2329:28: 2329:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2330:38: 2330:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2331:36: 2331:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2332:28: 2332:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2333:38: 2333:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2334:36: 2334:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2335:28: 2335:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2336:38: 2336:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2337:36: 2337:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2338:28: 2338:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2339:38: 2339:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2340:36: 2340:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2341:28: 2341:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2342:38: 2342:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2343:36: 2343:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2344:28: 2344:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2345:38: 2345:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2346:36: 2346:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2347:28: 2347:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2348:38: 2348:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2349:36: 2349:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2350:28: 2350:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2351:38: 2351:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2352:36: 2352:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2353:28: 2353:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2354:38: 2354:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2355:36: 2355:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2356:28: 2356:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2357:38: 2357:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2358:36: 2358:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2359:28: 2359:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2360:38: 2360:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2361:36: 2361:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2362:28: 2362:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2363:38: 2363:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2364:36: 2364:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2365:28: 2365:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2366:38: 2366:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2367:36: 2367:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2368:28: 2368:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2369:38: 2369:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2370:36: 2370:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2371:28: 2371:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2372:38: 2372:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2373:36: 2373:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2374:28: 2374:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2375:38: 2375:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2376:36: 2376:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2377:28: 2377:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2378:38: 2378:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2379:36: 2379:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2380:28: 2380:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2381:38: 2381:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2382:36: 2382:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2383:28: 2383:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2384:38: 2384:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2385:36: 2385:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2386:28: 2386:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2387:38: 2387:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2388:36: 2388:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2389:28: 2389:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2390:38: 2390:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2391:36: 2391:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2392:28: 2392:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2393:38: 2393:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2394:36: 2394:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2395:28: 2395:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2396:38: 2396:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2397:36: 2397:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2398:28: 2398:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2399:38: 2399:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2400:36: 2400:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2401:28: 2401:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2402:38: 2402:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2403:36: 2403:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2404:28: 2404:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2405:38: 2405:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2406:36: 2406:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2407:28: 2407:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2408:38: 2408:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2409:36: 2409:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2410:28: 2410:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2411:38: 2411:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2412:36: 2412:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2413:28: 2413:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2414:38: 2414:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2415:36: 2415:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2416:28: 2416:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2417:38: 2417:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2418:36: 2418:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2419:28: 2419:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2420:38: 2420:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2421:36: 2421:59 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2428:47: 2428:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2431:48: 2431:66 (#0) by default
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2441:9: 2443:36 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:436 ~ c2rust_lib[1043]::compress::BZ2_compressBlock)
bb0:
  _4 = ((*_1).17: i32)
  using: _1@Entry
  _5 = const 0_i32
  using: 
  _3 = Gt(move _4, move _5)
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1])
  switchInt(move _3) -> [0: bb8, otherwise: bb1]
  using: _3@Mir(bb0[2])
bb1:
  _6 = ((*_1).26: u32)
  using: _1@Entry
  ((*_1).26: u32) = Not(move _6)
  using: _1@Entry, _6@Mir(bb1[0])
  _8 = ((*_1).27: u32)
  using: _1@Entry
  _9 = const 1_i32
  using: 
  _10 = CheckedShl(_8, _9)
  using: _8@Mir(bb1[2]), _9@Mir(bb1[3])
  assert(!move (_10.1: bool), "attempt to shift left by `{}`, which would overflow", move _9) -> bb2
  using: _10@Entry, _8@Entry, _9@Entry
bb2:
  _7 = move (_10.0: u32)
  using: _10@Mir(bb1[4])
  _12 = ((*_1).27: u32)
  using: _1@Entry
  _13 = const 31_i32
  using: 
  _14 = CheckedShr(_12, _13)
  using: _12@Mir(bb2[1]), _13@Mir(bb2[2])
  assert(!move (_14.1: bool), "attempt to shift right by `{}`, which would overflow", move _13) -> bb3
  using: _14@Entry, _12@Entry, _13@Entry
bb3:
  _11 = move (_14.0: u32)
  using: _14@Mir(bb2[3])
  ((*_1).27: u32) = BitOr(move _7, move _11)
  using: _1@Entry, _7@Mir(bb2[0]), _11@Mir(bb3[0])
  _15 = ((*_1).26: u32)
  using: _1@Entry
  ((*_1).27: u32) = BitXor(((*_1).27: u32), move _15)
  using: _1@Entry, _1@Entry, _15@Mir(bb3[2])
  _17 = ((*_1).29: i32)
  using: _1@Entry
  _18 = const 1_i32
  using: 
  _16 = Gt(move _17, move _18)
  using: _17@Mir(bb3[4]), _18@Mir(bb3[5])
  switchInt(move _16) -> [0: bb5, otherwise: bb4]
  using: _16@Mir(bb3[6])
bb4:
  _19 = const 0_i32
  using: 
  ((*_1).19: i32) = move _19
  using: _1@Entry, _19@Mir(bb4[0])
  goto -> bb5
  using: 
bb5:
  _21 = ((*_1).28: i32)
  using: _1@Phi(bb5)
  _22 = const 2_i32
  using: 
  _20 = Ge(move _21, move _22)
  using: _21@Mir(bb5[0]), _22@Mir(bb5[1])
  switchInt(move _20) -> [0: bb7, otherwise: bb6]
  using: _20@Mir(bb5[2])
bb6:
  _25 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _24 = (*_25)
  using: _25@Mir(bb6[0])
  _29 = const b"    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d\n\x00"
  using: 
  _28 = &raw const (*_29)
  using: _29@Mir(bb6[2])
  _27 = move _28 as *const u8 (Pointer(ArrayToPointer))
  using: _28@Mir(bb6[3])
  _26 = move _27 as *const i8 (PtrToPtr)
  using: _27@Mir(bb6[4])
  _30 = ((*_1).29: i32)
  using: _1@Phi(bb5)
  _31 = ((*_1).26: u32)
  using: _1@Phi(bb5)
  _32 = ((*_1).27: u32)
  using: _1@Phi(bb5)
  _33 = ((*_1).17: i32)
  using: _1@Phi(bb5)
  _23 = compress::fprintf(move _24, move _26, move _30, move _31, move _32, move _33) -> bb7
  using: _24@Mir(bb6[1]), _26@Mir(bb6[5]), _30@Mir(bb6[6]), _31@Mir(bb6[7]), _32@Mir(bb6[8]), _33@Mir(bb6[9])
bb7:
  _35 = _1
  using: _1@Phi(bb7)
  _34 = blocksort::BZ2_blockSort(move _35) -> bb8
  using: _35@Mir(bb7[0])
bb8:
  _40 = ((*_1).5: *mut u32)
  using: _1@Phi(bb8)
  _39 = move _40 as *mut u8 (PtrToPtr)
  using: _40@Mir(bb8[0])
  _42 = ((*_1).17: i32)
  using: _1@Phi(bb8)
  _41 = move _42 as isize (IntToInt)
  using: _42@Mir(bb8[2])
  _38 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _39, move _41) -> bb9
  using: _39@Mir(bb8[1]), _41@Mir(bb8[3])
bb9:
  _37 = &mut (*_38)
  using: _38@Mir(bb8[4])
  _36 = &raw mut (*_37)
  using: _37@Mir(bb9[0])
  ((*_1).11: *mut u8) = move _36
  using: _1@Phi(bb8), _36@Mir(bb9[1])
  _44 = ((*_1).29: i32)
  using: _1@Phi(bb8)
  _45 = const 1_i32
  using: 
  _43 = Eq(move _44, move _45)
  using: _44@Mir(bb9[3]), _45@Mir(bb9[4])
  switchInt(move _43) -> [0: bb16, otherwise: bb10]
  using: _43@Mir(bb9[5])
bb10:
  _47 = _1
  using: _1@Phi(bb8)
  _46 = compress::BZ2_bsInitWrite(move _47) -> bb11
  using: _47@Mir(bb10[0])
bb11:
  _49 = _1
  using: _1@Phi(bb8)
  _50 = const 66_u8
  using: 
  _48 = compress::bsPutUChar(move _49, move _50) -> bb12
  using: _49@Mir(bb11[0]), _50@Mir(bb11[1])
bb12:
  _52 = _1
  using: _1@Phi(bb8)
  _53 = const 90_u8
  using: 
  _51 = compress::bsPutUChar(move _52, move _53) -> bb13
  using: _52@Mir(bb12[0]), _53@Mir(bb12[1])
bb13:
  _55 = _1
  using: _1@Phi(bb8)
  _56 = const 104_u8
  using: 
  _54 = compress::bsPutUChar(move _55, move _56) -> bb14
  using: _55@Mir(bb13[0]), _56@Mir(bb13[1])
bb14:
  _58 = _1
  using: _1@Phi(bb8)
  _61 = const 48_i32
  using: 
  _62 = ((*_1).30: i32)
  using: _1@Phi(bb8)
  _63 = CheckedAdd(_61, _62)
  using: _61@Mir(bb14[1]), _62@Mir(bb14[2])
  assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", move _61, move _62) -> bb15
  using: _63@Entry, _61@Entry, _62@Entry
bb15:
  _60 = move (_63.0: i32)
  using: _63@Mir(bb14[3])
  _59 = move _60 as u8 (IntToInt)
  using: _60@Mir(bb15[0])
  _57 = compress::bsPutUChar(move _58, move _59) -> bb16
  using: _58@Mir(bb14[0]), _59@Mir(bb15[1])
bb16:
  _65 = ((*_1).17: i32)
  using: _1@Phi(bb16)
  _66 = const 0_i32
  using: 
  _64 = Gt(move _65, move _66)
  using: _65@Mir(bb16[0]), _66@Mir(bb16[1])
  switchInt(move _64) -> [0: bb28, otherwise: bb17]
  using: _64@Mir(bb16[2])
bb17:
  _68 = _1
  using: _1@Phi(bb16)
  _69 = const 49_u8
  using: 
  _67 = compress::bsPutUChar(move _68, move _69) -> bb18
  using: _68@Mir(bb17[0]), _69@Mir(bb17[1])
bb18:
  _71 = _1
  using: _1@Phi(bb16)
  _72 = const 65_u8
  using: 
  _70 = compress::bsPutUChar(move _71, move _72) -> bb19
  using: _71@Mir(bb18[0]), _72@Mir(bb18[1])
bb19:
  _74 = _1
  using: _1@Phi(bb16)
  _75 = const 89_u8
  using: 
  _73 = compress::bsPutUChar(move _74, move _75) -> bb20
  using: _74@Mir(bb19[0]), _75@Mir(bb19[1])
bb20:
  _77 = _1
  using: _1@Phi(bb16)
  _78 = const 38_u8
  using: 
  _76 = compress::bsPutUChar(move _77, move _78) -> bb21
  using: _77@Mir(bb20[0]), _78@Mir(bb20[1])
bb21:
  _80 = _1
  using: _1@Phi(bb16)
  _81 = const 83_u8
  using: 
  _79 = compress::bsPutUChar(move _80, move _81) -> bb22
  using: _80@Mir(bb21[0]), _81@Mir(bb21[1])
bb22:
  _83 = _1
  using: _1@Phi(bb16)
  _84 = const 89_u8
  using: 
  _82 = compress::bsPutUChar(move _83, move _84) -> bb23
  using: _83@Mir(bb22[0]), _84@Mir(bb22[1])
bb23:
  _86 = _1
  using: _1@Phi(bb16)
  _87 = ((*_1).26: u32)
  using: _1@Phi(bb16)
  _85 = compress::bsPutUInt32(move _86, move _87) -> bb24
  using: _86@Mir(bb23[0]), _87@Mir(bb23[1])
bb24:
  _89 = _1
  using: _1@Phi(bb16)
  _90 = const 1_i32
  using: 
  _91 = const 0_u32
  using: 
  _88 = compress::bsW(move _89, move _90, move _91) -> bb25
  using: _89@Mir(bb24[0]), _90@Mir(bb24[1]), _91@Mir(bb24[2])
bb25:
  _93 = _1
  using: _1@Phi(bb16)
  _94 = const 24_i32
  using: 
  _96 = ((*_1).7: i32)
  using: _1@Phi(bb16)
  _95 = move _96 as u32 (IntToInt)
  using: _96@Mir(bb25[2])
  _92 = compress::bsW(move _93, move _94, move _95) -> bb26
  using: _93@Mir(bb25[0]), _94@Mir(bb25[1]), _95@Mir(bb25[3])
bb26:
  _98 = _1
  using: _1@Phi(bb16)
  _97 = compress::generateMTFValues(move _98) -> bb27
  using: _98@Mir(bb26[0])
bb27:
  _100 = _1
  using: _1@Phi(bb16)
  _99 = compress::sendMTFValues(move _100) -> bb28
  using: _100@Mir(bb27[0])
bb28:
  _101 = _2
  using: _2@Entry
  switchInt(move _101) -> [0: bb39, otherwise: bb29]
  using: _101@Mir(bb28[0])
bb29:
  _103 = _1
  using: _1@Phi(bb28)
  _104 = const 23_u8
  using: 
  _102 = compress::bsPutUChar(move _103, move _104) -> bb30
  using: _103@Mir(bb29[0]), _104@Mir(bb29[1])
bb30:
  _106 = _1
  using: _1@Phi(bb28)
  _107 = const 114_u8
  using: 
  _105 = compress::bsPutUChar(move _106, move _107) -> bb31
  using: _106@Mir(bb30[0]), _107@Mir(bb30[1])
bb31:
  _109 = _1
  using: _1@Phi(bb28)
  _110 = const 69_u8
  using: 
  _108 = compress::bsPutUChar(move _109, move _110) -> bb32
  using: _109@Mir(bb31[0]), _110@Mir(bb31[1])
bb32:
  _112 = _1
  using: _1@Phi(bb28)
  _113 = const 56_u8
  using: 
  _111 = compress::bsPutUChar(move _112, move _113) -> bb33
  using: _112@Mir(bb32[0]), _113@Mir(bb32[1])
bb33:
  _115 = _1
  using: _1@Phi(bb28)
  _116 = const 80_u8
  using: 
  _114 = compress::bsPutUChar(move _115, move _116) -> bb34
  using: _115@Mir(bb33[0]), _116@Mir(bb33[1])
bb34:
  _118 = _1
  using: _1@Phi(bb28)
  _119 = const 144_u8
  using: 
  _117 = compress::bsPutUChar(move _118, move _119) -> bb35
  using: _118@Mir(bb34[0]), _119@Mir(bb34[1])
bb35:
  _121 = _1
  using: _1@Phi(bb28)
  _122 = ((*_1).27: u32)
  using: _1@Phi(bb28)
  _120 = compress::bsPutUInt32(move _121, move _122) -> bb36
  using: _121@Mir(bb35[0]), _122@Mir(bb35[1])
bb36:
  _124 = ((*_1).28: i32)
  using: _1@Phi(bb28)
  _125 = const 2_i32
  using: 
  _123 = Ge(move _124, move _125)
  using: _124@Mir(bb36[0]), _125@Mir(bb36[1])
  switchInt(move _123) -> [0: bb38, otherwise: bb37]
  using: _123@Mir(bb36[2])
bb37:
  _128 = const {alloc882: *mut *mut blocksort::__sFILE}
  using: 
  _127 = (*_128)
  using: _128@Mir(bb37[0])
  _132 = const b"    final combined CRC = 0x%08x\n   \x00"
  using: 
  _131 = &raw const (*_132)
  using: _132@Mir(bb37[2])
  _130 = move _131 as *const u8 (Pointer(ArrayToPointer))
  using: _131@Mir(bb37[3])
  _129 = move _130 as *const i8 (PtrToPtr)
  using: _130@Mir(bb37[4])
  _133 = ((*_1).27: u32)
  using: _1@Phi(bb28)
  _126 = compress::fprintf(move _127, move _129, move _133) -> bb38
  using: _127@Mir(bb37[1]), _129@Mir(bb37[5]), _133@Mir(bb37[6])
bb38:
  _135 = _1
  using: _1@Phi(bb38)
  _134 = compress::bsFinishWrite(move _135) -> bb39
  using: _135@Mir(bb38[0])
bb39:
  return
  using: _0@Entry
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2458:13: 2461:66 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/compress.rs:2466:41: 2466:69 (#0) by default
rewrite call compress::fprintf @ workspace/bzip2/rust/compress.rs:2509:13: 2511:74 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:457 ~ c2rust_lib[1043]::decompress::makeMaps_d)
bb0:
  _2 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  ((*_1).27: i32) = move _3
  using: _1@Entry, _3@Mir(bb0[1])
  _2 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _2
  using: _2@Phi(bb1)
  _6 = const 256_i32
  using: 
  _4 = Lt(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb9, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _9 = _2
  using: _2@Phi(bb1)
  _8 = move _9 as usize (IntToInt)
  using: _9@Mir(bb2[0])
  _10 = const 256_usize
  using: 
  _11 = Lt(_8, _10)
  using: _8@Mir(bb2[1]), _10@Mir(bb2[2])
  assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _8) -> bb3
  using: _11@Entry, _10@Entry, _8@Entry
bb3:
  _7 = ((*_1).28: [u8; 256])[_8]
  using: _1@Phi(bb1), _8@Mir(bb2[1])
  switchInt(move _7) -> [0: bb7, otherwise: bb4]
  using: _7@Mir(bb3[0])
bb4:
  _12 = _2
  using: _2@Phi(bb1)
  _14 = ((*_1).27: i32)
  using: _1@Phi(bb1)
  _13 = move _14 as usize (IntToInt)
  using: _14@Mir(bb4[1])
  _15 = const 256_usize
  using: 
  _16 = Lt(_13, _15)
  using: _13@Mir(bb4[2]), _15@Mir(bb4[3])
  assert(move _16, "index out of bounds: the length is {} but the index is {}", move _15, _13) -> bb5
  using: _16@Entry, _15@Entry, _13@Entry
bb5:
  ((*_1).30: [u8; 256])[_13] = move _12 as u8 (IntToInt)
  using: _1@Phi(bb1), _13@Mir(bb4[2]), _12@Mir(bb4[0])
  _17 = CheckedAdd(((*_1).27: i32), const 1_i32)
  using: _1@Phi(bb1)
  assert(!move (_17.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).27: i32), const 1_i32) -> bb6
  using: _17@Entry, _1@Entry
bb6:
  ((*_1).27: i32) = move (_17.0: i32)
  using: _1@Phi(bb1), _17@Mir(bb5[1])
  goto -> bb7
  using: 
bb7:
  _18 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb7)
  assert(!move (_18.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb8
  using: _18@Entry, _2@Entry
bb8:
  _2 = move (_18.0: i32)
  using: _18@Mir(bb7[0])
  goto -> bb1
  using: 
bb9:
  return
  using: _0@Entry
@DefId(0:458 ~ c2rust_lib[1043]::decompress::BZ2_decompress)
bb0:
  _3 = const 0_u8
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Entry
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  _14 = const 0_i32
  using: 
  _15 = const 0_i32
  using: 
  _16 = const 0_i32
  using: 
  _17 = const 0_i32
  using: 
  _18 = const 0_i32
  using: 
  _19 = const 0_i32
  using: 
  _20 = const 0_i32
  using: 
  _21 = const 0_i32
  using: 
  _22 = const 0_i32
  using: 
  _23 = const 0_i32
  using: 
  _24 = const 0_i32
  using: 
  _25 = const 0_i32
  using: 
  _26 = const 0_i32
  using: 
  _27 = const 0_i32
  using: 
  _28 = const 0_i32
  using: 
  _29 = const {0x0 as *mut i32}
  using: 
  _30 = const {0x0 as *mut i32}
  using: 
  _31 = const {0x0 as *mut i32}
  using: 
  _33 = ((*_1).1: i32)
  using: _1@Entry
  _34 = const 10_i32
  using: 
  _32 = Eq(move _33, move _34)
  using: _33@Mir(bb0[29]), _34@Mir(bb0[30])
  switchInt(move _32) -> [0: bb2, otherwise: bb1]
  using: _32@Mir(bb0[31])
bb1:
  _35 = const 0_i32
  using: 
  ((*_1).40: i32) = move _35
  using: _1@Entry, _35@Mir(bb1[0])
  _36 = const 0_i32
  using: 
  ((*_1).41: i32) = move _36
  using: _1@Entry, _36@Mir(bb1[2])
  _37 = const 0_i32
  using: 
  ((*_1).42: i32) = move _37
  using: _1@Entry, _37@Mir(bb1[4])
  _38 = const 0_i32
  using: 
  ((*_1).43: i32) = move _38
  using: _1@Entry, _38@Mir(bb1[6])
  _39 = const 0_i32
  using: 
  ((*_1).44: i32) = move _39
  using: _1@Entry, _39@Mir(bb1[8])
  _40 = const 0_i32
  using: 
  ((*_1).45: i32) = move _40
  using: _1@Entry, _40@Mir(bb1[10])
  _41 = const 0_i32
  using: 
  ((*_1).46: i32) = move _41
  using: _1@Entry, _41@Mir(bb1[12])
  _42 = const 0_i32
  using: 
  ((*_1).47: i32) = move _42
  using: _1@Entry, _42@Mir(bb1[14])
  _43 = const 0_i32
  using: 
  ((*_1).48: i32) = move _43
  using: _1@Entry, _43@Mir(bb1[16])
  _44 = const 0_i32
  using: 
  ((*_1).49: i32) = move _44
  using: _1@Entry, _44@Mir(bb1[18])
  _45 = const 0_i32
  using: 
  ((*_1).50: i32) = move _45
  using: _1@Entry, _45@Mir(bb1[20])
  _46 = const 0_i32
  using: 
  ((*_1).51: i32) = move _46
  using: _1@Entry, _46@Mir(bb1[22])
  _47 = const 0_i32
  using: 
  ((*_1).52: i32) = move _47
  using: _1@Entry, _47@Mir(bb1[24])
  _48 = const 0_i32
  using: 
  ((*_1).53: i32) = move _48
  using: _1@Entry, _48@Mir(bb1[26])
  _49 = const 0_i32
  using: 
  ((*_1).54: i32) = move _49
  using: _1@Entry, _49@Mir(bb1[28])
  _50 = const 0_i32
  using: 
  ((*_1).55: i32) = move _50
  using: _1@Entry, _50@Mir(bb1[30])
  _51 = const 0_i32
  using: 
  ((*_1).56: i32) = move _51
  using: _1@Entry, _51@Mir(bb1[32])
  _52 = const 0_i32
  using: 
  ((*_1).57: i32) = move _52
  using: _1@Entry, _52@Mir(bb1[34])
  _53 = const 0_i32
  using: 
  ((*_1).58: i32) = move _53
  using: _1@Entry, _53@Mir(bb1[36])
  _54 = const 0_i32
  using: 
  ((*_1).59: i32) = move _54
  using: _1@Entry, _54@Mir(bb1[38])
  _55 = const 0_i32
  using: 
  ((*_1).60: i32) = move _55
  using: _1@Entry, _55@Mir(bb1[40])
  ((*_1).61: *mut i32) = const 0_usize as *mut i32 (PointerFromExposedAddress)
  using: _1@Entry
  ((*_1).62: *mut i32) = const 0_usize as *mut i32 (PointerFromExposedAddress)
  using: _1@Entry
  ((*_1).63: *mut i32) = const 0_usize as *mut i32 (PointerFromExposedAddress)
  using: _1@Entry
  goto -> bb2
  using: 
bb2:
  _56 = ((*_1).40: i32)
  using: _1@Phi(bb2)
  _8 = move _56
  using: _56@Mir(bb2[0])
  _57 = ((*_1).41: i32)
  using: _1@Phi(bb2)
  _9 = move _57
  using: _57@Mir(bb2[2])
  _58 = ((*_1).42: i32)
  using: _1@Phi(bb2)
  _10 = move _58
  using: _58@Mir(bb2[4])
  _59 = ((*_1).43: i32)
  using: _1@Phi(bb2)
  _11 = move _59
  using: _59@Mir(bb2[6])
  _60 = ((*_1).44: i32)
  using: _1@Phi(bb2)
  _12 = move _60
  using: _60@Mir(bb2[8])
  _61 = ((*_1).45: i32)
  using: _1@Phi(bb2)
  _13 = move _61
  using: _61@Mir(bb2[10])
  _62 = ((*_1).46: i32)
  using: _1@Phi(bb2)
  _14 = move _62
  using: _62@Mir(bb2[12])
  _63 = ((*_1).47: i32)
  using: _1@Phi(bb2)
  _15 = move _63
  using: _63@Mir(bb2[14])
  _64 = ((*_1).48: i32)
  using: _1@Phi(bb2)
  _16 = move _64
  using: _64@Mir(bb2[16])
  _65 = ((*_1).49: i32)
  using: _1@Phi(bb2)
  _17 = move _65
  using: _65@Mir(bb2[18])
  _66 = ((*_1).50: i32)
  using: _1@Phi(bb2)
  _18 = move _66
  using: _66@Mir(bb2[20])
  _67 = ((*_1).51: i32)
  using: _1@Phi(bb2)
  _19 = move _67
  using: _67@Mir(bb2[22])
  _68 = ((*_1).52: i32)
  using: _1@Phi(bb2)
  _20 = move _68
  using: _68@Mir(bb2[24])
  _69 = ((*_1).53: i32)
  using: _1@Phi(bb2)
  _21 = move _69
  using: _69@Mir(bb2[26])
  _70 = ((*_1).54: i32)
  using: _1@Phi(bb2)
  _22 = move _70
  using: _70@Mir(bb2[28])
  _71 = ((*_1).55: i32)
  using: _1@Phi(bb2)
  _23 = move _71
  using: _71@Mir(bb2[30])
  _72 = ((*_1).56: i32)
  using: _1@Phi(bb2)
  _24 = move _72
  using: _72@Mir(bb2[32])
  _73 = ((*_1).57: i32)
  using: _1@Phi(bb2)
  _25 = move _73
  using: _73@Mir(bb2[34])
  _74 = ((*_1).58: i32)
  using: _1@Phi(bb2)
  _26 = move _74
  using: _74@Mir(bb2[36])
  _75 = ((*_1).59: i32)
  using: _1@Phi(bb2)
  _27 = move _75
  using: _75@Mir(bb2[38])
  _76 = ((*_1).60: i32)
  using: _1@Phi(bb2)
  _28 = move _76
  using: _76@Mir(bb2[40])
  _77 = ((*_1).61: *mut i32)
  using: _1@Phi(bb2)
  _29 = move _77
  using: _77@Mir(bb2[42])
  _78 = ((*_1).62: *mut i32)
  using: _1@Phi(bb2)
  _30 = move _78
  using: _78@Mir(bb2[44])
  _79 = ((*_1).63: *mut i32)
  using: _1@Phi(bb2)
  _31 = move _79
  using: _79@Mir(bb2[46])
  _4 = const 0_i32
  using: 
  switchInt(((*_1).1: i32)) -> [10: bb4, 11: bb24, 12: bb25, 13: bb26, 14: bb27, 15: bb28, 16: bb29, 17: bb30, 18: bb31, 19: bb32, 20: bb33, 21: bb34, 22: bb35, 23: bb36, 24: bb37, 25: bb38, 26: bb39, 27: bb40, 28: bb41, 29: bb42, 30: bb43, 31: bb44, 32: bb45, 33: bb46, 34: bb47, 35: bb48, 36: bb49, 37: bb50, 38: bb51, 39: bb52, 40: bb53, 41: bb54, 42: bb55, 43: bb56, 44: bb57, 45: bb58, 46: bb59, 47: bb60, 48: bb61, 49: bb62, 50: bb63, otherwise: bb3]
  using: _1@Phi(bb2)
bb3:
  _125 = const 4001_i32
  using: 
  _124 = bzlib::BZ2_bz__AssertH__fail(move _125) -> bb64
  using: _125@Mir(bb3[0])
bb4:
  _80 = const 10_i32
  using: 
  ((*_1).1: i32) = move _80
  using: _1@Phi(bb2), _80@Mir(bb4[0])
  goto -> bb5
  using: 
bb5:
  _82 = ((*_1).8: i32)
  using: _1@Phi(bb5)
  _83 = const 8_i32
  using: 
  _81 = Ge(move _82, move _83)
  using: _82@Mir(bb5[0]), _83@Mir(bb5[1])
  switchInt(move _81) -> [0: bb7, otherwise: bb6]
  using: _81@Mir(bb5[2])
bb6:
  _84 = const 0_u32
  using: 
  _86 = ((*_1).7: u32)
  using: _1@Phi(bb5)
  _88 = ((*_1).8: i32)
  using: _1@Phi(bb5)
  _89 = const 8_i32
  using: 
  _90 = CheckedSub(_88, _89)
  using: _88@Mir(bb6[2]), _89@Mir(bb6[3])
  assert(!move (_90.1: bool), "attempt to compute `{} - {}`, which would overflow", move _88, move _89) -> bb8
  using: _90@Entry, _88@Entry, _89@Entry
bb7:
  _3559 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  _97 = ((*_3559).1: u32)
  using: _3559@Mir(bb7[0])
  _98 = const 0_u32
  using: 
  _96 = Eq(move _97, move _98)
  using: _97@Mir(bb7[1]), _98@Mir(bb7[2])
  switchInt(move _96) -> [0: bb12, otherwise: bb11]
  using: _96@Mir(bb7[3])
bb8:
  _87 = move (_90.0: i32)
  using: _90@Mir(bb6[4])
  _91 = CheckedShr(_86, _87)
  using: _86@Mir(bb6[1]), _87@Mir(bb8[0])
  assert(!move (_91.1: bool), "attempt to shift right by `{}`, which would overflow", move _87) -> bb9
  using: _91@Entry, _86@Entry, _87@Entry
bb9:
  _85 = move (_91.0: u32)
  using: _91@Mir(bb8[1])
  _92 = const 255_u32
  using: 
  _84 = BitAnd(move _85, move _92)
  using: _85@Mir(bb9[0]), _92@Mir(bb9[1])
  _93 = const 8_i32
  using: 
  _94 = CheckedSub(((*_1).8: i32), _93)
  using: _1@Phi(bb5), _93@Mir(bb9[3])
  assert(!move (_94.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _93) -> bb10
  using: _94@Entry, _1@Entry, _93@Entry
bb10:
  ((*_1).8: i32) = move (_94.0: i32)
  using: _1@Phi(bb5), _94@Mir(bb9[4])
  _95 = _84
  using: _84@Mir(bb9[2])
  _3 = move _95 as u8 (IntToInt)
  using: _95@Mir(bb10[1])
  _2 = const 5658374378798827547_u64
  using: 
  goto -> bb20
  using: 
bb11:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb20
  using: 
bb12:
  _100 = ((*_1).7: u32)
  using: _1@Phi(bb5)
  _101 = const 8_i32
  using: 
  _102 = CheckedShl(_100, _101)
  using: _100@Mir(bb12[0]), _101@Mir(bb12[1])
  assert(!move (_102.1: bool), "attempt to shift left by `{}`, which would overflow", move _101) -> bb13
  using: _102@Entry, _100@Entry, _101@Entry
bb13:
  _99 = move (_102.0: u32)
  using: _102@Mir(bb12[2])
  _3560 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  _106 = ((*_3560).0: *mut i8)
  using: _3560@Mir(bb13[1])
  _105 = move _106 as *mut u8 (PtrToPtr)
  using: _106@Mir(bb13[2])
  _104 = (*_105)
  using: _105@Mir(bb13[3])
  _103 = move _104 as u32 (IntToInt)
  using: _104@Mir(bb13[4])
  ((*_1).7: u32) = BitOr(move _99, move _103)
  using: _1@Phi(bb5), _99@Mir(bb13[0]), _103@Mir(bb13[5])
  _107 = const 8_i32
  using: 
  _108 = CheckedAdd(((*_1).8: i32), _107)
  using: _1@Phi(bb5), _107@Mir(bb13[7])
  assert(!move (_108.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _107) -> bb14
  using: _108@Entry, _1@Entry, _107@Entry
bb14:
  ((*_1).8: i32) = move (_108.0: i32)
  using: _1@Phi(bb5), _108@Mir(bb13[8])
  _3561 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  _110 = ((*_3561).0: *mut i8)
  using: _3561@Mir(bb14[1])
  _109 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _110, const 1_isize) -> bb15
  using: _110@Mir(bb14[2])
bb15:
  _3562 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  ((*_3562).0: *mut i8) = move _109
  using: _3562@Mir(bb15[0]), _109@Mir(bb14[3])
  _3563 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  _112 = ((*_3563).1: u32)
  using: _3563@Mir(bb15[2])
  _111 = core::num::<impl u32>::wrapping_sub(move _112, const 1_u32) -> bb16
  using: _112@Mir(bb15[3])
bb16:
  _3564 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  ((*_3564).1: u32) = move _111
  using: _3564@Mir(bb16[0]), _111@Mir(bb15[4])
  _3565 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  _114 = ((*_3565).2: u32)
  using: _3565@Mir(bb16[2])
  _113 = core::num::<impl u32>::wrapping_add(move _114, const 1_u32) -> bb17
  using: _114@Mir(bb16[3])
bb17:
  _3566 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  ((*_3566).2: u32) = move _113
  using: _3566@Mir(bb17[0]), _113@Mir(bb16[4])
  _3567 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  _116 = ((*_3567).2: u32)
  using: _3567@Mir(bb17[2])
  _117 = const 0_u32
  using: 
  _115 = Eq(move _116, move _117)
  using: _116@Mir(bb17[3]), _117@Mir(bb17[4])
  switchInt(move _115) -> [0: bb5, otherwise: bb18]
  using: _115@Mir(bb17[5])
bb18:
  _3568 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  _119 = ((*_3568).3: u32)
  using: _3568@Mir(bb18[0])
  _118 = core::num::<impl u32>::wrapping_add(move _119, const 1_u32) -> bb19
  using: _119@Mir(bb18[1])
bb19:
  _3569 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb5)
  ((*_3569).3: u32) = move _118
  using: _3569@Mir(bb19[0]), _118@Mir(bb18[2])
  goto -> bb5
  using: 
bb20:
  switchInt(_2) -> [15885526978618306830: bb66, otherwise: bb21]
  using: _2@Phi(bb20)
bb21:
  _122 = _3
  using: _3@Phi(bb20)
  _121 = move _122 as i32 (IntToInt)
  using: _122@Mir(bb21[0])
  _123 = const 66_i32
  using: 
  _120 = Ne(move _121, move _123)
  using: _121@Mir(bb21[1]), _123@Mir(bb21[2])
  switchInt(move _120) -> [0: bb23, otherwise: bb22]
  using: _120@Mir(bb21[3])
bb22:
  _4 = const -5_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb66
  using: 
bb23:
  _2 = const 12259750428863723923_u64
  using: 
  goto -> bb66
  using: 
bb24:
  _2 = const 12259750428863723923_u64
  using: 
  goto -> bb66
  using: 
bb25:
  _2 = const 15146946972525368609_u64
  using: 
  goto -> bb66
  using: 
bb26:
  _2 = const 13504760517129887221_u64
  using: 
  goto -> bb66
  using: 
bb27:
  _2 = const 7948568793456312728_u64
  using: 
  goto -> bb66
  using: 
bb28:
  _2 = const 16703841960874917807_u64
  using: 
  goto -> bb66
  using: 
bb29:
  _2 = const 12231332282017165356_u64
  using: 
  goto -> bb66
  using: 
bb30:
  _2 = const 7286555771988341860_u64
  using: 
  goto -> bb66
  using: 
bb31:
  _2 = const 6656868271313165664_u64
  using: 
  goto -> bb66
  using: 
bb32:
  _2 = const 15902903523132075486_u64
  using: 
  goto -> bb66
  using: 
bb33:
  _2 = const 16204949703499709801_u64
  using: 
  goto -> bb66
  using: 
bb34:
  _2 = const 5505795673017046993_u64
  using: 
  goto -> bb66
  using: 
bb35:
  _2 = const 14563596112884461881_u64
  using: 
  goto -> bb66
  using: 
bb36:
  _2 = const 12051594319698232578_u64
  using: 
  goto -> bb66
  using: 
bb37:
  _2 = const 14315698657705028467_u64
  using: 
  goto -> bb66
  using: 
bb38:
  _2 = const 640681092829779800_u64
  using: 
  goto -> bb66
  using: 
bb39:
  _2 = const 588075840077989673_u64
  using: 
  goto -> bb66
  using: 
bb40:
  _2 = const 34749046854646975_u64
  using: 
  goto -> bb66
  using: 
bb41:
  _2 = const 16487873541482693172_u64
  using: 
  goto -> bb66
  using: 
bb42:
  _2 = const 1422779171932145779_u64
  using: 
  goto -> bb66
  using: 
bb43:
  _2 = const 3906616468301123675_u64
  using: 
  goto -> bb66
  using: 
bb44:
  _2 = const 5769007513321684282_u64
  using: 
  goto -> bb66
  using: 
bb45:
  _2 = const 4874723077730206021_u64
  using: 
  goto -> bb66
  using: 
bb46:
  _2 = const 10945178116989557996_u64
  using: 
  goto -> bb66
  using: 
bb47:
  _2 = const 1736021991379636935_u64
  using: 
  goto -> bb66
  using: 
bb48:
  _2 = const 5008197131544113214_u64
  using: 
  goto -> bb66
  using: 
bb49:
  _2 = const 16722720626876144162_u64
  using: 
  goto -> bb66
  using: 
bb50:
  _2 = const 14744029255125744966_u64
  using: 
  goto -> bb66
  using: 
bb51:
  _2 = const 5374617794059532979_u64
  using: 
  goto -> bb66
  using: 
bb52:
  _2 = const 13999925517074022731_u64
  using: 
  goto -> bb66
  using: 
bb53:
  _2 = const 2629672494974161066_u64
  using: 
  goto -> bb66
  using: 
bb54:
  _2 = const 1050378859040334210_u64
  using: 
  goto -> bb66
  using: 
bb55:
  _2 = const 10200488719709598753_u64
  using: 
  goto -> bb66
  using: 
bb56:
  _2 = const 9864403379770423142_u64
  using: 
  goto -> bb66
  using: 
bb57:
  _2 = const 8489059574810375089_u64
  using: 
  goto -> bb66
  using: 
bb58:
  _2 = const 12998570369541158573_u64
  using: 
  goto -> bb66
  using: 
bb59:
  _2 = const 10541196509243133637_u64
  using: 
  goto -> bb66
  using: 
bb60:
  _2 = const 8760950161942609538_u64
  using: 
  goto -> bb66
  using: 
bb61:
  _2 = const 3131443096645543054_u64
  using: 
  goto -> bb66
  using: 
bb62:
  _2 = const 1975408140333322065_u64
  using: 
  goto -> bb66
  using: 
bb63:
  _2 = const 15818179691129344165_u64
  using: 
  goto -> bb66
  using: 
bb64:
  _127 = const 4002_i32
  using: 
  _126 = bzlib::BZ2_bz__AssertH__fail(move _127) -> bb65
  using: _127@Mir(bb64[0])
bb65:
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb66
  using: 
bb66:
  switchInt(_2) -> [12259750428863723923: bb67, otherwise: bb87]
  using: _2@Phi(bb66)
bb67:
  _128 = const 11_i32
  using: 
  ((*_1).1: i32) = move _128
  using: _1@Phi(bb66), _128@Mir(bb67[0])
  goto -> bb68
  using: 
bb68:
  _130 = ((*_1).8: i32)
  using: _1@Phi(bb68)
  _131 = const 8_i32
  using: 
  _129 = Ge(move _130, move _131)
  using: _130@Mir(bb68[0]), _131@Mir(bb68[1])
  switchInt(move _129) -> [0: bb70, otherwise: bb69]
  using: _129@Mir(bb68[2])
bb69:
  _132 = const 0_u32
  using: 
  _134 = ((*_1).7: u32)
  using: _1@Phi(bb68)
  _136 = ((*_1).8: i32)
  using: _1@Phi(bb68)
  _137 = const 8_i32
  using: 
  _138 = CheckedSub(_136, _137)
  using: _136@Mir(bb69[2]), _137@Mir(bb69[3])
  assert(!move (_138.1: bool), "attempt to compute `{} - {}`, which would overflow", move _136, move _137) -> bb71
  using: _138@Entry, _136@Entry, _137@Entry
bb70:
  _3570 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  _145 = ((*_3570).1: u32)
  using: _3570@Mir(bb70[0])
  _146 = const 0_u32
  using: 
  _144 = Eq(move _145, move _146)
  using: _145@Mir(bb70[1]), _146@Mir(bb70[2])
  switchInt(move _144) -> [0: bb75, otherwise: bb74]
  using: _144@Mir(bb70[3])
bb71:
  _135 = move (_138.0: i32)
  using: _138@Mir(bb69[4])
  _139 = CheckedShr(_134, _135)
  using: _134@Mir(bb69[1]), _135@Mir(bb71[0])
  assert(!move (_139.1: bool), "attempt to shift right by `{}`, which would overflow", move _135) -> bb72
  using: _139@Entry, _134@Entry, _135@Entry
bb72:
  _133 = move (_139.0: u32)
  using: _139@Mir(bb71[1])
  _140 = const 255_u32
  using: 
  _132 = BitAnd(move _133, move _140)
  using: _133@Mir(bb72[0]), _140@Mir(bb72[1])
  _141 = const 8_i32
  using: 
  _142 = CheckedSub(((*_1).8: i32), _141)
  using: _1@Phi(bb68), _141@Mir(bb72[3])
  assert(!move (_142.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _141) -> bb73
  using: _142@Entry, _1@Entry, _141@Entry
bb73:
  ((*_1).8: i32) = move (_142.0: i32)
  using: _1@Phi(bb68), _142@Mir(bb72[4])
  _143 = _132
  using: _132@Mir(bb72[2])
  _3 = move _143 as u8 (IntToInt)
  using: _143@Mir(bb73[1])
  _2 = const 1658462350791934405_u64
  using: 
  goto -> bb83
  using: 
bb74:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb83
  using: 
bb75:
  _148 = ((*_1).7: u32)
  using: _1@Phi(bb68)
  _149 = const 8_i32
  using: 
  _150 = CheckedShl(_148, _149)
  using: _148@Mir(bb75[0]), _149@Mir(bb75[1])
  assert(!move (_150.1: bool), "attempt to shift left by `{}`, which would overflow", move _149) -> bb76
  using: _150@Entry, _148@Entry, _149@Entry
bb76:
  _147 = move (_150.0: u32)
  using: _150@Mir(bb75[2])
  _3571 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  _154 = ((*_3571).0: *mut i8)
  using: _3571@Mir(bb76[1])
  _153 = move _154 as *mut u8 (PtrToPtr)
  using: _154@Mir(bb76[2])
  _152 = (*_153)
  using: _153@Mir(bb76[3])
  _151 = move _152 as u32 (IntToInt)
  using: _152@Mir(bb76[4])
  ((*_1).7: u32) = BitOr(move _147, move _151)
  using: _1@Phi(bb68), _147@Mir(bb76[0]), _151@Mir(bb76[5])
  _155 = const 8_i32
  using: 
  _156 = CheckedAdd(((*_1).8: i32), _155)
  using: _1@Phi(bb68), _155@Mir(bb76[7])
  assert(!move (_156.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _155) -> bb77
  using: _156@Entry, _1@Entry, _155@Entry
bb77:
  ((*_1).8: i32) = move (_156.0: i32)
  using: _1@Phi(bb68), _156@Mir(bb76[8])
  _3572 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  _158 = ((*_3572).0: *mut i8)
  using: _3572@Mir(bb77[1])
  _157 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _158, const 1_isize) -> bb78
  using: _158@Mir(bb77[2])
bb78:
  _3573 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  ((*_3573).0: *mut i8) = move _157
  using: _3573@Mir(bb78[0]), _157@Mir(bb77[3])
  _3574 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  _160 = ((*_3574).1: u32)
  using: _3574@Mir(bb78[2])
  _159 = core::num::<impl u32>::wrapping_sub(move _160, const 1_u32) -> bb79
  using: _160@Mir(bb78[3])
bb79:
  _3575 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  ((*_3575).1: u32) = move _159
  using: _3575@Mir(bb79[0]), _159@Mir(bb78[4])
  _3576 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  _162 = ((*_3576).2: u32)
  using: _3576@Mir(bb79[2])
  _161 = core::num::<impl u32>::wrapping_add(move _162, const 1_u32) -> bb80
  using: _162@Mir(bb79[3])
bb80:
  _3577 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  ((*_3577).2: u32) = move _161
  using: _3577@Mir(bb80[0]), _161@Mir(bb79[4])
  _3578 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  _164 = ((*_3578).2: u32)
  using: _3578@Mir(bb80[2])
  _165 = const 0_u32
  using: 
  _163 = Eq(move _164, move _165)
  using: _164@Mir(bb80[3]), _165@Mir(bb80[4])
  switchInt(move _163) -> [0: bb68, otherwise: bb81]
  using: _163@Mir(bb80[5])
bb81:
  _3579 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  _167 = ((*_3579).3: u32)
  using: _3579@Mir(bb81[0])
  _166 = core::num::<impl u32>::wrapping_add(move _167, const 1_u32) -> bb82
  using: _167@Mir(bb81[1])
bb82:
  _3580 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb68)
  ((*_3580).3: u32) = move _166
  using: _3580@Mir(bb82[0]), _166@Mir(bb81[2])
  goto -> bb68
  using: 
bb83:
  switchInt(_2) -> [15885526978618306830: bb87, otherwise: bb84]
  using: _2@Phi(bb83)
bb84:
  _170 = _3
  using: _3@Phi(bb83)
  _169 = move _170 as i32 (IntToInt)
  using: _170@Mir(bb84[0])
  _171 = const 90_i32
  using: 
  _168 = Ne(move _169, move _171)
  using: _169@Mir(bb84[1]), _171@Mir(bb84[2])
  switchInt(move _168) -> [0: bb86, otherwise: bb85]
  using: _168@Mir(bb84[3])
bb85:
  _4 = const -5_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb87
  using: 
bb86:
  _2 = const 15146946972525368609_u64
  using: 
  goto -> bb87
  using: 
bb87:
  switchInt(_2) -> [15146946972525368609: bb88, otherwise: bb108]
  using: _2@Phi(bb87)
bb88:
  _172 = const 12_i32
  using: 
  ((*_1).1: i32) = move _172
  using: _1@Phi(bb87), _172@Mir(bb88[0])
  goto -> bb89
  using: 
bb89:
  _174 = ((*_1).8: i32)
  using: _1@Phi(bb89)
  _175 = const 8_i32
  using: 
  _173 = Ge(move _174, move _175)
  using: _174@Mir(bb89[0]), _175@Mir(bb89[1])
  switchInt(move _173) -> [0: bb91, otherwise: bb90]
  using: _173@Mir(bb89[2])
bb90:
  _176 = const 0_u32
  using: 
  _178 = ((*_1).7: u32)
  using: _1@Phi(bb89)
  _180 = ((*_1).8: i32)
  using: _1@Phi(bb89)
  _181 = const 8_i32
  using: 
  _182 = CheckedSub(_180, _181)
  using: _180@Mir(bb90[2]), _181@Mir(bb90[3])
  assert(!move (_182.1: bool), "attempt to compute `{} - {}`, which would overflow", move _180, move _181) -> bb92
  using: _182@Entry, _180@Entry, _181@Entry
bb91:
  _3581 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  _189 = ((*_3581).1: u32)
  using: _3581@Mir(bb91[0])
  _190 = const 0_u32
  using: 
  _188 = Eq(move _189, move _190)
  using: _189@Mir(bb91[1]), _190@Mir(bb91[2])
  switchInt(move _188) -> [0: bb96, otherwise: bb95]
  using: _188@Mir(bb91[3])
bb92:
  _179 = move (_182.0: i32)
  using: _182@Mir(bb90[4])
  _183 = CheckedShr(_178, _179)
  using: _178@Mir(bb90[1]), _179@Mir(bb92[0])
  assert(!move (_183.1: bool), "attempt to shift right by `{}`, which would overflow", move _179) -> bb93
  using: _183@Entry, _178@Entry, _179@Entry
bb93:
  _177 = move (_183.0: u32)
  using: _183@Mir(bb92[1])
  _184 = const 255_u32
  using: 
  _176 = BitAnd(move _177, move _184)
  using: _177@Mir(bb93[0]), _184@Mir(bb93[1])
  _185 = const 8_i32
  using: 
  _186 = CheckedSub(((*_1).8: i32), _185)
  using: _1@Phi(bb89), _185@Mir(bb93[3])
  assert(!move (_186.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _185) -> bb94
  using: _186@Entry, _1@Entry, _185@Entry
bb94:
  ((*_1).8: i32) = move (_186.0: i32)
  using: _1@Phi(bb89), _186@Mir(bb93[4])
  _187 = _176
  using: _176@Mir(bb93[2])
  _3 = move _187 as u8 (IntToInt)
  using: _187@Mir(bb94[1])
  _2 = const 16314074004867283505_u64
  using: 
  goto -> bb104
  using: 
bb95:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb104
  using: 
bb96:
  _192 = ((*_1).7: u32)
  using: _1@Phi(bb89)
  _193 = const 8_i32
  using: 
  _194 = CheckedShl(_192, _193)
  using: _192@Mir(bb96[0]), _193@Mir(bb96[1])
  assert(!move (_194.1: bool), "attempt to shift left by `{}`, which would overflow", move _193) -> bb97
  using: _194@Entry, _192@Entry, _193@Entry
bb97:
  _191 = move (_194.0: u32)
  using: _194@Mir(bb96[2])
  _3582 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  _198 = ((*_3582).0: *mut i8)
  using: _3582@Mir(bb97[1])
  _197 = move _198 as *mut u8 (PtrToPtr)
  using: _198@Mir(bb97[2])
  _196 = (*_197)
  using: _197@Mir(bb97[3])
  _195 = move _196 as u32 (IntToInt)
  using: _196@Mir(bb97[4])
  ((*_1).7: u32) = BitOr(move _191, move _195)
  using: _1@Phi(bb89), _191@Mir(bb97[0]), _195@Mir(bb97[5])
  _199 = const 8_i32
  using: 
  _200 = CheckedAdd(((*_1).8: i32), _199)
  using: _1@Phi(bb89), _199@Mir(bb97[7])
  assert(!move (_200.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _199) -> bb98
  using: _200@Entry, _1@Entry, _199@Entry
bb98:
  ((*_1).8: i32) = move (_200.0: i32)
  using: _1@Phi(bb89), _200@Mir(bb97[8])
  _3583 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  _202 = ((*_3583).0: *mut i8)
  using: _3583@Mir(bb98[1])
  _201 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _202, const 1_isize) -> bb99
  using: _202@Mir(bb98[2])
bb99:
  _3584 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  ((*_3584).0: *mut i8) = move _201
  using: _3584@Mir(bb99[0]), _201@Mir(bb98[3])
  _3585 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  _204 = ((*_3585).1: u32)
  using: _3585@Mir(bb99[2])
  _203 = core::num::<impl u32>::wrapping_sub(move _204, const 1_u32) -> bb100
  using: _204@Mir(bb99[3])
bb100:
  _3586 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  ((*_3586).1: u32) = move _203
  using: _3586@Mir(bb100[0]), _203@Mir(bb99[4])
  _3587 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  _206 = ((*_3587).2: u32)
  using: _3587@Mir(bb100[2])
  _205 = core::num::<impl u32>::wrapping_add(move _206, const 1_u32) -> bb101
  using: _206@Mir(bb100[3])
bb101:
  _3588 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  ((*_3588).2: u32) = move _205
  using: _3588@Mir(bb101[0]), _205@Mir(bb100[4])
  _3589 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  _208 = ((*_3589).2: u32)
  using: _3589@Mir(bb101[2])
  _209 = const 0_u32
  using: 
  _207 = Eq(move _208, move _209)
  using: _208@Mir(bb101[3]), _209@Mir(bb101[4])
  switchInt(move _207) -> [0: bb89, otherwise: bb102]
  using: _207@Mir(bb101[5])
bb102:
  _3590 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  _211 = ((*_3590).3: u32)
  using: _3590@Mir(bb102[0])
  _210 = core::num::<impl u32>::wrapping_add(move _211, const 1_u32) -> bb103
  using: _211@Mir(bb102[1])
bb103:
  _3591 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb89)
  ((*_3591).3: u32) = move _210
  using: _3591@Mir(bb103[0]), _210@Mir(bb102[2])
  goto -> bb89
  using: 
bb104:
  switchInt(_2) -> [15885526978618306830: bb108, otherwise: bb105]
  using: _2@Phi(bb104)
bb105:
  _214 = _3
  using: _3@Phi(bb104)
  _213 = move _214 as i32 (IntToInt)
  using: _214@Mir(bb105[0])
  _215 = const 104_i32
  using: 
  _212 = Ne(move _213, move _215)
  using: _213@Mir(bb105[1]), _215@Mir(bb105[2])
  switchInt(move _212) -> [0: bb107, otherwise: bb106]
  using: _212@Mir(bb105[3])
bb106:
  _4 = const -5_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb108
  using: 
bb107:
  _2 = const 13504760517129887221_u64
  using: 
  goto -> bb108
  using: 
bb108:
  switchInt(_2) -> [13504760517129887221: bb109, otherwise: bb162]
  using: _2@Phi(bb108)
bb109:
  _216 = const 13_i32
  using: 
  ((*_1).1: i32) = move _216
  using: _1@Phi(bb108), _216@Mir(bb109[0])
  goto -> bb110
  using: 
bb110:
  _218 = ((*_1).8: i32)
  using: _1@Phi(bb110)
  _219 = const 8_i32
  using: 
  _217 = Ge(move _218, move _219)
  using: _218@Mir(bb110[0]), _219@Mir(bb110[1])
  switchInt(move _217) -> [0: bb112, otherwise: bb111]
  using: _217@Mir(bb110[2])
bb111:
  _220 = const 0_u32
  using: 
  _222 = ((*_1).7: u32)
  using: _1@Phi(bb110)
  _224 = ((*_1).8: i32)
  using: _1@Phi(bb110)
  _225 = const 8_i32
  using: 
  _226 = CheckedSub(_224, _225)
  using: _224@Mir(bb111[2]), _225@Mir(bb111[3])
  assert(!move (_226.1: bool), "attempt to compute `{} - {}`, which would overflow", move _224, move _225) -> bb113
  using: _226@Entry, _224@Entry, _225@Entry
bb112:
  _3592 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  _233 = ((*_3592).1: u32)
  using: _3592@Mir(bb112[0])
  _234 = const 0_u32
  using: 
  _232 = Eq(move _233, move _234)
  using: _233@Mir(bb112[1]), _234@Mir(bb112[2])
  switchInt(move _232) -> [0: bb117, otherwise: bb116]
  using: _232@Mir(bb112[3])
bb113:
  _223 = move (_226.0: i32)
  using: _226@Mir(bb111[4])
  _227 = CheckedShr(_222, _223)
  using: _222@Mir(bb111[1]), _223@Mir(bb113[0])
  assert(!move (_227.1: bool), "attempt to shift right by `{}`, which would overflow", move _223) -> bb114
  using: _227@Entry, _222@Entry, _223@Entry
bb114:
  _221 = move (_227.0: u32)
  using: _227@Mir(bb113[1])
  _228 = const 255_u32
  using: 
  _220 = BitAnd(move _221, move _228)
  using: _221@Mir(bb114[0]), _228@Mir(bb114[1])
  _229 = const 8_i32
  using: 
  _230 = CheckedSub(((*_1).8: i32), _229)
  using: _1@Phi(bb110), _229@Mir(bb114[3])
  assert(!move (_230.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _229) -> bb115
  using: _230@Entry, _1@Entry, _229@Entry
bb115:
  ((*_1).8: i32) = move (_230.0: i32)
  using: _1@Phi(bb110), _230@Mir(bb114[4])
  _231 = _220
  using: _220@Mir(bb114[2])
  ((*_1).9: i32) = move _231 as i32 (IntToInt)
  using: _1@Phi(bb110), _231@Mir(bb115[1])
  _2 = const 1915186496383530739_u64
  using: 
  goto -> bb125
  using: 
bb116:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb125
  using: 
bb117:
  _236 = ((*_1).7: u32)
  using: _1@Phi(bb110)
  _237 = const 8_i32
  using: 
  _238 = CheckedShl(_236, _237)
  using: _236@Mir(bb117[0]), _237@Mir(bb117[1])
  assert(!move (_238.1: bool), "attempt to shift left by `{}`, which would overflow", move _237) -> bb118
  using: _238@Entry, _236@Entry, _237@Entry
bb118:
  _235 = move (_238.0: u32)
  using: _238@Mir(bb117[2])
  _3593 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  _242 = ((*_3593).0: *mut i8)
  using: _3593@Mir(bb118[1])
  _241 = move _242 as *mut u8 (PtrToPtr)
  using: _242@Mir(bb118[2])
  _240 = (*_241)
  using: _241@Mir(bb118[3])
  _239 = move _240 as u32 (IntToInt)
  using: _240@Mir(bb118[4])
  ((*_1).7: u32) = BitOr(move _235, move _239)
  using: _1@Phi(bb110), _235@Mir(bb118[0]), _239@Mir(bb118[5])
  _243 = const 8_i32
  using: 
  _244 = CheckedAdd(((*_1).8: i32), _243)
  using: _1@Phi(bb110), _243@Mir(bb118[7])
  assert(!move (_244.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _243) -> bb119
  using: _244@Entry, _1@Entry, _243@Entry
bb119:
  ((*_1).8: i32) = move (_244.0: i32)
  using: _1@Phi(bb110), _244@Mir(bb118[8])
  _3594 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  _246 = ((*_3594).0: *mut i8)
  using: _3594@Mir(bb119[1])
  _245 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _246, const 1_isize) -> bb120
  using: _246@Mir(bb119[2])
bb120:
  _3595 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  ((*_3595).0: *mut i8) = move _245
  using: _3595@Mir(bb120[0]), _245@Mir(bb119[3])
  _3596 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  _248 = ((*_3596).1: u32)
  using: _3596@Mir(bb120[2])
  _247 = core::num::<impl u32>::wrapping_sub(move _248, const 1_u32) -> bb121
  using: _248@Mir(bb120[3])
bb121:
  _3597 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  ((*_3597).1: u32) = move _247
  using: _3597@Mir(bb121[0]), _247@Mir(bb120[4])
  _3598 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  _250 = ((*_3598).2: u32)
  using: _3598@Mir(bb121[2])
  _249 = core::num::<impl u32>::wrapping_add(move _250, const 1_u32) -> bb122
  using: _250@Mir(bb121[3])
bb122:
  _3599 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  ((*_3599).2: u32) = move _249
  using: _3599@Mir(bb122[0]), _249@Mir(bb121[4])
  _3600 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  _252 = ((*_3600).2: u32)
  using: _3600@Mir(bb122[2])
  _253 = const 0_u32
  using: 
  _251 = Eq(move _252, move _253)
  using: _252@Mir(bb122[3]), _253@Mir(bb122[4])
  switchInt(move _251) -> [0: bb110, otherwise: bb123]
  using: _251@Mir(bb122[5])
bb123:
  _3601 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  _255 = ((*_3601).3: u32)
  using: _3601@Mir(bb123[0])
  _254 = core::num::<impl u32>::wrapping_add(move _255, const 1_u32) -> bb124
  using: _255@Mir(bb123[1])
bb124:
  _3602 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb110)
  ((*_3602).3: u32) = move _254
  using: _3602@Mir(bb124[0]), _254@Mir(bb123[2])
  goto -> bb110
  using: 
bb125:
  switchInt(_2) -> [15885526978618306830: bb162, otherwise: bb126]
  using: _2@Phi(bb125)
bb126:
  _258 = ((*_1).9: i32)
  using: _1@Phi(bb125)
  _259 = const 49_i32
  using: 
  _257 = Lt(move _258, move _259)
  using: _258@Mir(bb126[0]), _259@Mir(bb126[1])
  switchInt(move _257) -> [0: bb128, otherwise: bb127]
  using: _257@Mir(bb126[2])
bb127:
  _256 = const true
  using: 
  goto -> bb129
  using: 
bb128:
  _261 = ((*_1).9: i32)
  using: _1@Phi(bb125)
  _262 = const 57_i32
  using: 
  _260 = Gt(move _261, move _262)
  using: _261@Mir(bb128[0]), _262@Mir(bb128[1])
  _256 = move _260
  using: _260@Mir(bb128[2])
  goto -> bb129
  using: 
bb129:
  switchInt(move _256) -> [0: bb131, otherwise: bb130]
  using: _256@Phi(bb129)
bb130:
  _4 = const -5_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb162
  using: 
bb131:
  _263 = const 48_i32
  using: 
  _264 = CheckedSub(((*_1).9: i32), _263)
  using: _1@Phi(bb129), _263@Mir(bb131[0])
  assert(!move (_264.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).9: i32), move _263) -> bb132
  using: _264@Entry, _1@Entry, _263@Entry
bb132:
  ((*_1).9: i32) = move (_264.0: i32)
  using: _1@Phi(bb129), _264@Mir(bb131[1])
  _265 = ((*_1).10: u8)
  using: _1@Phi(bb129)
  switchInt(move _265) -> [0: bb153, otherwise: bb133]
  using: _265@Mir(bb132[1])
bb133:
  _268 = ((*_7).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _7@Mir(bb0[4])
  _270 = const "non-null function pointer"
  using: 
  _269 = _270
  using: _270@Mir(bb133[1])
  _267 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _268, move _269) -> bb134
  using: _268@Mir(bb133[0]), _269@Mir(bb133[2])
bb134:
  _271 = ((*_7).11: *mut std::ffi::c_void)
  using: _7@Mir(bb0[4])
  _276 = ((*_1).9: i32)
  using: _1@Phi(bb129)
  _277 = const 100000_i32
  using: 
  _278 = CheckedMul(_276, _277)
  using: _276@Mir(bb134[1]), _277@Mir(bb134[2])
  assert(!move (_278.1: bool), "attempt to compute `{} * {}`, which would overflow", move _276, move _277) -> bb135
  using: _278@Entry, _276@Entry, _277@Entry
bb135:
  _275 = move (_278.0: i32)
  using: _278@Mir(bb134[3])
  _274 = move _275 as u64 (IntToInt)
  using: _275@Mir(bb135[0])
  _280 = std::mem::size_of::<u16>() -> bb136
  using: 
bb136:
  _279 = move _280 as u64 (IntToInt)
  using: _280@Mir(bb135[2])
  _273 = core::num::<impl u64>::wrapping_mul(move _274, move _279) -> bb137
  using: _274@Mir(bb135[1]), _279@Mir(bb136[0])
bb137:
  _272 = move _273 as i32 (IntToInt)
  using: _273@Mir(bb136[1])
  _281 = const 1_i32
  using: 
  _266 = move _267(move _271, move _272, move _281) -> bb138
  using: _267@Entry, _271@Mir(bb134[0]), _272@Mir(bb137[0]), _281@Mir(bb137[1])
bb138:
  ((*_1).21: *mut u16) = move _266 as *mut u16 (PtrToPtr)
  using: _1@Phi(bb129), _266@Mir(bb137[2])
  _284 = ((*_7).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _7@Mir(bb0[4])
  _286 = const "non-null function pointer"
  using: 
  _285 = _286
  using: _286@Mir(bb138[2])
  _283 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _284, move _285) -> bb139
  using: _284@Mir(bb138[1]), _285@Mir(bb138[3])
bb139:
  _287 = ((*_7).11: *mut std::ffi::c_void)
  using: _7@Mir(bb0[4])
  _293 = const 1_i32
  using: 
  _295 = ((*_1).9: i32)
  using: _1@Phi(bb129)
  _296 = const 100000_i32
  using: 
  _297 = CheckedMul(_295, _296)
  using: _295@Mir(bb139[2]), _296@Mir(bb139[3])
  assert(!move (_297.1: bool), "attempt to compute `{} * {}`, which would overflow", move _295, move _296) -> bb140
  using: _297@Entry, _295@Entry, _296@Entry
bb140:
  _294 = move (_297.0: i32)
  using: _297@Mir(bb139[4])
  _298 = CheckedAdd(_293, _294)
  using: _293@Mir(bb139[1]), _294@Mir(bb140[0])
  assert(!move (_298.1: bool), "attempt to compute `{} + {}`, which would overflow", move _293, move _294) -> bb141
  using: _298@Entry, _293@Entry, _294@Entry
bb141:
  _292 = move (_298.0: i32)
  using: _298@Mir(bb140[1])
  _299 = const 1_i32
  using: 
  _300 = CheckedShr(_292, _299)
  using: _292@Mir(bb141[0]), _299@Mir(bb141[1])
  assert(!move (_300.1: bool), "attempt to shift right by `{}`, which would overflow", move _299) -> bb142
  using: _300@Entry, _292@Entry, _299@Entry
bb142:
  _291 = move (_300.0: i32)
  using: _300@Mir(bb141[2])
  _290 = move _291 as u64 (IntToInt)
  using: _291@Mir(bb142[0])
  _302 = std::mem::size_of::<u8>() -> bb143
  using: 
bb143:
  _301 = move _302 as u64 (IntToInt)
  using: _302@Mir(bb142[2])
  _289 = core::num::<impl u64>::wrapping_mul(move _290, move _301) -> bb144
  using: _290@Mir(bb142[1]), _301@Mir(bb143[0])
bb144:
  _288 = move _289 as i32 (IntToInt)
  using: _289@Mir(bb143[1])
  _303 = const 1_i32
  using: 
  _282 = move _283(move _287, move _288, move _303) -> bb145
  using: _283@Entry, _287@Mir(bb139[0]), _288@Mir(bb144[0]), _303@Mir(bb144[1])
bb145:
  ((*_1).22: *mut u8) = move _282 as *mut u8 (PtrToPtr)
  using: _1@Phi(bb129), _282@Mir(bb144[2])
  _306 = ((*_1).21: *mut u16)
  using: _1@Phi(bb129)
  _305 = std::ptr::mut_ptr::<impl *mut u16>::is_null(move _306) -> bb149
  using: _306@Mir(bb145[1])
bb146:
  _304 = const true
  using: 
  goto -> bb148
  using: 
bb147:
  _308 = ((*_1).22: *mut u8)
  using: _1@Phi(bb129)
  _307 = std::ptr::mut_ptr::<impl *mut u8>::is_null(move _308) -> bb150
  using: _308@Mir(bb147[0])
bb148:
  switchInt(move _304) -> [0: bb152, otherwise: bb151]
  using: _304@Phi(bb148)
bb149:
  switchInt(move _305) -> [0: bb147, otherwise: bb146]
  using: _305@Mir(bb145[2])
bb150:
  _304 = move _307
  using: _307@Mir(bb147[1])
  goto -> bb148
  using: 
bb151:
  _4 = const -3_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb162
  using: 
bb152:
  _2 = const 7948568793456312728_u64
  using: 
  goto -> bb162
  using: 
bb153:
  _311 = ((*_7).9: std::option::Option<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>)
  using: _7@Mir(bb0[4])
  _313 = const "non-null function pointer"
  using: 
  _312 = _313
  using: _313@Mir(bb153[1])
  _310 = std::option::Option::<unsafe extern "C" fn(*mut std::ffi::c_void, i32, i32) -> *mut std::ffi::c_void>::expect(move _311, move _312) -> bb154
  using: _311@Mir(bb153[0]), _312@Mir(bb153[2])
bb154:
  _314 = ((*_7).11: *mut std::ffi::c_void)
  using: _7@Mir(bb0[4])
  _319 = ((*_1).9: i32)
  using: _1@Phi(bb148)
  _320 = const 100000_i32
  using: 
  _321 = CheckedMul(_319, _320)
  using: _319@Mir(bb154[1]), _320@Mir(bb154[2])
  assert(!move (_321.1: bool), "attempt to compute `{} * {}`, which would overflow", move _319, move _320) -> bb155
  using: _321@Entry, _319@Entry, _320@Entry
bb155:
  _318 = move (_321.0: i32)
  using: _321@Mir(bb154[3])
  _317 = move _318 as u64 (IntToInt)
  using: _318@Mir(bb155[0])
  _323 = std::mem::size_of::<i32>() -> bb156
  using: 
bb156:
  _322 = move _323 as u64 (IntToInt)
  using: _323@Mir(bb155[2])
  _316 = core::num::<impl u64>::wrapping_mul(move _317, move _322) -> bb157
  using: _317@Mir(bb155[1]), _322@Mir(bb156[0])
bb157:
  _315 = move _316 as i32 (IntToInt)
  using: _316@Mir(bb156[1])
  _324 = const 1_i32
  using: 
  _309 = move _310(move _314, move _315, move _324) -> bb158
  using: _310@Entry, _314@Mir(bb154[0]), _315@Mir(bb157[0]), _324@Mir(bb157[1])
bb158:
  ((*_1).20: *mut u32) = move _309 as *mut u32 (PtrToPtr)
  using: _1@Phi(bb148), _309@Mir(bb157[2])
  _326 = ((*_1).20: *mut u32)
  using: _1@Phi(bb148)
  _325 = std::ptr::mut_ptr::<impl *mut u32>::is_null(move _326) -> bb159
  using: _326@Mir(bb158[1])
bb159:
  switchInt(move _325) -> [0: bb161, otherwise: bb160]
  using: _325@Mir(bb158[2])
bb160:
  _329 = ((*_1).20: *mut u32)
  using: _1@Phi(bb148)
  _328 = move _329 as usize (PointerExposeAddress)
  using: _329@Mir(bb160[0])
  _327 = Eq(move _328, const 0_usize)
  using: _328@Mir(bb160[1])
  assume(move _327)
  using: _327@Mir(bb160[2])
  _4 = const -3_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb162
  using: 
bb161:
  _2 = const 7948568793456312728_u64
  using: 
  goto -> bb162
  using: 
bb162:
  switchInt(_2) -> [7948568793456312728: bb163, otherwise: bb185]
  using: _2@Phi(bb162)
bb163:
  _330 = const 14_i32
  using: 
  ((*_1).1: i32) = move _330
  using: _1@Phi(bb162), _330@Mir(bb163[0])
  goto -> bb164
  using: 
bb164:
  _332 = ((*_1).8: i32)
  using: _1@Phi(bb164)
  _333 = const 8_i32
  using: 
  _331 = Ge(move _332, move _333)
  using: _332@Mir(bb164[0]), _333@Mir(bb164[1])
  switchInt(move _331) -> [0: bb166, otherwise: bb165]
  using: _331@Mir(bb164[2])
bb165:
  _334 = const 0_u32
  using: 
  _336 = ((*_1).7: u32)
  using: _1@Phi(bb164)
  _338 = ((*_1).8: i32)
  using: _1@Phi(bb164)
  _339 = const 8_i32
  using: 
  _340 = CheckedSub(_338, _339)
  using: _338@Mir(bb165[2]), _339@Mir(bb165[3])
  assert(!move (_340.1: bool), "attempt to compute `{} - {}`, which would overflow", move _338, move _339) -> bb167
  using: _340@Entry, _338@Entry, _339@Entry
bb166:
  _3603 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  _347 = ((*_3603).1: u32)
  using: _3603@Mir(bb166[0])
  _348 = const 0_u32
  using: 
  _346 = Eq(move _347, move _348)
  using: _347@Mir(bb166[1]), _348@Mir(bb166[2])
  switchInt(move _346) -> [0: bb171, otherwise: bb170]
  using: _346@Mir(bb166[3])
bb167:
  _337 = move (_340.0: i32)
  using: _340@Mir(bb165[4])
  _341 = CheckedShr(_336, _337)
  using: _336@Mir(bb165[1]), _337@Mir(bb167[0])
  assert(!move (_341.1: bool), "attempt to shift right by `{}`, which would overflow", move _337) -> bb168
  using: _341@Entry, _336@Entry, _337@Entry
bb168:
  _335 = move (_341.0: u32)
  using: _341@Mir(bb167[1])
  _342 = const 255_u32
  using: 
  _334 = BitAnd(move _335, move _342)
  using: _335@Mir(bb168[0]), _342@Mir(bb168[1])
  _343 = const 8_i32
  using: 
  _344 = CheckedSub(((*_1).8: i32), _343)
  using: _1@Phi(bb164), _343@Mir(bb168[3])
  assert(!move (_344.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _343) -> bb169
  using: _344@Entry, _1@Entry, _343@Entry
bb169:
  ((*_1).8: i32) = move (_344.0: i32)
  using: _1@Phi(bb164), _344@Mir(bb168[4])
  _345 = _334
  using: _334@Mir(bb168[2])
  _3 = move _345 as u8 (IntToInt)
  using: _345@Mir(bb169[1])
  _2 = const 9846950269610550213_u64
  using: 
  goto -> bb179
  using: 
bb170:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb179
  using: 
bb171:
  _350 = ((*_1).7: u32)
  using: _1@Phi(bb164)
  _351 = const 8_i32
  using: 
  _352 = CheckedShl(_350, _351)
  using: _350@Mir(bb171[0]), _351@Mir(bb171[1])
  assert(!move (_352.1: bool), "attempt to shift left by `{}`, which would overflow", move _351) -> bb172
  using: _352@Entry, _350@Entry, _351@Entry
bb172:
  _349 = move (_352.0: u32)
  using: _352@Mir(bb171[2])
  _3604 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  _356 = ((*_3604).0: *mut i8)
  using: _3604@Mir(bb172[1])
  _355 = move _356 as *mut u8 (PtrToPtr)
  using: _356@Mir(bb172[2])
  _354 = (*_355)
  using: _355@Mir(bb172[3])
  _353 = move _354 as u32 (IntToInt)
  using: _354@Mir(bb172[4])
  ((*_1).7: u32) = BitOr(move _349, move _353)
  using: _1@Phi(bb164), _349@Mir(bb172[0]), _353@Mir(bb172[5])
  _357 = const 8_i32
  using: 
  _358 = CheckedAdd(((*_1).8: i32), _357)
  using: _1@Phi(bb164), _357@Mir(bb172[7])
  assert(!move (_358.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _357) -> bb173
  using: _358@Entry, _1@Entry, _357@Entry
bb173:
  ((*_1).8: i32) = move (_358.0: i32)
  using: _1@Phi(bb164), _358@Mir(bb172[8])
  _3605 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  _360 = ((*_3605).0: *mut i8)
  using: _3605@Mir(bb173[1])
  _359 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _360, const 1_isize) -> bb174
  using: _360@Mir(bb173[2])
bb174:
  _3606 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  ((*_3606).0: *mut i8) = move _359
  using: _3606@Mir(bb174[0]), _359@Mir(bb173[3])
  _3607 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  _362 = ((*_3607).1: u32)
  using: _3607@Mir(bb174[2])
  _361 = core::num::<impl u32>::wrapping_sub(move _362, const 1_u32) -> bb175
  using: _362@Mir(bb174[3])
bb175:
  _3608 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  ((*_3608).1: u32) = move _361
  using: _3608@Mir(bb175[0]), _361@Mir(bb174[4])
  _3609 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  _364 = ((*_3609).2: u32)
  using: _3609@Mir(bb175[2])
  _363 = core::num::<impl u32>::wrapping_add(move _364, const 1_u32) -> bb176
  using: _364@Mir(bb175[3])
bb176:
  _3610 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  ((*_3610).2: u32) = move _363
  using: _3610@Mir(bb176[0]), _363@Mir(bb175[4])
  _3611 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  _366 = ((*_3611).2: u32)
  using: _3611@Mir(bb176[2])
  _367 = const 0_u32
  using: 
  _365 = Eq(move _366, move _367)
  using: _366@Mir(bb176[3]), _367@Mir(bb176[4])
  switchInt(move _365) -> [0: bb164, otherwise: bb177]
  using: _365@Mir(bb176[5])
bb177:
  _3612 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  _369 = ((*_3612).3: u32)
  using: _3612@Mir(bb177[0])
  _368 = core::num::<impl u32>::wrapping_add(move _369, const 1_u32) -> bb178
  using: _369@Mir(bb177[1])
bb178:
  _3613 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb164)
  ((*_3613).3: u32) = move _368
  using: _3613@Mir(bb178[0]), _368@Mir(bb177[2])
  goto -> bb164
  using: 
bb179:
  switchInt(_2) -> [15885526978618306830: bb185, otherwise: bb180]
  using: _2@Phi(bb179)
bb180:
  _372 = _3
  using: _3@Phi(bb179)
  _371 = move _372 as i32 (IntToInt)
  using: _372@Mir(bb180[0])
  _373 = const 23_i32
  using: 
  _370 = Eq(move _371, move _373)
  using: _371@Mir(bb180[1]), _373@Mir(bb180[2])
  switchInt(move _370) -> [0: bb182, otherwise: bb181]
  using: _370@Mir(bb180[3])
bb181:
  _2 = const 10200488719709598753_u64
  using: 
  goto -> bb185
  using: 
bb182:
  _376 = _3
  using: _3@Phi(bb179)
  _375 = move _376 as i32 (IntToInt)
  using: _376@Mir(bb182[0])
  _377 = const 49_i32
  using: 
  _374 = Ne(move _375, move _377)
  using: _375@Mir(bb182[1]), _377@Mir(bb182[2])
  switchInt(move _374) -> [0: bb184, otherwise: bb183]
  using: _374@Mir(bb182[3])
bb183:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb185
  using: 
bb184:
  _2 = const 16703841960874917807_u64
  using: 
  goto -> bb185
  using: 
bb185:
  switchInt(_2) -> [10200488719709598753: bb186, 16703841960874917807: bb206, otherwise: bb226]
  using: _2@Phi(bb185)
bb186:
  _378 = const 42_i32
  using: 
  ((*_1).1: i32) = move _378
  using: _1@Phi(bb185), _378@Mir(bb186[0])
  goto -> bb187
  using: 
bb187:
  _380 = ((*_1).8: i32)
  using: _1@Phi(bb187)
  _381 = const 8_i32
  using: 
  _379 = Ge(move _380, move _381)
  using: _380@Mir(bb187[0]), _381@Mir(bb187[1])
  switchInt(move _379) -> [0: bb189, otherwise: bb188]
  using: _379@Mir(bb187[2])
bb188:
  _382 = const 0_u32
  using: 
  _384 = ((*_1).7: u32)
  using: _1@Phi(bb187)
  _386 = ((*_1).8: i32)
  using: _1@Phi(bb187)
  _387 = const 8_i32
  using: 
  _388 = CheckedSub(_386, _387)
  using: _386@Mir(bb188[2]), _387@Mir(bb188[3])
  assert(!move (_388.1: bool), "attempt to compute `{} - {}`, which would overflow", move _386, move _387) -> bb190
  using: _388@Entry, _386@Entry, _387@Entry
bb189:
  _3614 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  _395 = ((*_3614).1: u32)
  using: _3614@Mir(bb189[0])
  _396 = const 0_u32
  using: 
  _394 = Eq(move _395, move _396)
  using: _395@Mir(bb189[1]), _396@Mir(bb189[2])
  switchInt(move _394) -> [0: bb194, otherwise: bb193]
  using: _394@Mir(bb189[3])
bb190:
  _385 = move (_388.0: i32)
  using: _388@Mir(bb188[4])
  _389 = CheckedShr(_384, _385)
  using: _384@Mir(bb188[1]), _385@Mir(bb190[0])
  assert(!move (_389.1: bool), "attempt to shift right by `{}`, which would overflow", move _385) -> bb191
  using: _389@Entry, _384@Entry, _385@Entry
bb191:
  _383 = move (_389.0: u32)
  using: _389@Mir(bb190[1])
  _390 = const 255_u32
  using: 
  _382 = BitAnd(move _383, move _390)
  using: _383@Mir(bb191[0]), _390@Mir(bb191[1])
  _391 = const 8_i32
  using: 
  _392 = CheckedSub(((*_1).8: i32), _391)
  using: _1@Phi(bb187), _391@Mir(bb191[3])
  assert(!move (_392.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _391) -> bb192
  using: _392@Entry, _1@Entry, _391@Entry
bb192:
  ((*_1).8: i32) = move (_392.0: i32)
  using: _1@Phi(bb187), _392@Mir(bb191[4])
  _393 = _382
  using: _382@Mir(bb191[2])
  _3 = move _393 as u8 (IntToInt)
  using: _393@Mir(bb192[1])
  _2 = const 13262463590990658200_u64
  using: 
  goto -> bb202
  using: 
bb193:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb202
  using: 
bb194:
  _398 = ((*_1).7: u32)
  using: _1@Phi(bb187)
  _399 = const 8_i32
  using: 
  _400 = CheckedShl(_398, _399)
  using: _398@Mir(bb194[0]), _399@Mir(bb194[1])
  assert(!move (_400.1: bool), "attempt to shift left by `{}`, which would overflow", move _399) -> bb195
  using: _400@Entry, _398@Entry, _399@Entry
bb195:
  _397 = move (_400.0: u32)
  using: _400@Mir(bb194[2])
  _3615 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  _404 = ((*_3615).0: *mut i8)
  using: _3615@Mir(bb195[1])
  _403 = move _404 as *mut u8 (PtrToPtr)
  using: _404@Mir(bb195[2])
  _402 = (*_403)
  using: _403@Mir(bb195[3])
  _401 = move _402 as u32 (IntToInt)
  using: _402@Mir(bb195[4])
  ((*_1).7: u32) = BitOr(move _397, move _401)
  using: _1@Phi(bb187), _397@Mir(bb195[0]), _401@Mir(bb195[5])
  _405 = const 8_i32
  using: 
  _406 = CheckedAdd(((*_1).8: i32), _405)
  using: _1@Phi(bb187), _405@Mir(bb195[7])
  assert(!move (_406.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _405) -> bb196
  using: _406@Entry, _1@Entry, _405@Entry
bb196:
  ((*_1).8: i32) = move (_406.0: i32)
  using: _1@Phi(bb187), _406@Mir(bb195[8])
  _3616 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  _408 = ((*_3616).0: *mut i8)
  using: _3616@Mir(bb196[1])
  _407 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _408, const 1_isize) -> bb197
  using: _408@Mir(bb196[2])
bb197:
  _3617 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  ((*_3617).0: *mut i8) = move _407
  using: _3617@Mir(bb197[0]), _407@Mir(bb196[3])
  _3618 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  _410 = ((*_3618).1: u32)
  using: _3618@Mir(bb197[2])
  _409 = core::num::<impl u32>::wrapping_sub(move _410, const 1_u32) -> bb198
  using: _410@Mir(bb197[3])
bb198:
  _3619 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  ((*_3619).1: u32) = move _409
  using: _3619@Mir(bb198[0]), _409@Mir(bb197[4])
  _3620 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  _412 = ((*_3620).2: u32)
  using: _3620@Mir(bb198[2])
  _411 = core::num::<impl u32>::wrapping_add(move _412, const 1_u32) -> bb199
  using: _412@Mir(bb198[3])
bb199:
  _3621 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  ((*_3621).2: u32) = move _411
  using: _3621@Mir(bb199[0]), _411@Mir(bb198[4])
  _3622 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  _414 = ((*_3622).2: u32)
  using: _3622@Mir(bb199[2])
  _415 = const 0_u32
  using: 
  _413 = Eq(move _414, move _415)
  using: _414@Mir(bb199[3]), _415@Mir(bb199[4])
  switchInt(move _413) -> [0: bb187, otherwise: bb200]
  using: _413@Mir(bb199[5])
bb200:
  _3623 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  _417 = ((*_3623).3: u32)
  using: _3623@Mir(bb200[0])
  _416 = core::num::<impl u32>::wrapping_add(move _417, const 1_u32) -> bb201
  using: _417@Mir(bb200[1])
bb201:
  _3624 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb187)
  ((*_3624).3: u32) = move _416
  using: _3624@Mir(bb201[0]), _416@Mir(bb200[2])
  goto -> bb187
  using: 
bb202:
  switchInt(_2) -> [15885526978618306830: bb226, otherwise: bb203]
  using: _2@Phi(bb202)
bb203:
  _420 = _3
  using: _3@Phi(bb202)
  _419 = move _420 as i32 (IntToInt)
  using: _420@Mir(bb203[0])
  _421 = const 114_i32
  using: 
  _418 = Ne(move _419, move _421)
  using: _419@Mir(bb203[1]), _421@Mir(bb203[2])
  switchInt(move _418) -> [0: bb205, otherwise: bb204]
  using: _418@Mir(bb203[3])
bb204:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb226
  using: 
bb205:
  _2 = const 9864403379770423142_u64
  using: 
  goto -> bb226
  using: 
bb206:
  _422 = const 15_i32
  using: 
  ((*_1).1: i32) = move _422
  using: _1@Phi(bb202), _422@Mir(bb206[0])
  goto -> bb207
  using: 
bb207:
  _424 = ((*_1).8: i32)
  using: _1@Phi(bb207)
  _425 = const 8_i32
  using: 
  _423 = Ge(move _424, move _425)
  using: _424@Mir(bb207[0]), _425@Mir(bb207[1])
  switchInt(move _423) -> [0: bb209, otherwise: bb208]
  using: _423@Mir(bb207[2])
bb208:
  _426 = const 0_u32
  using: 
  _428 = ((*_1).7: u32)
  using: _1@Phi(bb207)
  _430 = ((*_1).8: i32)
  using: _1@Phi(bb207)
  _431 = const 8_i32
  using: 
  _432 = CheckedSub(_430, _431)
  using: _430@Mir(bb208[2]), _431@Mir(bb208[3])
  assert(!move (_432.1: bool), "attempt to compute `{} - {}`, which would overflow", move _430, move _431) -> bb210
  using: _432@Entry, _430@Entry, _431@Entry
bb209:
  _3625 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  _439 = ((*_3625).1: u32)
  using: _3625@Mir(bb209[0])
  _440 = const 0_u32
  using: 
  _438 = Eq(move _439, move _440)
  using: _439@Mir(bb209[1]), _440@Mir(bb209[2])
  switchInt(move _438) -> [0: bb214, otherwise: bb213]
  using: _438@Mir(bb209[3])
bb210:
  _429 = move (_432.0: i32)
  using: _432@Mir(bb208[4])
  _433 = CheckedShr(_428, _429)
  using: _428@Mir(bb208[1]), _429@Mir(bb210[0])
  assert(!move (_433.1: bool), "attempt to shift right by `{}`, which would overflow", move _429) -> bb211
  using: _433@Entry, _428@Entry, _429@Entry
bb211:
  _427 = move (_433.0: u32)
  using: _433@Mir(bb210[1])
  _434 = const 255_u32
  using: 
  _426 = BitAnd(move _427, move _434)
  using: _427@Mir(bb211[0]), _434@Mir(bb211[1])
  _435 = const 8_i32
  using: 
  _436 = CheckedSub(((*_1).8: i32), _435)
  using: _1@Phi(bb207), _435@Mir(bb211[3])
  assert(!move (_436.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _435) -> bb212
  using: _436@Entry, _1@Entry, _435@Entry
bb212:
  ((*_1).8: i32) = move (_436.0: i32)
  using: _1@Phi(bb207), _436@Mir(bb211[4])
  _437 = _426
  using: _426@Mir(bb211[2])
  _3 = move _437 as u8 (IntToInt)
  using: _437@Mir(bb212[1])
  _2 = const 3569141194949357899_u64
  using: 
  goto -> bb222
  using: 
bb213:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb222
  using: 
bb214:
  _442 = ((*_1).7: u32)
  using: _1@Phi(bb207)
  _443 = const 8_i32
  using: 
  _444 = CheckedShl(_442, _443)
  using: _442@Mir(bb214[0]), _443@Mir(bb214[1])
  assert(!move (_444.1: bool), "attempt to shift left by `{}`, which would overflow", move _443) -> bb215
  using: _444@Entry, _442@Entry, _443@Entry
bb215:
  _441 = move (_444.0: u32)
  using: _444@Mir(bb214[2])
  _3626 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  _448 = ((*_3626).0: *mut i8)
  using: _3626@Mir(bb215[1])
  _447 = move _448 as *mut u8 (PtrToPtr)
  using: _448@Mir(bb215[2])
  _446 = (*_447)
  using: _447@Mir(bb215[3])
  _445 = move _446 as u32 (IntToInt)
  using: _446@Mir(bb215[4])
  ((*_1).7: u32) = BitOr(move _441, move _445)
  using: _1@Phi(bb207), _441@Mir(bb215[0]), _445@Mir(bb215[5])
  _449 = const 8_i32
  using: 
  _450 = CheckedAdd(((*_1).8: i32), _449)
  using: _1@Phi(bb207), _449@Mir(bb215[7])
  assert(!move (_450.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _449) -> bb216
  using: _450@Entry, _1@Entry, _449@Entry
bb216:
  ((*_1).8: i32) = move (_450.0: i32)
  using: _1@Phi(bb207), _450@Mir(bb215[8])
  _3627 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  _452 = ((*_3627).0: *mut i8)
  using: _3627@Mir(bb216[1])
  _451 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _452, const 1_isize) -> bb217
  using: _452@Mir(bb216[2])
bb217:
  _3628 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  ((*_3628).0: *mut i8) = move _451
  using: _3628@Mir(bb217[0]), _451@Mir(bb216[3])
  _3629 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  _454 = ((*_3629).1: u32)
  using: _3629@Mir(bb217[2])
  _453 = core::num::<impl u32>::wrapping_sub(move _454, const 1_u32) -> bb218
  using: _454@Mir(bb217[3])
bb218:
  _3630 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  ((*_3630).1: u32) = move _453
  using: _3630@Mir(bb218[0]), _453@Mir(bb217[4])
  _3631 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  _456 = ((*_3631).2: u32)
  using: _3631@Mir(bb218[2])
  _455 = core::num::<impl u32>::wrapping_add(move _456, const 1_u32) -> bb219
  using: _456@Mir(bb218[3])
bb219:
  _3632 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  ((*_3632).2: u32) = move _455
  using: _3632@Mir(bb219[0]), _455@Mir(bb218[4])
  _3633 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  _458 = ((*_3633).2: u32)
  using: _3633@Mir(bb219[2])
  _459 = const 0_u32
  using: 
  _457 = Eq(move _458, move _459)
  using: _458@Mir(bb219[3]), _459@Mir(bb219[4])
  switchInt(move _457) -> [0: bb207, otherwise: bb220]
  using: _457@Mir(bb219[5])
bb220:
  _3634 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  _461 = ((*_3634).3: u32)
  using: _3634@Mir(bb220[0])
  _460 = core::num::<impl u32>::wrapping_add(move _461, const 1_u32) -> bb221
  using: _461@Mir(bb220[1])
bb221:
  _3635 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb207)
  ((*_3635).3: u32) = move _460
  using: _3635@Mir(bb221[0]), _460@Mir(bb220[2])
  goto -> bb207
  using: 
bb222:
  switchInt(_2) -> [15885526978618306830: bb226, otherwise: bb223]
  using: _2@Phi(bb222)
bb223:
  _464 = _3
  using: _3@Phi(bb222)
  _463 = move _464 as i32 (IntToInt)
  using: _464@Mir(bb223[0])
  _465 = const 65_i32
  using: 
  _462 = Ne(move _463, move _465)
  using: _463@Mir(bb223[1]), _465@Mir(bb223[2])
  switchInt(move _462) -> [0: bb225, otherwise: bb224]
  using: _462@Mir(bb223[3])
bb224:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb226
  using: 
bb225:
  _2 = const 12231332282017165356_u64
  using: 
  goto -> bb226
  using: 
bb226:
  switchInt(_2) -> [9864403379770423142: bb227, 12231332282017165356: bb247, otherwise: bb267]
  using: _2@Phi(bb226)
bb227:
  _466 = const 43_i32
  using: 
  ((*_1).1: i32) = move _466
  using: _1@Phi(bb226), _466@Mir(bb227[0])
  goto -> bb228
  using: 
bb228:
  _468 = ((*_1).8: i32)
  using: _1@Phi(bb228)
  _469 = const 8_i32
  using: 
  _467 = Ge(move _468, move _469)
  using: _468@Mir(bb228[0]), _469@Mir(bb228[1])
  switchInt(move _467) -> [0: bb230, otherwise: bb229]
  using: _467@Mir(bb228[2])
bb229:
  _470 = const 0_u32
  using: 
  _472 = ((*_1).7: u32)
  using: _1@Phi(bb228)
  _474 = ((*_1).8: i32)
  using: _1@Phi(bb228)
  _475 = const 8_i32
  using: 
  _476 = CheckedSub(_474, _475)
  using: _474@Mir(bb229[2]), _475@Mir(bb229[3])
  assert(!move (_476.1: bool), "attempt to compute `{} - {}`, which would overflow", move _474, move _475) -> bb231
  using: _476@Entry, _474@Entry, _475@Entry
bb230:
  _3636 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  _483 = ((*_3636).1: u32)
  using: _3636@Mir(bb230[0])
  _484 = const 0_u32
  using: 
  _482 = Eq(move _483, move _484)
  using: _483@Mir(bb230[1]), _484@Mir(bb230[2])
  switchInt(move _482) -> [0: bb235, otherwise: bb234]
  using: _482@Mir(bb230[3])
bb231:
  _473 = move (_476.0: i32)
  using: _476@Mir(bb229[4])
  _477 = CheckedShr(_472, _473)
  using: _472@Mir(bb229[1]), _473@Mir(bb231[0])
  assert(!move (_477.1: bool), "attempt to shift right by `{}`, which would overflow", move _473) -> bb232
  using: _477@Entry, _472@Entry, _473@Entry
bb232:
  _471 = move (_477.0: u32)
  using: _477@Mir(bb231[1])
  _478 = const 255_u32
  using: 
  _470 = BitAnd(move _471, move _478)
  using: _471@Mir(bb232[0]), _478@Mir(bb232[1])
  _479 = const 8_i32
  using: 
  _480 = CheckedSub(((*_1).8: i32), _479)
  using: _1@Phi(bb228), _479@Mir(bb232[3])
  assert(!move (_480.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _479) -> bb233
  using: _480@Entry, _1@Entry, _479@Entry
bb233:
  ((*_1).8: i32) = move (_480.0: i32)
  using: _1@Phi(bb228), _480@Mir(bb232[4])
  _481 = _470
  using: _470@Mir(bb232[2])
  _3 = move _481 as u8 (IntToInt)
  using: _481@Mir(bb233[1])
  _2 = const 10756506701594629759_u64
  using: 
  goto -> bb243
  using: 
bb234:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb243
  using: 
bb235:
  _486 = ((*_1).7: u32)
  using: _1@Phi(bb228)
  _487 = const 8_i32
  using: 
  _488 = CheckedShl(_486, _487)
  using: _486@Mir(bb235[0]), _487@Mir(bb235[1])
  assert(!move (_488.1: bool), "attempt to shift left by `{}`, which would overflow", move _487) -> bb236
  using: _488@Entry, _486@Entry, _487@Entry
bb236:
  _485 = move (_488.0: u32)
  using: _488@Mir(bb235[2])
  _3637 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  _492 = ((*_3637).0: *mut i8)
  using: _3637@Mir(bb236[1])
  _491 = move _492 as *mut u8 (PtrToPtr)
  using: _492@Mir(bb236[2])
  _490 = (*_491)
  using: _491@Mir(bb236[3])
  _489 = move _490 as u32 (IntToInt)
  using: _490@Mir(bb236[4])
  ((*_1).7: u32) = BitOr(move _485, move _489)
  using: _1@Phi(bb228), _485@Mir(bb236[0]), _489@Mir(bb236[5])
  _493 = const 8_i32
  using: 
  _494 = CheckedAdd(((*_1).8: i32), _493)
  using: _1@Phi(bb228), _493@Mir(bb236[7])
  assert(!move (_494.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _493) -> bb237
  using: _494@Entry, _1@Entry, _493@Entry
bb237:
  ((*_1).8: i32) = move (_494.0: i32)
  using: _1@Phi(bb228), _494@Mir(bb236[8])
  _3638 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  _496 = ((*_3638).0: *mut i8)
  using: _3638@Mir(bb237[1])
  _495 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _496, const 1_isize) -> bb238
  using: _496@Mir(bb237[2])
bb238:
  _3639 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  ((*_3639).0: *mut i8) = move _495
  using: _3639@Mir(bb238[0]), _495@Mir(bb237[3])
  _3640 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  _498 = ((*_3640).1: u32)
  using: _3640@Mir(bb238[2])
  _497 = core::num::<impl u32>::wrapping_sub(move _498, const 1_u32) -> bb239
  using: _498@Mir(bb238[3])
bb239:
  _3641 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  ((*_3641).1: u32) = move _497
  using: _3641@Mir(bb239[0]), _497@Mir(bb238[4])
  _3642 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  _500 = ((*_3642).2: u32)
  using: _3642@Mir(bb239[2])
  _499 = core::num::<impl u32>::wrapping_add(move _500, const 1_u32) -> bb240
  using: _500@Mir(bb239[3])
bb240:
  _3643 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  ((*_3643).2: u32) = move _499
  using: _3643@Mir(bb240[0]), _499@Mir(bb239[4])
  _3644 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  _502 = ((*_3644).2: u32)
  using: _3644@Mir(bb240[2])
  _503 = const 0_u32
  using: 
  _501 = Eq(move _502, move _503)
  using: _502@Mir(bb240[3]), _503@Mir(bb240[4])
  switchInt(move _501) -> [0: bb228, otherwise: bb241]
  using: _501@Mir(bb240[5])
bb241:
  _3645 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  _505 = ((*_3645).3: u32)
  using: _3645@Mir(bb241[0])
  _504 = core::num::<impl u32>::wrapping_add(move _505, const 1_u32) -> bb242
  using: _505@Mir(bb241[1])
bb242:
  _3646 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb228)
  ((*_3646).3: u32) = move _504
  using: _3646@Mir(bb242[0]), _504@Mir(bb241[2])
  goto -> bb228
  using: 
bb243:
  switchInt(_2) -> [15885526978618306830: bb267, otherwise: bb244]
  using: _2@Phi(bb243)
bb244:
  _508 = _3
  using: _3@Phi(bb243)
  _507 = move _508 as i32 (IntToInt)
  using: _508@Mir(bb244[0])
  _509 = const 69_i32
  using: 
  _506 = Ne(move _507, move _509)
  using: _507@Mir(bb244[1]), _509@Mir(bb244[2])
  switchInt(move _506) -> [0: bb246, otherwise: bb245]
  using: _506@Mir(bb244[3])
bb245:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb267
  using: 
bb246:
  _2 = const 8489059574810375089_u64
  using: 
  goto -> bb267
  using: 
bb247:
  _510 = const 16_i32
  using: 
  ((*_1).1: i32) = move _510
  using: _1@Phi(bb243), _510@Mir(bb247[0])
  goto -> bb248
  using: 
bb248:
  _512 = ((*_1).8: i32)
  using: _1@Phi(bb248)
  _513 = const 8_i32
  using: 
  _511 = Ge(move _512, move _513)
  using: _512@Mir(bb248[0]), _513@Mir(bb248[1])
  switchInt(move _511) -> [0: bb250, otherwise: bb249]
  using: _511@Mir(bb248[2])
bb249:
  _514 = const 0_u32
  using: 
  _516 = ((*_1).7: u32)
  using: _1@Phi(bb248)
  _518 = ((*_1).8: i32)
  using: _1@Phi(bb248)
  _519 = const 8_i32
  using: 
  _520 = CheckedSub(_518, _519)
  using: _518@Mir(bb249[2]), _519@Mir(bb249[3])
  assert(!move (_520.1: bool), "attempt to compute `{} - {}`, which would overflow", move _518, move _519) -> bb251
  using: _520@Entry, _518@Entry, _519@Entry
bb250:
  _3647 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  _527 = ((*_3647).1: u32)
  using: _3647@Mir(bb250[0])
  _528 = const 0_u32
  using: 
  _526 = Eq(move _527, move _528)
  using: _527@Mir(bb250[1]), _528@Mir(bb250[2])
  switchInt(move _526) -> [0: bb255, otherwise: bb254]
  using: _526@Mir(bb250[3])
bb251:
  _517 = move (_520.0: i32)
  using: _520@Mir(bb249[4])
  _521 = CheckedShr(_516, _517)
  using: _516@Mir(bb249[1]), _517@Mir(bb251[0])
  assert(!move (_521.1: bool), "attempt to shift right by `{}`, which would overflow", move _517) -> bb252
  using: _521@Entry, _516@Entry, _517@Entry
bb252:
  _515 = move (_521.0: u32)
  using: _521@Mir(bb251[1])
  _522 = const 255_u32
  using: 
  _514 = BitAnd(move _515, move _522)
  using: _515@Mir(bb252[0]), _522@Mir(bb252[1])
  _523 = const 8_i32
  using: 
  _524 = CheckedSub(((*_1).8: i32), _523)
  using: _1@Phi(bb248), _523@Mir(bb252[3])
  assert(!move (_524.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _523) -> bb253
  using: _524@Entry, _1@Entry, _523@Entry
bb253:
  ((*_1).8: i32) = move (_524.0: i32)
  using: _1@Phi(bb248), _524@Mir(bb252[4])
  _525 = _514
  using: _514@Mir(bb252[2])
  _3 = move _525 as u8 (IntToInt)
  using: _525@Mir(bb253[1])
  _2 = const 16517180880614114163_u64
  using: 
  goto -> bb263
  using: 
bb254:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb263
  using: 
bb255:
  _530 = ((*_1).7: u32)
  using: _1@Phi(bb248)
  _531 = const 8_i32
  using: 
  _532 = CheckedShl(_530, _531)
  using: _530@Mir(bb255[0]), _531@Mir(bb255[1])
  assert(!move (_532.1: bool), "attempt to shift left by `{}`, which would overflow", move _531) -> bb256
  using: _532@Entry, _530@Entry, _531@Entry
bb256:
  _529 = move (_532.0: u32)
  using: _532@Mir(bb255[2])
  _3648 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  _536 = ((*_3648).0: *mut i8)
  using: _3648@Mir(bb256[1])
  _535 = move _536 as *mut u8 (PtrToPtr)
  using: _536@Mir(bb256[2])
  _534 = (*_535)
  using: _535@Mir(bb256[3])
  _533 = move _534 as u32 (IntToInt)
  using: _534@Mir(bb256[4])
  ((*_1).7: u32) = BitOr(move _529, move _533)
  using: _1@Phi(bb248), _529@Mir(bb256[0]), _533@Mir(bb256[5])
  _537 = const 8_i32
  using: 
  _538 = CheckedAdd(((*_1).8: i32), _537)
  using: _1@Phi(bb248), _537@Mir(bb256[7])
  assert(!move (_538.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _537) -> bb257
  using: _538@Entry, _1@Entry, _537@Entry
bb257:
  ((*_1).8: i32) = move (_538.0: i32)
  using: _1@Phi(bb248), _538@Mir(bb256[8])
  _3649 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  _540 = ((*_3649).0: *mut i8)
  using: _3649@Mir(bb257[1])
  _539 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _540, const 1_isize) -> bb258
  using: _540@Mir(bb257[2])
bb258:
  _3650 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  ((*_3650).0: *mut i8) = move _539
  using: _3650@Mir(bb258[0]), _539@Mir(bb257[3])
  _3651 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  _542 = ((*_3651).1: u32)
  using: _3651@Mir(bb258[2])
  _541 = core::num::<impl u32>::wrapping_sub(move _542, const 1_u32) -> bb259
  using: _542@Mir(bb258[3])
bb259:
  _3652 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  ((*_3652).1: u32) = move _541
  using: _3652@Mir(bb259[0]), _541@Mir(bb258[4])
  _3653 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  _544 = ((*_3653).2: u32)
  using: _3653@Mir(bb259[2])
  _543 = core::num::<impl u32>::wrapping_add(move _544, const 1_u32) -> bb260
  using: _544@Mir(bb259[3])
bb260:
  _3654 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  ((*_3654).2: u32) = move _543
  using: _3654@Mir(bb260[0]), _543@Mir(bb259[4])
  _3655 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  _546 = ((*_3655).2: u32)
  using: _3655@Mir(bb260[2])
  _547 = const 0_u32
  using: 
  _545 = Eq(move _546, move _547)
  using: _546@Mir(bb260[3]), _547@Mir(bb260[4])
  switchInt(move _545) -> [0: bb248, otherwise: bb261]
  using: _545@Mir(bb260[5])
bb261:
  _3656 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  _549 = ((*_3656).3: u32)
  using: _3656@Mir(bb261[0])
  _548 = core::num::<impl u32>::wrapping_add(move _549, const 1_u32) -> bb262
  using: _549@Mir(bb261[1])
bb262:
  _3657 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb248)
  ((*_3657).3: u32) = move _548
  using: _3657@Mir(bb262[0]), _548@Mir(bb261[2])
  goto -> bb248
  using: 
bb263:
  switchInt(_2) -> [15885526978618306830: bb267, otherwise: bb264]
  using: _2@Phi(bb263)
bb264:
  _552 = _3
  using: _3@Phi(bb263)
  _551 = move _552 as i32 (IntToInt)
  using: _552@Mir(bb264[0])
  _553 = const 89_i32
  using: 
  _550 = Ne(move _551, move _553)
  using: _551@Mir(bb264[1]), _553@Mir(bb264[2])
  switchInt(move _550) -> [0: bb266, otherwise: bb265]
  using: _550@Mir(bb264[3])
bb265:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb267
  using: 
bb266:
  _2 = const 7286555771988341860_u64
  using: 
  goto -> bb267
  using: 
bb267:
  switchInt(_2) -> [8489059574810375089: bb268, 7286555771988341860: bb288, otherwise: bb308]
  using: _2@Phi(bb267)
bb268:
  _554 = const 44_i32
  using: 
  ((*_1).1: i32) = move _554
  using: _1@Phi(bb267), _554@Mir(bb268[0])
  goto -> bb269
  using: 
bb269:
  _556 = ((*_1).8: i32)
  using: _1@Phi(bb269)
  _557 = const 8_i32
  using: 
  _555 = Ge(move _556, move _557)
  using: _556@Mir(bb269[0]), _557@Mir(bb269[1])
  switchInt(move _555) -> [0: bb271, otherwise: bb270]
  using: _555@Mir(bb269[2])
bb270:
  _558 = const 0_u32
  using: 
  _560 = ((*_1).7: u32)
  using: _1@Phi(bb269)
  _562 = ((*_1).8: i32)
  using: _1@Phi(bb269)
  _563 = const 8_i32
  using: 
  _564 = CheckedSub(_562, _563)
  using: _562@Mir(bb270[2]), _563@Mir(bb270[3])
  assert(!move (_564.1: bool), "attempt to compute `{} - {}`, which would overflow", move _562, move _563) -> bb272
  using: _564@Entry, _562@Entry, _563@Entry
bb271:
  _3658 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  _571 = ((*_3658).1: u32)
  using: _3658@Mir(bb271[0])
  _572 = const 0_u32
  using: 
  _570 = Eq(move _571, move _572)
  using: _571@Mir(bb271[1]), _572@Mir(bb271[2])
  switchInt(move _570) -> [0: bb276, otherwise: bb275]
  using: _570@Mir(bb271[3])
bb272:
  _561 = move (_564.0: i32)
  using: _564@Mir(bb270[4])
  _565 = CheckedShr(_560, _561)
  using: _560@Mir(bb270[1]), _561@Mir(bb272[0])
  assert(!move (_565.1: bool), "attempt to shift right by `{}`, which would overflow", move _561) -> bb273
  using: _565@Entry, _560@Entry, _561@Entry
bb273:
  _559 = move (_565.0: u32)
  using: _565@Mir(bb272[1])
  _566 = const 255_u32
  using: 
  _558 = BitAnd(move _559, move _566)
  using: _559@Mir(bb273[0]), _566@Mir(bb273[1])
  _567 = const 8_i32
  using: 
  _568 = CheckedSub(((*_1).8: i32), _567)
  using: _1@Phi(bb269), _567@Mir(bb273[3])
  assert(!move (_568.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _567) -> bb274
  using: _568@Entry, _1@Entry, _567@Entry
bb274:
  ((*_1).8: i32) = move (_568.0: i32)
  using: _1@Phi(bb269), _568@Mir(bb273[4])
  _569 = _558
  using: _558@Mir(bb273[2])
  _3 = move _569 as u8 (IntToInt)
  using: _569@Mir(bb274[1])
  _2 = const 9819403752380335018_u64
  using: 
  goto -> bb284
  using: 
bb275:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb284
  using: 
bb276:
  _574 = ((*_1).7: u32)
  using: _1@Phi(bb269)
  _575 = const 8_i32
  using: 
  _576 = CheckedShl(_574, _575)
  using: _574@Mir(bb276[0]), _575@Mir(bb276[1])
  assert(!move (_576.1: bool), "attempt to shift left by `{}`, which would overflow", move _575) -> bb277
  using: _576@Entry, _574@Entry, _575@Entry
bb277:
  _573 = move (_576.0: u32)
  using: _576@Mir(bb276[2])
  _3659 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  _580 = ((*_3659).0: *mut i8)
  using: _3659@Mir(bb277[1])
  _579 = move _580 as *mut u8 (PtrToPtr)
  using: _580@Mir(bb277[2])
  _578 = (*_579)
  using: _579@Mir(bb277[3])
  _577 = move _578 as u32 (IntToInt)
  using: _578@Mir(bb277[4])
  ((*_1).7: u32) = BitOr(move _573, move _577)
  using: _1@Phi(bb269), _573@Mir(bb277[0]), _577@Mir(bb277[5])
  _581 = const 8_i32
  using: 
  _582 = CheckedAdd(((*_1).8: i32), _581)
  using: _1@Phi(bb269), _581@Mir(bb277[7])
  assert(!move (_582.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _581) -> bb278
  using: _582@Entry, _1@Entry, _581@Entry
bb278:
  ((*_1).8: i32) = move (_582.0: i32)
  using: _1@Phi(bb269), _582@Mir(bb277[8])
  _3660 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  _584 = ((*_3660).0: *mut i8)
  using: _3660@Mir(bb278[1])
  _583 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _584, const 1_isize) -> bb279
  using: _584@Mir(bb278[2])
bb279:
  _3661 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  ((*_3661).0: *mut i8) = move _583
  using: _3661@Mir(bb279[0]), _583@Mir(bb278[3])
  _3662 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  _586 = ((*_3662).1: u32)
  using: _3662@Mir(bb279[2])
  _585 = core::num::<impl u32>::wrapping_sub(move _586, const 1_u32) -> bb280
  using: _586@Mir(bb279[3])
bb280:
  _3663 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  ((*_3663).1: u32) = move _585
  using: _3663@Mir(bb280[0]), _585@Mir(bb279[4])
  _3664 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  _588 = ((*_3664).2: u32)
  using: _3664@Mir(bb280[2])
  _587 = core::num::<impl u32>::wrapping_add(move _588, const 1_u32) -> bb281
  using: _588@Mir(bb280[3])
bb281:
  _3665 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  ((*_3665).2: u32) = move _587
  using: _3665@Mir(bb281[0]), _587@Mir(bb280[4])
  _3666 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  _590 = ((*_3666).2: u32)
  using: _3666@Mir(bb281[2])
  _591 = const 0_u32
  using: 
  _589 = Eq(move _590, move _591)
  using: _590@Mir(bb281[3]), _591@Mir(bb281[4])
  switchInt(move _589) -> [0: bb269, otherwise: bb282]
  using: _589@Mir(bb281[5])
bb282:
  _3667 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  _593 = ((*_3667).3: u32)
  using: _3667@Mir(bb282[0])
  _592 = core::num::<impl u32>::wrapping_add(move _593, const 1_u32) -> bb283
  using: _593@Mir(bb282[1])
bb283:
  _3668 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb269)
  ((*_3668).3: u32) = move _592
  using: _3668@Mir(bb283[0]), _592@Mir(bb282[2])
  goto -> bb269
  using: 
bb284:
  switchInt(_2) -> [15885526978618306830: bb308, otherwise: bb285]
  using: _2@Phi(bb284)
bb285:
  _596 = _3
  using: _3@Phi(bb284)
  _595 = move _596 as i32 (IntToInt)
  using: _596@Mir(bb285[0])
  _597 = const 56_i32
  using: 
  _594 = Ne(move _595, move _597)
  using: _595@Mir(bb285[1]), _597@Mir(bb285[2])
  switchInt(move _594) -> [0: bb287, otherwise: bb286]
  using: _594@Mir(bb285[3])
bb286:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb308
  using: 
bb287:
  _2 = const 12998570369541158573_u64
  using: 
  goto -> bb308
  using: 
bb288:
  _598 = const 17_i32
  using: 
  ((*_1).1: i32) = move _598
  using: _1@Phi(bb284), _598@Mir(bb288[0])
  goto -> bb289
  using: 
bb289:
  _600 = ((*_1).8: i32)
  using: _1@Phi(bb289)
  _601 = const 8_i32
  using: 
  _599 = Ge(move _600, move _601)
  using: _600@Mir(bb289[0]), _601@Mir(bb289[1])
  switchInt(move _599) -> [0: bb291, otherwise: bb290]
  using: _599@Mir(bb289[2])
bb290:
  _602 = const 0_u32
  using: 
  _604 = ((*_1).7: u32)
  using: _1@Phi(bb289)
  _606 = ((*_1).8: i32)
  using: _1@Phi(bb289)
  _607 = const 8_i32
  using: 
  _608 = CheckedSub(_606, _607)
  using: _606@Mir(bb290[2]), _607@Mir(bb290[3])
  assert(!move (_608.1: bool), "attempt to compute `{} - {}`, which would overflow", move _606, move _607) -> bb292
  using: _608@Entry, _606@Entry, _607@Entry
bb291:
  _3669 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  _615 = ((*_3669).1: u32)
  using: _3669@Mir(bb291[0])
  _616 = const 0_u32
  using: 
  _614 = Eq(move _615, move _616)
  using: _615@Mir(bb291[1]), _616@Mir(bb291[2])
  switchInt(move _614) -> [0: bb296, otherwise: bb295]
  using: _614@Mir(bb291[3])
bb292:
  _605 = move (_608.0: i32)
  using: _608@Mir(bb290[4])
  _609 = CheckedShr(_604, _605)
  using: _604@Mir(bb290[1]), _605@Mir(bb292[0])
  assert(!move (_609.1: bool), "attempt to shift right by `{}`, which would overflow", move _605) -> bb293
  using: _609@Entry, _604@Entry, _605@Entry
bb293:
  _603 = move (_609.0: u32)
  using: _609@Mir(bb292[1])
  _610 = const 255_u32
  using: 
  _602 = BitAnd(move _603, move _610)
  using: _603@Mir(bb293[0]), _610@Mir(bb293[1])
  _611 = const 8_i32
  using: 
  _612 = CheckedSub(((*_1).8: i32), _611)
  using: _1@Phi(bb289), _611@Mir(bb293[3])
  assert(!move (_612.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _611) -> bb294
  using: _612@Entry, _1@Entry, _611@Entry
bb294:
  ((*_1).8: i32) = move (_612.0: i32)
  using: _1@Phi(bb289), _612@Mir(bb293[4])
  _613 = _602
  using: _602@Mir(bb293[2])
  _3 = move _613 as u8 (IntToInt)
  using: _613@Mir(bb294[1])
  _2 = const 2606663910910355487_u64
  using: 
  goto -> bb304
  using: 
bb295:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb304
  using: 
bb296:
  _618 = ((*_1).7: u32)
  using: _1@Phi(bb289)
  _619 = const 8_i32
  using: 
  _620 = CheckedShl(_618, _619)
  using: _618@Mir(bb296[0]), _619@Mir(bb296[1])
  assert(!move (_620.1: bool), "attempt to shift left by `{}`, which would overflow", move _619) -> bb297
  using: _620@Entry, _618@Entry, _619@Entry
bb297:
  _617 = move (_620.0: u32)
  using: _620@Mir(bb296[2])
  _3670 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  _624 = ((*_3670).0: *mut i8)
  using: _3670@Mir(bb297[1])
  _623 = move _624 as *mut u8 (PtrToPtr)
  using: _624@Mir(bb297[2])
  _622 = (*_623)
  using: _623@Mir(bb297[3])
  _621 = move _622 as u32 (IntToInt)
  using: _622@Mir(bb297[4])
  ((*_1).7: u32) = BitOr(move _617, move _621)
  using: _1@Phi(bb289), _617@Mir(bb297[0]), _621@Mir(bb297[5])
  _625 = const 8_i32
  using: 
  _626 = CheckedAdd(((*_1).8: i32), _625)
  using: _1@Phi(bb289), _625@Mir(bb297[7])
  assert(!move (_626.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _625) -> bb298
  using: _626@Entry, _1@Entry, _625@Entry
bb298:
  ((*_1).8: i32) = move (_626.0: i32)
  using: _1@Phi(bb289), _626@Mir(bb297[8])
  _3671 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  _628 = ((*_3671).0: *mut i8)
  using: _3671@Mir(bb298[1])
  _627 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _628, const 1_isize) -> bb299
  using: _628@Mir(bb298[2])
bb299:
  _3672 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  ((*_3672).0: *mut i8) = move _627
  using: _3672@Mir(bb299[0]), _627@Mir(bb298[3])
  _3673 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  _630 = ((*_3673).1: u32)
  using: _3673@Mir(bb299[2])
  _629 = core::num::<impl u32>::wrapping_sub(move _630, const 1_u32) -> bb300
  using: _630@Mir(bb299[3])
bb300:
  _3674 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  ((*_3674).1: u32) = move _629
  using: _3674@Mir(bb300[0]), _629@Mir(bb299[4])
  _3675 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  _632 = ((*_3675).2: u32)
  using: _3675@Mir(bb300[2])
  _631 = core::num::<impl u32>::wrapping_add(move _632, const 1_u32) -> bb301
  using: _632@Mir(bb300[3])
bb301:
  _3676 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  ((*_3676).2: u32) = move _631
  using: _3676@Mir(bb301[0]), _631@Mir(bb300[4])
  _3677 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  _634 = ((*_3677).2: u32)
  using: _3677@Mir(bb301[2])
  _635 = const 0_u32
  using: 
  _633 = Eq(move _634, move _635)
  using: _634@Mir(bb301[3]), _635@Mir(bb301[4])
  switchInt(move _633) -> [0: bb289, otherwise: bb302]
  using: _633@Mir(bb301[5])
bb302:
  _3678 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  _637 = ((*_3678).3: u32)
  using: _3678@Mir(bb302[0])
  _636 = core::num::<impl u32>::wrapping_add(move _637, const 1_u32) -> bb303
  using: _637@Mir(bb302[1])
bb303:
  _3679 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb289)
  ((*_3679).3: u32) = move _636
  using: _3679@Mir(bb303[0]), _636@Mir(bb302[2])
  goto -> bb289
  using: 
bb304:
  switchInt(_2) -> [15885526978618306830: bb308, otherwise: bb305]
  using: _2@Phi(bb304)
bb305:
  _640 = _3
  using: _3@Phi(bb304)
  _639 = move _640 as i32 (IntToInt)
  using: _640@Mir(bb305[0])
  _641 = const 38_i32
  using: 
  _638 = Ne(move _639, move _641)
  using: _639@Mir(bb305[1]), _641@Mir(bb305[2])
  switchInt(move _638) -> [0: bb307, otherwise: bb306]
  using: _638@Mir(bb305[3])
bb306:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb308
  using: 
bb307:
  _2 = const 6656868271313165664_u64
  using: 
  goto -> bb308
  using: 
bb308:
  switchInt(_2) -> [12998570369541158573: bb309, 6656868271313165664: bb329, otherwise: bb349]
  using: _2@Phi(bb308)
bb309:
  _642 = const 45_i32
  using: 
  ((*_1).1: i32) = move _642
  using: _1@Phi(bb308), _642@Mir(bb309[0])
  goto -> bb310
  using: 
bb310:
  _644 = ((*_1).8: i32)
  using: _1@Phi(bb310)
  _645 = const 8_i32
  using: 
  _643 = Ge(move _644, move _645)
  using: _644@Mir(bb310[0]), _645@Mir(bb310[1])
  switchInt(move _643) -> [0: bb312, otherwise: bb311]
  using: _643@Mir(bb310[2])
bb311:
  _646 = const 0_u32
  using: 
  _648 = ((*_1).7: u32)
  using: _1@Phi(bb310)
  _650 = ((*_1).8: i32)
  using: _1@Phi(bb310)
  _651 = const 8_i32
  using: 
  _652 = CheckedSub(_650, _651)
  using: _650@Mir(bb311[2]), _651@Mir(bb311[3])
  assert(!move (_652.1: bool), "attempt to compute `{} - {}`, which would overflow", move _650, move _651) -> bb313
  using: _652@Entry, _650@Entry, _651@Entry
bb312:
  _3680 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  _659 = ((*_3680).1: u32)
  using: _3680@Mir(bb312[0])
  _660 = const 0_u32
  using: 
  _658 = Eq(move _659, move _660)
  using: _659@Mir(bb312[1]), _660@Mir(bb312[2])
  switchInt(move _658) -> [0: bb317, otherwise: bb316]
  using: _658@Mir(bb312[3])
bb313:
  _649 = move (_652.0: i32)
  using: _652@Mir(bb311[4])
  _653 = CheckedShr(_648, _649)
  using: _648@Mir(bb311[1]), _649@Mir(bb313[0])
  assert(!move (_653.1: bool), "attempt to shift right by `{}`, which would overflow", move _649) -> bb314
  using: _653@Entry, _648@Entry, _649@Entry
bb314:
  _647 = move (_653.0: u32)
  using: _653@Mir(bb313[1])
  _654 = const 255_u32
  using: 
  _646 = BitAnd(move _647, move _654)
  using: _647@Mir(bb314[0]), _654@Mir(bb314[1])
  _655 = const 8_i32
  using: 
  _656 = CheckedSub(((*_1).8: i32), _655)
  using: _1@Phi(bb310), _655@Mir(bb314[3])
  assert(!move (_656.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _655) -> bb315
  using: _656@Entry, _1@Entry, _655@Entry
bb315:
  ((*_1).8: i32) = move (_656.0: i32)
  using: _1@Phi(bb310), _656@Mir(bb314[4])
  _657 = _646
  using: _646@Mir(bb314[2])
  _3 = move _657 as u8 (IntToInt)
  using: _657@Mir(bb315[1])
  _2 = const 9454797012561717444_u64
  using: 
  goto -> bb325
  using: 
bb316:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb325
  using: 
bb317:
  _662 = ((*_1).7: u32)
  using: _1@Phi(bb310)
  _663 = const 8_i32
  using: 
  _664 = CheckedShl(_662, _663)
  using: _662@Mir(bb317[0]), _663@Mir(bb317[1])
  assert(!move (_664.1: bool), "attempt to shift left by `{}`, which would overflow", move _663) -> bb318
  using: _664@Entry, _662@Entry, _663@Entry
bb318:
  _661 = move (_664.0: u32)
  using: _664@Mir(bb317[2])
  _3681 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  _668 = ((*_3681).0: *mut i8)
  using: _3681@Mir(bb318[1])
  _667 = move _668 as *mut u8 (PtrToPtr)
  using: _668@Mir(bb318[2])
  _666 = (*_667)
  using: _667@Mir(bb318[3])
  _665 = move _666 as u32 (IntToInt)
  using: _666@Mir(bb318[4])
  ((*_1).7: u32) = BitOr(move _661, move _665)
  using: _1@Phi(bb310), _661@Mir(bb318[0]), _665@Mir(bb318[5])
  _669 = const 8_i32
  using: 
  _670 = CheckedAdd(((*_1).8: i32), _669)
  using: _1@Phi(bb310), _669@Mir(bb318[7])
  assert(!move (_670.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _669) -> bb319
  using: _670@Entry, _1@Entry, _669@Entry
bb319:
  ((*_1).8: i32) = move (_670.0: i32)
  using: _1@Phi(bb310), _670@Mir(bb318[8])
  _3682 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  _672 = ((*_3682).0: *mut i8)
  using: _3682@Mir(bb319[1])
  _671 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _672, const 1_isize) -> bb320
  using: _672@Mir(bb319[2])
bb320:
  _3683 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  ((*_3683).0: *mut i8) = move _671
  using: _3683@Mir(bb320[0]), _671@Mir(bb319[3])
  _3684 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  _674 = ((*_3684).1: u32)
  using: _3684@Mir(bb320[2])
  _673 = core::num::<impl u32>::wrapping_sub(move _674, const 1_u32) -> bb321
  using: _674@Mir(bb320[3])
bb321:
  _3685 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  ((*_3685).1: u32) = move _673
  using: _3685@Mir(bb321[0]), _673@Mir(bb320[4])
  _3686 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  _676 = ((*_3686).2: u32)
  using: _3686@Mir(bb321[2])
  _675 = core::num::<impl u32>::wrapping_add(move _676, const 1_u32) -> bb322
  using: _676@Mir(bb321[3])
bb322:
  _3687 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  ((*_3687).2: u32) = move _675
  using: _3687@Mir(bb322[0]), _675@Mir(bb321[4])
  _3688 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  _678 = ((*_3688).2: u32)
  using: _3688@Mir(bb322[2])
  _679 = const 0_u32
  using: 
  _677 = Eq(move _678, move _679)
  using: _678@Mir(bb322[3]), _679@Mir(bb322[4])
  switchInt(move _677) -> [0: bb310, otherwise: bb323]
  using: _677@Mir(bb322[5])
bb323:
  _3689 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  _681 = ((*_3689).3: u32)
  using: _3689@Mir(bb323[0])
  _680 = core::num::<impl u32>::wrapping_add(move _681, const 1_u32) -> bb324
  using: _681@Mir(bb323[1])
bb324:
  _3690 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb310)
  ((*_3690).3: u32) = move _680
  using: _3690@Mir(bb324[0]), _680@Mir(bb323[2])
  goto -> bb310
  using: 
bb325:
  switchInt(_2) -> [15885526978618306830: bb349, otherwise: bb326]
  using: _2@Phi(bb325)
bb326:
  _684 = _3
  using: _3@Phi(bb325)
  _683 = move _684 as i32 (IntToInt)
  using: _684@Mir(bb326[0])
  _685 = const 80_i32
  using: 
  _682 = Ne(move _683, move _685)
  using: _683@Mir(bb326[1]), _685@Mir(bb326[2])
  switchInt(move _682) -> [0: bb328, otherwise: bb327]
  using: _682@Mir(bb326[3])
bb327:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb349
  using: 
bb328:
  _2 = const 10541196509243133637_u64
  using: 
  goto -> bb349
  using: 
bb329:
  _686 = const 18_i32
  using: 
  ((*_1).1: i32) = move _686
  using: _1@Phi(bb325), _686@Mir(bb329[0])
  goto -> bb330
  using: 
bb330:
  _688 = ((*_1).8: i32)
  using: _1@Phi(bb330)
  _689 = const 8_i32
  using: 
  _687 = Ge(move _688, move _689)
  using: _688@Mir(bb330[0]), _689@Mir(bb330[1])
  switchInt(move _687) -> [0: bb332, otherwise: bb331]
  using: _687@Mir(bb330[2])
bb331:
  _690 = const 0_u32
  using: 
  _692 = ((*_1).7: u32)
  using: _1@Phi(bb330)
  _694 = ((*_1).8: i32)
  using: _1@Phi(bb330)
  _695 = const 8_i32
  using: 
  _696 = CheckedSub(_694, _695)
  using: _694@Mir(bb331[2]), _695@Mir(bb331[3])
  assert(!move (_696.1: bool), "attempt to compute `{} - {}`, which would overflow", move _694, move _695) -> bb333
  using: _696@Entry, _694@Entry, _695@Entry
bb332:
  _3691 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  _703 = ((*_3691).1: u32)
  using: _3691@Mir(bb332[0])
  _704 = const 0_u32
  using: 
  _702 = Eq(move _703, move _704)
  using: _703@Mir(bb332[1]), _704@Mir(bb332[2])
  switchInt(move _702) -> [0: bb337, otherwise: bb336]
  using: _702@Mir(bb332[3])
bb333:
  _693 = move (_696.0: i32)
  using: _696@Mir(bb331[4])
  _697 = CheckedShr(_692, _693)
  using: _692@Mir(bb331[1]), _693@Mir(bb333[0])
  assert(!move (_697.1: bool), "attempt to shift right by `{}`, which would overflow", move _693) -> bb334
  using: _697@Entry, _692@Entry, _693@Entry
bb334:
  _691 = move (_697.0: u32)
  using: _697@Mir(bb333[1])
  _698 = const 255_u32
  using: 
  _690 = BitAnd(move _691, move _698)
  using: _691@Mir(bb334[0]), _698@Mir(bb334[1])
  _699 = const 8_i32
  using: 
  _700 = CheckedSub(((*_1).8: i32), _699)
  using: _1@Phi(bb330), _699@Mir(bb334[3])
  assert(!move (_700.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _699) -> bb335
  using: _700@Entry, _1@Entry, _699@Entry
bb335:
  ((*_1).8: i32) = move (_700.0: i32)
  using: _1@Phi(bb330), _700@Mir(bb334[4])
  _701 = _690
  using: _690@Mir(bb334[2])
  _3 = move _701 as u8 (IntToInt)
  using: _701@Mir(bb335[1])
  _2 = const 8125779086361653720_u64
  using: 
  goto -> bb345
  using: 
bb336:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb345
  using: 
bb337:
  _706 = ((*_1).7: u32)
  using: _1@Phi(bb330)
  _707 = const 8_i32
  using: 
  _708 = CheckedShl(_706, _707)
  using: _706@Mir(bb337[0]), _707@Mir(bb337[1])
  assert(!move (_708.1: bool), "attempt to shift left by `{}`, which would overflow", move _707) -> bb338
  using: _708@Entry, _706@Entry, _707@Entry
bb338:
  _705 = move (_708.0: u32)
  using: _708@Mir(bb337[2])
  _3692 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  _712 = ((*_3692).0: *mut i8)
  using: _3692@Mir(bb338[1])
  _711 = move _712 as *mut u8 (PtrToPtr)
  using: _712@Mir(bb338[2])
  _710 = (*_711)
  using: _711@Mir(bb338[3])
  _709 = move _710 as u32 (IntToInt)
  using: _710@Mir(bb338[4])
  ((*_1).7: u32) = BitOr(move _705, move _709)
  using: _1@Phi(bb330), _705@Mir(bb338[0]), _709@Mir(bb338[5])
  _713 = const 8_i32
  using: 
  _714 = CheckedAdd(((*_1).8: i32), _713)
  using: _1@Phi(bb330), _713@Mir(bb338[7])
  assert(!move (_714.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _713) -> bb339
  using: _714@Entry, _1@Entry, _713@Entry
bb339:
  ((*_1).8: i32) = move (_714.0: i32)
  using: _1@Phi(bb330), _714@Mir(bb338[8])
  _3693 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  _716 = ((*_3693).0: *mut i8)
  using: _3693@Mir(bb339[1])
  _715 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _716, const 1_isize) -> bb340
  using: _716@Mir(bb339[2])
bb340:
  _3694 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  ((*_3694).0: *mut i8) = move _715
  using: _3694@Mir(bb340[0]), _715@Mir(bb339[3])
  _3695 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  _718 = ((*_3695).1: u32)
  using: _3695@Mir(bb340[2])
  _717 = core::num::<impl u32>::wrapping_sub(move _718, const 1_u32) -> bb341
  using: _718@Mir(bb340[3])
bb341:
  _3696 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  ((*_3696).1: u32) = move _717
  using: _3696@Mir(bb341[0]), _717@Mir(bb340[4])
  _3697 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  _720 = ((*_3697).2: u32)
  using: _3697@Mir(bb341[2])
  _719 = core::num::<impl u32>::wrapping_add(move _720, const 1_u32) -> bb342
  using: _720@Mir(bb341[3])
bb342:
  _3698 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  ((*_3698).2: u32) = move _719
  using: _3698@Mir(bb342[0]), _719@Mir(bb341[4])
  _3699 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  _722 = ((*_3699).2: u32)
  using: _3699@Mir(bb342[2])
  _723 = const 0_u32
  using: 
  _721 = Eq(move _722, move _723)
  using: _722@Mir(bb342[3]), _723@Mir(bb342[4])
  switchInt(move _721) -> [0: bb330, otherwise: bb343]
  using: _721@Mir(bb342[5])
bb343:
  _3700 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  _725 = ((*_3700).3: u32)
  using: _3700@Mir(bb343[0])
  _724 = core::num::<impl u32>::wrapping_add(move _725, const 1_u32) -> bb344
  using: _725@Mir(bb343[1])
bb344:
  _3701 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb330)
  ((*_3701).3: u32) = move _724
  using: _3701@Mir(bb344[0]), _724@Mir(bb343[2])
  goto -> bb330
  using: 
bb345:
  switchInt(_2) -> [15885526978618306830: bb349, otherwise: bb346]
  using: _2@Phi(bb345)
bb346:
  _728 = _3
  using: _3@Phi(bb345)
  _727 = move _728 as i32 (IntToInt)
  using: _728@Mir(bb346[0])
  _729 = const 83_i32
  using: 
  _726 = Ne(move _727, move _729)
  using: _727@Mir(bb346[1]), _729@Mir(bb346[2])
  switchInt(move _726) -> [0: bb348, otherwise: bb347]
  using: _726@Mir(bb346[3])
bb347:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb349
  using: 
bb348:
  _2 = const 15902903523132075486_u64
  using: 
  goto -> bb349
  using: 
bb349:
  switchInt(_2) -> [10541196509243133637: bb350, 15902903523132075486: bb370, otherwise: bb393]
  using: _2@Phi(bb349)
bb350:
  _730 = const 46_i32
  using: 
  ((*_1).1: i32) = move _730
  using: _1@Phi(bb349), _730@Mir(bb350[0])
  goto -> bb351
  using: 
bb351:
  _732 = ((*_1).8: i32)
  using: _1@Phi(bb351)
  _733 = const 8_i32
  using: 
  _731 = Ge(move _732, move _733)
  using: _732@Mir(bb351[0]), _733@Mir(bb351[1])
  switchInt(move _731) -> [0: bb353, otherwise: bb352]
  using: _731@Mir(bb351[2])
bb352:
  _734 = const 0_u32
  using: 
  _736 = ((*_1).7: u32)
  using: _1@Phi(bb351)
  _738 = ((*_1).8: i32)
  using: _1@Phi(bb351)
  _739 = const 8_i32
  using: 
  _740 = CheckedSub(_738, _739)
  using: _738@Mir(bb352[2]), _739@Mir(bb352[3])
  assert(!move (_740.1: bool), "attempt to compute `{} - {}`, which would overflow", move _738, move _739) -> bb354
  using: _740@Entry, _738@Entry, _739@Entry
bb353:
  _3702 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  _747 = ((*_3702).1: u32)
  using: _3702@Mir(bb353[0])
  _748 = const 0_u32
  using: 
  _746 = Eq(move _747, move _748)
  using: _747@Mir(bb353[1]), _748@Mir(bb353[2])
  switchInt(move _746) -> [0: bb358, otherwise: bb357]
  using: _746@Mir(bb353[3])
bb354:
  _737 = move (_740.0: i32)
  using: _740@Mir(bb352[4])
  _741 = CheckedShr(_736, _737)
  using: _736@Mir(bb352[1]), _737@Mir(bb354[0])
  assert(!move (_741.1: bool), "attempt to shift right by `{}`, which would overflow", move _737) -> bb355
  using: _741@Entry, _736@Entry, _737@Entry
bb355:
  _735 = move (_741.0: u32)
  using: _741@Mir(bb354[1])
  _742 = const 255_u32
  using: 
  _734 = BitAnd(move _735, move _742)
  using: _735@Mir(bb355[0]), _742@Mir(bb355[1])
  _743 = const 8_i32
  using: 
  _744 = CheckedSub(((*_1).8: i32), _743)
  using: _1@Phi(bb351), _743@Mir(bb355[3])
  assert(!move (_744.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _743) -> bb356
  using: _744@Entry, _1@Entry, _743@Entry
bb356:
  ((*_1).8: i32) = move (_744.0: i32)
  using: _1@Phi(bb351), _744@Mir(bb355[4])
  _745 = _734
  using: _734@Mir(bb355[2])
  _3 = move _745 as u8 (IntToInt)
  using: _745@Mir(bb356[1])
  _2 = const 724777313732190959_u64
  using: 
  goto -> bb366
  using: 
bb357:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb366
  using: 
bb358:
  _750 = ((*_1).7: u32)
  using: _1@Phi(bb351)
  _751 = const 8_i32
  using: 
  _752 = CheckedShl(_750, _751)
  using: _750@Mir(bb358[0]), _751@Mir(bb358[1])
  assert(!move (_752.1: bool), "attempt to shift left by `{}`, which would overflow", move _751) -> bb359
  using: _752@Entry, _750@Entry, _751@Entry
bb359:
  _749 = move (_752.0: u32)
  using: _752@Mir(bb358[2])
  _3703 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  _756 = ((*_3703).0: *mut i8)
  using: _3703@Mir(bb359[1])
  _755 = move _756 as *mut u8 (PtrToPtr)
  using: _756@Mir(bb359[2])
  _754 = (*_755)
  using: _755@Mir(bb359[3])
  _753 = move _754 as u32 (IntToInt)
  using: _754@Mir(bb359[4])
  ((*_1).7: u32) = BitOr(move _749, move _753)
  using: _1@Phi(bb351), _749@Mir(bb359[0]), _753@Mir(bb359[5])
  _757 = const 8_i32
  using: 
  _758 = CheckedAdd(((*_1).8: i32), _757)
  using: _1@Phi(bb351), _757@Mir(bb359[7])
  assert(!move (_758.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _757) -> bb360
  using: _758@Entry, _1@Entry, _757@Entry
bb360:
  ((*_1).8: i32) = move (_758.0: i32)
  using: _1@Phi(bb351), _758@Mir(bb359[8])
  _3704 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  _760 = ((*_3704).0: *mut i8)
  using: _3704@Mir(bb360[1])
  _759 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _760, const 1_isize) -> bb361
  using: _760@Mir(bb360[2])
bb361:
  _3705 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  ((*_3705).0: *mut i8) = move _759
  using: _3705@Mir(bb361[0]), _759@Mir(bb360[3])
  _3706 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  _762 = ((*_3706).1: u32)
  using: _3706@Mir(bb361[2])
  _761 = core::num::<impl u32>::wrapping_sub(move _762, const 1_u32) -> bb362
  using: _762@Mir(bb361[3])
bb362:
  _3707 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  ((*_3707).1: u32) = move _761
  using: _3707@Mir(bb362[0]), _761@Mir(bb361[4])
  _3708 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  _764 = ((*_3708).2: u32)
  using: _3708@Mir(bb362[2])
  _763 = core::num::<impl u32>::wrapping_add(move _764, const 1_u32) -> bb363
  using: _764@Mir(bb362[3])
bb363:
  _3709 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  ((*_3709).2: u32) = move _763
  using: _3709@Mir(bb363[0]), _763@Mir(bb362[4])
  _3710 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  _766 = ((*_3710).2: u32)
  using: _3710@Mir(bb363[2])
  _767 = const 0_u32
  using: 
  _765 = Eq(move _766, move _767)
  using: _766@Mir(bb363[3]), _767@Mir(bb363[4])
  switchInt(move _765) -> [0: bb351, otherwise: bb364]
  using: _765@Mir(bb363[5])
bb364:
  _3711 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  _769 = ((*_3711).3: u32)
  using: _3711@Mir(bb364[0])
  _768 = core::num::<impl u32>::wrapping_add(move _769, const 1_u32) -> bb365
  using: _769@Mir(bb364[1])
bb365:
  _3712 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb351)
  ((*_3712).3: u32) = move _768
  using: _3712@Mir(bb365[0]), _768@Mir(bb364[2])
  goto -> bb351
  using: 
bb366:
  switchInt(_2) -> [15885526978618306830: bb393, otherwise: bb367]
  using: _2@Phi(bb366)
bb367:
  _772 = _3
  using: _3@Phi(bb366)
  _771 = move _772 as i32 (IntToInt)
  using: _772@Mir(bb367[0])
  _773 = const 144_i32
  using: 
  _770 = Ne(move _771, move _773)
  using: _771@Mir(bb367[1]), _773@Mir(bb367[2])
  switchInt(move _770) -> [0: bb369, otherwise: bb368]
  using: _770@Mir(bb367[3])
bb368:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb393
  using: 
bb369:
  _774 = const 0_i32
  using: 
  ((*_1).24: u32) = move _774 as u32 (IntToInt)
  using: _1@Phi(bb366), _774@Mir(bb369[0])
  _2 = const 8760950161942609538_u64
  using: 
  goto -> bb393
  using: 
bb370:
  _775 = const 19_i32
  using: 
  ((*_1).1: i32) = move _775
  using: _1@Phi(bb366), _775@Mir(bb370[0])
  goto -> bb371
  using: 
bb371:
  _777 = ((*_1).8: i32)
  using: _1@Phi(bb371)
  _778 = const 8_i32
  using: 
  _776 = Ge(move _777, move _778)
  using: _777@Mir(bb371[0]), _778@Mir(bb371[1])
  switchInt(move _776) -> [0: bb373, otherwise: bb372]
  using: _776@Mir(bb371[2])
bb372:
  _779 = const 0_u32
  using: 
  _781 = ((*_1).7: u32)
  using: _1@Phi(bb371)
  _783 = ((*_1).8: i32)
  using: _1@Phi(bb371)
  _784 = const 8_i32
  using: 
  _785 = CheckedSub(_783, _784)
  using: _783@Mir(bb372[2]), _784@Mir(bb372[3])
  assert(!move (_785.1: bool), "attempt to compute `{} - {}`, which would overflow", move _783, move _784) -> bb374
  using: _785@Entry, _783@Entry, _784@Entry
bb373:
  _3713 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  _792 = ((*_3713).1: u32)
  using: _3713@Mir(bb373[0])
  _793 = const 0_u32
  using: 
  _791 = Eq(move _792, move _793)
  using: _792@Mir(bb373[1]), _793@Mir(bb373[2])
  switchInt(move _791) -> [0: bb378, otherwise: bb377]
  using: _791@Mir(bb373[3])
bb374:
  _782 = move (_785.0: i32)
  using: _785@Mir(bb372[4])
  _786 = CheckedShr(_781, _782)
  using: _781@Mir(bb372[1]), _782@Mir(bb374[0])
  assert(!move (_786.1: bool), "attempt to shift right by `{}`, which would overflow", move _782) -> bb375
  using: _786@Entry, _781@Entry, _782@Entry
bb375:
  _780 = move (_786.0: u32)
  using: _786@Mir(bb374[1])
  _787 = const 255_u32
  using: 
  _779 = BitAnd(move _780, move _787)
  using: _780@Mir(bb375[0]), _787@Mir(bb375[1])
  _788 = const 8_i32
  using: 
  _789 = CheckedSub(((*_1).8: i32), _788)
  using: _1@Phi(bb371), _788@Mir(bb375[3])
  assert(!move (_789.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _788) -> bb376
  using: _789@Entry, _1@Entry, _788@Entry
bb376:
  ((*_1).8: i32) = move (_789.0: i32)
  using: _1@Phi(bb371), _789@Mir(bb375[4])
  _790 = _779
  using: _779@Mir(bb375[2])
  _3 = move _790 as u8 (IntToInt)
  using: _790@Mir(bb376[1])
  _2 = const 958128786106592581_u64
  using: 
  goto -> bb386
  using: 
bb377:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb386
  using: 
bb378:
  _795 = ((*_1).7: u32)
  using: _1@Phi(bb371)
  _796 = const 8_i32
  using: 
  _797 = CheckedShl(_795, _796)
  using: _795@Mir(bb378[0]), _796@Mir(bb378[1])
  assert(!move (_797.1: bool), "attempt to shift left by `{}`, which would overflow", move _796) -> bb379
  using: _797@Entry, _795@Entry, _796@Entry
bb379:
  _794 = move (_797.0: u32)
  using: _797@Mir(bb378[2])
  _3714 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  _801 = ((*_3714).0: *mut i8)
  using: _3714@Mir(bb379[1])
  _800 = move _801 as *mut u8 (PtrToPtr)
  using: _801@Mir(bb379[2])
  _799 = (*_800)
  using: _800@Mir(bb379[3])
  _798 = move _799 as u32 (IntToInt)
  using: _799@Mir(bb379[4])
  ((*_1).7: u32) = BitOr(move _794, move _798)
  using: _1@Phi(bb371), _794@Mir(bb379[0]), _798@Mir(bb379[5])
  _802 = const 8_i32
  using: 
  _803 = CheckedAdd(((*_1).8: i32), _802)
  using: _1@Phi(bb371), _802@Mir(bb379[7])
  assert(!move (_803.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _802) -> bb380
  using: _803@Entry, _1@Entry, _802@Entry
bb380:
  ((*_1).8: i32) = move (_803.0: i32)
  using: _1@Phi(bb371), _803@Mir(bb379[8])
  _3715 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  _805 = ((*_3715).0: *mut i8)
  using: _3715@Mir(bb380[1])
  _804 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _805, const 1_isize) -> bb381
  using: _805@Mir(bb380[2])
bb381:
  _3716 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  ((*_3716).0: *mut i8) = move _804
  using: _3716@Mir(bb381[0]), _804@Mir(bb380[3])
  _3717 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  _807 = ((*_3717).1: u32)
  using: _3717@Mir(bb381[2])
  _806 = core::num::<impl u32>::wrapping_sub(move _807, const 1_u32) -> bb382
  using: _807@Mir(bb381[3])
bb382:
  _3718 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  ((*_3718).1: u32) = move _806
  using: _3718@Mir(bb382[0]), _806@Mir(bb381[4])
  _3719 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  _809 = ((*_3719).2: u32)
  using: _3719@Mir(bb382[2])
  _808 = core::num::<impl u32>::wrapping_add(move _809, const 1_u32) -> bb383
  using: _809@Mir(bb382[3])
bb383:
  _3720 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  ((*_3720).2: u32) = move _808
  using: _3720@Mir(bb383[0]), _808@Mir(bb382[4])
  _3721 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  _811 = ((*_3721).2: u32)
  using: _3721@Mir(bb383[2])
  _812 = const 0_u32
  using: 
  _810 = Eq(move _811, move _812)
  using: _811@Mir(bb383[3]), _812@Mir(bb383[4])
  switchInt(move _810) -> [0: bb371, otherwise: bb384]
  using: _810@Mir(bb383[5])
bb384:
  _3722 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  _814 = ((*_3722).3: u32)
  using: _3722@Mir(bb384[0])
  _813 = core::num::<impl u32>::wrapping_add(move _814, const 1_u32) -> bb385
  using: _814@Mir(bb384[1])
bb385:
  _3723 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb371)
  ((*_3723).3: u32) = move _813
  using: _3723@Mir(bb385[0]), _813@Mir(bb384[2])
  goto -> bb371
  using: 
bb386:
  switchInt(_2) -> [15885526978618306830: bb393, otherwise: bb387]
  using: _2@Phi(bb386)
bb387:
  _817 = _3
  using: _3@Phi(bb386)
  _816 = move _817 as i32 (IntToInt)
  using: _817@Mir(bb387[0])
  _818 = const 89_i32
  using: 
  _815 = Ne(move _816, move _818)
  using: _816@Mir(bb387[1]), _818@Mir(bb387[2])
  switchInt(move _815) -> [0: bb389, otherwise: bb388]
  using: _815@Mir(bb387[3])
bb388:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb393
  using: 
bb389:
  _819 = CheckedAdd(((*_1).11: i32), const 1_i32)
  using: _1@Phi(bb386)
  assert(!move (_819.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).11: i32), const 1_i32) -> bb390
  using: _819@Entry, _1@Entry
bb390:
  ((*_1).11: i32) = move (_819.0: i32)
  using: _1@Phi(bb386), _819@Mir(bb389[0])
  _821 = ((*_1).12: i32)
  using: _1@Phi(bb386)
  _822 = const 2_i32
  using: 
  _820 = Ge(move _821, move _822)
  using: _821@Mir(bb390[1]), _822@Mir(bb390[2])
  switchInt(move _820) -> [0: bb392, otherwise: bb391]
  using: _820@Mir(bb390[3])
bb391:
  _825 = const {alloc924: *mut *mut blocksort::__sFILE}
  using: 
  _824 = (*_825)
  using: _825@Mir(bb391[0])
  _829 = const b"\n    [%d: huff+mtf \x00"
  using: 
  _828 = &raw const (*_829)
  using: _829@Mir(bb391[2])
  _827 = move _828 as *const u8 (Pointer(ArrayToPointer))
  using: _828@Mir(bb391[3])
  _826 = move _827 as *const i8 (PtrToPtr)
  using: _827@Mir(bb391[4])
  _830 = ((*_1).11: i32)
  using: _1@Phi(bb386)
  _823 = decompress::fprintf(move _824, move _826, move _830) -> bb392
  using: _824@Mir(bb391[1]), _826@Mir(bb391[5]), _830@Mir(bb391[6])
bb392:
  _831 = const 0_i32
  using: 
  ((*_1).23: u32) = move _831 as u32 (IntToInt)
  using: _1@Phi(bb392), _831@Mir(bb392[0])
  _2 = const 16204949703499709801_u64
  using: 
  goto -> bb393
  using: 
bb393:
  switchInt(_2) -> [8760950161942609538: bb394, 16204949703499709801: bb413, otherwise: bb432]
  using: _2@Phi(bb393)
bb394:
  _832 = const 47_i32
  using: 
  ((*_1).1: i32) = move _832
  using: _1@Phi(bb393), _832@Mir(bb394[0])
  goto -> bb395
  using: 
bb395:
  _834 = ((*_1).8: i32)
  using: _1@Phi(bb395)
  _835 = const 8_i32
  using: 
  _833 = Ge(move _834, move _835)
  using: _834@Mir(bb395[0]), _835@Mir(bb395[1])
  switchInt(move _833) -> [0: bb397, otherwise: bb396]
  using: _833@Mir(bb395[2])
bb396:
  _836 = const 0_u32
  using: 
  _838 = ((*_1).7: u32)
  using: _1@Phi(bb395)
  _840 = ((*_1).8: i32)
  using: _1@Phi(bb395)
  _841 = const 8_i32
  using: 
  _842 = CheckedSub(_840, _841)
  using: _840@Mir(bb396[2]), _841@Mir(bb396[3])
  assert(!move (_842.1: bool), "attempt to compute `{} - {}`, which would overflow", move _840, move _841) -> bb398
  using: _842@Entry, _840@Entry, _841@Entry
bb397:
  _3724 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  _849 = ((*_3724).1: u32)
  using: _3724@Mir(bb397[0])
  _850 = const 0_u32
  using: 
  _848 = Eq(move _849, move _850)
  using: _849@Mir(bb397[1]), _850@Mir(bb397[2])
  switchInt(move _848) -> [0: bb402, otherwise: bb401]
  using: _848@Mir(bb397[3])
bb398:
  _839 = move (_842.0: i32)
  using: _842@Mir(bb396[4])
  _843 = CheckedShr(_838, _839)
  using: _838@Mir(bb396[1]), _839@Mir(bb398[0])
  assert(!move (_843.1: bool), "attempt to shift right by `{}`, which would overflow", move _839) -> bb399
  using: _843@Entry, _838@Entry, _839@Entry
bb399:
  _837 = move (_843.0: u32)
  using: _843@Mir(bb398[1])
  _844 = const 255_u32
  using: 
  _836 = BitAnd(move _837, move _844)
  using: _837@Mir(bb399[0]), _844@Mir(bb399[1])
  _845 = const 8_i32
  using: 
  _846 = CheckedSub(((*_1).8: i32), _845)
  using: _1@Phi(bb395), _845@Mir(bb399[3])
  assert(!move (_846.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _845) -> bb400
  using: _846@Entry, _1@Entry, _845@Entry
bb400:
  ((*_1).8: i32) = move (_846.0: i32)
  using: _1@Phi(bb395), _846@Mir(bb399[4])
  _847 = _836
  using: _836@Mir(bb399[2])
  _3 = move _847 as u8 (IntToInt)
  using: _847@Mir(bb400[1])
  _2 = const 14486187473704332379_u64
  using: 
  goto -> bb410
  using: 
bb401:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb410
  using: 
bb402:
  _852 = ((*_1).7: u32)
  using: _1@Phi(bb395)
  _853 = const 8_i32
  using: 
  _854 = CheckedShl(_852, _853)
  using: _852@Mir(bb402[0]), _853@Mir(bb402[1])
  assert(!move (_854.1: bool), "attempt to shift left by `{}`, which would overflow", move _853) -> bb403
  using: _854@Entry, _852@Entry, _853@Entry
bb403:
  _851 = move (_854.0: u32)
  using: _854@Mir(bb402[2])
  _3725 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  _858 = ((*_3725).0: *mut i8)
  using: _3725@Mir(bb403[1])
  _857 = move _858 as *mut u8 (PtrToPtr)
  using: _858@Mir(bb403[2])
  _856 = (*_857)
  using: _857@Mir(bb403[3])
  _855 = move _856 as u32 (IntToInt)
  using: _856@Mir(bb403[4])
  ((*_1).7: u32) = BitOr(move _851, move _855)
  using: _1@Phi(bb395), _851@Mir(bb403[0]), _855@Mir(bb403[5])
  _859 = const 8_i32
  using: 
  _860 = CheckedAdd(((*_1).8: i32), _859)
  using: _1@Phi(bb395), _859@Mir(bb403[7])
  assert(!move (_860.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _859) -> bb404
  using: _860@Entry, _1@Entry, _859@Entry
bb404:
  ((*_1).8: i32) = move (_860.0: i32)
  using: _1@Phi(bb395), _860@Mir(bb403[8])
  _3726 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  _862 = ((*_3726).0: *mut i8)
  using: _3726@Mir(bb404[1])
  _861 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _862, const 1_isize) -> bb405
  using: _862@Mir(bb404[2])
bb405:
  _3727 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  ((*_3727).0: *mut i8) = move _861
  using: _3727@Mir(bb405[0]), _861@Mir(bb404[3])
  _3728 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  _864 = ((*_3728).1: u32)
  using: _3728@Mir(bb405[2])
  _863 = core::num::<impl u32>::wrapping_sub(move _864, const 1_u32) -> bb406
  using: _864@Mir(bb405[3])
bb406:
  _3729 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  ((*_3729).1: u32) = move _863
  using: _3729@Mir(bb406[0]), _863@Mir(bb405[4])
  _3730 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  _866 = ((*_3730).2: u32)
  using: _3730@Mir(bb406[2])
  _865 = core::num::<impl u32>::wrapping_add(move _866, const 1_u32) -> bb407
  using: _866@Mir(bb406[3])
bb407:
  _3731 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  ((*_3731).2: u32) = move _865
  using: _3731@Mir(bb407[0]), _865@Mir(bb406[4])
  _3732 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  _868 = ((*_3732).2: u32)
  using: _3732@Mir(bb407[2])
  _869 = const 0_u32
  using: 
  _867 = Eq(move _868, move _869)
  using: _868@Mir(bb407[3]), _869@Mir(bb407[4])
  switchInt(move _867) -> [0: bb395, otherwise: bb408]
  using: _867@Mir(bb407[5])
bb408:
  _3733 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  _871 = ((*_3733).3: u32)
  using: _3733@Mir(bb408[0])
  _870 = core::num::<impl u32>::wrapping_add(move _871, const 1_u32) -> bb409
  using: _871@Mir(bb408[1])
bb409:
  _3734 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb395)
  ((*_3734).3: u32) = move _870
  using: _3734@Mir(bb409[0]), _870@Mir(bb408[2])
  goto -> bb395
  using: 
bb410:
  switchInt(_2) -> [15885526978618306830: bb432, otherwise: bb411]
  using: _2@Phi(bb410)
bb411:
  _873 = ((*_1).24: u32)
  using: _1@Phi(bb410)
  _874 = const 8_i32
  using: 
  _875 = CheckedShl(_873, _874)
  using: _873@Mir(bb411[0]), _874@Mir(bb411[1])
  assert(!move (_875.1: bool), "attempt to shift left by `{}`, which would overflow", move _874) -> bb412
  using: _875@Entry, _873@Entry, _874@Entry
bb412:
  _872 = move (_875.0: u32)
  using: _875@Mir(bb411[2])
  _877 = _3
  using: _3@Phi(bb410)
  _876 = move _877 as u32 (IntToInt)
  using: _877@Mir(bb412[1])
  ((*_1).24: u32) = BitOr(move _872, move _876)
  using: _1@Phi(bb410), _872@Mir(bb412[0]), _876@Mir(bb412[2])
  _2 = const 3131443096645543054_u64
  using: 
  goto -> bb432
  using: 
bb413:
  _878 = const 20_i32
  using: 
  ((*_1).1: i32) = move _878
  using: _1@Phi(bb410), _878@Mir(bb413[0])
  goto -> bb414
  using: 
bb414:
  _880 = ((*_1).8: i32)
  using: _1@Phi(bb414)
  _881 = const 8_i32
  using: 
  _879 = Ge(move _880, move _881)
  using: _880@Mir(bb414[0]), _881@Mir(bb414[1])
  switchInt(move _879) -> [0: bb416, otherwise: bb415]
  using: _879@Mir(bb414[2])
bb415:
  _882 = const 0_u32
  using: 
  _884 = ((*_1).7: u32)
  using: _1@Phi(bb414)
  _886 = ((*_1).8: i32)
  using: _1@Phi(bb414)
  _887 = const 8_i32
  using: 
  _888 = CheckedSub(_886, _887)
  using: _886@Mir(bb415[2]), _887@Mir(bb415[3])
  assert(!move (_888.1: bool), "attempt to compute `{} - {}`, which would overflow", move _886, move _887) -> bb417
  using: _888@Entry, _886@Entry, _887@Entry
bb416:
  _3735 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  _895 = ((*_3735).1: u32)
  using: _3735@Mir(bb416[0])
  _896 = const 0_u32
  using: 
  _894 = Eq(move _895, move _896)
  using: _895@Mir(bb416[1]), _896@Mir(bb416[2])
  switchInt(move _894) -> [0: bb421, otherwise: bb420]
  using: _894@Mir(bb416[3])
bb417:
  _885 = move (_888.0: i32)
  using: _888@Mir(bb415[4])
  _889 = CheckedShr(_884, _885)
  using: _884@Mir(bb415[1]), _885@Mir(bb417[0])
  assert(!move (_889.1: bool), "attempt to shift right by `{}`, which would overflow", move _885) -> bb418
  using: _889@Entry, _884@Entry, _885@Entry
bb418:
  _883 = move (_889.0: u32)
  using: _889@Mir(bb417[1])
  _890 = const 255_u32
  using: 
  _882 = BitAnd(move _883, move _890)
  using: _883@Mir(bb418[0]), _890@Mir(bb418[1])
  _891 = const 8_i32
  using: 
  _892 = CheckedSub(((*_1).8: i32), _891)
  using: _1@Phi(bb414), _891@Mir(bb418[3])
  assert(!move (_892.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _891) -> bb419
  using: _892@Entry, _1@Entry, _891@Entry
bb419:
  ((*_1).8: i32) = move (_892.0: i32)
  using: _1@Phi(bb414), _892@Mir(bb418[4])
  _893 = _882
  using: _882@Mir(bb418[2])
  _3 = move _893 as u8 (IntToInt)
  using: _893@Mir(bb419[1])
  _2 = const 3790734079518302164_u64
  using: 
  goto -> bb429
  using: 
bb420:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb429
  using: 
bb421:
  _898 = ((*_1).7: u32)
  using: _1@Phi(bb414)
  _899 = const 8_i32
  using: 
  _900 = CheckedShl(_898, _899)
  using: _898@Mir(bb421[0]), _899@Mir(bb421[1])
  assert(!move (_900.1: bool), "attempt to shift left by `{}`, which would overflow", move _899) -> bb422
  using: _900@Entry, _898@Entry, _899@Entry
bb422:
  _897 = move (_900.0: u32)
  using: _900@Mir(bb421[2])
  _3736 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  _904 = ((*_3736).0: *mut i8)
  using: _3736@Mir(bb422[1])
  _903 = move _904 as *mut u8 (PtrToPtr)
  using: _904@Mir(bb422[2])
  _902 = (*_903)
  using: _903@Mir(bb422[3])
  _901 = move _902 as u32 (IntToInt)
  using: _902@Mir(bb422[4])
  ((*_1).7: u32) = BitOr(move _897, move _901)
  using: _1@Phi(bb414), _897@Mir(bb422[0]), _901@Mir(bb422[5])
  _905 = const 8_i32
  using: 
  _906 = CheckedAdd(((*_1).8: i32), _905)
  using: _1@Phi(bb414), _905@Mir(bb422[7])
  assert(!move (_906.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _905) -> bb423
  using: _906@Entry, _1@Entry, _905@Entry
bb423:
  ((*_1).8: i32) = move (_906.0: i32)
  using: _1@Phi(bb414), _906@Mir(bb422[8])
  _3737 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  _908 = ((*_3737).0: *mut i8)
  using: _3737@Mir(bb423[1])
  _907 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _908, const 1_isize) -> bb424
  using: _908@Mir(bb423[2])
bb424:
  _3738 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  ((*_3738).0: *mut i8) = move _907
  using: _3738@Mir(bb424[0]), _907@Mir(bb423[3])
  _3739 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  _910 = ((*_3739).1: u32)
  using: _3739@Mir(bb424[2])
  _909 = core::num::<impl u32>::wrapping_sub(move _910, const 1_u32) -> bb425
  using: _910@Mir(bb424[3])
bb425:
  _3740 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  ((*_3740).1: u32) = move _909
  using: _3740@Mir(bb425[0]), _909@Mir(bb424[4])
  _3741 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  _912 = ((*_3741).2: u32)
  using: _3741@Mir(bb425[2])
  _911 = core::num::<impl u32>::wrapping_add(move _912, const 1_u32) -> bb426
  using: _912@Mir(bb425[3])
bb426:
  _3742 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  ((*_3742).2: u32) = move _911
  using: _3742@Mir(bb426[0]), _911@Mir(bb425[4])
  _3743 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  _914 = ((*_3743).2: u32)
  using: _3743@Mir(bb426[2])
  _915 = const 0_u32
  using: 
  _913 = Eq(move _914, move _915)
  using: _914@Mir(bb426[3]), _915@Mir(bb426[4])
  switchInt(move _913) -> [0: bb414, otherwise: bb427]
  using: _913@Mir(bb426[5])
bb427:
  _3744 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  _917 = ((*_3744).3: u32)
  using: _3744@Mir(bb427[0])
  _916 = core::num::<impl u32>::wrapping_add(move _917, const 1_u32) -> bb428
  using: _917@Mir(bb427[1])
bb428:
  _3745 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb414)
  ((*_3745).3: u32) = move _916
  using: _3745@Mir(bb428[0]), _916@Mir(bb427[2])
  goto -> bb414
  using: 
bb429:
  switchInt(_2) -> [15885526978618306830: bb432, otherwise: bb430]
  using: _2@Phi(bb429)
bb430:
  _919 = ((*_1).23: u32)
  using: _1@Phi(bb429)
  _920 = const 8_i32
  using: 
  _921 = CheckedShl(_919, _920)
  using: _919@Mir(bb430[0]), _920@Mir(bb430[1])
  assert(!move (_921.1: bool), "attempt to shift left by `{}`, which would overflow", move _920) -> bb431
  using: _921@Entry, _919@Entry, _920@Entry
bb431:
  _918 = move (_921.0: u32)
  using: _921@Mir(bb430[2])
  _923 = _3
  using: _3@Phi(bb429)
  _922 = move _923 as u32 (IntToInt)
  using: _923@Mir(bb431[1])
  ((*_1).23: u32) = BitOr(move _918, move _922)
  using: _1@Phi(bb429), _918@Mir(bb431[0]), _922@Mir(bb431[2])
  _2 = const 5505795673017046993_u64
  using: 
  goto -> bb432
  using: 
bb432:
  switchInt(_2) -> [3131443096645543054: bb433, 5505795673017046993: bb452, otherwise: bb471]
  using: _2@Phi(bb432)
bb433:
  _924 = const 48_i32
  using: 
  ((*_1).1: i32) = move _924
  using: _1@Phi(bb432), _924@Mir(bb433[0])
  goto -> bb434
  using: 
bb434:
  _926 = ((*_1).8: i32)
  using: _1@Phi(bb434)
  _927 = const 8_i32
  using: 
  _925 = Ge(move _926, move _927)
  using: _926@Mir(bb434[0]), _927@Mir(bb434[1])
  switchInt(move _925) -> [0: bb436, otherwise: bb435]
  using: _925@Mir(bb434[2])
bb435:
  _928 = const 0_u32
  using: 
  _930 = ((*_1).7: u32)
  using: _1@Phi(bb434)
  _932 = ((*_1).8: i32)
  using: _1@Phi(bb434)
  _933 = const 8_i32
  using: 
  _934 = CheckedSub(_932, _933)
  using: _932@Mir(bb435[2]), _933@Mir(bb435[3])
  assert(!move (_934.1: bool), "attempt to compute `{} - {}`, which would overflow", move _932, move _933) -> bb437
  using: _934@Entry, _932@Entry, _933@Entry
bb436:
  _3746 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  _941 = ((*_3746).1: u32)
  using: _3746@Mir(bb436[0])
  _942 = const 0_u32
  using: 
  _940 = Eq(move _941, move _942)
  using: _941@Mir(bb436[1]), _942@Mir(bb436[2])
  switchInt(move _940) -> [0: bb441, otherwise: bb440]
  using: _940@Mir(bb436[3])
bb437:
  _931 = move (_934.0: i32)
  using: _934@Mir(bb435[4])
  _935 = CheckedShr(_930, _931)
  using: _930@Mir(bb435[1]), _931@Mir(bb437[0])
  assert(!move (_935.1: bool), "attempt to shift right by `{}`, which would overflow", move _931) -> bb438
  using: _935@Entry, _930@Entry, _931@Entry
bb438:
  _929 = move (_935.0: u32)
  using: _935@Mir(bb437[1])
  _936 = const 255_u32
  using: 
  _928 = BitAnd(move _929, move _936)
  using: _929@Mir(bb438[0]), _936@Mir(bb438[1])
  _937 = const 8_i32
  using: 
  _938 = CheckedSub(((*_1).8: i32), _937)
  using: _1@Phi(bb434), _937@Mir(bb438[3])
  assert(!move (_938.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _937) -> bb439
  using: _938@Entry, _1@Entry, _937@Entry
bb439:
  ((*_1).8: i32) = move (_938.0: i32)
  using: _1@Phi(bb434), _938@Mir(bb438[4])
  _939 = _928
  using: _928@Mir(bb438[2])
  _3 = move _939 as u8 (IntToInt)
  using: _939@Mir(bb439[1])
  _2 = const 3659807904093622879_u64
  using: 
  goto -> bb449
  using: 
bb440:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb449
  using: 
bb441:
  _944 = ((*_1).7: u32)
  using: _1@Phi(bb434)
  _945 = const 8_i32
  using: 
  _946 = CheckedShl(_944, _945)
  using: _944@Mir(bb441[0]), _945@Mir(bb441[1])
  assert(!move (_946.1: bool), "attempt to shift left by `{}`, which would overflow", move _945) -> bb442
  using: _946@Entry, _944@Entry, _945@Entry
bb442:
  _943 = move (_946.0: u32)
  using: _946@Mir(bb441[2])
  _3747 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  _950 = ((*_3747).0: *mut i8)
  using: _3747@Mir(bb442[1])
  _949 = move _950 as *mut u8 (PtrToPtr)
  using: _950@Mir(bb442[2])
  _948 = (*_949)
  using: _949@Mir(bb442[3])
  _947 = move _948 as u32 (IntToInt)
  using: _948@Mir(bb442[4])
  ((*_1).7: u32) = BitOr(move _943, move _947)
  using: _1@Phi(bb434), _943@Mir(bb442[0]), _947@Mir(bb442[5])
  _951 = const 8_i32
  using: 
  _952 = CheckedAdd(((*_1).8: i32), _951)
  using: _1@Phi(bb434), _951@Mir(bb442[7])
  assert(!move (_952.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _951) -> bb443
  using: _952@Entry, _1@Entry, _951@Entry
bb443:
  ((*_1).8: i32) = move (_952.0: i32)
  using: _1@Phi(bb434), _952@Mir(bb442[8])
  _3748 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  _954 = ((*_3748).0: *mut i8)
  using: _3748@Mir(bb443[1])
  _953 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _954, const 1_isize) -> bb444
  using: _954@Mir(bb443[2])
bb444:
  _3749 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  ((*_3749).0: *mut i8) = move _953
  using: _3749@Mir(bb444[0]), _953@Mir(bb443[3])
  _3750 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  _956 = ((*_3750).1: u32)
  using: _3750@Mir(bb444[2])
  _955 = core::num::<impl u32>::wrapping_sub(move _956, const 1_u32) -> bb445
  using: _956@Mir(bb444[3])
bb445:
  _3751 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  ((*_3751).1: u32) = move _955
  using: _3751@Mir(bb445[0]), _955@Mir(bb444[4])
  _3752 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  _958 = ((*_3752).2: u32)
  using: _3752@Mir(bb445[2])
  _957 = core::num::<impl u32>::wrapping_add(move _958, const 1_u32) -> bb446
  using: _958@Mir(bb445[3])
bb446:
  _3753 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  ((*_3753).2: u32) = move _957
  using: _3753@Mir(bb446[0]), _957@Mir(bb445[4])
  _3754 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  _960 = ((*_3754).2: u32)
  using: _3754@Mir(bb446[2])
  _961 = const 0_u32
  using: 
  _959 = Eq(move _960, move _961)
  using: _960@Mir(bb446[3]), _961@Mir(bb446[4])
  switchInt(move _959) -> [0: bb434, otherwise: bb447]
  using: _959@Mir(bb446[5])
bb447:
  _3755 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  _963 = ((*_3755).3: u32)
  using: _3755@Mir(bb447[0])
  _962 = core::num::<impl u32>::wrapping_add(move _963, const 1_u32) -> bb448
  using: _963@Mir(bb447[1])
bb448:
  _3756 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb434)
  ((*_3756).3: u32) = move _962
  using: _3756@Mir(bb448[0]), _962@Mir(bb447[2])
  goto -> bb434
  using: 
bb449:
  switchInt(_2) -> [15885526978618306830: bb471, otherwise: bb450]
  using: _2@Phi(bb449)
bb450:
  _965 = ((*_1).24: u32)
  using: _1@Phi(bb449)
  _966 = const 8_i32
  using: 
  _967 = CheckedShl(_965, _966)
  using: _965@Mir(bb450[0]), _966@Mir(bb450[1])
  assert(!move (_967.1: bool), "attempt to shift left by `{}`, which would overflow", move _966) -> bb451
  using: _967@Entry, _965@Entry, _966@Entry
bb451:
  _964 = move (_967.0: u32)
  using: _967@Mir(bb450[2])
  _969 = _3
  using: _3@Phi(bb449)
  _968 = move _969 as u32 (IntToInt)
  using: _969@Mir(bb451[1])
  ((*_1).24: u32) = BitOr(move _964, move _968)
  using: _1@Phi(bb449), _964@Mir(bb451[0]), _968@Mir(bb451[2])
  _2 = const 1975408140333322065_u64
  using: 
  goto -> bb471
  using: 
bb452:
  _970 = const 21_i32
  using: 
  ((*_1).1: i32) = move _970
  using: _1@Phi(bb449), _970@Mir(bb452[0])
  goto -> bb453
  using: 
bb453:
  _972 = ((*_1).8: i32)
  using: _1@Phi(bb453)
  _973 = const 8_i32
  using: 
  _971 = Ge(move _972, move _973)
  using: _972@Mir(bb453[0]), _973@Mir(bb453[1])
  switchInt(move _971) -> [0: bb455, otherwise: bb454]
  using: _971@Mir(bb453[2])
bb454:
  _974 = const 0_u32
  using: 
  _976 = ((*_1).7: u32)
  using: _1@Phi(bb453)
  _978 = ((*_1).8: i32)
  using: _1@Phi(bb453)
  _979 = const 8_i32
  using: 
  _980 = CheckedSub(_978, _979)
  using: _978@Mir(bb454[2]), _979@Mir(bb454[3])
  assert(!move (_980.1: bool), "attempt to compute `{} - {}`, which would overflow", move _978, move _979) -> bb456
  using: _980@Entry, _978@Entry, _979@Entry
bb455:
  _3757 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  _987 = ((*_3757).1: u32)
  using: _3757@Mir(bb455[0])
  _988 = const 0_u32
  using: 
  _986 = Eq(move _987, move _988)
  using: _987@Mir(bb455[1]), _988@Mir(bb455[2])
  switchInt(move _986) -> [0: bb460, otherwise: bb459]
  using: _986@Mir(bb455[3])
bb456:
  _977 = move (_980.0: i32)
  using: _980@Mir(bb454[4])
  _981 = CheckedShr(_976, _977)
  using: _976@Mir(bb454[1]), _977@Mir(bb456[0])
  assert(!move (_981.1: bool), "attempt to shift right by `{}`, which would overflow", move _977) -> bb457
  using: _981@Entry, _976@Entry, _977@Entry
bb457:
  _975 = move (_981.0: u32)
  using: _981@Mir(bb456[1])
  _982 = const 255_u32
  using: 
  _974 = BitAnd(move _975, move _982)
  using: _975@Mir(bb457[0]), _982@Mir(bb457[1])
  _983 = const 8_i32
  using: 
  _984 = CheckedSub(((*_1).8: i32), _983)
  using: _1@Phi(bb453), _983@Mir(bb457[3])
  assert(!move (_984.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _983) -> bb458
  using: _984@Entry, _1@Entry, _983@Entry
bb458:
  ((*_1).8: i32) = move (_984.0: i32)
  using: _1@Phi(bb453), _984@Mir(bb457[4])
  _985 = _974
  using: _974@Mir(bb457[2])
  _3 = move _985 as u8 (IntToInt)
  using: _985@Mir(bb458[1])
  _2 = const 16711521214030637000_u64
  using: 
  goto -> bb468
  using: 
bb459:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb468
  using: 
bb460:
  _990 = ((*_1).7: u32)
  using: _1@Phi(bb453)
  _991 = const 8_i32
  using: 
  _992 = CheckedShl(_990, _991)
  using: _990@Mir(bb460[0]), _991@Mir(bb460[1])
  assert(!move (_992.1: bool), "attempt to shift left by `{}`, which would overflow", move _991) -> bb461
  using: _992@Entry, _990@Entry, _991@Entry
bb461:
  _989 = move (_992.0: u32)
  using: _992@Mir(bb460[2])
  _3758 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  _996 = ((*_3758).0: *mut i8)
  using: _3758@Mir(bb461[1])
  _995 = move _996 as *mut u8 (PtrToPtr)
  using: _996@Mir(bb461[2])
  _994 = (*_995)
  using: _995@Mir(bb461[3])
  _993 = move _994 as u32 (IntToInt)
  using: _994@Mir(bb461[4])
  ((*_1).7: u32) = BitOr(move _989, move _993)
  using: _1@Phi(bb453), _989@Mir(bb461[0]), _993@Mir(bb461[5])
  _997 = const 8_i32
  using: 
  _998 = CheckedAdd(((*_1).8: i32), _997)
  using: _1@Phi(bb453), _997@Mir(bb461[7])
  assert(!move (_998.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _997) -> bb462
  using: _998@Entry, _1@Entry, _997@Entry
bb462:
  ((*_1).8: i32) = move (_998.0: i32)
  using: _1@Phi(bb453), _998@Mir(bb461[8])
  _3759 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  _1000 = ((*_3759).0: *mut i8)
  using: _3759@Mir(bb462[1])
  _999 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1000, const 1_isize) -> bb463
  using: _1000@Mir(bb462[2])
bb463:
  _3760 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  ((*_3760).0: *mut i8) = move _999
  using: _3760@Mir(bb463[0]), _999@Mir(bb462[3])
  _3761 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  _1002 = ((*_3761).1: u32)
  using: _3761@Mir(bb463[2])
  _1001 = core::num::<impl u32>::wrapping_sub(move _1002, const 1_u32) -> bb464
  using: _1002@Mir(bb463[3])
bb464:
  _3762 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  ((*_3762).1: u32) = move _1001
  using: _3762@Mir(bb464[0]), _1001@Mir(bb463[4])
  _3763 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  _1004 = ((*_3763).2: u32)
  using: _3763@Mir(bb464[2])
  _1003 = core::num::<impl u32>::wrapping_add(move _1004, const 1_u32) -> bb465
  using: _1004@Mir(bb464[3])
bb465:
  _3764 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  ((*_3764).2: u32) = move _1003
  using: _3764@Mir(bb465[0]), _1003@Mir(bb464[4])
  _3765 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  _1006 = ((*_3765).2: u32)
  using: _3765@Mir(bb465[2])
  _1007 = const 0_u32
  using: 
  _1005 = Eq(move _1006, move _1007)
  using: _1006@Mir(bb465[3]), _1007@Mir(bb465[4])
  switchInt(move _1005) -> [0: bb453, otherwise: bb466]
  using: _1005@Mir(bb465[5])
bb466:
  _3766 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  _1009 = ((*_3766).3: u32)
  using: _3766@Mir(bb466[0])
  _1008 = core::num::<impl u32>::wrapping_add(move _1009, const 1_u32) -> bb467
  using: _1009@Mir(bb466[1])
bb467:
  _3767 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb453)
  ((*_3767).3: u32) = move _1008
  using: _3767@Mir(bb467[0]), _1008@Mir(bb466[2])
  goto -> bb453
  using: 
bb468:
  switchInt(_2) -> [15885526978618306830: bb471, otherwise: bb469]
  using: _2@Phi(bb468)
bb469:
  _1011 = ((*_1).23: u32)
  using: _1@Phi(bb468)
  _1012 = const 8_i32
  using: 
  _1013 = CheckedShl(_1011, _1012)
  using: _1011@Mir(bb469[0]), _1012@Mir(bb469[1])
  assert(!move (_1013.1: bool), "attempt to shift left by `{}`, which would overflow", move _1012) -> bb470
  using: _1013@Entry, _1011@Entry, _1012@Entry
bb470:
  _1010 = move (_1013.0: u32)
  using: _1013@Mir(bb469[2])
  _1015 = _3
  using: _3@Phi(bb468)
  _1014 = move _1015 as u32 (IntToInt)
  using: _1015@Mir(bb470[1])
  ((*_1).23: u32) = BitOr(move _1010, move _1014)
  using: _1@Phi(bb468), _1010@Mir(bb470[0]), _1014@Mir(bb470[2])
  _2 = const 14563596112884461881_u64
  using: 
  goto -> bb471
  using: 
bb471:
  switchInt(_2) -> [1975408140333322065: bb472, 14563596112884461881: bb491, otherwise: bb510]
  using: _2@Phi(bb471)
bb472:
  _1016 = const 49_i32
  using: 
  ((*_1).1: i32) = move _1016
  using: _1@Phi(bb471), _1016@Mir(bb472[0])
  goto -> bb473
  using: 
bb473:
  _1018 = ((*_1).8: i32)
  using: _1@Phi(bb473)
  _1019 = const 8_i32
  using: 
  _1017 = Ge(move _1018, move _1019)
  using: _1018@Mir(bb473[0]), _1019@Mir(bb473[1])
  switchInt(move _1017) -> [0: bb475, otherwise: bb474]
  using: _1017@Mir(bb473[2])
bb474:
  _1020 = const 0_u32
  using: 
  _1022 = ((*_1).7: u32)
  using: _1@Phi(bb473)
  _1024 = ((*_1).8: i32)
  using: _1@Phi(bb473)
  _1025 = const 8_i32
  using: 
  _1026 = CheckedSub(_1024, _1025)
  using: _1024@Mir(bb474[2]), _1025@Mir(bb474[3])
  assert(!move (_1026.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1024, move _1025) -> bb476
  using: _1026@Entry, _1024@Entry, _1025@Entry
bb475:
  _3768 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  _1033 = ((*_3768).1: u32)
  using: _3768@Mir(bb475[0])
  _1034 = const 0_u32
  using: 
  _1032 = Eq(move _1033, move _1034)
  using: _1033@Mir(bb475[1]), _1034@Mir(bb475[2])
  switchInt(move _1032) -> [0: bb480, otherwise: bb479]
  using: _1032@Mir(bb475[3])
bb476:
  _1023 = move (_1026.0: i32)
  using: _1026@Mir(bb474[4])
  _1027 = CheckedShr(_1022, _1023)
  using: _1022@Mir(bb474[1]), _1023@Mir(bb476[0])
  assert(!move (_1027.1: bool), "attempt to shift right by `{}`, which would overflow", move _1023) -> bb477
  using: _1027@Entry, _1022@Entry, _1023@Entry
bb477:
  _1021 = move (_1027.0: u32)
  using: _1027@Mir(bb476[1])
  _1028 = const 255_u32
  using: 
  _1020 = BitAnd(move _1021, move _1028)
  using: _1021@Mir(bb477[0]), _1028@Mir(bb477[1])
  _1029 = const 8_i32
  using: 
  _1030 = CheckedSub(((*_1).8: i32), _1029)
  using: _1@Phi(bb473), _1029@Mir(bb477[3])
  assert(!move (_1030.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1029) -> bb478
  using: _1030@Entry, _1@Entry, _1029@Entry
bb478:
  ((*_1).8: i32) = move (_1030.0: i32)
  using: _1@Phi(bb473), _1030@Mir(bb477[4])
  _1031 = _1020
  using: _1020@Mir(bb477[2])
  _3 = move _1031 as u8 (IntToInt)
  using: _1031@Mir(bb478[1])
  _2 = const 2394045633138979148_u64
  using: 
  goto -> bb488
  using: 
bb479:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb488
  using: 
bb480:
  _1036 = ((*_1).7: u32)
  using: _1@Phi(bb473)
  _1037 = const 8_i32
  using: 
  _1038 = CheckedShl(_1036, _1037)
  using: _1036@Mir(bb480[0]), _1037@Mir(bb480[1])
  assert(!move (_1038.1: bool), "attempt to shift left by `{}`, which would overflow", move _1037) -> bb481
  using: _1038@Entry, _1036@Entry, _1037@Entry
bb481:
  _1035 = move (_1038.0: u32)
  using: _1038@Mir(bb480[2])
  _3769 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  _1042 = ((*_3769).0: *mut i8)
  using: _3769@Mir(bb481[1])
  _1041 = move _1042 as *mut u8 (PtrToPtr)
  using: _1042@Mir(bb481[2])
  _1040 = (*_1041)
  using: _1041@Mir(bb481[3])
  _1039 = move _1040 as u32 (IntToInt)
  using: _1040@Mir(bb481[4])
  ((*_1).7: u32) = BitOr(move _1035, move _1039)
  using: _1@Phi(bb473), _1035@Mir(bb481[0]), _1039@Mir(bb481[5])
  _1043 = const 8_i32
  using: 
  _1044 = CheckedAdd(((*_1).8: i32), _1043)
  using: _1@Phi(bb473), _1043@Mir(bb481[7])
  assert(!move (_1044.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1043) -> bb482
  using: _1044@Entry, _1@Entry, _1043@Entry
bb482:
  ((*_1).8: i32) = move (_1044.0: i32)
  using: _1@Phi(bb473), _1044@Mir(bb481[8])
  _3770 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  _1046 = ((*_3770).0: *mut i8)
  using: _3770@Mir(bb482[1])
  _1045 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1046, const 1_isize) -> bb483
  using: _1046@Mir(bb482[2])
bb483:
  _3771 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  ((*_3771).0: *mut i8) = move _1045
  using: _3771@Mir(bb483[0]), _1045@Mir(bb482[3])
  _3772 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  _1048 = ((*_3772).1: u32)
  using: _3772@Mir(bb483[2])
  _1047 = core::num::<impl u32>::wrapping_sub(move _1048, const 1_u32) -> bb484
  using: _1048@Mir(bb483[3])
bb484:
  _3773 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  ((*_3773).1: u32) = move _1047
  using: _3773@Mir(bb484[0]), _1047@Mir(bb483[4])
  _3774 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  _1050 = ((*_3774).2: u32)
  using: _3774@Mir(bb484[2])
  _1049 = core::num::<impl u32>::wrapping_add(move _1050, const 1_u32) -> bb485
  using: _1050@Mir(bb484[3])
bb485:
  _3775 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  ((*_3775).2: u32) = move _1049
  using: _3775@Mir(bb485[0]), _1049@Mir(bb484[4])
  _3776 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  _1052 = ((*_3776).2: u32)
  using: _3776@Mir(bb485[2])
  _1053 = const 0_u32
  using: 
  _1051 = Eq(move _1052, move _1053)
  using: _1052@Mir(bb485[3]), _1053@Mir(bb485[4])
  switchInt(move _1051) -> [0: bb473, otherwise: bb486]
  using: _1051@Mir(bb485[5])
bb486:
  _3777 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  _1055 = ((*_3777).3: u32)
  using: _3777@Mir(bb486[0])
  _1054 = core::num::<impl u32>::wrapping_add(move _1055, const 1_u32) -> bb487
  using: _1055@Mir(bb486[1])
bb487:
  _3778 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb473)
  ((*_3778).3: u32) = move _1054
  using: _3778@Mir(bb487[0]), _1054@Mir(bb486[2])
  goto -> bb473
  using: 
bb488:
  switchInt(_2) -> [15885526978618306830: bb510, otherwise: bb489]
  using: _2@Phi(bb488)
bb489:
  _1057 = ((*_1).24: u32)
  using: _1@Phi(bb488)
  _1058 = const 8_i32
  using: 
  _1059 = CheckedShl(_1057, _1058)
  using: _1057@Mir(bb489[0]), _1058@Mir(bb489[1])
  assert(!move (_1059.1: bool), "attempt to shift left by `{}`, which would overflow", move _1058) -> bb490
  using: _1059@Entry, _1057@Entry, _1058@Entry
bb490:
  _1056 = move (_1059.0: u32)
  using: _1059@Mir(bb489[2])
  _1061 = _3
  using: _3@Phi(bb488)
  _1060 = move _1061 as u32 (IntToInt)
  using: _1061@Mir(bb490[1])
  ((*_1).24: u32) = BitOr(move _1056, move _1060)
  using: _1@Phi(bb488), _1056@Mir(bb490[0]), _1060@Mir(bb490[2])
  _2 = const 15818179691129344165_u64
  using: 
  goto -> bb510
  using: 
bb491:
  _1062 = const 22_i32
  using: 
  ((*_1).1: i32) = move _1062
  using: _1@Phi(bb488), _1062@Mir(bb491[0])
  goto -> bb492
  using: 
bb492:
  _1064 = ((*_1).8: i32)
  using: _1@Phi(bb492)
  _1065 = const 8_i32
  using: 
  _1063 = Ge(move _1064, move _1065)
  using: _1064@Mir(bb492[0]), _1065@Mir(bb492[1])
  switchInt(move _1063) -> [0: bb494, otherwise: bb493]
  using: _1063@Mir(bb492[2])
bb493:
  _1066 = const 0_u32
  using: 
  _1068 = ((*_1).7: u32)
  using: _1@Phi(bb492)
  _1070 = ((*_1).8: i32)
  using: _1@Phi(bb492)
  _1071 = const 8_i32
  using: 
  _1072 = CheckedSub(_1070, _1071)
  using: _1070@Mir(bb493[2]), _1071@Mir(bb493[3])
  assert(!move (_1072.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1070, move _1071) -> bb495
  using: _1072@Entry, _1070@Entry, _1071@Entry
bb494:
  _3779 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  _1079 = ((*_3779).1: u32)
  using: _3779@Mir(bb494[0])
  _1080 = const 0_u32
  using: 
  _1078 = Eq(move _1079, move _1080)
  using: _1079@Mir(bb494[1]), _1080@Mir(bb494[2])
  switchInt(move _1078) -> [0: bb499, otherwise: bb498]
  using: _1078@Mir(bb494[3])
bb495:
  _1069 = move (_1072.0: i32)
  using: _1072@Mir(bb493[4])
  _1073 = CheckedShr(_1068, _1069)
  using: _1068@Mir(bb493[1]), _1069@Mir(bb495[0])
  assert(!move (_1073.1: bool), "attempt to shift right by `{}`, which would overflow", move _1069) -> bb496
  using: _1073@Entry, _1068@Entry, _1069@Entry
bb496:
  _1067 = move (_1073.0: u32)
  using: _1073@Mir(bb495[1])
  _1074 = const 255_u32
  using: 
  _1066 = BitAnd(move _1067, move _1074)
  using: _1067@Mir(bb496[0]), _1074@Mir(bb496[1])
  _1075 = const 8_i32
  using: 
  _1076 = CheckedSub(((*_1).8: i32), _1075)
  using: _1@Phi(bb492), _1075@Mir(bb496[3])
  assert(!move (_1076.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1075) -> bb497
  using: _1076@Entry, _1@Entry, _1075@Entry
bb497:
  ((*_1).8: i32) = move (_1076.0: i32)
  using: _1@Phi(bb492), _1076@Mir(bb496[4])
  _1077 = _1066
  using: _1066@Mir(bb496[2])
  _3 = move _1077 as u8 (IntToInt)
  using: _1077@Mir(bb497[1])
  _2 = const 17870985093275900527_u64
  using: 
  goto -> bb507
  using: 
bb498:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb507
  using: 
bb499:
  _1082 = ((*_1).7: u32)
  using: _1@Phi(bb492)
  _1083 = const 8_i32
  using: 
  _1084 = CheckedShl(_1082, _1083)
  using: _1082@Mir(bb499[0]), _1083@Mir(bb499[1])
  assert(!move (_1084.1: bool), "attempt to shift left by `{}`, which would overflow", move _1083) -> bb500
  using: _1084@Entry, _1082@Entry, _1083@Entry
bb500:
  _1081 = move (_1084.0: u32)
  using: _1084@Mir(bb499[2])
  _3780 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  _1088 = ((*_3780).0: *mut i8)
  using: _3780@Mir(bb500[1])
  _1087 = move _1088 as *mut u8 (PtrToPtr)
  using: _1088@Mir(bb500[2])
  _1086 = (*_1087)
  using: _1087@Mir(bb500[3])
  _1085 = move _1086 as u32 (IntToInt)
  using: _1086@Mir(bb500[4])
  ((*_1).7: u32) = BitOr(move _1081, move _1085)
  using: _1@Phi(bb492), _1081@Mir(bb500[0]), _1085@Mir(bb500[5])
  _1089 = const 8_i32
  using: 
  _1090 = CheckedAdd(((*_1).8: i32), _1089)
  using: _1@Phi(bb492), _1089@Mir(bb500[7])
  assert(!move (_1090.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1089) -> bb501
  using: _1090@Entry, _1@Entry, _1089@Entry
bb501:
  ((*_1).8: i32) = move (_1090.0: i32)
  using: _1@Phi(bb492), _1090@Mir(bb500[8])
  _3781 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  _1092 = ((*_3781).0: *mut i8)
  using: _3781@Mir(bb501[1])
  _1091 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1092, const 1_isize) -> bb502
  using: _1092@Mir(bb501[2])
bb502:
  _3782 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  ((*_3782).0: *mut i8) = move _1091
  using: _3782@Mir(bb502[0]), _1091@Mir(bb501[3])
  _3783 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  _1094 = ((*_3783).1: u32)
  using: _3783@Mir(bb502[2])
  _1093 = core::num::<impl u32>::wrapping_sub(move _1094, const 1_u32) -> bb503
  using: _1094@Mir(bb502[3])
bb503:
  _3784 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  ((*_3784).1: u32) = move _1093
  using: _3784@Mir(bb503[0]), _1093@Mir(bb502[4])
  _3785 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  _1096 = ((*_3785).2: u32)
  using: _3785@Mir(bb503[2])
  _1095 = core::num::<impl u32>::wrapping_add(move _1096, const 1_u32) -> bb504
  using: _1096@Mir(bb503[3])
bb504:
  _3786 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  ((*_3786).2: u32) = move _1095
  using: _3786@Mir(bb504[0]), _1095@Mir(bb503[4])
  _3787 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  _1098 = ((*_3787).2: u32)
  using: _3787@Mir(bb504[2])
  _1099 = const 0_u32
  using: 
  _1097 = Eq(move _1098, move _1099)
  using: _1098@Mir(bb504[3]), _1099@Mir(bb504[4])
  switchInt(move _1097) -> [0: bb492, otherwise: bb505]
  using: _1097@Mir(bb504[5])
bb505:
  _3788 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  _1101 = ((*_3788).3: u32)
  using: _3788@Mir(bb505[0])
  _1100 = core::num::<impl u32>::wrapping_add(move _1101, const 1_u32) -> bb506
  using: _1101@Mir(bb505[1])
bb506:
  _3789 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb492)
  ((*_3789).3: u32) = move _1100
  using: _3789@Mir(bb506[0]), _1100@Mir(bb505[2])
  goto -> bb492
  using: 
bb507:
  switchInt(_2) -> [15885526978618306830: bb510, otherwise: bb508]
  using: _2@Phi(bb507)
bb508:
  _1103 = ((*_1).23: u32)
  using: _1@Phi(bb507)
  _1104 = const 8_i32
  using: 
  _1105 = CheckedShl(_1103, _1104)
  using: _1103@Mir(bb508[0]), _1104@Mir(bb508[1])
  assert(!move (_1105.1: bool), "attempt to shift left by `{}`, which would overflow", move _1104) -> bb509
  using: _1105@Entry, _1103@Entry, _1104@Entry
bb509:
  _1102 = move (_1105.0: u32)
  using: _1105@Mir(bb508[2])
  _1107 = _3
  using: _3@Phi(bb507)
  _1106 = move _1107 as u32 (IntToInt)
  using: _1107@Mir(bb509[1])
  ((*_1).23: u32) = BitOr(move _1102, move _1106)
  using: _1@Phi(bb507), _1102@Mir(bb509[0]), _1106@Mir(bb509[2])
  _2 = const 12051594319698232578_u64
  using: 
  goto -> bb510
  using: 
bb510:
  switchInt(_2) -> [12051594319698232578: bb511, 15818179691129344165: bb530, otherwise: bb549]
  using: _2@Phi(bb510)
bb511:
  _1108 = const 23_i32
  using: 
  ((*_1).1: i32) = move _1108
  using: _1@Phi(bb510), _1108@Mir(bb511[0])
  goto -> bb512
  using: 
bb512:
  _1110 = ((*_1).8: i32)
  using: _1@Phi(bb512)
  _1111 = const 8_i32
  using: 
  _1109 = Ge(move _1110, move _1111)
  using: _1110@Mir(bb512[0]), _1111@Mir(bb512[1])
  switchInt(move _1109) -> [0: bb514, otherwise: bb513]
  using: _1109@Mir(bb512[2])
bb513:
  _1112 = const 0_u32
  using: 
  _1114 = ((*_1).7: u32)
  using: _1@Phi(bb512)
  _1116 = ((*_1).8: i32)
  using: _1@Phi(bb512)
  _1117 = const 8_i32
  using: 
  _1118 = CheckedSub(_1116, _1117)
  using: _1116@Mir(bb513[2]), _1117@Mir(bb513[3])
  assert(!move (_1118.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1116, move _1117) -> bb515
  using: _1118@Entry, _1116@Entry, _1117@Entry
bb514:
  _3790 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  _1125 = ((*_3790).1: u32)
  using: _3790@Mir(bb514[0])
  _1126 = const 0_u32
  using: 
  _1124 = Eq(move _1125, move _1126)
  using: _1125@Mir(bb514[1]), _1126@Mir(bb514[2])
  switchInt(move _1124) -> [0: bb519, otherwise: bb518]
  using: _1124@Mir(bb514[3])
bb515:
  _1115 = move (_1118.0: i32)
  using: _1118@Mir(bb513[4])
  _1119 = CheckedShr(_1114, _1115)
  using: _1114@Mir(bb513[1]), _1115@Mir(bb515[0])
  assert(!move (_1119.1: bool), "attempt to shift right by `{}`, which would overflow", move _1115) -> bb516
  using: _1119@Entry, _1114@Entry, _1115@Entry
bb516:
  _1113 = move (_1119.0: u32)
  using: _1119@Mir(bb515[1])
  _1120 = const 255_u32
  using: 
  _1112 = BitAnd(move _1113, move _1120)
  using: _1113@Mir(bb516[0]), _1120@Mir(bb516[1])
  _1121 = const 8_i32
  using: 
  _1122 = CheckedSub(((*_1).8: i32), _1121)
  using: _1@Phi(bb512), _1121@Mir(bb516[3])
  assert(!move (_1122.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1121) -> bb517
  using: _1122@Entry, _1@Entry, _1121@Entry
bb517:
  ((*_1).8: i32) = move (_1122.0: i32)
  using: _1@Phi(bb512), _1122@Mir(bb516[4])
  _1123 = _1112
  using: _1112@Mir(bb516[2])
  _3 = move _1123 as u8 (IntToInt)
  using: _1123@Mir(bb517[1])
  _2 = const 13734492969709581318_u64
  using: 
  goto -> bb527
  using: 
bb518:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb527
  using: 
bb519:
  _1128 = ((*_1).7: u32)
  using: _1@Phi(bb512)
  _1129 = const 8_i32
  using: 
  _1130 = CheckedShl(_1128, _1129)
  using: _1128@Mir(bb519[0]), _1129@Mir(bb519[1])
  assert(!move (_1130.1: bool), "attempt to shift left by `{}`, which would overflow", move _1129) -> bb520
  using: _1130@Entry, _1128@Entry, _1129@Entry
bb520:
  _1127 = move (_1130.0: u32)
  using: _1130@Mir(bb519[2])
  _3791 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  _1134 = ((*_3791).0: *mut i8)
  using: _3791@Mir(bb520[1])
  _1133 = move _1134 as *mut u8 (PtrToPtr)
  using: _1134@Mir(bb520[2])
  _1132 = (*_1133)
  using: _1133@Mir(bb520[3])
  _1131 = move _1132 as u32 (IntToInt)
  using: _1132@Mir(bb520[4])
  ((*_1).7: u32) = BitOr(move _1127, move _1131)
  using: _1@Phi(bb512), _1127@Mir(bb520[0]), _1131@Mir(bb520[5])
  _1135 = const 8_i32
  using: 
  _1136 = CheckedAdd(((*_1).8: i32), _1135)
  using: _1@Phi(bb512), _1135@Mir(bb520[7])
  assert(!move (_1136.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1135) -> bb521
  using: _1136@Entry, _1@Entry, _1135@Entry
bb521:
  ((*_1).8: i32) = move (_1136.0: i32)
  using: _1@Phi(bb512), _1136@Mir(bb520[8])
  _3792 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  _1138 = ((*_3792).0: *mut i8)
  using: _3792@Mir(bb521[1])
  _1137 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1138, const 1_isize) -> bb522
  using: _1138@Mir(bb521[2])
bb522:
  _3793 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  ((*_3793).0: *mut i8) = move _1137
  using: _3793@Mir(bb522[0]), _1137@Mir(bb521[3])
  _3794 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  _1140 = ((*_3794).1: u32)
  using: _3794@Mir(bb522[2])
  _1139 = core::num::<impl u32>::wrapping_sub(move _1140, const 1_u32) -> bb523
  using: _1140@Mir(bb522[3])
bb523:
  _3795 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  ((*_3795).1: u32) = move _1139
  using: _3795@Mir(bb523[0]), _1139@Mir(bb522[4])
  _3796 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  _1142 = ((*_3796).2: u32)
  using: _3796@Mir(bb523[2])
  _1141 = core::num::<impl u32>::wrapping_add(move _1142, const 1_u32) -> bb524
  using: _1142@Mir(bb523[3])
bb524:
  _3797 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  ((*_3797).2: u32) = move _1141
  using: _3797@Mir(bb524[0]), _1141@Mir(bb523[4])
  _3798 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  _1144 = ((*_3798).2: u32)
  using: _3798@Mir(bb524[2])
  _1145 = const 0_u32
  using: 
  _1143 = Eq(move _1144, move _1145)
  using: _1144@Mir(bb524[3]), _1145@Mir(bb524[4])
  switchInt(move _1143) -> [0: bb512, otherwise: bb525]
  using: _1143@Mir(bb524[5])
bb525:
  _3799 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  _1147 = ((*_3799).3: u32)
  using: _3799@Mir(bb525[0])
  _1146 = core::num::<impl u32>::wrapping_add(move _1147, const 1_u32) -> bb526
  using: _1147@Mir(bb525[1])
bb526:
  _3800 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb512)
  ((*_3800).3: u32) = move _1146
  using: _3800@Mir(bb526[0]), _1146@Mir(bb525[2])
  goto -> bb512
  using: 
bb527:
  switchInt(_2) -> [15885526978618306830: bb549, otherwise: bb528]
  using: _2@Phi(bb527)
bb528:
  _1149 = ((*_1).23: u32)
  using: _1@Phi(bb527)
  _1150 = const 8_i32
  using: 
  _1151 = CheckedShl(_1149, _1150)
  using: _1149@Mir(bb528[0]), _1150@Mir(bb528[1])
  assert(!move (_1151.1: bool), "attempt to shift left by `{}`, which would overflow", move _1150) -> bb529
  using: _1151@Entry, _1149@Entry, _1150@Entry
bb529:
  _1148 = move (_1151.0: u32)
  using: _1151@Mir(bb528[2])
  _1153 = _3
  using: _3@Phi(bb527)
  _1152 = move _1153 as u32 (IntToInt)
  using: _1153@Mir(bb529[1])
  ((*_1).23: u32) = BitOr(move _1148, move _1152)
  using: _1@Phi(bb527), _1148@Mir(bb529[0]), _1152@Mir(bb529[2])
  _2 = const 14315698657705028467_u64
  using: 
  goto -> bb549
  using: 
bb530:
  _1154 = const 50_i32
  using: 
  ((*_1).1: i32) = move _1154
  using: _1@Phi(bb527), _1154@Mir(bb530[0])
  goto -> bb531
  using: 
bb531:
  _1156 = ((*_1).8: i32)
  using: _1@Phi(bb531)
  _1157 = const 8_i32
  using: 
  _1155 = Ge(move _1156, move _1157)
  using: _1156@Mir(bb531[0]), _1157@Mir(bb531[1])
  switchInt(move _1155) -> [0: bb533, otherwise: bb532]
  using: _1155@Mir(bb531[2])
bb532:
  _1158 = const 0_u32
  using: 
  _1160 = ((*_1).7: u32)
  using: _1@Phi(bb531)
  _1162 = ((*_1).8: i32)
  using: _1@Phi(bb531)
  _1163 = const 8_i32
  using: 
  _1164 = CheckedSub(_1162, _1163)
  using: _1162@Mir(bb532[2]), _1163@Mir(bb532[3])
  assert(!move (_1164.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1162, move _1163) -> bb534
  using: _1164@Entry, _1162@Entry, _1163@Entry
bb533:
  _3801 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  _1171 = ((*_3801).1: u32)
  using: _3801@Mir(bb533[0])
  _1172 = const 0_u32
  using: 
  _1170 = Eq(move _1171, move _1172)
  using: _1171@Mir(bb533[1]), _1172@Mir(bb533[2])
  switchInt(move _1170) -> [0: bb538, otherwise: bb537]
  using: _1170@Mir(bb533[3])
bb534:
  _1161 = move (_1164.0: i32)
  using: _1164@Mir(bb532[4])
  _1165 = CheckedShr(_1160, _1161)
  using: _1160@Mir(bb532[1]), _1161@Mir(bb534[0])
  assert(!move (_1165.1: bool), "attempt to shift right by `{}`, which would overflow", move _1161) -> bb535
  using: _1165@Entry, _1160@Entry, _1161@Entry
bb535:
  _1159 = move (_1165.0: u32)
  using: _1165@Mir(bb534[1])
  _1166 = const 255_u32
  using: 
  _1158 = BitAnd(move _1159, move _1166)
  using: _1159@Mir(bb535[0]), _1166@Mir(bb535[1])
  _1167 = const 8_i32
  using: 
  _1168 = CheckedSub(((*_1).8: i32), _1167)
  using: _1@Phi(bb531), _1167@Mir(bb535[3])
  assert(!move (_1168.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1167) -> bb536
  using: _1168@Entry, _1@Entry, _1167@Entry
bb536:
  ((*_1).8: i32) = move (_1168.0: i32)
  using: _1@Phi(bb531), _1168@Mir(bb535[4])
  _1169 = _1158
  using: _1158@Mir(bb535[2])
  _3 = move _1169 as u8 (IntToInt)
  using: _1169@Mir(bb536[1])
  _2 = const 1904329045571868869_u64
  using: 
  goto -> bb546
  using: 
bb537:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb546
  using: 
bb538:
  _1174 = ((*_1).7: u32)
  using: _1@Phi(bb531)
  _1175 = const 8_i32
  using: 
  _1176 = CheckedShl(_1174, _1175)
  using: _1174@Mir(bb538[0]), _1175@Mir(bb538[1])
  assert(!move (_1176.1: bool), "attempt to shift left by `{}`, which would overflow", move _1175) -> bb539
  using: _1176@Entry, _1174@Entry, _1175@Entry
bb539:
  _1173 = move (_1176.0: u32)
  using: _1176@Mir(bb538[2])
  _3802 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  _1180 = ((*_3802).0: *mut i8)
  using: _3802@Mir(bb539[1])
  _1179 = move _1180 as *mut u8 (PtrToPtr)
  using: _1180@Mir(bb539[2])
  _1178 = (*_1179)
  using: _1179@Mir(bb539[3])
  _1177 = move _1178 as u32 (IntToInt)
  using: _1178@Mir(bb539[4])
  ((*_1).7: u32) = BitOr(move _1173, move _1177)
  using: _1@Phi(bb531), _1173@Mir(bb539[0]), _1177@Mir(bb539[5])
  _1181 = const 8_i32
  using: 
  _1182 = CheckedAdd(((*_1).8: i32), _1181)
  using: _1@Phi(bb531), _1181@Mir(bb539[7])
  assert(!move (_1182.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1181) -> bb540
  using: _1182@Entry, _1@Entry, _1181@Entry
bb540:
  ((*_1).8: i32) = move (_1182.0: i32)
  using: _1@Phi(bb531), _1182@Mir(bb539[8])
  _3803 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  _1184 = ((*_3803).0: *mut i8)
  using: _3803@Mir(bb540[1])
  _1183 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1184, const 1_isize) -> bb541
  using: _1184@Mir(bb540[2])
bb541:
  _3804 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  ((*_3804).0: *mut i8) = move _1183
  using: _3804@Mir(bb541[0]), _1183@Mir(bb540[3])
  _3805 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  _1186 = ((*_3805).1: u32)
  using: _3805@Mir(bb541[2])
  _1185 = core::num::<impl u32>::wrapping_sub(move _1186, const 1_u32) -> bb542
  using: _1186@Mir(bb541[3])
bb542:
  _3806 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  ((*_3806).1: u32) = move _1185
  using: _3806@Mir(bb542[0]), _1185@Mir(bb541[4])
  _3807 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  _1188 = ((*_3807).2: u32)
  using: _3807@Mir(bb542[2])
  _1187 = core::num::<impl u32>::wrapping_add(move _1188, const 1_u32) -> bb543
  using: _1188@Mir(bb542[3])
bb543:
  _3808 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  ((*_3808).2: u32) = move _1187
  using: _3808@Mir(bb543[0]), _1187@Mir(bb542[4])
  _3809 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  _1190 = ((*_3809).2: u32)
  using: _3809@Mir(bb543[2])
  _1191 = const 0_u32
  using: 
  _1189 = Eq(move _1190, move _1191)
  using: _1190@Mir(bb543[3]), _1191@Mir(bb543[4])
  switchInt(move _1189) -> [0: bb531, otherwise: bb544]
  using: _1189@Mir(bb543[5])
bb544:
  _3810 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  _1193 = ((*_3810).3: u32)
  using: _3810@Mir(bb544[0])
  _1192 = core::num::<impl u32>::wrapping_add(move _1193, const 1_u32) -> bb545
  using: _1193@Mir(bb544[1])
bb545:
  _3811 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb531)
  ((*_3811).3: u32) = move _1192
  using: _3811@Mir(bb545[0]), _1192@Mir(bb544[2])
  goto -> bb531
  using: 
bb546:
  switchInt(_2) -> [15885526978618306830: bb549, otherwise: bb547]
  using: _2@Phi(bb546)
bb547:
  _1195 = ((*_1).24: u32)
  using: _1@Phi(bb546)
  _1196 = const 8_i32
  using: 
  _1197 = CheckedShl(_1195, _1196)
  using: _1195@Mir(bb547[0]), _1196@Mir(bb547[1])
  assert(!move (_1197.1: bool), "attempt to shift left by `{}`, which would overflow", move _1196) -> bb548
  using: _1197@Entry, _1195@Entry, _1196@Entry
bb548:
  _1194 = move (_1197.0: u32)
  using: _1197@Mir(bb547[2])
  _1199 = _3
  using: _3@Phi(bb546)
  _1198 = move _1199 as u32 (IntToInt)
  using: _1199@Mir(bb548[1])
  ((*_1).24: u32) = BitOr(move _1194, move _1198)
  using: _1@Phi(bb546), _1194@Mir(bb548[0]), _1198@Mir(bb548[2])
  _1200 = const 1_i32
  using: 
  ((*_1).1: i32) = move _1200
  using: _1@Phi(bb546), _1200@Mir(bb548[4])
  _4 = const 4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb549
  using: 
bb549:
  switchInt(_2) -> [14315698657705028467: bb550, otherwise: bb568]
  using: _2@Phi(bb549)
bb550:
  _1201 = const 24_i32
  using: 
  ((*_1).1: i32) = move _1201
  using: _1@Phi(bb549), _1201@Mir(bb550[0])
  goto -> bb551
  using: 
bb551:
  _1203 = ((*_1).8: i32)
  using: _1@Phi(bb551)
  _1204 = const 1_i32
  using: 
  _1202 = Ge(move _1203, move _1204)
  using: _1203@Mir(bb551[0]), _1204@Mir(bb551[1])
  switchInt(move _1202) -> [0: bb553, otherwise: bb552]
  using: _1202@Mir(bb551[2])
bb552:
  _1205 = const 0_u32
  using: 
  _1207 = ((*_1).7: u32)
  using: _1@Phi(bb551)
  _1209 = ((*_1).8: i32)
  using: _1@Phi(bb551)
  _1210 = const 1_i32
  using: 
  _1211 = CheckedSub(_1209, _1210)
  using: _1209@Mir(bb552[2]), _1210@Mir(bb552[3])
  assert(!move (_1211.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1209, move _1210) -> bb554
  using: _1211@Entry, _1209@Entry, _1210@Entry
bb553:
  _3812 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  _1218 = ((*_3812).1: u32)
  using: _3812@Mir(bb553[0])
  _1219 = const 0_u32
  using: 
  _1217 = Eq(move _1218, move _1219)
  using: _1218@Mir(bb553[1]), _1219@Mir(bb553[2])
  switchInt(move _1217) -> [0: bb558, otherwise: bb557]
  using: _1217@Mir(bb553[3])
bb554:
  _1208 = move (_1211.0: i32)
  using: _1211@Mir(bb552[4])
  _1212 = CheckedShr(_1207, _1208)
  using: _1207@Mir(bb552[1]), _1208@Mir(bb554[0])
  assert(!move (_1212.1: bool), "attempt to shift right by `{}`, which would overflow", move _1208) -> bb555
  using: _1212@Entry, _1207@Entry, _1208@Entry
bb555:
  _1206 = move (_1212.0: u32)
  using: _1212@Mir(bb554[1])
  _1213 = const 1_u32
  using: 
  _1205 = BitAnd(move _1206, move _1213)
  using: _1206@Mir(bb555[0]), _1213@Mir(bb555[1])
  _1214 = const 1_i32
  using: 
  _1215 = CheckedSub(((*_1).8: i32), _1214)
  using: _1@Phi(bb551), _1214@Mir(bb555[3])
  assert(!move (_1215.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1214) -> bb556
  using: _1215@Entry, _1@Entry, _1214@Entry
bb556:
  ((*_1).8: i32) = move (_1215.0: i32)
  using: _1@Phi(bb551), _1215@Mir(bb555[4])
  _1216 = _1205
  using: _1205@Mir(bb555[2])
  ((*_1).4: u8) = move _1216 as u8 (IntToInt)
  using: _1@Phi(bb551), _1216@Mir(bb556[1])
  _2 = const 15030729790988239748_u64
  using: 
  goto -> bb566
  using: 
bb557:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb566
  using: 
bb558:
  _1221 = ((*_1).7: u32)
  using: _1@Phi(bb551)
  _1222 = const 8_i32
  using: 
  _1223 = CheckedShl(_1221, _1222)
  using: _1221@Mir(bb558[0]), _1222@Mir(bb558[1])
  assert(!move (_1223.1: bool), "attempt to shift left by `{}`, which would overflow", move _1222) -> bb559
  using: _1223@Entry, _1221@Entry, _1222@Entry
bb559:
  _1220 = move (_1223.0: u32)
  using: _1223@Mir(bb558[2])
  _3813 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  _1227 = ((*_3813).0: *mut i8)
  using: _3813@Mir(bb559[1])
  _1226 = move _1227 as *mut u8 (PtrToPtr)
  using: _1227@Mir(bb559[2])
  _1225 = (*_1226)
  using: _1226@Mir(bb559[3])
  _1224 = move _1225 as u32 (IntToInt)
  using: _1225@Mir(bb559[4])
  ((*_1).7: u32) = BitOr(move _1220, move _1224)
  using: _1@Phi(bb551), _1220@Mir(bb559[0]), _1224@Mir(bb559[5])
  _1228 = const 8_i32
  using: 
  _1229 = CheckedAdd(((*_1).8: i32), _1228)
  using: _1@Phi(bb551), _1228@Mir(bb559[7])
  assert(!move (_1229.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1228) -> bb560
  using: _1229@Entry, _1@Entry, _1228@Entry
bb560:
  ((*_1).8: i32) = move (_1229.0: i32)
  using: _1@Phi(bb551), _1229@Mir(bb559[8])
  _3814 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  _1231 = ((*_3814).0: *mut i8)
  using: _3814@Mir(bb560[1])
  _1230 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1231, const 1_isize) -> bb561
  using: _1231@Mir(bb560[2])
bb561:
  _3815 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  ((*_3815).0: *mut i8) = move _1230
  using: _3815@Mir(bb561[0]), _1230@Mir(bb560[3])
  _3816 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  _1233 = ((*_3816).1: u32)
  using: _3816@Mir(bb561[2])
  _1232 = core::num::<impl u32>::wrapping_sub(move _1233, const 1_u32) -> bb562
  using: _1233@Mir(bb561[3])
bb562:
  _3817 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  ((*_3817).1: u32) = move _1232
  using: _3817@Mir(bb562[0]), _1232@Mir(bb561[4])
  _3818 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  _1235 = ((*_3818).2: u32)
  using: _3818@Mir(bb562[2])
  _1234 = core::num::<impl u32>::wrapping_add(move _1235, const 1_u32) -> bb563
  using: _1235@Mir(bb562[3])
bb563:
  _3819 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  ((*_3819).2: u32) = move _1234
  using: _3819@Mir(bb563[0]), _1234@Mir(bb562[4])
  _3820 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  _1237 = ((*_3820).2: u32)
  using: _3820@Mir(bb563[2])
  _1238 = const 0_u32
  using: 
  _1236 = Eq(move _1237, move _1238)
  using: _1237@Mir(bb563[3]), _1238@Mir(bb563[4])
  switchInt(move _1236) -> [0: bb551, otherwise: bb564]
  using: _1236@Mir(bb563[5])
bb564:
  _3821 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  _1240 = ((*_3821).3: u32)
  using: _3821@Mir(bb564[0])
  _1239 = core::num::<impl u32>::wrapping_add(move _1240, const 1_u32) -> bb565
  using: _1240@Mir(bb564[1])
bb565:
  _3822 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb551)
  ((*_3822).3: u32) = move _1239
  using: _3822@Mir(bb565[0]), _1239@Mir(bb564[2])
  goto -> bb551
  using: 
bb566:
  switchInt(_2) -> [15885526978618306830: bb568, otherwise: bb567]
  using: _2@Phi(bb566)
bb567:
  _1241 = const 0_i32
  using: 
  ((*_1).13: i32) = move _1241
  using: _1@Phi(bb566), _1241@Mir(bb567[0])
  _2 = const 640681092829779800_u64
  using: 
  goto -> bb568
  using: 
bb568:
  switchInt(_2) -> [640681092829779800: bb569, otherwise: bb588]
  using: _2@Phi(bb568)
bb569:
  _1242 = const 25_i32
  using: 
  ((*_1).1: i32) = move _1242
  using: _1@Phi(bb568), _1242@Mir(bb569[0])
  goto -> bb570
  using: 
bb570:
  _1244 = ((*_1).8: i32)
  using: _1@Phi(bb570)
  _1245 = const 8_i32
  using: 
  _1243 = Ge(move _1244, move _1245)
  using: _1244@Mir(bb570[0]), _1245@Mir(bb570[1])
  switchInt(move _1243) -> [0: bb572, otherwise: bb571]
  using: _1243@Mir(bb570[2])
bb571:
  _1246 = const 0_u32
  using: 
  _1248 = ((*_1).7: u32)
  using: _1@Phi(bb570)
  _1250 = ((*_1).8: i32)
  using: _1@Phi(bb570)
  _1251 = const 8_i32
  using: 
  _1252 = CheckedSub(_1250, _1251)
  using: _1250@Mir(bb571[2]), _1251@Mir(bb571[3])
  assert(!move (_1252.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1250, move _1251) -> bb573
  using: _1252@Entry, _1250@Entry, _1251@Entry
bb572:
  _3823 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  _1259 = ((*_3823).1: u32)
  using: _3823@Mir(bb572[0])
  _1260 = const 0_u32
  using: 
  _1258 = Eq(move _1259, move _1260)
  using: _1259@Mir(bb572[1]), _1260@Mir(bb572[2])
  switchInt(move _1258) -> [0: bb577, otherwise: bb576]
  using: _1258@Mir(bb572[3])
bb573:
  _1249 = move (_1252.0: i32)
  using: _1252@Mir(bb571[4])
  _1253 = CheckedShr(_1248, _1249)
  using: _1248@Mir(bb571[1]), _1249@Mir(bb573[0])
  assert(!move (_1253.1: bool), "attempt to shift right by `{}`, which would overflow", move _1249) -> bb574
  using: _1253@Entry, _1248@Entry, _1249@Entry
bb574:
  _1247 = move (_1253.0: u32)
  using: _1253@Mir(bb573[1])
  _1254 = const 255_u32
  using: 
  _1246 = BitAnd(move _1247, move _1254)
  using: _1247@Mir(bb574[0]), _1254@Mir(bb574[1])
  _1255 = const 8_i32
  using: 
  _1256 = CheckedSub(((*_1).8: i32), _1255)
  using: _1@Phi(bb570), _1255@Mir(bb574[3])
  assert(!move (_1256.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1255) -> bb575
  using: _1256@Entry, _1@Entry, _1255@Entry
bb575:
  ((*_1).8: i32) = move (_1256.0: i32)
  using: _1@Phi(bb570), _1256@Mir(bb574[4])
  _1257 = _1246
  using: _1246@Mir(bb574[2])
  _3 = move _1257 as u8 (IntToInt)
  using: _1257@Mir(bb575[1])
  _2 = const 8260322496947496197_u64
  using: 
  goto -> bb585
  using: 
bb576:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb585
  using: 
bb577:
  _1262 = ((*_1).7: u32)
  using: _1@Phi(bb570)
  _1263 = const 8_i32
  using: 
  _1264 = CheckedShl(_1262, _1263)
  using: _1262@Mir(bb577[0]), _1263@Mir(bb577[1])
  assert(!move (_1264.1: bool), "attempt to shift left by `{}`, which would overflow", move _1263) -> bb578
  using: _1264@Entry, _1262@Entry, _1263@Entry
bb578:
  _1261 = move (_1264.0: u32)
  using: _1264@Mir(bb577[2])
  _3824 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  _1268 = ((*_3824).0: *mut i8)
  using: _3824@Mir(bb578[1])
  _1267 = move _1268 as *mut u8 (PtrToPtr)
  using: _1268@Mir(bb578[2])
  _1266 = (*_1267)
  using: _1267@Mir(bb578[3])
  _1265 = move _1266 as u32 (IntToInt)
  using: _1266@Mir(bb578[4])
  ((*_1).7: u32) = BitOr(move _1261, move _1265)
  using: _1@Phi(bb570), _1261@Mir(bb578[0]), _1265@Mir(bb578[5])
  _1269 = const 8_i32
  using: 
  _1270 = CheckedAdd(((*_1).8: i32), _1269)
  using: _1@Phi(bb570), _1269@Mir(bb578[7])
  assert(!move (_1270.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1269) -> bb579
  using: _1270@Entry, _1@Entry, _1269@Entry
bb579:
  ((*_1).8: i32) = move (_1270.0: i32)
  using: _1@Phi(bb570), _1270@Mir(bb578[8])
  _3825 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  _1272 = ((*_3825).0: *mut i8)
  using: _3825@Mir(bb579[1])
  _1271 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1272, const 1_isize) -> bb580
  using: _1272@Mir(bb579[2])
bb580:
  _3826 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  ((*_3826).0: *mut i8) = move _1271
  using: _3826@Mir(bb580[0]), _1271@Mir(bb579[3])
  _3827 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  _1274 = ((*_3827).1: u32)
  using: _3827@Mir(bb580[2])
  _1273 = core::num::<impl u32>::wrapping_sub(move _1274, const 1_u32) -> bb581
  using: _1274@Mir(bb580[3])
bb581:
  _3828 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  ((*_3828).1: u32) = move _1273
  using: _3828@Mir(bb581[0]), _1273@Mir(bb580[4])
  _3829 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  _1276 = ((*_3829).2: u32)
  using: _3829@Mir(bb581[2])
  _1275 = core::num::<impl u32>::wrapping_add(move _1276, const 1_u32) -> bb582
  using: _1276@Mir(bb581[3])
bb582:
  _3830 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  ((*_3830).2: u32) = move _1275
  using: _3830@Mir(bb582[0]), _1275@Mir(bb581[4])
  _3831 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  _1278 = ((*_3831).2: u32)
  using: _3831@Mir(bb582[2])
  _1279 = const 0_u32
  using: 
  _1277 = Eq(move _1278, move _1279)
  using: _1278@Mir(bb582[3]), _1279@Mir(bb582[4])
  switchInt(move _1277) -> [0: bb570, otherwise: bb583]
  using: _1277@Mir(bb582[5])
bb583:
  _3832 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  _1281 = ((*_3832).3: u32)
  using: _3832@Mir(bb583[0])
  _1280 = core::num::<impl u32>::wrapping_add(move _1281, const 1_u32) -> bb584
  using: _1281@Mir(bb583[1])
bb584:
  _3833 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb570)
  ((*_3833).3: u32) = move _1280
  using: _3833@Mir(bb584[0]), _1280@Mir(bb583[2])
  goto -> bb570
  using: 
bb585:
  switchInt(_2) -> [15885526978618306830: bb588, otherwise: bb586]
  using: _2@Phi(bb585)
bb586:
  _1283 = ((*_1).13: i32)
  using: _1@Phi(bb585)
  _1284 = const 8_i32
  using: 
  _1285 = CheckedShl(_1283, _1284)
  using: _1283@Mir(bb586[0]), _1284@Mir(bb586[1])
  assert(!move (_1285.1: bool), "attempt to shift left by `{}`, which would overflow", move _1284) -> bb587
  using: _1285@Entry, _1283@Entry, _1284@Entry
bb587:
  _1282 = move (_1285.0: i32)
  using: _1285@Mir(bb586[2])
  _1287 = _3
  using: _3@Phi(bb585)
  _1286 = move _1287 as i32 (IntToInt)
  using: _1287@Mir(bb587[1])
  ((*_1).13: i32) = BitOr(move _1282, move _1286)
  using: _1@Phi(bb585), _1282@Mir(bb587[0]), _1286@Mir(bb587[2])
  _2 = const 588075840077989673_u64
  using: 
  goto -> bb588
  using: 
bb588:
  switchInt(_2) -> [588075840077989673: bb589, otherwise: bb608]
  using: _2@Phi(bb588)
bb589:
  _1288 = const 26_i32
  using: 
  ((*_1).1: i32) = move _1288
  using: _1@Phi(bb588), _1288@Mir(bb589[0])
  goto -> bb590
  using: 
bb590:
  _1290 = ((*_1).8: i32)
  using: _1@Phi(bb590)
  _1291 = const 8_i32
  using: 
  _1289 = Ge(move _1290, move _1291)
  using: _1290@Mir(bb590[0]), _1291@Mir(bb590[1])
  switchInt(move _1289) -> [0: bb592, otherwise: bb591]
  using: _1289@Mir(bb590[2])
bb591:
  _1292 = const 0_u32
  using: 
  _1294 = ((*_1).7: u32)
  using: _1@Phi(bb590)
  _1296 = ((*_1).8: i32)
  using: _1@Phi(bb590)
  _1297 = const 8_i32
  using: 
  _1298 = CheckedSub(_1296, _1297)
  using: _1296@Mir(bb591[2]), _1297@Mir(bb591[3])
  assert(!move (_1298.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1296, move _1297) -> bb593
  using: _1298@Entry, _1296@Entry, _1297@Entry
bb592:
  _3834 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  _1305 = ((*_3834).1: u32)
  using: _3834@Mir(bb592[0])
  _1306 = const 0_u32
  using: 
  _1304 = Eq(move _1305, move _1306)
  using: _1305@Mir(bb592[1]), _1306@Mir(bb592[2])
  switchInt(move _1304) -> [0: bb597, otherwise: bb596]
  using: _1304@Mir(bb592[3])
bb593:
  _1295 = move (_1298.0: i32)
  using: _1298@Mir(bb591[4])
  _1299 = CheckedShr(_1294, _1295)
  using: _1294@Mir(bb591[1]), _1295@Mir(bb593[0])
  assert(!move (_1299.1: bool), "attempt to shift right by `{}`, which would overflow", move _1295) -> bb594
  using: _1299@Entry, _1294@Entry, _1295@Entry
bb594:
  _1293 = move (_1299.0: u32)
  using: _1299@Mir(bb593[1])
  _1300 = const 255_u32
  using: 
  _1292 = BitAnd(move _1293, move _1300)
  using: _1293@Mir(bb594[0]), _1300@Mir(bb594[1])
  _1301 = const 8_i32
  using: 
  _1302 = CheckedSub(((*_1).8: i32), _1301)
  using: _1@Phi(bb590), _1301@Mir(bb594[3])
  assert(!move (_1302.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1301) -> bb595
  using: _1302@Entry, _1@Entry, _1301@Entry
bb595:
  ((*_1).8: i32) = move (_1302.0: i32)
  using: _1@Phi(bb590), _1302@Mir(bb594[4])
  _1303 = _1292
  using: _1292@Mir(bb594[2])
  _3 = move _1303 as u8 (IntToInt)
  using: _1303@Mir(bb595[1])
  _2 = const 5561851013817067674_u64
  using: 
  goto -> bb605
  using: 
bb596:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb605
  using: 
bb597:
  _1308 = ((*_1).7: u32)
  using: _1@Phi(bb590)
  _1309 = const 8_i32
  using: 
  _1310 = CheckedShl(_1308, _1309)
  using: _1308@Mir(bb597[0]), _1309@Mir(bb597[1])
  assert(!move (_1310.1: bool), "attempt to shift left by `{}`, which would overflow", move _1309) -> bb598
  using: _1310@Entry, _1308@Entry, _1309@Entry
bb598:
  _1307 = move (_1310.0: u32)
  using: _1310@Mir(bb597[2])
  _3835 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  _1314 = ((*_3835).0: *mut i8)
  using: _3835@Mir(bb598[1])
  _1313 = move _1314 as *mut u8 (PtrToPtr)
  using: _1314@Mir(bb598[2])
  _1312 = (*_1313)
  using: _1313@Mir(bb598[3])
  _1311 = move _1312 as u32 (IntToInt)
  using: _1312@Mir(bb598[4])
  ((*_1).7: u32) = BitOr(move _1307, move _1311)
  using: _1@Phi(bb590), _1307@Mir(bb598[0]), _1311@Mir(bb598[5])
  _1315 = const 8_i32
  using: 
  _1316 = CheckedAdd(((*_1).8: i32), _1315)
  using: _1@Phi(bb590), _1315@Mir(bb598[7])
  assert(!move (_1316.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1315) -> bb599
  using: _1316@Entry, _1@Entry, _1315@Entry
bb599:
  ((*_1).8: i32) = move (_1316.0: i32)
  using: _1@Phi(bb590), _1316@Mir(bb598[8])
  _3836 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  _1318 = ((*_3836).0: *mut i8)
  using: _3836@Mir(bb599[1])
  _1317 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1318, const 1_isize) -> bb600
  using: _1318@Mir(bb599[2])
bb600:
  _3837 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  ((*_3837).0: *mut i8) = move _1317
  using: _3837@Mir(bb600[0]), _1317@Mir(bb599[3])
  _3838 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  _1320 = ((*_3838).1: u32)
  using: _3838@Mir(bb600[2])
  _1319 = core::num::<impl u32>::wrapping_sub(move _1320, const 1_u32) -> bb601
  using: _1320@Mir(bb600[3])
bb601:
  _3839 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  ((*_3839).1: u32) = move _1319
  using: _3839@Mir(bb601[0]), _1319@Mir(bb600[4])
  _3840 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  _1322 = ((*_3840).2: u32)
  using: _3840@Mir(bb601[2])
  _1321 = core::num::<impl u32>::wrapping_add(move _1322, const 1_u32) -> bb602
  using: _1322@Mir(bb601[3])
bb602:
  _3841 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  ((*_3841).2: u32) = move _1321
  using: _3841@Mir(bb602[0]), _1321@Mir(bb601[4])
  _3842 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  _1324 = ((*_3842).2: u32)
  using: _3842@Mir(bb602[2])
  _1325 = const 0_u32
  using: 
  _1323 = Eq(move _1324, move _1325)
  using: _1324@Mir(bb602[3]), _1325@Mir(bb602[4])
  switchInt(move _1323) -> [0: bb590, otherwise: bb603]
  using: _1323@Mir(bb602[5])
bb603:
  _3843 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  _1327 = ((*_3843).3: u32)
  using: _3843@Mir(bb603[0])
  _1326 = core::num::<impl u32>::wrapping_add(move _1327, const 1_u32) -> bb604
  using: _1327@Mir(bb603[1])
bb604:
  _3844 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb590)
  ((*_3844).3: u32) = move _1326
  using: _3844@Mir(bb604[0]), _1326@Mir(bb603[2])
  goto -> bb590
  using: 
bb605:
  switchInt(_2) -> [15885526978618306830: bb608, otherwise: bb606]
  using: _2@Phi(bb605)
bb606:
  _1329 = ((*_1).13: i32)
  using: _1@Phi(bb605)
  _1330 = const 8_i32
  using: 
  _1331 = CheckedShl(_1329, _1330)
  using: _1329@Mir(bb606[0]), _1330@Mir(bb606[1])
  assert(!move (_1331.1: bool), "attempt to shift left by `{}`, which would overflow", move _1330) -> bb607
  using: _1331@Entry, _1329@Entry, _1330@Entry
bb607:
  _1328 = move (_1331.0: i32)
  using: _1331@Mir(bb606[2])
  _1333 = _3
  using: _3@Phi(bb605)
  _1332 = move _1333 as i32 (IntToInt)
  using: _1333@Mir(bb607[1])
  ((*_1).13: i32) = BitOr(move _1328, move _1332)
  using: _1@Phi(bb605), _1328@Mir(bb607[0]), _1332@Mir(bb607[2])
  _2 = const 34749046854646975_u64
  using: 
  goto -> bb608
  using: 
bb608:
  switchInt(_2) -> [34749046854646975: bb609, otherwise: bb634]
  using: _2@Phi(bb608)
bb609:
  _1334 = const 27_i32
  using: 
  ((*_1).1: i32) = move _1334
  using: _1@Phi(bb608), _1334@Mir(bb609[0])
  goto -> bb610
  using: 
bb610:
  _1336 = ((*_1).8: i32)
  using: _1@Phi(bb610)
  _1337 = const 8_i32
  using: 
  _1335 = Ge(move _1336, move _1337)
  using: _1336@Mir(bb610[0]), _1337@Mir(bb610[1])
  switchInt(move _1335) -> [0: bb612, otherwise: bb611]
  using: _1335@Mir(bb610[2])
bb611:
  _1338 = const 0_u32
  using: 
  _1340 = ((*_1).7: u32)
  using: _1@Phi(bb610)
  _1342 = ((*_1).8: i32)
  using: _1@Phi(bb610)
  _1343 = const 8_i32
  using: 
  _1344 = CheckedSub(_1342, _1343)
  using: _1342@Mir(bb611[2]), _1343@Mir(bb611[3])
  assert(!move (_1344.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1342, move _1343) -> bb613
  using: _1344@Entry, _1342@Entry, _1343@Entry
bb612:
  _3845 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  _1351 = ((*_3845).1: u32)
  using: _3845@Mir(bb612[0])
  _1352 = const 0_u32
  using: 
  _1350 = Eq(move _1351, move _1352)
  using: _1351@Mir(bb612[1]), _1352@Mir(bb612[2])
  switchInt(move _1350) -> [0: bb617, otherwise: bb616]
  using: _1350@Mir(bb612[3])
bb613:
  _1341 = move (_1344.0: i32)
  using: _1344@Mir(bb611[4])
  _1345 = CheckedShr(_1340, _1341)
  using: _1340@Mir(bb611[1]), _1341@Mir(bb613[0])
  assert(!move (_1345.1: bool), "attempt to shift right by `{}`, which would overflow", move _1341) -> bb614
  using: _1345@Entry, _1340@Entry, _1341@Entry
bb614:
  _1339 = move (_1345.0: u32)
  using: _1345@Mir(bb613[1])
  _1346 = const 255_u32
  using: 
  _1338 = BitAnd(move _1339, move _1346)
  using: _1339@Mir(bb614[0]), _1346@Mir(bb614[1])
  _1347 = const 8_i32
  using: 
  _1348 = CheckedSub(((*_1).8: i32), _1347)
  using: _1@Phi(bb610), _1347@Mir(bb614[3])
  assert(!move (_1348.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1347) -> bb615
  using: _1348@Entry, _1@Entry, _1347@Entry
bb615:
  ((*_1).8: i32) = move (_1348.0: i32)
  using: _1@Phi(bb610), _1348@Mir(bb614[4])
  _1349 = _1338
  using: _1338@Mir(bb614[2])
  _3 = move _1349 as u8 (IntToInt)
  using: _1349@Mir(bb615[1])
  _2 = const 10471999855724930313_u64
  using: 
  goto -> bb625
  using: 
bb616:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb625
  using: 
bb617:
  _1354 = ((*_1).7: u32)
  using: _1@Phi(bb610)
  _1355 = const 8_i32
  using: 
  _1356 = CheckedShl(_1354, _1355)
  using: _1354@Mir(bb617[0]), _1355@Mir(bb617[1])
  assert(!move (_1356.1: bool), "attempt to shift left by `{}`, which would overflow", move _1355) -> bb618
  using: _1356@Entry, _1354@Entry, _1355@Entry
bb618:
  _1353 = move (_1356.0: u32)
  using: _1356@Mir(bb617[2])
  _3846 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  _1360 = ((*_3846).0: *mut i8)
  using: _3846@Mir(bb618[1])
  _1359 = move _1360 as *mut u8 (PtrToPtr)
  using: _1360@Mir(bb618[2])
  _1358 = (*_1359)
  using: _1359@Mir(bb618[3])
  _1357 = move _1358 as u32 (IntToInt)
  using: _1358@Mir(bb618[4])
  ((*_1).7: u32) = BitOr(move _1353, move _1357)
  using: _1@Phi(bb610), _1353@Mir(bb618[0]), _1357@Mir(bb618[5])
  _1361 = const 8_i32
  using: 
  _1362 = CheckedAdd(((*_1).8: i32), _1361)
  using: _1@Phi(bb610), _1361@Mir(bb618[7])
  assert(!move (_1362.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1361) -> bb619
  using: _1362@Entry, _1@Entry, _1361@Entry
bb619:
  ((*_1).8: i32) = move (_1362.0: i32)
  using: _1@Phi(bb610), _1362@Mir(bb618[8])
  _3847 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  _1364 = ((*_3847).0: *mut i8)
  using: _3847@Mir(bb619[1])
  _1363 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1364, const 1_isize) -> bb620
  using: _1364@Mir(bb619[2])
bb620:
  _3848 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  ((*_3848).0: *mut i8) = move _1363
  using: _3848@Mir(bb620[0]), _1363@Mir(bb619[3])
  _3849 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  _1366 = ((*_3849).1: u32)
  using: _3849@Mir(bb620[2])
  _1365 = core::num::<impl u32>::wrapping_sub(move _1366, const 1_u32) -> bb621
  using: _1366@Mir(bb620[3])
bb621:
  _3850 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  ((*_3850).1: u32) = move _1365
  using: _3850@Mir(bb621[0]), _1365@Mir(bb620[4])
  _3851 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  _1368 = ((*_3851).2: u32)
  using: _3851@Mir(bb621[2])
  _1367 = core::num::<impl u32>::wrapping_add(move _1368, const 1_u32) -> bb622
  using: _1368@Mir(bb621[3])
bb622:
  _3852 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  ((*_3852).2: u32) = move _1367
  using: _3852@Mir(bb622[0]), _1367@Mir(bb621[4])
  _3853 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  _1370 = ((*_3853).2: u32)
  using: _3853@Mir(bb622[2])
  _1371 = const 0_u32
  using: 
  _1369 = Eq(move _1370, move _1371)
  using: _1370@Mir(bb622[3]), _1371@Mir(bb622[4])
  switchInt(move _1369) -> [0: bb610, otherwise: bb623]
  using: _1369@Mir(bb622[5])
bb623:
  _3854 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  _1373 = ((*_3854).3: u32)
  using: _3854@Mir(bb623[0])
  _1372 = core::num::<impl u32>::wrapping_add(move _1373, const 1_u32) -> bb624
  using: _1373@Mir(bb623[1])
bb624:
  _3855 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb610)
  ((*_3855).3: u32) = move _1372
  using: _3855@Mir(bb624[0]), _1372@Mir(bb623[2])
  goto -> bb610
  using: 
bb625:
  switchInt(_2) -> [15885526978618306830: bb634, otherwise: bb626]
  using: _2@Phi(bb625)
bb626:
  _1375 = ((*_1).13: i32)
  using: _1@Phi(bb625)
  _1376 = const 8_i32
  using: 
  _1377 = CheckedShl(_1375, _1376)
  using: _1375@Mir(bb626[0]), _1376@Mir(bb626[1])
  assert(!move (_1377.1: bool), "attempt to shift left by `{}`, which would overflow", move _1376) -> bb627
  using: _1377@Entry, _1375@Entry, _1376@Entry
bb627:
  _1374 = move (_1377.0: i32)
  using: _1377@Mir(bb626[2])
  _1379 = _3
  using: _3@Phi(bb625)
  _1378 = move _1379 as i32 (IntToInt)
  using: _1379@Mir(bb627[1])
  ((*_1).13: i32) = BitOr(move _1374, move _1378)
  using: _1@Phi(bb625), _1374@Mir(bb627[0]), _1378@Mir(bb627[2])
  _1381 = ((*_1).13: i32)
  using: _1@Phi(bb625)
  _1382 = const 0_i32
  using: 
  _1380 = Lt(move _1381, move _1382)
  using: _1381@Mir(bb627[4]), _1382@Mir(bb627[5])
  switchInt(move _1380) -> [0: bb629, otherwise: bb628]
  using: _1380@Mir(bb627[6])
bb628:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb629:
  _1384 = ((*_1).13: i32)
  using: _1@Phi(bb625)
  _1386 = const 10_i32
  using: 
  _1388 = const 100000_i32
  using: 
  _1389 = ((*_1).9: i32)
  using: _1@Phi(bb625)
  _1390 = CheckedMul(_1388, _1389)
  using: _1388@Mir(bb629[2]), _1389@Mir(bb629[3])
  assert(!move (_1390.1: bool), "attempt to compute `{} * {}`, which would overflow", move _1388, move _1389) -> bb630
  using: _1390@Entry, _1388@Entry, _1389@Entry
bb630:
  _1387 = move (_1390.0: i32)
  using: _1390@Mir(bb629[4])
  _1391 = CheckedAdd(_1386, _1387)
  using: _1386@Mir(bb629[1]), _1387@Mir(bb630[0])
  assert(!move (_1391.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1386, move _1387) -> bb631
  using: _1391@Entry, _1386@Entry, _1387@Entry
bb631:
  _1385 = move (_1391.0: i32)
  using: _1391@Mir(bb630[1])
  _1383 = Gt(move _1384, move _1385)
  using: _1384@Mir(bb629[0]), _1385@Mir(bb631[0])
  switchInt(move _1383) -> [0: bb633, otherwise: bb632]
  using: _1383@Mir(bb631[1])
bb632:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb633:
  _8 = const 0_i32
  using: 
  _2 = const 17262312153619709241_u64
  using: 
  goto -> bb634
  using: 
bb634:
  switchInt(_2) -> [15885526978618306830: bb636, 2629672494974161066: bb637, 13999925517074022731: bb655, 5374617794059532979: bb672, 14744029255125744966: bb690, 16722720626876144162: bb707, 5008197131544113214: bb725, 1736021991379636935: bb746, 10945178116989557996: bb764, 4874723077730206021: bb780, 5769007513321684282: bb801, 3906616468301123675: bb819, 1422779171932145779: bb840, 17262312153619709241: bb862, 16487873541482693172: bb870, otherwise: bb635]
  using: _2@Phi(bb634)
bb635:
  _2017 = const 41_i32
  using: 
  ((*_1).1: i32) = move _2017
  using: _1@Phi(bb634), _2017@Mir(bb635[0])
  goto -> bb892
  using: 
bb636:
  _1392 = _8
  using: _8@Phi(bb634)
  ((*_1).40: i32) = move _1392
  using: _1@Phi(bb892), _1392@Mir(bb636[0])
  _3536 = _9
  using: _9@Phi(bb634)
  ((*_1).41: i32) = move _3536
  using: _1@Phi(bb892), _3536@Mir(bb636[2])
  _3537 = _10
  using: _10@Phi(bb634)
  ((*_1).42: i32) = move _3537
  using: _1@Phi(bb892), _3537@Mir(bb636[4])
  _3538 = _11
  using: _11@Phi(bb634)
  ((*_1).43: i32) = move _3538
  using: _1@Phi(bb892), _3538@Mir(bb636[6])
  _3539 = _12
  using: _12@Phi(bb634)
  ((*_1).44: i32) = move _3539
  using: _1@Phi(bb892), _3539@Mir(bb636[8])
  _3540 = _13
  using: _13@Phi(bb634)
  ((*_1).45: i32) = move _3540
  using: _1@Phi(bb892), _3540@Mir(bb636[10])
  _3541 = _14
  using: _14@Phi(bb634)
  ((*_1).46: i32) = move _3541
  using: _1@Phi(bb892), _3541@Mir(bb636[12])
  _3542 = _15
  using: _15@Phi(bb634)
  ((*_1).47: i32) = move _3542
  using: _1@Phi(bb892), _3542@Mir(bb636[14])
  _3543 = _16
  using: _16@Phi(bb634)
  ((*_1).48: i32) = move _3543
  using: _1@Phi(bb892), _3543@Mir(bb636[16])
  _3544 = _17
  using: _17@Phi(bb634)
  ((*_1).49: i32) = move _3544
  using: _1@Phi(bb892), _3544@Mir(bb636[18])
  _3545 = _18
  using: _18@Phi(bb634)
  ((*_1).50: i32) = move _3545
  using: _1@Phi(bb892), _3545@Mir(bb636[20])
  _3546 = _19
  using: _19@Phi(bb634)
  ((*_1).51: i32) = move _3546
  using: _1@Phi(bb892), _3546@Mir(bb636[22])
  _3547 = _20
  using: _20@Phi(bb634)
  ((*_1).52: i32) = move _3547
  using: _1@Phi(bb892), _3547@Mir(bb636[24])
  _3548 = _21
  using: _21@Phi(bb634)
  ((*_1).53: i32) = move _3548
  using: _1@Phi(bb892), _3548@Mir(bb636[26])
  _3549 = _22
  using: _22@Phi(bb634)
  ((*_1).54: i32) = move _3549
  using: _1@Phi(bb892), _3549@Mir(bb636[28])
  _3550 = _23
  using: _23@Mir(bb2[31])
  ((*_1).55: i32) = move _3550
  using: _1@Phi(bb892), _3550@Mir(bb636[30])
  _3551 = _24
  using: _24@Phi(bb634)
  ((*_1).56: i32) = move _3551
  using: _1@Phi(bb892), _3551@Mir(bb636[32])
  _3552 = _25
  using: _25@Phi(bb634)
  ((*_1).57: i32) = move _3552
  using: _1@Phi(bb892), _3552@Mir(bb636[34])
  _3553 = _26
  using: _26@Phi(bb634)
  ((*_1).58: i32) = move _3553
  using: _1@Phi(bb892), _3553@Mir(bb636[36])
  _3554 = _27
  using: _27@Phi(bb634)
  ((*_1).59: i32) = move _3554
  using: _1@Phi(bb892), _3554@Mir(bb636[38])
  _3555 = _28
  using: _28@Phi(bb634)
  ((*_1).60: i32) = move _3555
  using: _1@Phi(bb892), _3555@Mir(bb636[40])
  _3556 = _29
  using: _29@Phi(bb634)
  ((*_1).61: *mut i32) = move _3556
  using: _1@Phi(bb892), _3556@Mir(bb636[42])
  _3557 = _30
  using: _30@Phi(bb634)
  ((*_1).62: *mut i32) = move _3557
  using: _1@Phi(bb892), _3557@Mir(bb636[44])
  _3558 = _31
  using: _31@Phi(bb634)
  ((*_1).63: *mut i32) = move _3558
  using: _1@Phi(bb892), _3558@Mir(bb636[46])
  _0 = _4
  using: _4@Phi(bb634)
  goto -> bb1477
  using: 
bb637:
  _1393 = const 40_i32
  using: 
  ((*_1).1: i32) = move _1393
  using: _1@Phi(bb892), _1393@Mir(bb637[0])
  goto -> bb638
  using: 
bb638:
  _1395 = ((*_1).8: i32)
  using: _1@Phi(bb638)
  _1396 = _24
  using: _24@Phi(bb634)
  _1394 = Ge(move _1395, move _1396)
  using: _1395@Mir(bb638[0]), _1396@Mir(bb638[1])
  switchInt(move _1394) -> [0: bb645, otherwise: bb639]
  using: _1394@Mir(bb638[2])
bb639:
  _1397 = const 0_u32
  using: 
  _1399 = ((*_1).7: u32)
  using: _1@Phi(bb638)
  _1401 = ((*_1).8: i32)
  using: _1@Phi(bb638)
  _1402 = _24
  using: _24@Phi(bb634)
  _1403 = CheckedSub(_1401, _1402)
  using: _1401@Mir(bb639[2]), _1402@Mir(bb639[3])
  assert(!move (_1403.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1401, move _1402) -> bb640
  using: _1403@Entry, _1401@Entry, _1402@Entry
bb640:
  _1400 = move (_1403.0: i32)
  using: _1403@Mir(bb639[4])
  _1404 = CheckedShr(_1399, _1400)
  using: _1399@Mir(bb639[1]), _1400@Mir(bb640[0])
  assert(!move (_1404.1: bool), "attempt to shift right by `{}`, which would overflow", move _1400) -> bb641
  using: _1404@Entry, _1399@Entry, _1400@Entry
bb641:
  _1398 = move (_1404.0: u32)
  using: _1404@Mir(bb640[1])
  _1408 = const 1_i32
  using: 
  _1409 = _24
  using: _24@Phi(bb634)
  _1410 = CheckedShl(_1408, _1409)
  using: _1408@Mir(bb641[1]), _1409@Mir(bb641[2])
  assert(!move (_1410.1: bool), "attempt to shift left by `{}`, which would overflow", move _1409) -> bb642
  using: _1410@Entry, _1408@Entry, _1409@Entry
bb642:
  _1407 = move (_1410.0: i32)
  using: _1410@Mir(bb641[3])
  _1411 = const 1_i32
  using: 
  _1412 = CheckedSub(_1407, _1411)
  using: _1407@Mir(bb642[0]), _1411@Mir(bb642[1])
  assert(!move (_1412.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1407, move _1411) -> bb643
  using: _1412@Entry, _1407@Entry, _1411@Entry
bb643:
  _1406 = move (_1412.0: i32)
  using: _1412@Mir(bb642[2])
  _1405 = move _1406 as u32 (IntToInt)
  using: _1406@Mir(bb643[0])
  _1397 = BitAnd(move _1398, move _1405)
  using: _1398@Mir(bb641[0]), _1405@Mir(bb643[1])
  _1413 = _24
  using: _24@Phi(bb634)
  _1414 = CheckedSub(((*_1).8: i32), _1413)
  using: _1@Phi(bb638), _1413@Mir(bb643[3])
  assert(!move (_1414.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1413) -> bb644
  using: _1414@Entry, _1@Entry, _1413@Entry
bb644:
  ((*_1).8: i32) = move (_1414.0: i32)
  using: _1@Phi(bb638), _1414@Mir(bb643[4])
  _1415 = _1397
  using: _1397@Mir(bb643[2])
  _25 = move _1415 as i32 (IntToInt)
  using: _1415@Mir(bb644[1])
  _2 = const 9078889872071895942_u64
  using: 
  goto -> bb908
  using: 
bb645:
  _3856 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  _1417 = ((*_3856).1: u32)
  using: _3856@Mir(bb645[0])
  _1418 = const 0_u32
  using: 
  _1416 = Eq(move _1417, move _1418)
  using: _1417@Mir(bb645[1]), _1418@Mir(bb645[2])
  switchInt(move _1416) -> [0: bb647, otherwise: bb646]
  using: _1416@Mir(bb645[3])
bb646:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb647:
  _1420 = ((*_1).7: u32)
  using: _1@Phi(bb638)
  _1421 = const 8_i32
  using: 
  _1422 = CheckedShl(_1420, _1421)
  using: _1420@Mir(bb647[0]), _1421@Mir(bb647[1])
  assert(!move (_1422.1: bool), "attempt to shift left by `{}`, which would overflow", move _1421) -> bb648
  using: _1422@Entry, _1420@Entry, _1421@Entry
bb648:
  _1419 = move (_1422.0: u32)
  using: _1422@Mir(bb647[2])
  _3857 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  _1426 = ((*_3857).0: *mut i8)
  using: _3857@Mir(bb648[1])
  _1425 = move _1426 as *mut u8 (PtrToPtr)
  using: _1426@Mir(bb648[2])
  _1424 = (*_1425)
  using: _1425@Mir(bb648[3])
  _1423 = move _1424 as u32 (IntToInt)
  using: _1424@Mir(bb648[4])
  ((*_1).7: u32) = BitOr(move _1419, move _1423)
  using: _1@Phi(bb638), _1419@Mir(bb648[0]), _1423@Mir(bb648[5])
  _1427 = const 8_i32
  using: 
  _1428 = CheckedAdd(((*_1).8: i32), _1427)
  using: _1@Phi(bb638), _1427@Mir(bb648[7])
  assert(!move (_1428.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1427) -> bb649
  using: _1428@Entry, _1@Entry, _1427@Entry
bb649:
  ((*_1).8: i32) = move (_1428.0: i32)
  using: _1@Phi(bb638), _1428@Mir(bb648[8])
  _3858 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  _1430 = ((*_3858).0: *mut i8)
  using: _3858@Mir(bb649[1])
  _1429 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1430, const 1_isize) -> bb650
  using: _1430@Mir(bb649[2])
bb650:
  _3859 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  ((*_3859).0: *mut i8) = move _1429
  using: _3859@Mir(bb650[0]), _1429@Mir(bb649[3])
  _3860 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  _1432 = ((*_3860).1: u32)
  using: _3860@Mir(bb650[2])
  _1431 = core::num::<impl u32>::wrapping_sub(move _1432, const 1_u32) -> bb651
  using: _1432@Mir(bb650[3])
bb651:
  _3861 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  ((*_3861).1: u32) = move _1431
  using: _3861@Mir(bb651[0]), _1431@Mir(bb650[4])
  _3862 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  _1434 = ((*_3862).2: u32)
  using: _3862@Mir(bb651[2])
  _1433 = core::num::<impl u32>::wrapping_add(move _1434, const 1_u32) -> bb652
  using: _1434@Mir(bb651[3])
bb652:
  _3863 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  ((*_3863).2: u32) = move _1433
  using: _3863@Mir(bb652[0]), _1433@Mir(bb651[4])
  _3864 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  _1436 = ((*_3864).2: u32)
  using: _3864@Mir(bb652[2])
  _1437 = const 0_u32
  using: 
  _1435 = Eq(move _1436, move _1437)
  using: _1436@Mir(bb652[3]), _1437@Mir(bb652[4])
  switchInt(move _1435) -> [0: bb638, otherwise: bb653]
  using: _1435@Mir(bb652[5])
bb653:
  _3865 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  _1439 = ((*_3865).3: u32)
  using: _3865@Mir(bb653[0])
  _1438 = core::num::<impl u32>::wrapping_add(move _1439, const 1_u32) -> bb654
  using: _1439@Mir(bb653[1])
bb654:
  _3866 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb638)
  ((*_3866).3: u32) = move _1438
  using: _3866@Mir(bb654[0]), _1438@Mir(bb653[2])
  goto -> bb638
  using: 
bb655:
  _1440 = const 39_i32
  using: 
  ((*_1).1: i32) = move _1440
  using: _1@Phi(bb638), _1440@Mir(bb655[0])
  goto -> bb656
  using: 
bb656:
  _1442 = ((*_1).8: i32)
  using: _1@Phi(bb656)
  _1443 = const 1_i32
  using: 
  _1441 = Ge(move _1442, move _1443)
  using: _1442@Mir(bb656[0]), _1443@Mir(bb656[1])
  switchInt(move _1441) -> [0: bb661, otherwise: bb657]
  using: _1441@Mir(bb656[2])
bb657:
  _1444 = const 0_u32
  using: 
  _1446 = ((*_1).7: u32)
  using: _1@Phi(bb656)
  _1448 = ((*_1).8: i32)
  using: _1@Phi(bb656)
  _1449 = const 1_i32
  using: 
  _1450 = CheckedSub(_1448, _1449)
  using: _1448@Mir(bb657[2]), _1449@Mir(bb657[3])
  assert(!move (_1450.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1448, move _1449) -> bb658
  using: _1450@Entry, _1448@Entry, _1449@Entry
bb658:
  _1447 = move (_1450.0: i32)
  using: _1450@Mir(bb657[4])
  _1451 = CheckedShr(_1446, _1447)
  using: _1446@Mir(bb657[1]), _1447@Mir(bb658[0])
  assert(!move (_1451.1: bool), "attempt to shift right by `{}`, which would overflow", move _1447) -> bb659
  using: _1451@Entry, _1446@Entry, _1447@Entry
bb659:
  _1445 = move (_1451.0: u32)
  using: _1451@Mir(bb658[1])
  _1452 = const 1_u32
  using: 
  _1444 = BitAnd(move _1445, move _1452)
  using: _1445@Mir(bb659[0]), _1452@Mir(bb659[1])
  _1453 = const 1_i32
  using: 
  _1454 = CheckedSub(((*_1).8: i32), _1453)
  using: _1@Phi(bb656), _1453@Mir(bb659[3])
  assert(!move (_1454.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1453) -> bb660
  using: _1454@Entry, _1@Entry, _1453@Entry
bb660:
  ((*_1).8: i32) = move (_1454.0: i32)
  using: _1@Phi(bb656), _1454@Mir(bb659[4])
  _1455 = _1444
  using: _1444@Mir(bb659[2])
  _26 = move _1455 as i32 (IntToInt)
  using: _1455@Mir(bb660[1])
  _1481 = _25
  using: _25@Phi(bb634)
  _1482 = const 1_i32
  using: 
  _1483 = CheckedShl(_1481, _1482)
  using: _1481@Mir(bb660[3]), _1482@Mir(bb660[4])
  assert(!move (_1483.1: bool), "attempt to shift left by `{}`, which would overflow", move _1482) -> bb671
  using: _1483@Entry, _1481@Entry, _1482@Entry
bb661:
  _3867 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  _1457 = ((*_3867).1: u32)
  using: _3867@Mir(bb661[0])
  _1458 = const 0_u32
  using: 
  _1456 = Eq(move _1457, move _1458)
  using: _1457@Mir(bb661[1]), _1458@Mir(bb661[2])
  switchInt(move _1456) -> [0: bb663, otherwise: bb662]
  using: _1456@Mir(bb661[3])
bb662:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb663:
  _1460 = ((*_1).7: u32)
  using: _1@Phi(bb656)
  _1461 = const 8_i32
  using: 
  _1462 = CheckedShl(_1460, _1461)
  using: _1460@Mir(bb663[0]), _1461@Mir(bb663[1])
  assert(!move (_1462.1: bool), "attempt to shift left by `{}`, which would overflow", move _1461) -> bb664
  using: _1462@Entry, _1460@Entry, _1461@Entry
bb664:
  _1459 = move (_1462.0: u32)
  using: _1462@Mir(bb663[2])
  _3868 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  _1466 = ((*_3868).0: *mut i8)
  using: _3868@Mir(bb664[1])
  _1465 = move _1466 as *mut u8 (PtrToPtr)
  using: _1466@Mir(bb664[2])
  _1464 = (*_1465)
  using: _1465@Mir(bb664[3])
  _1463 = move _1464 as u32 (IntToInt)
  using: _1464@Mir(bb664[4])
  ((*_1).7: u32) = BitOr(move _1459, move _1463)
  using: _1@Phi(bb656), _1459@Mir(bb664[0]), _1463@Mir(bb664[5])
  _1467 = const 8_i32
  using: 
  _1468 = CheckedAdd(((*_1).8: i32), _1467)
  using: _1@Phi(bb656), _1467@Mir(bb664[7])
  assert(!move (_1468.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1467) -> bb665
  using: _1468@Entry, _1@Entry, _1467@Entry
bb665:
  ((*_1).8: i32) = move (_1468.0: i32)
  using: _1@Phi(bb656), _1468@Mir(bb664[8])
  _3869 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  _1470 = ((*_3869).0: *mut i8)
  using: _3869@Mir(bb665[1])
  _1469 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1470, const 1_isize) -> bb666
  using: _1470@Mir(bb665[2])
bb666:
  _3870 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  ((*_3870).0: *mut i8) = move _1469
  using: _3870@Mir(bb666[0]), _1469@Mir(bb665[3])
  _3871 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  _1472 = ((*_3871).1: u32)
  using: _3871@Mir(bb666[2])
  _1471 = core::num::<impl u32>::wrapping_sub(move _1472, const 1_u32) -> bb667
  using: _1472@Mir(bb666[3])
bb667:
  _3872 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  ((*_3872).1: u32) = move _1471
  using: _3872@Mir(bb667[0]), _1471@Mir(bb666[4])
  _3873 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  _1474 = ((*_3873).2: u32)
  using: _3873@Mir(bb667[2])
  _1473 = core::num::<impl u32>::wrapping_add(move _1474, const 1_u32) -> bb668
  using: _1474@Mir(bb667[3])
bb668:
  _3874 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  ((*_3874).2: u32) = move _1473
  using: _3874@Mir(bb668[0]), _1473@Mir(bb667[4])
  _3875 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  _1476 = ((*_3875).2: u32)
  using: _3875@Mir(bb668[2])
  _1477 = const 0_u32
  using: 
  _1475 = Eq(move _1476, move _1477)
  using: _1476@Mir(bb668[3]), _1477@Mir(bb668[4])
  switchInt(move _1475) -> [0: bb656, otherwise: bb669]
  using: _1475@Mir(bb668[5])
bb669:
  _3876 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  _1479 = ((*_3876).3: u32)
  using: _3876@Mir(bb669[0])
  _1478 = core::num::<impl u32>::wrapping_add(move _1479, const 1_u32) -> bb670
  using: _1479@Mir(bb669[1])
bb670:
  _3877 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb656)
  ((*_3877).3: u32) = move _1478
  using: _3877@Mir(bb670[0]), _1478@Mir(bb669[2])
  goto -> bb656
  using: 
bb671:
  _1480 = move (_1483.0: i32)
  using: _1483@Mir(bb660[5])
  _1484 = _26
  using: _26@Mir(bb660[2])
  _25 = BitOr(move _1480, move _1484)
  using: _1480@Mir(bb671[0]), _1484@Mir(bb671[1])
  _2 = const 13605767259572914371_u64
  using: 
  goto -> bb908
  using: 
bb672:
  _1485 = const 38_i32
  using: 
  ((*_1).1: i32) = move _1485
  using: _1@Phi(bb656), _1485@Mir(bb672[0])
  goto -> bb673
  using: 
bb673:
  _1487 = ((*_1).8: i32)
  using: _1@Phi(bb673)
  _1488 = _24
  using: _24@Phi(bb634)
  _1486 = Ge(move _1487, move _1488)
  using: _1487@Mir(bb673[0]), _1488@Mir(bb673[1])
  switchInt(move _1486) -> [0: bb680, otherwise: bb674]
  using: _1486@Mir(bb673[2])
bb674:
  _1489 = const 0_u32
  using: 
  _1491 = ((*_1).7: u32)
  using: _1@Phi(bb673)
  _1493 = ((*_1).8: i32)
  using: _1@Phi(bb673)
  _1494 = _24
  using: _24@Phi(bb634)
  _1495 = CheckedSub(_1493, _1494)
  using: _1493@Mir(bb674[2]), _1494@Mir(bb674[3])
  assert(!move (_1495.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1493, move _1494) -> bb675
  using: _1495@Entry, _1493@Entry, _1494@Entry
bb675:
  _1492 = move (_1495.0: i32)
  using: _1495@Mir(bb674[4])
  _1496 = CheckedShr(_1491, _1492)
  using: _1491@Mir(bb674[1]), _1492@Mir(bb675[0])
  assert(!move (_1496.1: bool), "attempt to shift right by `{}`, which would overflow", move _1492) -> bb676
  using: _1496@Entry, _1491@Entry, _1492@Entry
bb676:
  _1490 = move (_1496.0: u32)
  using: _1496@Mir(bb675[1])
  _1500 = const 1_i32
  using: 
  _1501 = _24
  using: _24@Phi(bb634)
  _1502 = CheckedShl(_1500, _1501)
  using: _1500@Mir(bb676[1]), _1501@Mir(bb676[2])
  assert(!move (_1502.1: bool), "attempt to shift left by `{}`, which would overflow", move _1501) -> bb677
  using: _1502@Entry, _1500@Entry, _1501@Entry
bb677:
  _1499 = move (_1502.0: i32)
  using: _1502@Mir(bb676[3])
  _1503 = const 1_i32
  using: 
  _1504 = CheckedSub(_1499, _1503)
  using: _1499@Mir(bb677[0]), _1503@Mir(bb677[1])
  assert(!move (_1504.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1499, move _1503) -> bb678
  using: _1504@Entry, _1499@Entry, _1503@Entry
bb678:
  _1498 = move (_1504.0: i32)
  using: _1504@Mir(bb677[2])
  _1497 = move _1498 as u32 (IntToInt)
  using: _1498@Mir(bb678[0])
  _1489 = BitAnd(move _1490, move _1497)
  using: _1490@Mir(bb676[0]), _1497@Mir(bb678[1])
  _1505 = _24
  using: _24@Phi(bb634)
  _1506 = CheckedSub(((*_1).8: i32), _1505)
  using: _1@Phi(bb673), _1505@Mir(bb678[3])
  assert(!move (_1506.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1505) -> bb679
  using: _1506@Entry, _1@Entry, _1505@Entry
bb679:
  ((*_1).8: i32) = move (_1506.0: i32)
  using: _1@Phi(bb673), _1506@Mir(bb678[4])
  _1507 = _1489
  using: _1489@Mir(bb678[2])
  _25 = move _1507 as i32 (IntToInt)
  using: _1507@Mir(bb679[1])
  _2 = const 13605767259572914371_u64
  using: 
  goto -> bb908
  using: 
bb680:
  _3878 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  _1509 = ((*_3878).1: u32)
  using: _3878@Mir(bb680[0])
  _1510 = const 0_u32
  using: 
  _1508 = Eq(move _1509, move _1510)
  using: _1509@Mir(bb680[1]), _1510@Mir(bb680[2])
  switchInt(move _1508) -> [0: bb682, otherwise: bb681]
  using: _1508@Mir(bb680[3])
bb681:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb682:
  _1512 = ((*_1).7: u32)
  using: _1@Phi(bb673)
  _1513 = const 8_i32
  using: 
  _1514 = CheckedShl(_1512, _1513)
  using: _1512@Mir(bb682[0]), _1513@Mir(bb682[1])
  assert(!move (_1514.1: bool), "attempt to shift left by `{}`, which would overflow", move _1513) -> bb683
  using: _1514@Entry, _1512@Entry, _1513@Entry
bb683:
  _1511 = move (_1514.0: u32)
  using: _1514@Mir(bb682[2])
  _3879 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  _1518 = ((*_3879).0: *mut i8)
  using: _3879@Mir(bb683[1])
  _1517 = move _1518 as *mut u8 (PtrToPtr)
  using: _1518@Mir(bb683[2])
  _1516 = (*_1517)
  using: _1517@Mir(bb683[3])
  _1515 = move _1516 as u32 (IntToInt)
  using: _1516@Mir(bb683[4])
  ((*_1).7: u32) = BitOr(move _1511, move _1515)
  using: _1@Phi(bb673), _1511@Mir(bb683[0]), _1515@Mir(bb683[5])
  _1519 = const 8_i32
  using: 
  _1520 = CheckedAdd(((*_1).8: i32), _1519)
  using: _1@Phi(bb673), _1519@Mir(bb683[7])
  assert(!move (_1520.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1519) -> bb684
  using: _1520@Entry, _1@Entry, _1519@Entry
bb684:
  ((*_1).8: i32) = move (_1520.0: i32)
  using: _1@Phi(bb673), _1520@Mir(bb683[8])
  _3880 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  _1522 = ((*_3880).0: *mut i8)
  using: _3880@Mir(bb684[1])
  _1521 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1522, const 1_isize) -> bb685
  using: _1522@Mir(bb684[2])
bb685:
  _3881 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  ((*_3881).0: *mut i8) = move _1521
  using: _3881@Mir(bb685[0]), _1521@Mir(bb684[3])
  _3882 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  _1524 = ((*_3882).1: u32)
  using: _3882@Mir(bb685[2])
  _1523 = core::num::<impl u32>::wrapping_sub(move _1524, const 1_u32) -> bb686
  using: _1524@Mir(bb685[3])
bb686:
  _3883 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  ((*_3883).1: u32) = move _1523
  using: _3883@Mir(bb686[0]), _1523@Mir(bb685[4])
  _3884 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  _1526 = ((*_3884).2: u32)
  using: _3884@Mir(bb686[2])
  _1525 = core::num::<impl u32>::wrapping_add(move _1526, const 1_u32) -> bb687
  using: _1526@Mir(bb686[3])
bb687:
  _3885 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  ((*_3885).2: u32) = move _1525
  using: _3885@Mir(bb687[0]), _1525@Mir(bb686[4])
  _3886 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  _1528 = ((*_3886).2: u32)
  using: _3886@Mir(bb687[2])
  _1529 = const 0_u32
  using: 
  _1527 = Eq(move _1528, move _1529)
  using: _1528@Mir(bb687[3]), _1529@Mir(bb687[4])
  switchInt(move _1527) -> [0: bb673, otherwise: bb688]
  using: _1527@Mir(bb687[5])
bb688:
  _3887 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  _1531 = ((*_3887).3: u32)
  using: _3887@Mir(bb688[0])
  _1530 = core::num::<impl u32>::wrapping_add(move _1531, const 1_u32) -> bb689
  using: _1531@Mir(bb688[1])
bb689:
  _3888 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb673)
  ((*_3888).3: u32) = move _1530
  using: _3888@Mir(bb689[0]), _1530@Mir(bb688[2])
  goto -> bb673
  using: 
bb690:
  _1532 = const 37_i32
  using: 
  ((*_1).1: i32) = move _1532
  using: _1@Phi(bb673), _1532@Mir(bb690[0])
  goto -> bb691
  using: 
bb691:
  _1534 = ((*_1).8: i32)
  using: _1@Phi(bb691)
  _1535 = const 1_i32
  using: 
  _1533 = Ge(move _1534, move _1535)
  using: _1534@Mir(bb691[0]), _1535@Mir(bb691[1])
  switchInt(move _1533) -> [0: bb696, otherwise: bb692]
  using: _1533@Mir(bb691[2])
bb692:
  _1536 = const 0_u32
  using: 
  _1538 = ((*_1).7: u32)
  using: _1@Phi(bb691)
  _1540 = ((*_1).8: i32)
  using: _1@Phi(bb691)
  _1541 = const 1_i32
  using: 
  _1542 = CheckedSub(_1540, _1541)
  using: _1540@Mir(bb692[2]), _1541@Mir(bb692[3])
  assert(!move (_1542.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1540, move _1541) -> bb693
  using: _1542@Entry, _1540@Entry, _1541@Entry
bb693:
  _1539 = move (_1542.0: i32)
  using: _1542@Mir(bb692[4])
  _1543 = CheckedShr(_1538, _1539)
  using: _1538@Mir(bb692[1]), _1539@Mir(bb693[0])
  assert(!move (_1543.1: bool), "attempt to shift right by `{}`, which would overflow", move _1539) -> bb694
  using: _1543@Entry, _1538@Entry, _1539@Entry
bb694:
  _1537 = move (_1543.0: u32)
  using: _1543@Mir(bb693[1])
  _1544 = const 1_u32
  using: 
  _1536 = BitAnd(move _1537, move _1544)
  using: _1537@Mir(bb694[0]), _1544@Mir(bb694[1])
  _1545 = const 1_i32
  using: 
  _1546 = CheckedSub(((*_1).8: i32), _1545)
  using: _1@Phi(bb691), _1545@Mir(bb694[3])
  assert(!move (_1546.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1545) -> bb695
  using: _1546@Entry, _1@Entry, _1545@Entry
bb695:
  ((*_1).8: i32) = move (_1546.0: i32)
  using: _1@Phi(bb691), _1546@Mir(bb694[4])
  _1547 = _1536
  using: _1536@Mir(bb694[2])
  _26 = move _1547 as i32 (IntToInt)
  using: _1547@Mir(bb695[1])
  _1573 = _25
  using: _25@Phi(bb634)
  _1574 = const 1_i32
  using: 
  _1575 = CheckedShl(_1573, _1574)
  using: _1573@Mir(bb695[3]), _1574@Mir(bb695[4])
  assert(!move (_1575.1: bool), "attempt to shift left by `{}`, which would overflow", move _1574) -> bb706
  using: _1575@Entry, _1573@Entry, _1574@Entry
bb696:
  _3889 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  _1549 = ((*_3889).1: u32)
  using: _3889@Mir(bb696[0])
  _1550 = const 0_u32
  using: 
  _1548 = Eq(move _1549, move _1550)
  using: _1549@Mir(bb696[1]), _1550@Mir(bb696[2])
  switchInt(move _1548) -> [0: bb698, otherwise: bb697]
  using: _1548@Mir(bb696[3])
bb697:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb698:
  _1552 = ((*_1).7: u32)
  using: _1@Phi(bb691)
  _1553 = const 8_i32
  using: 
  _1554 = CheckedShl(_1552, _1553)
  using: _1552@Mir(bb698[0]), _1553@Mir(bb698[1])
  assert(!move (_1554.1: bool), "attempt to shift left by `{}`, which would overflow", move _1553) -> bb699
  using: _1554@Entry, _1552@Entry, _1553@Entry
bb699:
  _1551 = move (_1554.0: u32)
  using: _1554@Mir(bb698[2])
  _3890 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  _1558 = ((*_3890).0: *mut i8)
  using: _3890@Mir(bb699[1])
  _1557 = move _1558 as *mut u8 (PtrToPtr)
  using: _1558@Mir(bb699[2])
  _1556 = (*_1557)
  using: _1557@Mir(bb699[3])
  _1555 = move _1556 as u32 (IntToInt)
  using: _1556@Mir(bb699[4])
  ((*_1).7: u32) = BitOr(move _1551, move _1555)
  using: _1@Phi(bb691), _1551@Mir(bb699[0]), _1555@Mir(bb699[5])
  _1559 = const 8_i32
  using: 
  _1560 = CheckedAdd(((*_1).8: i32), _1559)
  using: _1@Phi(bb691), _1559@Mir(bb699[7])
  assert(!move (_1560.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1559) -> bb700
  using: _1560@Entry, _1@Entry, _1559@Entry
bb700:
  ((*_1).8: i32) = move (_1560.0: i32)
  using: _1@Phi(bb691), _1560@Mir(bb699[8])
  _3891 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  _1562 = ((*_3891).0: *mut i8)
  using: _3891@Mir(bb700[1])
  _1561 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1562, const 1_isize) -> bb701
  using: _1562@Mir(bb700[2])
bb701:
  _3892 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  ((*_3892).0: *mut i8) = move _1561
  using: _3892@Mir(bb701[0]), _1561@Mir(bb700[3])
  _3893 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  _1564 = ((*_3893).1: u32)
  using: _3893@Mir(bb701[2])
  _1563 = core::num::<impl u32>::wrapping_sub(move _1564, const 1_u32) -> bb702
  using: _1564@Mir(bb701[3])
bb702:
  _3894 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  ((*_3894).1: u32) = move _1563
  using: _3894@Mir(bb702[0]), _1563@Mir(bb701[4])
  _3895 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  _1566 = ((*_3895).2: u32)
  using: _3895@Mir(bb702[2])
  _1565 = core::num::<impl u32>::wrapping_add(move _1566, const 1_u32) -> bb703
  using: _1566@Mir(bb702[3])
bb703:
  _3896 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  ((*_3896).2: u32) = move _1565
  using: _3896@Mir(bb703[0]), _1565@Mir(bb702[4])
  _3897 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  _1568 = ((*_3897).2: u32)
  using: _3897@Mir(bb703[2])
  _1569 = const 0_u32
  using: 
  _1567 = Eq(move _1568, move _1569)
  using: _1568@Mir(bb703[3]), _1569@Mir(bb703[4])
  switchInt(move _1567) -> [0: bb691, otherwise: bb704]
  using: _1567@Mir(bb703[5])
bb704:
  _3898 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  _1571 = ((*_3898).3: u32)
  using: _3898@Mir(bb704[0])
  _1570 = core::num::<impl u32>::wrapping_add(move _1571, const 1_u32) -> bb705
  using: _1571@Mir(bb704[1])
bb705:
  _3899 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb691)
  ((*_3899).3: u32) = move _1570
  using: _3899@Mir(bb705[0]), _1570@Mir(bb704[2])
  goto -> bb691
  using: 
bb706:
  _1572 = move (_1575.0: i32)
  using: _1575@Mir(bb695[5])
  _1576 = _26
  using: _26@Mir(bb695[2])
  _25 = BitOr(move _1572, move _1576)
  using: _1572@Mir(bb706[0]), _1576@Mir(bb706[1])
  _2 = const 1550405138573481750_u64
  using: 
  goto -> bb908
  using: 
bb707:
  _1577 = const 36_i32
  using: 
  ((*_1).1: i32) = move _1577
  using: _1@Phi(bb691), _1577@Mir(bb707[0])
  goto -> bb708
  using: 
bb708:
  _1579 = ((*_1).8: i32)
  using: _1@Phi(bb708)
  _1580 = _24
  using: _24@Phi(bb634)
  _1578 = Ge(move _1579, move _1580)
  using: _1579@Mir(bb708[0]), _1580@Mir(bb708[1])
  switchInt(move _1578) -> [0: bb715, otherwise: bb709]
  using: _1578@Mir(bb708[2])
bb709:
  _1581 = const 0_u32
  using: 
  _1583 = ((*_1).7: u32)
  using: _1@Phi(bb708)
  _1585 = ((*_1).8: i32)
  using: _1@Phi(bb708)
  _1586 = _24
  using: _24@Phi(bb634)
  _1587 = CheckedSub(_1585, _1586)
  using: _1585@Mir(bb709[2]), _1586@Mir(bb709[3])
  assert(!move (_1587.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1585, move _1586) -> bb710
  using: _1587@Entry, _1585@Entry, _1586@Entry
bb710:
  _1584 = move (_1587.0: i32)
  using: _1587@Mir(bb709[4])
  _1588 = CheckedShr(_1583, _1584)
  using: _1583@Mir(bb709[1]), _1584@Mir(bb710[0])
  assert(!move (_1588.1: bool), "attempt to shift right by `{}`, which would overflow", move _1584) -> bb711
  using: _1588@Entry, _1583@Entry, _1584@Entry
bb711:
  _1582 = move (_1588.0: u32)
  using: _1588@Mir(bb710[1])
  _1592 = const 1_i32
  using: 
  _1593 = _24
  using: _24@Phi(bb634)
  _1594 = CheckedShl(_1592, _1593)
  using: _1592@Mir(bb711[1]), _1593@Mir(bb711[2])
  assert(!move (_1594.1: bool), "attempt to shift left by `{}`, which would overflow", move _1593) -> bb712
  using: _1594@Entry, _1592@Entry, _1593@Entry
bb712:
  _1591 = move (_1594.0: i32)
  using: _1594@Mir(bb711[3])
  _1595 = const 1_i32
  using: 
  _1596 = CheckedSub(_1591, _1595)
  using: _1591@Mir(bb712[0]), _1595@Mir(bb712[1])
  assert(!move (_1596.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1591, move _1595) -> bb713
  using: _1596@Entry, _1591@Entry, _1595@Entry
bb713:
  _1590 = move (_1596.0: i32)
  using: _1596@Mir(bb712[2])
  _1589 = move _1590 as u32 (IntToInt)
  using: _1590@Mir(bb713[0])
  _1581 = BitAnd(move _1582, move _1589)
  using: _1582@Mir(bb711[0]), _1589@Mir(bb713[1])
  _1597 = _24
  using: _24@Phi(bb634)
  _1598 = CheckedSub(((*_1).8: i32), _1597)
  using: _1@Phi(bb708), _1597@Mir(bb713[3])
  assert(!move (_1598.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1597) -> bb714
  using: _1598@Entry, _1@Entry, _1597@Entry
bb714:
  ((*_1).8: i32) = move (_1598.0: i32)
  using: _1@Phi(bb708), _1598@Mir(bb713[4])
  _1599 = _1581
  using: _1581@Mir(bb713[2])
  _25 = move _1599 as i32 (IntToInt)
  using: _1599@Mir(bb714[1])
  _2 = const 1550405138573481750_u64
  using: 
  goto -> bb908
  using: 
bb715:
  _3900 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  _1601 = ((*_3900).1: u32)
  using: _3900@Mir(bb715[0])
  _1602 = const 0_u32
  using: 
  _1600 = Eq(move _1601, move _1602)
  using: _1601@Mir(bb715[1]), _1602@Mir(bb715[2])
  switchInt(move _1600) -> [0: bb717, otherwise: bb716]
  using: _1600@Mir(bb715[3])
bb716:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb717:
  _1604 = ((*_1).7: u32)
  using: _1@Phi(bb708)
  _1605 = const 8_i32
  using: 
  _1606 = CheckedShl(_1604, _1605)
  using: _1604@Mir(bb717[0]), _1605@Mir(bb717[1])
  assert(!move (_1606.1: bool), "attempt to shift left by `{}`, which would overflow", move _1605) -> bb718
  using: _1606@Entry, _1604@Entry, _1605@Entry
bb718:
  _1603 = move (_1606.0: u32)
  using: _1606@Mir(bb717[2])
  _3901 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  _1610 = ((*_3901).0: *mut i8)
  using: _3901@Mir(bb718[1])
  _1609 = move _1610 as *mut u8 (PtrToPtr)
  using: _1610@Mir(bb718[2])
  _1608 = (*_1609)
  using: _1609@Mir(bb718[3])
  _1607 = move _1608 as u32 (IntToInt)
  using: _1608@Mir(bb718[4])
  ((*_1).7: u32) = BitOr(move _1603, move _1607)
  using: _1@Phi(bb708), _1603@Mir(bb718[0]), _1607@Mir(bb718[5])
  _1611 = const 8_i32
  using: 
  _1612 = CheckedAdd(((*_1).8: i32), _1611)
  using: _1@Phi(bb708), _1611@Mir(bb718[7])
  assert(!move (_1612.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1611) -> bb719
  using: _1612@Entry, _1@Entry, _1611@Entry
bb719:
  ((*_1).8: i32) = move (_1612.0: i32)
  using: _1@Phi(bb708), _1612@Mir(bb718[8])
  _3902 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  _1614 = ((*_3902).0: *mut i8)
  using: _3902@Mir(bb719[1])
  _1613 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1614, const 1_isize) -> bb720
  using: _1614@Mir(bb719[2])
bb720:
  _3903 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  ((*_3903).0: *mut i8) = move _1613
  using: _3903@Mir(bb720[0]), _1613@Mir(bb719[3])
  _3904 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  _1616 = ((*_3904).1: u32)
  using: _3904@Mir(bb720[2])
  _1615 = core::num::<impl u32>::wrapping_sub(move _1616, const 1_u32) -> bb721
  using: _1616@Mir(bb720[3])
bb721:
  _3905 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  ((*_3905).1: u32) = move _1615
  using: _3905@Mir(bb721[0]), _1615@Mir(bb720[4])
  _3906 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  _1618 = ((*_3906).2: u32)
  using: _3906@Mir(bb721[2])
  _1617 = core::num::<impl u32>::wrapping_add(move _1618, const 1_u32) -> bb722
  using: _1618@Mir(bb721[3])
bb722:
  _3907 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  ((*_3907).2: u32) = move _1617
  using: _3907@Mir(bb722[0]), _1617@Mir(bb721[4])
  _3908 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  _1620 = ((*_3908).2: u32)
  using: _3908@Mir(bb722[2])
  _1621 = const 0_u32
  using: 
  _1619 = Eq(move _1620, move _1621)
  using: _1620@Mir(bb722[3]), _1621@Mir(bb722[4])
  switchInt(move _1619) -> [0: bb708, otherwise: bb723]
  using: _1619@Mir(bb722[5])
bb723:
  _3909 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  _1623 = ((*_3909).3: u32)
  using: _3909@Mir(bb723[0])
  _1622 = core::num::<impl u32>::wrapping_add(move _1623, const 1_u32) -> bb724
  using: _1623@Mir(bb723[1])
bb724:
  _3910 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb708)
  ((*_3910).3: u32) = move _1622
  using: _3910@Mir(bb724[0]), _1622@Mir(bb723[2])
  goto -> bb708
  using: 
bb725:
  _1624 = const 35_i32
  using: 
  ((*_1).1: i32) = move _1624
  using: _1@Phi(bb708), _1624@Mir(bb725[0])
  goto -> bb726
  using: 
bb726:
  _1626 = ((*_1).8: i32)
  using: _1@Phi(bb726)
  _1627 = const 1_i32
  using: 
  _1625 = Ge(move _1626, move _1627)
  using: _1626@Mir(bb726[0]), _1627@Mir(bb726[1])
  switchInt(move _1625) -> [0: bb731, otherwise: bb727]
  using: _1625@Mir(bb726[2])
bb727:
  _1628 = const 0_u32
  using: 
  _1630 = ((*_1).7: u32)
  using: _1@Phi(bb726)
  _1632 = ((*_1).8: i32)
  using: _1@Phi(bb726)
  _1633 = const 1_i32
  using: 
  _1634 = CheckedSub(_1632, _1633)
  using: _1632@Mir(bb727[2]), _1633@Mir(bb727[3])
  assert(!move (_1634.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1632, move _1633) -> bb728
  using: _1634@Entry, _1632@Entry, _1633@Entry
bb728:
  _1631 = move (_1634.0: i32)
  using: _1634@Mir(bb727[4])
  _1635 = CheckedShr(_1630, _1631)
  using: _1630@Mir(bb727[1]), _1631@Mir(bb728[0])
  assert(!move (_1635.1: bool), "attempt to shift right by `{}`, which would overflow", move _1631) -> bb729
  using: _1635@Entry, _1630@Entry, _1631@Entry
bb729:
  _1629 = move (_1635.0: u32)
  using: _1635@Mir(bb728[1])
  _1636 = const 1_u32
  using: 
  _1628 = BitAnd(move _1629, move _1636)
  using: _1629@Mir(bb729[0]), _1636@Mir(bb729[1])
  _1637 = const 1_i32
  using: 
  _1638 = CheckedSub(((*_1).8: i32), _1637)
  using: _1@Phi(bb726), _1637@Mir(bb729[3])
  assert(!move (_1638.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1637) -> bb730
  using: _1638@Entry, _1@Entry, _1637@Entry
bb730:
  ((*_1).8: i32) = move (_1638.0: i32)
  using: _1@Phi(bb726), _1638@Mir(bb729[4])
  _1639 = _1628
  using: _1628@Mir(bb729[2])
  _3 = move _1639 as u8 (IntToInt)
  using: _1639@Mir(bb730[1])
  _1666 = _3
  using: _3@Mir(bb730[2])
  _1665 = move _1666 as i32 (IntToInt)
  using: _1666@Mir(bb730[3])
  _1667 = const 0_i32
  using: 
  _1664 = Eq(move _1665, move _1667)
  using: _1665@Mir(bb730[4]), _1667@Mir(bb730[5])
  switchInt(move _1664) -> [0: bb743, otherwise: bb741]
  using: _1664@Mir(bb730[6])
bb731:
  _3911 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  _1641 = ((*_3911).1: u32)
  using: _3911@Mir(bb731[0])
  _1642 = const 0_u32
  using: 
  _1640 = Eq(move _1641, move _1642)
  using: _1641@Mir(bb731[1]), _1642@Mir(bb731[2])
  switchInt(move _1640) -> [0: bb733, otherwise: bb732]
  using: _1640@Mir(bb731[3])
bb732:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb733:
  _1644 = ((*_1).7: u32)
  using: _1@Phi(bb726)
  _1645 = const 8_i32
  using: 
  _1646 = CheckedShl(_1644, _1645)
  using: _1644@Mir(bb733[0]), _1645@Mir(bb733[1])
  assert(!move (_1646.1: bool), "attempt to shift left by `{}`, which would overflow", move _1645) -> bb734
  using: _1646@Entry, _1644@Entry, _1645@Entry
bb734:
  _1643 = move (_1646.0: u32)
  using: _1646@Mir(bb733[2])
  _3912 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  _1650 = ((*_3912).0: *mut i8)
  using: _3912@Mir(bb734[1])
  _1649 = move _1650 as *mut u8 (PtrToPtr)
  using: _1650@Mir(bb734[2])
  _1648 = (*_1649)
  using: _1649@Mir(bb734[3])
  _1647 = move _1648 as u32 (IntToInt)
  using: _1648@Mir(bb734[4])
  ((*_1).7: u32) = BitOr(move _1643, move _1647)
  using: _1@Phi(bb726), _1643@Mir(bb734[0]), _1647@Mir(bb734[5])
  _1651 = const 8_i32
  using: 
  _1652 = CheckedAdd(((*_1).8: i32), _1651)
  using: _1@Phi(bb726), _1651@Mir(bb734[7])
  assert(!move (_1652.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1651) -> bb735
  using: _1652@Entry, _1@Entry, _1651@Entry
bb735:
  ((*_1).8: i32) = move (_1652.0: i32)
  using: _1@Phi(bb726), _1652@Mir(bb734[8])
  _3913 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  _1654 = ((*_3913).0: *mut i8)
  using: _3913@Mir(bb735[1])
  _1653 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1654, const 1_isize) -> bb736
  using: _1654@Mir(bb735[2])
bb736:
  _3914 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  ((*_3914).0: *mut i8) = move _1653
  using: _3914@Mir(bb736[0]), _1653@Mir(bb735[3])
  _3915 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  _1656 = ((*_3915).1: u32)
  using: _3915@Mir(bb736[2])
  _1655 = core::num::<impl u32>::wrapping_sub(move _1656, const 1_u32) -> bb737
  using: _1656@Mir(bb736[3])
bb737:
  _3916 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  ((*_3916).1: u32) = move _1655
  using: _3916@Mir(bb737[0]), _1655@Mir(bb736[4])
  _3917 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  _1658 = ((*_3917).2: u32)
  using: _3917@Mir(bb737[2])
  _1657 = core::num::<impl u32>::wrapping_add(move _1658, const 1_u32) -> bb738
  using: _1658@Mir(bb737[3])
bb738:
  _3918 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  ((*_3918).2: u32) = move _1657
  using: _3918@Mir(bb738[0]), _1657@Mir(bb737[4])
  _3919 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  _1660 = ((*_3919).2: u32)
  using: _3919@Mir(bb738[2])
  _1661 = const 0_u32
  using: 
  _1659 = Eq(move _1660, move _1661)
  using: _1660@Mir(bb738[3]), _1661@Mir(bb738[4])
  switchInt(move _1659) -> [0: bb726, otherwise: bb739]
  using: _1659@Mir(bb738[5])
bb739:
  _3920 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  _1663 = ((*_3920).3: u32)
  using: _3920@Mir(bb739[0])
  _1662 = core::num::<impl u32>::wrapping_add(move _1663, const 1_u32) -> bb740
  using: _1663@Mir(bb739[1])
bb740:
  _3921 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb726)
  ((*_3921).3: u32) = move _1662
  using: _3921@Mir(bb740[0]), _1662@Mir(bb739[2])
  goto -> bb726
  using: 
bb741:
  _1668 = CheckedAdd(_22, const 1_i32)
  using: _22@Phi(bb634)
  assert(!move (_1668.1: bool), "attempt to compute `{} + {}`, which would overflow", _22, const 1_i32) -> bb742
  using: _1668@Entry, _22@Entry
bb742:
  _22 = move (_1668.0: i32)
  using: _1668@Mir(bb741[0])
  goto -> bb745
  using: 
bb743:
  _1669 = CheckedSub(_22, const 1_i32)
  using: _22@Phi(bb634)
  assert(!move (_1669.1: bool), "attempt to compute `{} - {}`, which would overflow", _22, const 1_i32) -> bb744
  using: _1669@Entry, _22@Entry
bb744:
  _22 = move (_1669.0: i32)
  using: _1669@Mir(bb743[0])
  goto -> bb745
  using: 
bb745:
  _2 = const 11858046780433112516_u64
  using: 
  goto -> bb908
  using: 
bb746:
  _1670 = const 34_i32
  using: 
  ((*_1).1: i32) = move _1670
  using: _1@Phi(bb726), _1670@Mir(bb746[0])
  goto -> bb747
  using: 
bb747:
  _1672 = ((*_1).8: i32)
  using: _1@Phi(bb747)
  _1673 = const 1_i32
  using: 
  _1671 = Ge(move _1672, move _1673)
  using: _1672@Mir(bb747[0]), _1673@Mir(bb747[1])
  switchInt(move _1671) -> [0: bb752, otherwise: bb748]
  using: _1671@Mir(bb747[2])
bb748:
  _1674 = const 0_u32
  using: 
  _1676 = ((*_1).7: u32)
  using: _1@Phi(bb747)
  _1678 = ((*_1).8: i32)
  using: _1@Phi(bb747)
  _1679 = const 1_i32
  using: 
  _1680 = CheckedSub(_1678, _1679)
  using: _1678@Mir(bb748[2]), _1679@Mir(bb748[3])
  assert(!move (_1680.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1678, move _1679) -> bb749
  using: _1680@Entry, _1678@Entry, _1679@Entry
bb749:
  _1677 = move (_1680.0: i32)
  using: _1680@Mir(bb748[4])
  _1681 = CheckedShr(_1676, _1677)
  using: _1676@Mir(bb748[1]), _1677@Mir(bb749[0])
  assert(!move (_1681.1: bool), "attempt to shift right by `{}`, which would overflow", move _1677) -> bb750
  using: _1681@Entry, _1676@Entry, _1677@Entry
bb750:
  _1675 = move (_1681.0: u32)
  using: _1681@Mir(bb749[1])
  _1682 = const 1_u32
  using: 
  _1674 = BitAnd(move _1675, move _1682)
  using: _1675@Mir(bb750[0]), _1682@Mir(bb750[1])
  _1683 = const 1_i32
  using: 
  _1684 = CheckedSub(((*_1).8: i32), _1683)
  using: _1@Phi(bb747), _1683@Mir(bb750[3])
  assert(!move (_1684.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1683) -> bb751
  using: _1684@Entry, _1@Entry, _1683@Entry
bb751:
  ((*_1).8: i32) = move (_1684.0: i32)
  using: _1@Phi(bb747), _1684@Mir(bb750[4])
  _1685 = _1674
  using: _1674@Mir(bb750[2])
  _3 = move _1685 as u8 (IntToInt)
  using: _1685@Mir(bb751[1])
  _1713 = _3
  using: _3@Mir(bb751[2])
  _1712 = move _1713 as i32 (IntToInt)
  using: _1713@Mir(bb751[3])
  _1714 = const 0_i32
  using: 
  _1711 = Eq(move _1712, move _1714)
  using: _1712@Mir(bb751[4]), _1714@Mir(bb751[5])
  _1710 = Not(move _1711)
  using: _1711@Mir(bb751[6])
  switchInt(move _1710) -> [0: bb763, otherwise: bb762]
  using: _1710@Mir(bb751[7])
bb752:
  _3922 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  _1687 = ((*_3922).1: u32)
  using: _3922@Mir(bb752[0])
  _1688 = const 0_u32
  using: 
  _1686 = Eq(move _1687, move _1688)
  using: _1687@Mir(bb752[1]), _1688@Mir(bb752[2])
  switchInt(move _1686) -> [0: bb754, otherwise: bb753]
  using: _1686@Mir(bb752[3])
bb753:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb754:
  _1690 = ((*_1).7: u32)
  using: _1@Phi(bb747)
  _1691 = const 8_i32
  using: 
  _1692 = CheckedShl(_1690, _1691)
  using: _1690@Mir(bb754[0]), _1691@Mir(bb754[1])
  assert(!move (_1692.1: bool), "attempt to shift left by `{}`, which would overflow", move _1691) -> bb755
  using: _1692@Entry, _1690@Entry, _1691@Entry
bb755:
  _1689 = move (_1692.0: u32)
  using: _1692@Mir(bb754[2])
  _3923 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  _1696 = ((*_3923).0: *mut i8)
  using: _3923@Mir(bb755[1])
  _1695 = move _1696 as *mut u8 (PtrToPtr)
  using: _1696@Mir(bb755[2])
  _1694 = (*_1695)
  using: _1695@Mir(bb755[3])
  _1693 = move _1694 as u32 (IntToInt)
  using: _1694@Mir(bb755[4])
  ((*_1).7: u32) = BitOr(move _1689, move _1693)
  using: _1@Phi(bb747), _1689@Mir(bb755[0]), _1693@Mir(bb755[5])
  _1697 = const 8_i32
  using: 
  _1698 = CheckedAdd(((*_1).8: i32), _1697)
  using: _1@Phi(bb747), _1697@Mir(bb755[7])
  assert(!move (_1698.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1697) -> bb756
  using: _1698@Entry, _1@Entry, _1697@Entry
bb756:
  ((*_1).8: i32) = move (_1698.0: i32)
  using: _1@Phi(bb747), _1698@Mir(bb755[8])
  _3924 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  _1700 = ((*_3924).0: *mut i8)
  using: _3924@Mir(bb756[1])
  _1699 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1700, const 1_isize) -> bb757
  using: _1700@Mir(bb756[2])
bb757:
  _3925 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  ((*_3925).0: *mut i8) = move _1699
  using: _3925@Mir(bb757[0]), _1699@Mir(bb756[3])
  _3926 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  _1702 = ((*_3926).1: u32)
  using: _3926@Mir(bb757[2])
  _1701 = core::num::<impl u32>::wrapping_sub(move _1702, const 1_u32) -> bb758
  using: _1702@Mir(bb757[3])
bb758:
  _3927 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  ((*_3927).1: u32) = move _1701
  using: _3927@Mir(bb758[0]), _1701@Mir(bb757[4])
  _3928 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  _1704 = ((*_3928).2: u32)
  using: _3928@Mir(bb758[2])
  _1703 = core::num::<impl u32>::wrapping_add(move _1704, const 1_u32) -> bb759
  using: _1704@Mir(bb758[3])
bb759:
  _3929 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  ((*_3929).2: u32) = move _1703
  using: _3929@Mir(bb759[0]), _1703@Mir(bb758[4])
  _3930 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  _1706 = ((*_3930).2: u32)
  using: _3930@Mir(bb759[2])
  _1707 = const 0_u32
  using: 
  _1705 = Eq(move _1706, move _1707)
  using: _1706@Mir(bb759[3]), _1707@Mir(bb759[4])
  switchInt(move _1705) -> [0: bb747, otherwise: bb760]
  using: _1705@Mir(bb759[5])
bb760:
  _3931 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  _1709 = ((*_3931).3: u32)
  using: _3931@Mir(bb760[0])
  _1708 = core::num::<impl u32>::wrapping_add(move _1709, const 1_u32) -> bb761
  using: _1709@Mir(bb760[1])
bb761:
  _3932 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb747)
  ((*_3932).3: u32) = move _1708
  using: _3932@Mir(bb761[0]), _1708@Mir(bb760[2])
  goto -> bb747
  using: 
bb762:
  _2 = const 5008197131544113214_u64
  using: 
  goto -> bb634
  using: 
bb763:
  _2 = const 17503523010989424999_u64
  using: 
  goto -> bb908
  using: 
bb764:
  _1715 = const 33_i32
  using: 
  ((*_1).1: i32) = move _1715
  using: _1@Phi(bb747), _1715@Mir(bb764[0])
  goto -> bb765
  using: 
bb765:
  _1717 = ((*_1).8: i32)
  using: _1@Phi(bb765)
  _1718 = const 5_i32
  using: 
  _1716 = Ge(move _1717, move _1718)
  using: _1717@Mir(bb765[0]), _1718@Mir(bb765[1])
  switchInt(move _1716) -> [0: bb770, otherwise: bb766]
  using: _1716@Mir(bb765[2])
bb766:
  _1719 = const 0_u32
  using: 
  _1721 = ((*_1).7: u32)
  using: _1@Phi(bb765)
  _1723 = ((*_1).8: i32)
  using: _1@Phi(bb765)
  _1724 = const 5_i32
  using: 
  _1725 = CheckedSub(_1723, _1724)
  using: _1723@Mir(bb766[2]), _1724@Mir(bb766[3])
  assert(!move (_1725.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1723, move _1724) -> bb767
  using: _1725@Entry, _1723@Entry, _1724@Entry
bb767:
  _1722 = move (_1725.0: i32)
  using: _1725@Mir(bb766[4])
  _1726 = CheckedShr(_1721, _1722)
  using: _1721@Mir(bb766[1]), _1722@Mir(bb767[0])
  assert(!move (_1726.1: bool), "attempt to shift right by `{}`, which would overflow", move _1722) -> bb768
  using: _1726@Entry, _1721@Entry, _1722@Entry
bb768:
  _1720 = move (_1726.0: u32)
  using: _1726@Mir(bb767[1])
  _1727 = const 31_u32
  using: 
  _1719 = BitAnd(move _1720, move _1727)
  using: _1720@Mir(bb768[0]), _1727@Mir(bb768[1])
  _1728 = const 5_i32
  using: 
  _1729 = CheckedSub(((*_1).8: i32), _1728)
  using: _1@Phi(bb765), _1728@Mir(bb768[3])
  assert(!move (_1729.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1728) -> bb769
  using: _1729@Entry, _1@Entry, _1728@Entry
bb769:
  ((*_1).8: i32) = move (_1729.0: i32)
  using: _1@Phi(bb765), _1729@Mir(bb768[4])
  _1730 = _1719
  using: _1719@Mir(bb768[2])
  _22 = move _1730 as i32 (IntToInt)
  using: _1730@Mir(bb769[1])
  _8 = const 0_i32
  using: 
  _2 = const 3770765986603902964_u64
  using: 
  goto -> bb908
  using: 
bb770:
  _3933 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  _1732 = ((*_3933).1: u32)
  using: _3933@Mir(bb770[0])
  _1733 = const 0_u32
  using: 
  _1731 = Eq(move _1732, move _1733)
  using: _1732@Mir(bb770[1]), _1733@Mir(bb770[2])
  switchInt(move _1731) -> [0: bb772, otherwise: bb771]
  using: _1731@Mir(bb770[3])
bb771:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb772:
  _1735 = ((*_1).7: u32)
  using: _1@Phi(bb765)
  _1736 = const 8_i32
  using: 
  _1737 = CheckedShl(_1735, _1736)
  using: _1735@Mir(bb772[0]), _1736@Mir(bb772[1])
  assert(!move (_1737.1: bool), "attempt to shift left by `{}`, which would overflow", move _1736) -> bb773
  using: _1737@Entry, _1735@Entry, _1736@Entry
bb773:
  _1734 = move (_1737.0: u32)
  using: _1737@Mir(bb772[2])
  _3934 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  _1741 = ((*_3934).0: *mut i8)
  using: _3934@Mir(bb773[1])
  _1740 = move _1741 as *mut u8 (PtrToPtr)
  using: _1741@Mir(bb773[2])
  _1739 = (*_1740)
  using: _1740@Mir(bb773[3])
  _1738 = move _1739 as u32 (IntToInt)
  using: _1739@Mir(bb773[4])
  ((*_1).7: u32) = BitOr(move _1734, move _1738)
  using: _1@Phi(bb765), _1734@Mir(bb773[0]), _1738@Mir(bb773[5])
  _1742 = const 8_i32
  using: 
  _1743 = CheckedAdd(((*_1).8: i32), _1742)
  using: _1@Phi(bb765), _1742@Mir(bb773[7])
  assert(!move (_1743.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1742) -> bb774
  using: _1743@Entry, _1@Entry, _1742@Entry
bb774:
  ((*_1).8: i32) = move (_1743.0: i32)
  using: _1@Phi(bb765), _1743@Mir(bb773[8])
  _3935 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  _1745 = ((*_3935).0: *mut i8)
  using: _3935@Mir(bb774[1])
  _1744 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1745, const 1_isize) -> bb775
  using: _1745@Mir(bb774[2])
bb775:
  _3936 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  ((*_3936).0: *mut i8) = move _1744
  using: _3936@Mir(bb775[0]), _1744@Mir(bb774[3])
  _3937 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  _1747 = ((*_3937).1: u32)
  using: _3937@Mir(bb775[2])
  _1746 = core::num::<impl u32>::wrapping_sub(move _1747, const 1_u32) -> bb776
  using: _1747@Mir(bb775[3])
bb776:
  _3938 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  ((*_3938).1: u32) = move _1746
  using: _3938@Mir(bb776[0]), _1746@Mir(bb775[4])
  _3939 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  _1749 = ((*_3939).2: u32)
  using: _3939@Mir(bb776[2])
  _1748 = core::num::<impl u32>::wrapping_add(move _1749, const 1_u32) -> bb777
  using: _1749@Mir(bb776[3])
bb777:
  _3940 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  ((*_3940).2: u32) = move _1748
  using: _3940@Mir(bb777[0]), _1748@Mir(bb776[4])
  _3941 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  _1751 = ((*_3941).2: u32)
  using: _3941@Mir(bb777[2])
  _1752 = const 0_u32
  using: 
  _1750 = Eq(move _1751, move _1752)
  using: _1751@Mir(bb777[3]), _1752@Mir(bb777[4])
  switchInt(move _1750) -> [0: bb765, otherwise: bb778]
  using: _1750@Mir(bb777[5])
bb778:
  _3942 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  _1754 = ((*_3942).3: u32)
  using: _3942@Mir(bb778[0])
  _1753 = core::num::<impl u32>::wrapping_add(move _1754, const 1_u32) -> bb779
  using: _1754@Mir(bb778[1])
bb779:
  _3943 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb765)
  ((*_3943).3: u32) = move _1753
  using: _3943@Mir(bb779[0]), _1753@Mir(bb778[2])
  goto -> bb765
  using: 
bb780:
  _1755 = const 32_i32
  using: 
  ((*_1).1: i32) = move _1755
  using: _1@Phi(bb765), _1755@Mir(bb780[0])
  goto -> bb781
  using: 
bb781:
  _1757 = ((*_1).8: i32)
  using: _1@Phi(bb781)
  _1758 = const 1_i32
  using: 
  _1756 = Ge(move _1757, move _1758)
  using: _1757@Mir(bb781[0]), _1758@Mir(bb781[1])
  switchInt(move _1756) -> [0: bb786, otherwise: bb782]
  using: _1756@Mir(bb781[2])
bb782:
  _1759 = const 0_u32
  using: 
  _1761 = ((*_1).7: u32)
  using: _1@Phi(bb781)
  _1763 = ((*_1).8: i32)
  using: _1@Phi(bb781)
  _1764 = const 1_i32
  using: 
  _1765 = CheckedSub(_1763, _1764)
  using: _1763@Mir(bb782[2]), _1764@Mir(bb782[3])
  assert(!move (_1765.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1763, move _1764) -> bb783
  using: _1765@Entry, _1763@Entry, _1764@Entry
bb783:
  _1762 = move (_1765.0: i32)
  using: _1765@Mir(bb782[4])
  _1766 = CheckedShr(_1761, _1762)
  using: _1761@Mir(bb782[1]), _1762@Mir(bb783[0])
  assert(!move (_1766.1: bool), "attempt to shift right by `{}`, which would overflow", move _1762) -> bb784
  using: _1766@Entry, _1761@Entry, _1762@Entry
bb784:
  _1760 = move (_1766.0: u32)
  using: _1766@Mir(bb783[1])
  _1767 = const 1_u32
  using: 
  _1759 = BitAnd(move _1760, move _1767)
  using: _1760@Mir(bb784[0]), _1767@Mir(bb784[1])
  _1768 = const 1_i32
  using: 
  _1769 = CheckedSub(((*_1).8: i32), _1768)
  using: _1@Phi(bb781), _1768@Mir(bb784[3])
  assert(!move (_1769.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1768) -> bb785
  using: _1769@Entry, _1@Entry, _1768@Entry
bb785:
  ((*_1).8: i32) = move (_1769.0: i32)
  using: _1@Phi(bb781), _1769@Mir(bb784[4])
  _1770 = _1759
  using: _1759@Mir(bb784[2])
  _3 = move _1770 as u8 (IntToInt)
  using: _1770@Mir(bb785[1])
  _1797 = _3
  using: _3@Mir(bb785[2])
  _1796 = move _1797 as i32 (IntToInt)
  using: _1797@Mir(bb785[3])
  _1798 = const 0_i32
  using: 
  _1795 = Eq(move _1796, move _1798)
  using: _1796@Mir(bb785[4]), _1798@Mir(bb785[5])
  switchInt(move _1795) -> [0: bb797, otherwise: bb796]
  using: _1795@Mir(bb785[6])
bb786:
  _3944 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  _1772 = ((*_3944).1: u32)
  using: _3944@Mir(bb786[0])
  _1773 = const 0_u32
  using: 
  _1771 = Eq(move _1772, move _1773)
  using: _1772@Mir(bb786[1]), _1773@Mir(bb786[2])
  switchInt(move _1771) -> [0: bb788, otherwise: bb787]
  using: _1771@Mir(bb786[3])
bb787:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb788:
  _1775 = ((*_1).7: u32)
  using: _1@Phi(bb781)
  _1776 = const 8_i32
  using: 
  _1777 = CheckedShl(_1775, _1776)
  using: _1775@Mir(bb788[0]), _1776@Mir(bb788[1])
  assert(!move (_1777.1: bool), "attempt to shift left by `{}`, which would overflow", move _1776) -> bb789
  using: _1777@Entry, _1775@Entry, _1776@Entry
bb789:
  _1774 = move (_1777.0: u32)
  using: _1777@Mir(bb788[2])
  _3945 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  _1781 = ((*_3945).0: *mut i8)
  using: _3945@Mir(bb789[1])
  _1780 = move _1781 as *mut u8 (PtrToPtr)
  using: _1781@Mir(bb789[2])
  _1779 = (*_1780)
  using: _1780@Mir(bb789[3])
  _1778 = move _1779 as u32 (IntToInt)
  using: _1779@Mir(bb789[4])
  ((*_1).7: u32) = BitOr(move _1774, move _1778)
  using: _1@Phi(bb781), _1774@Mir(bb789[0]), _1778@Mir(bb789[5])
  _1782 = const 8_i32
  using: 
  _1783 = CheckedAdd(((*_1).8: i32), _1782)
  using: _1@Phi(bb781), _1782@Mir(bb789[7])
  assert(!move (_1783.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1782) -> bb790
  using: _1783@Entry, _1@Entry, _1782@Entry
bb790:
  ((*_1).8: i32) = move (_1783.0: i32)
  using: _1@Phi(bb781), _1783@Mir(bb789[8])
  _3946 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  _1785 = ((*_3946).0: *mut i8)
  using: _3946@Mir(bb790[1])
  _1784 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1785, const 1_isize) -> bb791
  using: _1785@Mir(bb790[2])
bb791:
  _3947 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  ((*_3947).0: *mut i8) = move _1784
  using: _3947@Mir(bb791[0]), _1784@Mir(bb790[3])
  _3948 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  _1787 = ((*_3948).1: u32)
  using: _3948@Mir(bb791[2])
  _1786 = core::num::<impl u32>::wrapping_sub(move _1787, const 1_u32) -> bb792
  using: _1787@Mir(bb791[3])
bb792:
  _3949 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  ((*_3949).1: u32) = move _1786
  using: _3949@Mir(bb792[0]), _1786@Mir(bb791[4])
  _3950 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  _1789 = ((*_3950).2: u32)
  using: _3950@Mir(bb792[2])
  _1788 = core::num::<impl u32>::wrapping_add(move _1789, const 1_u32) -> bb793
  using: _1789@Mir(bb792[3])
bb793:
  _3951 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  ((*_3951).2: u32) = move _1788
  using: _3951@Mir(bb793[0]), _1788@Mir(bb792[4])
  _3952 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  _1791 = ((*_3952).2: u32)
  using: _3952@Mir(bb793[2])
  _1792 = const 0_u32
  using: 
  _1790 = Eq(move _1791, move _1792)
  using: _1791@Mir(bb793[3]), _1792@Mir(bb793[4])
  switchInt(move _1790) -> [0: bb781, otherwise: bb794]
  using: _1790@Mir(bb793[5])
bb794:
  _3953 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  _1794 = ((*_3953).3: u32)
  using: _3953@Mir(bb794[0])
  _1793 = core::num::<impl u32>::wrapping_add(move _1794, const 1_u32) -> bb795
  using: _1794@Mir(bb794[1])
bb795:
  _3954 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb781)
  ((*_3954).3: u32) = move _1793
  using: _3954@Mir(bb795[0]), _1793@Mir(bb794[2])
  goto -> bb781
  using: 
bb796:
  _2 = const 5281038271658253520_u64
  using: 
  goto -> bb908
  using: 
bb797:
  _1799 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb634)
  assert(!move (_1799.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb798
  using: _1799@Entry, _9@Entry
bb798:
  _9 = move (_1799.0: i32)
  using: _1799@Mir(bb797[0])
  _1801 = _9
  using: _9@Mir(bb798[0])
  _1802 = _12
  using: _12@Phi(bb634)
  _1800 = Ge(move _1801, move _1802)
  using: _1801@Mir(bb798[1]), _1802@Mir(bb798[2])
  switchInt(move _1800) -> [0: bb800, otherwise: bb799]
  using: _1800@Mir(bb798[3])
bb799:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb800:
  _2 = const 6927328446518169316_u64
  using: 
  goto -> bb908
  using: 
bb801:
  _1803 = const 31_i32
  using: 
  ((*_1).1: i32) = move _1803
  using: _1@Phi(bb781), _1803@Mir(bb801[0])
  goto -> bb802
  using: 
bb802:
  _1805 = ((*_1).8: i32)
  using: _1@Phi(bb802)
  _1806 = const 15_i32
  using: 
  _1804 = Ge(move _1805, move _1806)
  using: _1805@Mir(bb802[0]), _1806@Mir(bb802[1])
  switchInt(move _1804) -> [0: bb807, otherwise: bb803]
  using: _1804@Mir(bb802[2])
bb803:
  _1807 = const 0_u32
  using: 
  _1809 = ((*_1).7: u32)
  using: _1@Phi(bb802)
  _1811 = ((*_1).8: i32)
  using: _1@Phi(bb802)
  _1812 = const 15_i32
  using: 
  _1813 = CheckedSub(_1811, _1812)
  using: _1811@Mir(bb803[2]), _1812@Mir(bb803[3])
  assert(!move (_1813.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1811, move _1812) -> bb804
  using: _1813@Entry, _1811@Entry, _1812@Entry
bb804:
  _1810 = move (_1813.0: i32)
  using: _1813@Mir(bb803[4])
  _1814 = CheckedShr(_1809, _1810)
  using: _1809@Mir(bb803[1]), _1810@Mir(bb804[0])
  assert(!move (_1814.1: bool), "attempt to shift right by `{}`, which would overflow", move _1810) -> bb805
  using: _1814@Entry, _1809@Entry, _1810@Entry
bb805:
  _1808 = move (_1814.0: u32)
  using: _1814@Mir(bb804[1])
  _1815 = const 32767_u32
  using: 
  _1807 = BitAnd(move _1808, move _1815)
  using: _1808@Mir(bb805[0]), _1815@Mir(bb805[1])
  _1816 = const 15_i32
  using: 
  _1817 = CheckedSub(((*_1).8: i32), _1816)
  using: _1@Phi(bb802), _1816@Mir(bb805[3])
  assert(!move (_1817.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1816) -> bb806
  using: _1817@Entry, _1@Entry, _1816@Entry
bb806:
  ((*_1).8: i32) = move (_1817.0: i32)
  using: _1@Phi(bb802), _1817@Mir(bb805[4])
  _1818 = _1807
  using: _1807@Mir(bb805[2])
  _13 = move _1818 as i32 (IntToInt)
  using: _1818@Mir(bb806[1])
  _1844 = _13
  using: _13@Mir(bb806[2])
  _1845 = const 1_i32
  using: 
  _1843 = Lt(move _1844, move _1845)
  using: _1844@Mir(bb806[3]), _1845@Mir(bb806[4])
  switchInt(move _1843) -> [0: bb818, otherwise: bb817]
  using: _1843@Mir(bb806[5])
bb807:
  _3955 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  _1820 = ((*_3955).1: u32)
  using: _3955@Mir(bb807[0])
  _1821 = const 0_u32
  using: 
  _1819 = Eq(move _1820, move _1821)
  using: _1820@Mir(bb807[1]), _1821@Mir(bb807[2])
  switchInt(move _1819) -> [0: bb809, otherwise: bb808]
  using: _1819@Mir(bb807[3])
bb808:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb809:
  _1823 = ((*_1).7: u32)
  using: _1@Phi(bb802)
  _1824 = const 8_i32
  using: 
  _1825 = CheckedShl(_1823, _1824)
  using: _1823@Mir(bb809[0]), _1824@Mir(bb809[1])
  assert(!move (_1825.1: bool), "attempt to shift left by `{}`, which would overflow", move _1824) -> bb810
  using: _1825@Entry, _1823@Entry, _1824@Entry
bb810:
  _1822 = move (_1825.0: u32)
  using: _1825@Mir(bb809[2])
  _3956 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  _1829 = ((*_3956).0: *mut i8)
  using: _3956@Mir(bb810[1])
  _1828 = move _1829 as *mut u8 (PtrToPtr)
  using: _1829@Mir(bb810[2])
  _1827 = (*_1828)
  using: _1828@Mir(bb810[3])
  _1826 = move _1827 as u32 (IntToInt)
  using: _1827@Mir(bb810[4])
  ((*_1).7: u32) = BitOr(move _1822, move _1826)
  using: _1@Phi(bb802), _1822@Mir(bb810[0]), _1826@Mir(bb810[5])
  _1830 = const 8_i32
  using: 
  _1831 = CheckedAdd(((*_1).8: i32), _1830)
  using: _1@Phi(bb802), _1830@Mir(bb810[7])
  assert(!move (_1831.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1830) -> bb811
  using: _1831@Entry, _1@Entry, _1830@Entry
bb811:
  ((*_1).8: i32) = move (_1831.0: i32)
  using: _1@Phi(bb802), _1831@Mir(bb810[8])
  _3957 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  _1833 = ((*_3957).0: *mut i8)
  using: _3957@Mir(bb811[1])
  _1832 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1833, const 1_isize) -> bb812
  using: _1833@Mir(bb811[2])
bb812:
  _3958 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  ((*_3958).0: *mut i8) = move _1832
  using: _3958@Mir(bb812[0]), _1832@Mir(bb811[3])
  _3959 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  _1835 = ((*_3959).1: u32)
  using: _3959@Mir(bb812[2])
  _1834 = core::num::<impl u32>::wrapping_sub(move _1835, const 1_u32) -> bb813
  using: _1835@Mir(bb812[3])
bb813:
  _3960 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  ((*_3960).1: u32) = move _1834
  using: _3960@Mir(bb813[0]), _1834@Mir(bb812[4])
  _3961 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  _1837 = ((*_3961).2: u32)
  using: _3961@Mir(bb813[2])
  _1836 = core::num::<impl u32>::wrapping_add(move _1837, const 1_u32) -> bb814
  using: _1837@Mir(bb813[3])
bb814:
  _3962 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  ((*_3962).2: u32) = move _1836
  using: _3962@Mir(bb814[0]), _1836@Mir(bb813[4])
  _3963 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  _1839 = ((*_3963).2: u32)
  using: _3963@Mir(bb814[2])
  _1840 = const 0_u32
  using: 
  _1838 = Eq(move _1839, move _1840)
  using: _1839@Mir(bb814[3]), _1840@Mir(bb814[4])
  switchInt(move _1838) -> [0: bb802, otherwise: bb815]
  using: _1838@Mir(bb814[5])
bb815:
  _3964 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  _1842 = ((*_3964).3: u32)
  using: _3964@Mir(bb815[0])
  _1841 = core::num::<impl u32>::wrapping_add(move _1842, const 1_u32) -> bb816
  using: _1842@Mir(bb815[1])
bb816:
  _3965 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb802)
  ((*_3965).3: u32) = move _1841
  using: _3965@Mir(bb816[0]), _1841@Mir(bb815[2])
  goto -> bb802
  using: 
bb817:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb818:
  _8 = const 0_i32
  using: 
  _2 = const 6591141407893725683_u64
  using: 
  goto -> bb908
  using: 
bb819:
  _1846 = const 30_i32
  using: 
  ((*_1).1: i32) = move _1846
  using: _1@Phi(bb802), _1846@Mir(bb819[0])
  goto -> bb820
  using: 
bb820:
  _1848 = ((*_1).8: i32)
  using: _1@Phi(bb820)
  _1849 = const 3_i32
  using: 
  _1847 = Ge(move _1848, move _1849)
  using: _1848@Mir(bb820[0]), _1849@Mir(bb820[1])
  switchInt(move _1847) -> [0: bb825, otherwise: bb821]
  using: _1847@Mir(bb820[2])
bb821:
  _1850 = const 0_u32
  using: 
  _1852 = ((*_1).7: u32)
  using: _1@Phi(bb820)
  _1854 = ((*_1).8: i32)
  using: _1@Phi(bb820)
  _1855 = const 3_i32
  using: 
  _1856 = CheckedSub(_1854, _1855)
  using: _1854@Mir(bb821[2]), _1855@Mir(bb821[3])
  assert(!move (_1856.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1854, move _1855) -> bb822
  using: _1856@Entry, _1854@Entry, _1855@Entry
bb822:
  _1853 = move (_1856.0: i32)
  using: _1856@Mir(bb821[4])
  _1857 = CheckedShr(_1852, _1853)
  using: _1852@Mir(bb821[1]), _1853@Mir(bb822[0])
  assert(!move (_1857.1: bool), "attempt to shift right by `{}`, which would overflow", move _1853) -> bb823
  using: _1857@Entry, _1852@Entry, _1853@Entry
bb823:
  _1851 = move (_1857.0: u32)
  using: _1857@Mir(bb822[1])
  _1858 = const 7_u32
  using: 
  _1850 = BitAnd(move _1851, move _1858)
  using: _1851@Mir(bb823[0]), _1858@Mir(bb823[1])
  _1859 = const 3_i32
  using: 
  _1860 = CheckedSub(((*_1).8: i32), _1859)
  using: _1@Phi(bb820), _1859@Mir(bb823[3])
  assert(!move (_1860.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1859) -> bb824
  using: _1860@Entry, _1@Entry, _1859@Entry
bb824:
  ((*_1).8: i32) = move (_1860.0: i32)
  using: _1@Phi(bb820), _1860@Mir(bb823[4])
  _1861 = _1850
  using: _1850@Mir(bb823[2])
  _12 = move _1861 as i32 (IntToInt)
  using: _1861@Mir(bb824[1])
  _1889 = _12
  using: _12@Mir(bb824[2])
  _1890 = const 2_i32
  using: 
  _1888 = Lt(move _1889, move _1890)
  using: _1889@Mir(bb824[3]), _1890@Mir(bb824[4])
  switchInt(move _1888) -> [0: bb836, otherwise: bb835]
  using: _1888@Mir(bb824[5])
bb825:
  _3966 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  _1863 = ((*_3966).1: u32)
  using: _3966@Mir(bb825[0])
  _1864 = const 0_u32
  using: 
  _1862 = Eq(move _1863, move _1864)
  using: _1863@Mir(bb825[1]), _1864@Mir(bb825[2])
  switchInt(move _1862) -> [0: bb827, otherwise: bb826]
  using: _1862@Mir(bb825[3])
bb826:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb827:
  _1866 = ((*_1).7: u32)
  using: _1@Phi(bb820)
  _1867 = const 8_i32
  using: 
  _1868 = CheckedShl(_1866, _1867)
  using: _1866@Mir(bb827[0]), _1867@Mir(bb827[1])
  assert(!move (_1868.1: bool), "attempt to shift left by `{}`, which would overflow", move _1867) -> bb828
  using: _1868@Entry, _1866@Entry, _1867@Entry
bb828:
  _1865 = move (_1868.0: u32)
  using: _1868@Mir(bb827[2])
  _3967 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  _1872 = ((*_3967).0: *mut i8)
  using: _3967@Mir(bb828[1])
  _1871 = move _1872 as *mut u8 (PtrToPtr)
  using: _1872@Mir(bb828[2])
  _1870 = (*_1871)
  using: _1871@Mir(bb828[3])
  _1869 = move _1870 as u32 (IntToInt)
  using: _1870@Mir(bb828[4])
  ((*_1).7: u32) = BitOr(move _1865, move _1869)
  using: _1@Phi(bb820), _1865@Mir(bb828[0]), _1869@Mir(bb828[5])
  _1873 = const 8_i32
  using: 
  _1874 = CheckedAdd(((*_1).8: i32), _1873)
  using: _1@Phi(bb820), _1873@Mir(bb828[7])
  assert(!move (_1874.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1873) -> bb829
  using: _1874@Entry, _1@Entry, _1873@Entry
bb829:
  ((*_1).8: i32) = move (_1874.0: i32)
  using: _1@Phi(bb820), _1874@Mir(bb828[8])
  _3968 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  _1876 = ((*_3968).0: *mut i8)
  using: _3968@Mir(bb829[1])
  _1875 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1876, const 1_isize) -> bb830
  using: _1876@Mir(bb829[2])
bb830:
  _3969 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  ((*_3969).0: *mut i8) = move _1875
  using: _3969@Mir(bb830[0]), _1875@Mir(bb829[3])
  _3970 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  _1878 = ((*_3970).1: u32)
  using: _3970@Mir(bb830[2])
  _1877 = core::num::<impl u32>::wrapping_sub(move _1878, const 1_u32) -> bb831
  using: _1878@Mir(bb830[3])
bb831:
  _3971 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  ((*_3971).1: u32) = move _1877
  using: _3971@Mir(bb831[0]), _1877@Mir(bb830[4])
  _3972 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  _1880 = ((*_3972).2: u32)
  using: _3972@Mir(bb831[2])
  _1879 = core::num::<impl u32>::wrapping_add(move _1880, const 1_u32) -> bb832
  using: _1880@Mir(bb831[3])
bb832:
  _3973 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  ((*_3973).2: u32) = move _1879
  using: _3973@Mir(bb832[0]), _1879@Mir(bb831[4])
  _3974 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  _1882 = ((*_3974).2: u32)
  using: _3974@Mir(bb832[2])
  _1883 = const 0_u32
  using: 
  _1881 = Eq(move _1882, move _1883)
  using: _1882@Mir(bb832[3]), _1883@Mir(bb832[4])
  switchInt(move _1881) -> [0: bb820, otherwise: bb833]
  using: _1881@Mir(bb832[5])
bb833:
  _3975 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  _1885 = ((*_3975).3: u32)
  using: _3975@Mir(bb833[0])
  _1884 = core::num::<impl u32>::wrapping_add(move _1885, const 1_u32) -> bb834
  using: _1885@Mir(bb833[1])
bb834:
  _3976 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb820)
  ((*_3976).3: u32) = move _1884
  using: _3976@Mir(bb834[0]), _1884@Mir(bb833[2])
  goto -> bb820
  using: 
bb835:
  _1887 = const true
  using: 
  goto -> bb837
  using: 
bb836:
  _1892 = _12
  using: _12@Mir(bb824[2])
  _1893 = const 6_i32
  using: 
  _1891 = Gt(move _1892, move _1893)
  using: _1892@Mir(bb836[0]), _1893@Mir(bb836[1])
  _1887 = move _1891
  using: _1891@Mir(bb836[2])
  goto -> bb837
  using: 
bb837:
  _1886 = Not(move _1887)
  using: _1887@Phi(bb837)
  switchInt(move _1886) -> [0: bb839, otherwise: bb838]
  using: _1886@Mir(bb837[0])
bb838:
  _2 = const 5769007513321684282_u64
  using: 
  goto -> bb634
  using: 
bb839:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb840:
  _1894 = const 29_i32
  using: 
  ((*_1).1: i32) = move _1894
  using: _1@Phi(bb820), _1894@Mir(bb840[0])
  goto -> bb841
  using: 
bb841:
  _1896 = ((*_1).8: i32)
  using: _1@Phi(bb841)
  _1897 = const 1_i32
  using: 
  _1895 = Ge(move _1896, move _1897)
  using: _1896@Mir(bb841[0]), _1897@Mir(bb841[1])
  switchInt(move _1895) -> [0: bb846, otherwise: bb842]
  using: _1895@Mir(bb841[2])
bb842:
  _1898 = const 0_u32
  using: 
  _1900 = ((*_1).7: u32)
  using: _1@Phi(bb841)
  _1902 = ((*_1).8: i32)
  using: _1@Phi(bb841)
  _1903 = const 1_i32
  using: 
  _1904 = CheckedSub(_1902, _1903)
  using: _1902@Mir(bb842[2]), _1903@Mir(bb842[3])
  assert(!move (_1904.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1902, move _1903) -> bb843
  using: _1904@Entry, _1902@Entry, _1903@Entry
bb843:
  _1901 = move (_1904.0: i32)
  using: _1904@Mir(bb842[4])
  _1905 = CheckedShr(_1900, _1901)
  using: _1900@Mir(bb842[1]), _1901@Mir(bb843[0])
  assert(!move (_1905.1: bool), "attempt to shift right by `{}`, which would overflow", move _1901) -> bb844
  using: _1905@Entry, _1900@Entry, _1901@Entry
bb844:
  _1899 = move (_1905.0: u32)
  using: _1905@Mir(bb843[1])
  _1906 = const 1_u32
  using: 
  _1898 = BitAnd(move _1899, move _1906)
  using: _1899@Mir(bb844[0]), _1906@Mir(bb844[1])
  _1907 = const 1_i32
  using: 
  _1908 = CheckedSub(((*_1).8: i32), _1907)
  using: _1@Phi(bb841), _1907@Mir(bb844[3])
  assert(!move (_1908.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1907) -> bb845
  using: _1908@Entry, _1@Entry, _1907@Entry
bb845:
  ((*_1).8: i32) = move (_1908.0: i32)
  using: _1@Phi(bb841), _1908@Mir(bb844[4])
  _1909 = _1898
  using: _1898@Mir(bb844[2])
  _3 = move _1909 as u8 (IntToInt)
  using: _1909@Mir(bb845[1])
  _1936 = _3
  using: _3@Mir(bb845[2])
  _1935 = move _1936 as i32 (IntToInt)
  using: _1936@Mir(bb845[3])
  _1937 = const 1_i32
  using: 
  _1934 = Eq(move _1935, move _1937)
  using: _1935@Mir(bb845[4]), _1937@Mir(bb845[5])
  switchInt(move _1934) -> [0: bb860, otherwise: bb856]
  using: _1934@Mir(bb845[6])
bb846:
  _3977 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  _1911 = ((*_3977).1: u32)
  using: _3977@Mir(bb846[0])
  _1912 = const 0_u32
  using: 
  _1910 = Eq(move _1911, move _1912)
  using: _1911@Mir(bb846[1]), _1912@Mir(bb846[2])
  switchInt(move _1910) -> [0: bb848, otherwise: bb847]
  using: _1910@Mir(bb846[3])
bb847:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb848:
  _1914 = ((*_1).7: u32)
  using: _1@Phi(bb860)
  _1915 = const 8_i32
  using: 
  _1916 = CheckedShl(_1914, _1915)
  using: _1914@Mir(bb848[0]), _1915@Mir(bb848[1])
  assert(!move (_1916.1: bool), "attempt to shift left by `{}`, which would overflow", move _1915) -> bb849
  using: _1916@Entry, _1914@Entry, _1915@Entry
bb849:
  _1913 = move (_1916.0: u32)
  using: _1916@Mir(bb848[2])
  _3978 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  _1920 = ((*_3978).0: *mut i8)
  using: _3978@Mir(bb849[1])
  _1919 = move _1920 as *mut u8 (PtrToPtr)
  using: _1920@Mir(bb849[2])
  _1918 = (*_1919)
  using: _1919@Mir(bb849[3])
  _1917 = move _1918 as u32 (IntToInt)
  using: _1918@Mir(bb849[4])
  ((*_1).7: u32) = BitOr(move _1913, move _1917)
  using: _1@Phi(bb860), _1913@Mir(bb849[0]), _1917@Mir(bb849[5])
  _1921 = const 8_i32
  using: 
  _1922 = CheckedAdd(((*_1).8: i32), _1921)
  using: _1@Phi(bb860), _1921@Mir(bb849[7])
  assert(!move (_1922.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1921) -> bb850
  using: _1922@Entry, _1@Entry, _1921@Entry
bb850:
  ((*_1).8: i32) = move (_1922.0: i32)
  using: _1@Phi(bb860), _1922@Mir(bb849[8])
  _3979 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  _1924 = ((*_3979).0: *mut i8)
  using: _3979@Mir(bb850[1])
  _1923 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1924, const 1_isize) -> bb851
  using: _1924@Mir(bb850[2])
bb851:
  _3980 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  ((*_3980).0: *mut i8) = move _1923
  using: _3980@Mir(bb851[0]), _1923@Mir(bb850[3])
  _3981 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  _1926 = ((*_3981).1: u32)
  using: _3981@Mir(bb851[2])
  _1925 = core::num::<impl u32>::wrapping_sub(move _1926, const 1_u32) -> bb852
  using: _1926@Mir(bb851[3])
bb852:
  _3982 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  ((*_3982).1: u32) = move _1925
  using: _3982@Mir(bb852[0]), _1925@Mir(bb851[4])
  _3983 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  _1928 = ((*_3983).2: u32)
  using: _3983@Mir(bb852[2])
  _1927 = core::num::<impl u32>::wrapping_add(move _1928, const 1_u32) -> bb853
  using: _1928@Mir(bb852[3])
bb853:
  _3984 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  ((*_3984).2: u32) = move _1927
  using: _3984@Mir(bb853[0]), _1927@Mir(bb852[4])
  _3985 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  _1930 = ((*_3985).2: u32)
  using: _3985@Mir(bb853[2])
  _1931 = const 0_u32
  using: 
  _1929 = Eq(move _1930, move _1931)
  using: _1930@Mir(bb853[3]), _1931@Mir(bb853[4])
  switchInt(move _1929) -> [0: bb841, otherwise: bb854]
  using: _1929@Mir(bb853[5])
bb854:
  _3986 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  _1933 = ((*_3986).3: u32)
  using: _3986@Mir(bb854[0])
  _1932 = core::num::<impl u32>::wrapping_add(move _1933, const 1_u32) -> bb855
  using: _1933@Mir(bb854[1])
bb855:
  _3987 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb860)
  ((*_3987).3: u32) = move _1932
  using: _3987@Mir(bb855[0]), _1932@Mir(bb854[2])
  goto -> bb841
  using: 
bb856:
  _1938 = const 1_i32
  using: 
  _1942 = _8
  using: _8@Phi(bb634)
  _1943 = const 16_i32
  using: 
  _1944 = CheckedMul(_1942, _1943)
  using: _1942@Mir(bb856[1]), _1943@Mir(bb856[2])
  assert(!move (_1944.1: bool), "attempt to compute `{} * {}`, which would overflow", move _1942, move _1943) -> bb857
  using: _1944@Entry, _1942@Entry, _1943@Entry
bb857:
  _1941 = move (_1944.0: i32)
  using: _1944@Mir(bb856[3])
  _1945 = _9
  using: _9@Phi(bb634)
  _1946 = CheckedAdd(_1941, _1945)
  using: _1941@Mir(bb857[0]), _1945@Mir(bb857[1])
  assert(!move (_1946.1: bool), "attempt to compute `{} + {}`, which would overflow", move _1941, move _1945) -> bb858
  using: _1946@Entry, _1941@Entry, _1945@Entry
bb858:
  _1940 = move (_1946.0: i32)
  using: _1946@Mir(bb857[2])
  _1939 = move _1940 as usize (IntToInt)
  using: _1940@Mir(bb858[0])
  _1947 = const 256_usize
  using: 
  _1948 = Lt(_1939, _1947)
  using: _1939@Mir(bb858[1]), _1947@Mir(bb858[2])
  assert(move _1948, "index out of bounds: the length is {} but the index is {}", move _1947, _1939) -> bb859
  using: _1948@Entry, _1947@Entry, _1939@Entry
bb859:
  ((*_1).28: [u8; 256])[_1939] = move _1938 as u8 (IntToInt)
  using: _1@Phi(bb841), _1939@Mir(bb858[1]), _1938@Mir(bb856[0])
  goto -> bb860
  using: 
bb860:
  _1949 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb860)
  assert(!move (_1949.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb861
  using: _1949@Entry, _9@Entry
bb861:
  _9 = move (_1949.0: i32)
  using: _1949@Mir(bb860[0])
  _2 = const 3854024847017804838_u64
  using: 
  goto -> bb908
  using: 
bb862:
  _1951 = _8
  using: _8@Phi(bb860)
  _1952 = const 16_i32
  using: 
  _1950 = Lt(move _1951, move _1952)
  using: _1951@Mir(bb862[0]), _1952@Mir(bb862[1])
  switchInt(move _1950) -> [0: bb864, otherwise: bb863]
  using: _1950@Mir(bb862[2])
bb863:
  _2 = const 16487873541482693172_u64
  using: 
  goto -> bb634
  using: 
bb864:
  _8 = const 0_i32
  using: 
  goto -> bb865
  using: 
bb865:
  _1954 = _8
  using: _8@Phi(bb865)
  _1955 = const 256_i32
  using: 
  _1953 = Lt(move _1954, move _1955)
  using: _1954@Mir(bb865[0]), _1955@Mir(bb865[1])
  switchInt(move _1953) -> [0: bb869, otherwise: bb866]
  using: _1953@Mir(bb865[2])
bb866:
  _1956 = const 0_i32
  using: 
  _1958 = _8
  using: _8@Phi(bb865)
  _1957 = move _1958 as usize (IntToInt)
  using: _1958@Mir(bb866[1])
  _1959 = const 256_usize
  using: 
  _1960 = Lt(_1957, _1959)
  using: _1957@Mir(bb866[2]), _1959@Mir(bb866[3])
  assert(move _1960, "index out of bounds: the length is {} but the index is {}", move _1959, _1957) -> bb867
  using: _1960@Entry, _1959@Entry, _1957@Entry
bb867:
  ((*_1).28: [u8; 256])[_1957] = move _1956 as u8 (IntToInt)
  using: _1@Phi(bb865), _1957@Mir(bb866[2]), _1956@Mir(bb866[0])
  _1961 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb865)
  assert(!move (_1961.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb868
  using: _1961@Entry, _8@Entry
bb868:
  _8 = move (_1961.0: i32)
  using: _1961@Mir(bb867[1])
  goto -> bb865
  using: 
bb869:
  _8 = const 0_i32
  using: 
  _2 = const 3472349144349095221_u64
  using: 
  goto -> bb908
  using: 
bb870:
  _1962 = const 28_i32
  using: 
  ((*_1).1: i32) = move _1962
  using: _1@Phi(bb865), _1962@Mir(bb870[0])
  goto -> bb871
  using: 
bb871:
  _1964 = ((*_1).8: i32)
  using: _1@Phi(bb871)
  _1965 = const 1_i32
  using: 
  _1963 = Ge(move _1964, move _1965)
  using: _1964@Mir(bb871[0]), _1965@Mir(bb871[1])
  switchInt(move _1963) -> [0: bb876, otherwise: bb872]
  using: _1963@Mir(bb871[2])
bb872:
  _1966 = const 0_u32
  using: 
  _1968 = ((*_1).7: u32)
  using: _1@Phi(bb871)
  _1970 = ((*_1).8: i32)
  using: _1@Phi(bb871)
  _1971 = const 1_i32
  using: 
  _1972 = CheckedSub(_1970, _1971)
  using: _1970@Mir(bb872[2]), _1971@Mir(bb872[3])
  assert(!move (_1972.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1970, move _1971) -> bb873
  using: _1972@Entry, _1970@Entry, _1971@Entry
bb873:
  _1969 = move (_1972.0: i32)
  using: _1972@Mir(bb872[4])
  _1973 = CheckedShr(_1968, _1969)
  using: _1968@Mir(bb872[1]), _1969@Mir(bb873[0])
  assert(!move (_1973.1: bool), "attempt to shift right by `{}`, which would overflow", move _1969) -> bb874
  using: _1973@Entry, _1968@Entry, _1969@Entry
bb874:
  _1967 = move (_1973.0: u32)
  using: _1973@Mir(bb873[1])
  _1974 = const 1_u32
  using: 
  _1966 = BitAnd(move _1967, move _1974)
  using: _1967@Mir(bb874[0]), _1974@Mir(bb874[1])
  _1975 = const 1_i32
  using: 
  _1976 = CheckedSub(((*_1).8: i32), _1975)
  using: _1@Phi(bb871), _1975@Mir(bb874[3])
  assert(!move (_1976.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _1975) -> bb875
  using: _1976@Entry, _1@Entry, _1975@Entry
bb875:
  ((*_1).8: i32) = move (_1976.0: i32)
  using: _1@Phi(bb871), _1976@Mir(bb874[4])
  _1977 = _1966
  using: _1966@Mir(bb874[2])
  _3 = move _1977 as u8 (IntToInt)
  using: _1977@Mir(bb875[1])
  _2004 = _3
  using: _3@Mir(bb875[2])
  _2003 = move _2004 as i32 (IntToInt)
  using: _2004@Mir(bb875[3])
  _2005 = const 1_i32
  using: 
  _2002 = Eq(move _2003, move _2005)
  using: _2003@Mir(bb875[4]), _2005@Mir(bb875[5])
  switchInt(move _2002) -> [0: bb888, otherwise: bb886]
  using: _2002@Mir(bb875[6])
bb876:
  _3988 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  _1979 = ((*_3988).1: u32)
  using: _3988@Mir(bb876[0])
  _1980 = const 0_u32
  using: 
  _1978 = Eq(move _1979, move _1980)
  using: _1979@Mir(bb876[1]), _1980@Mir(bb876[2])
  switchInt(move _1978) -> [0: bb878, otherwise: bb877]
  using: _1978@Mir(bb876[3])
bb877:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb878:
  _1982 = ((*_1).7: u32)
  using: _1@Phi(bb890)
  _1983 = const 8_i32
  using: 
  _1984 = CheckedShl(_1982, _1983)
  using: _1982@Mir(bb878[0]), _1983@Mir(bb878[1])
  assert(!move (_1984.1: bool), "attempt to shift left by `{}`, which would overflow", move _1983) -> bb879
  using: _1984@Entry, _1982@Entry, _1983@Entry
bb879:
  _1981 = move (_1984.0: u32)
  using: _1984@Mir(bb878[2])
  _3989 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  _1988 = ((*_3989).0: *mut i8)
  using: _3989@Mir(bb879[1])
  _1987 = move _1988 as *mut u8 (PtrToPtr)
  using: _1988@Mir(bb879[2])
  _1986 = (*_1987)
  using: _1987@Mir(bb879[3])
  _1985 = move _1986 as u32 (IntToInt)
  using: _1986@Mir(bb879[4])
  ((*_1).7: u32) = BitOr(move _1981, move _1985)
  using: _1@Phi(bb890), _1981@Mir(bb879[0]), _1985@Mir(bb879[5])
  _1989 = const 8_i32
  using: 
  _1990 = CheckedAdd(((*_1).8: i32), _1989)
  using: _1@Phi(bb890), _1989@Mir(bb879[7])
  assert(!move (_1990.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _1989) -> bb880
  using: _1990@Entry, _1@Entry, _1989@Entry
bb880:
  ((*_1).8: i32) = move (_1990.0: i32)
  using: _1@Phi(bb890), _1990@Mir(bb879[8])
  _3990 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  _1992 = ((*_3990).0: *mut i8)
  using: _3990@Mir(bb880[1])
  _1991 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _1992, const 1_isize) -> bb881
  using: _1992@Mir(bb880[2])
bb881:
  _3991 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  ((*_3991).0: *mut i8) = move _1991
  using: _3991@Mir(bb881[0]), _1991@Mir(bb880[3])
  _3992 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  _1994 = ((*_3992).1: u32)
  using: _3992@Mir(bb881[2])
  _1993 = core::num::<impl u32>::wrapping_sub(move _1994, const 1_u32) -> bb882
  using: _1994@Mir(bb881[3])
bb882:
  _3993 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  ((*_3993).1: u32) = move _1993
  using: _3993@Mir(bb882[0]), _1993@Mir(bb881[4])
  _3994 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  _1996 = ((*_3994).2: u32)
  using: _3994@Mir(bb882[2])
  _1995 = core::num::<impl u32>::wrapping_add(move _1996, const 1_u32) -> bb883
  using: _1996@Mir(bb882[3])
bb883:
  _3995 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  ((*_3995).2: u32) = move _1995
  using: _3995@Mir(bb883[0]), _1995@Mir(bb882[4])
  _3996 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  _1998 = ((*_3996).2: u32)
  using: _3996@Mir(bb883[2])
  _1999 = const 0_u32
  using: 
  _1997 = Eq(move _1998, move _1999)
  using: _1998@Mir(bb883[3]), _1999@Mir(bb883[4])
  switchInt(move _1997) -> [0: bb871, otherwise: bb884]
  using: _1997@Mir(bb883[5])
bb884:
  _3997 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  _2001 = ((*_3997).3: u32)
  using: _3997@Mir(bb884[0])
  _2000 = core::num::<impl u32>::wrapping_add(move _2001, const 1_u32) -> bb885
  using: _2001@Mir(bb884[1])
bb885:
  _3998 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb890)
  ((*_3998).3: u32) = move _2000
  using: _3998@Mir(bb885[0]), _2000@Mir(bb884[2])
  goto -> bb871
  using: 
bb886:
  _2006 = const 1_i32
  using: 
  _2008 = _8
  using: _8@Mir(bb864[0])
  _2007 = move _2008 as usize (IntToInt)
  using: _2008@Mir(bb886[1])
  _2009 = const 16_usize
  using: 
  _2010 = Lt(_2007, _2009)
  using: _2007@Mir(bb886[2]), _2009@Mir(bb886[3])
  assert(move _2010, "index out of bounds: the length is {} but the index is {}", move _2009, _2007) -> bb887
  using: _2010@Entry, _2009@Entry, _2007@Entry
bb887:
  ((*_1).29: [u8; 16])[_2007] = move _2006 as u8 (IntToInt)
  using: _1@Phi(bb871), _2007@Mir(bb886[2]), _2006@Mir(bb886[0])
  goto -> bb890
  using: 
bb888:
  _2011 = const 0_i32
  using: 
  _2013 = _8
  using: _8@Mir(bb864[0])
  _2012 = move _2013 as usize (IntToInt)
  using: _2013@Mir(bb888[1])
  _2014 = const 16_usize
  using: 
  _2015 = Lt(_2012, _2014)
  using: _2012@Mir(bb888[2]), _2014@Mir(bb888[3])
  assert(move _2015, "index out of bounds: the length is {} but the index is {}", move _2014, _2012) -> bb889
  using: _2015@Entry, _2014@Entry, _2012@Entry
bb889:
  ((*_1).29: [u8; 16])[_2012] = move _2011 as u8 (IntToInt)
  using: _1@Phi(bb871), _2012@Mir(bb888[2]), _2011@Mir(bb888[0])
  goto -> bb890
  using: 
bb890:
  _2016 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb890)
  assert(!move (_2016.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb891
  using: _2016@Entry, _8@Entry
bb891:
  _8 = move (_2016.0: i32)
  using: _2016@Mir(bb890[0])
  _2 = const 17262312153619709241_u64
  using: 
  goto -> bb634
  using: 
bb892:
  _2019 = ((*_1).8: i32)
  using: _1@Phi(bb892)
  _2020 = const 1_i32
  using: 
  _2018 = Ge(move _2019, move _2020)
  using: _2019@Mir(bb892[0]), _2020@Mir(bb892[1])
  switchInt(move _2018) -> [0: bb897, otherwise: bb893]
  using: _2018@Mir(bb892[2])
bb893:
  _2021 = const 0_u32
  using: 
  _2023 = ((*_1).7: u32)
  using: _1@Phi(bb892)
  _2025 = ((*_1).8: i32)
  using: _1@Phi(bb892)
  _2026 = const 1_i32
  using: 
  _2027 = CheckedSub(_2025, _2026)
  using: _2025@Mir(bb893[2]), _2026@Mir(bb893[3])
  assert(!move (_2027.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2025, move _2026) -> bb894
  using: _2027@Entry, _2025@Entry, _2026@Entry
bb894:
  _2024 = move (_2027.0: i32)
  using: _2027@Mir(bb893[4])
  _2028 = CheckedShr(_2023, _2024)
  using: _2023@Mir(bb893[1]), _2024@Mir(bb894[0])
  assert(!move (_2028.1: bool), "attempt to shift right by `{}`, which would overflow", move _2024) -> bb895
  using: _2028@Entry, _2023@Entry, _2024@Entry
bb895:
  _2022 = move (_2028.0: u32)
  using: _2028@Mir(bb894[1])
  _2029 = const 1_u32
  using: 
  _2021 = BitAnd(move _2022, move _2029)
  using: _2022@Mir(bb895[0]), _2029@Mir(bb895[1])
  _2030 = const 1_i32
  using: 
  _2031 = CheckedSub(((*_1).8: i32), _2030)
  using: _1@Phi(bb892), _2030@Mir(bb895[3])
  assert(!move (_2031.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).8: i32), move _2030) -> bb896
  using: _2031@Entry, _1@Entry, _2030@Entry
bb896:
  ((*_1).8: i32) = move (_2031.0: i32)
  using: _1@Phi(bb892), _2031@Mir(bb895[4])
  _2032 = _2021
  using: _2021@Mir(bb895[2])
  _26 = move _2032 as i32 (IntToInt)
  using: _2032@Mir(bb896[1])
  _2058 = _25
  using: _25@Phi(bb634)
  _2059 = const 1_i32
  using: 
  _2060 = CheckedShl(_2058, _2059)
  using: _2058@Mir(bb896[3]), _2059@Mir(bb896[4])
  assert(!move (_2060.1: bool), "attempt to shift left by `{}`, which would overflow", move _2059) -> bb907
  using: _2060@Entry, _2058@Entry, _2059@Entry
bb897:
  _3999 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  _2034 = ((*_3999).1: u32)
  using: _3999@Mir(bb897[0])
  _2035 = const 0_u32
  using: 
  _2033 = Eq(move _2034, move _2035)
  using: _2034@Mir(bb897[1]), _2035@Mir(bb897[2])
  switchInt(move _2033) -> [0: bb899, otherwise: bb898]
  using: _2033@Mir(bb897[3])
bb898:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb899:
  _2037 = ((*_1).7: u32)
  using: _1@Phi(bb892)
  _2038 = const 8_i32
  using: 
  _2039 = CheckedShl(_2037, _2038)
  using: _2037@Mir(bb899[0]), _2038@Mir(bb899[1])
  assert(!move (_2039.1: bool), "attempt to shift left by `{}`, which would overflow", move _2038) -> bb900
  using: _2039@Entry, _2037@Entry, _2038@Entry
bb900:
  _2036 = move (_2039.0: u32)
  using: _2039@Mir(bb899[2])
  _4000 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  _2043 = ((*_4000).0: *mut i8)
  using: _4000@Mir(bb900[1])
  _2042 = move _2043 as *mut u8 (PtrToPtr)
  using: _2043@Mir(bb900[2])
  _2041 = (*_2042)
  using: _2042@Mir(bb900[3])
  _2040 = move _2041 as u32 (IntToInt)
  using: _2041@Mir(bb900[4])
  ((*_1).7: u32) = BitOr(move _2036, move _2040)
  using: _1@Phi(bb892), _2036@Mir(bb900[0]), _2040@Mir(bb900[5])
  _2044 = const 8_i32
  using: 
  _2045 = CheckedAdd(((*_1).8: i32), _2044)
  using: _1@Phi(bb892), _2044@Mir(bb900[7])
  assert(!move (_2045.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).8: i32), move _2044) -> bb901
  using: _2045@Entry, _1@Entry, _2044@Entry
bb901:
  ((*_1).8: i32) = move (_2045.0: i32)
  using: _1@Phi(bb892), _2045@Mir(bb900[8])
  _4001 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  _2047 = ((*_4001).0: *mut i8)
  using: _4001@Mir(bb901[1])
  _2046 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _2047, const 1_isize) -> bb902
  using: _2047@Mir(bb901[2])
bb902:
  _4002 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  ((*_4002).0: *mut i8) = move _2046
  using: _4002@Mir(bb902[0]), _2046@Mir(bb901[3])
  _4003 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  _2049 = ((*_4003).1: u32)
  using: _4003@Mir(bb902[2])
  _2048 = core::num::<impl u32>::wrapping_sub(move _2049, const 1_u32) -> bb903
  using: _2049@Mir(bb902[3])
bb903:
  _4004 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  ((*_4004).1: u32) = move _2048
  using: _4004@Mir(bb903[0]), _2048@Mir(bb902[4])
  _4005 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  _2051 = ((*_4005).2: u32)
  using: _4005@Mir(bb903[2])
  _2050 = core::num::<impl u32>::wrapping_add(move _2051, const 1_u32) -> bb904
  using: _2051@Mir(bb903[3])
bb904:
  _4006 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  ((*_4006).2: u32) = move _2050
  using: _4006@Mir(bb904[0]), _2050@Mir(bb903[4])
  _4007 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  _2053 = ((*_4007).2: u32)
  using: _4007@Mir(bb904[2])
  _2054 = const 0_u32
  using: 
  _2052 = Eq(move _2053, move _2054)
  using: _2053@Mir(bb904[3]), _2054@Mir(bb904[4])
  switchInt(move _2052) -> [0: bb892, otherwise: bb905]
  using: _2052@Mir(bb904[5])
bb905:
  _4008 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  _2056 = ((*_4008).3: u32)
  using: _4008@Mir(bb905[0])
  _2055 = core::num::<impl u32>::wrapping_add(move _2056, const 1_u32) -> bb906
  using: _2056@Mir(bb905[1])
bb906:
  _4009 = deref_copy ((*_1).0: *mut blocksort::bz_stream)
  using: _1@Phi(bb892)
  ((*_4009).3: u32) = move _2055
  using: _4009@Mir(bb906[0]), _2055@Mir(bb905[2])
  goto -> bb892
  using: 
bb907:
  _2057 = move (_2060.0: i32)
  using: _2060@Mir(bb896[5])
  _2061 = _26
  using: _26@Mir(bb896[2])
  _25 = BitOr(move _2057, move _2061)
  using: _2057@Mir(bb907[0]), _2061@Mir(bb907[1])
  _2 = const 9078889872071895942_u64
  using: 
  goto -> bb908
  using: 
bb908:
  switchInt(_2) -> [9078889872071895942: bb909, 13605767259572914371: bb928, 1550405138573481750: bb972, otherwise: bb991]
  using: _2@Phi(bb908)
bb909:
  _2063 = _24
  using: _24@Phi(bb908)
  _2064 = const 20_i32
  using: 
  _2062 = Gt(move _2063, move _2064)
  using: _2063@Mir(bb909[0]), _2064@Mir(bb909[1])
  switchInt(move _2062) -> [0: bb911, otherwise: bb910]
  using: _2062@Mir(bb909[2])
bb910:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb911:
  _2066 = _25
  using: _25@Phi(bb908)
  _2069 = _29
  using: _29@Phi(bb634)
  _2071 = _24
  using: _24@Phi(bb908)
  _2070 = move _2071 as isize (IntToInt)
  using: _2071@Mir(bb911[2])
  _2068 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2069, move _2070) -> bb912
  using: _2069@Mir(bb911[1]), _2070@Mir(bb911[3])
bb912:
  _2067 = (*_2068)
  using: _2068@Mir(bb911[4])
  _2065 = Le(move _2066, move _2067)
  using: _2066@Mir(bb911[0]), _2067@Mir(bb912[0])
  switchInt(move _2065) -> [0: bb926, otherwise: bb913]
  using: _2065@Mir(bb912[1])
bb913:
  _2075 = _25
  using: _25@Phi(bb908)
  _2078 = _30
  using: _30@Phi(bb634)
  _2080 = _24
  using: _24@Phi(bb908)
  _2079 = move _2080 as isize (IntToInt)
  using: _2080@Mir(bb913[2])
  _2077 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2078, move _2079) -> bb917
  using: _2078@Mir(bb913[1]), _2079@Mir(bb913[3])
bb914:
  _2072 = const true
  using: 
  goto -> bb916
  using: 
bb915:
  _2085 = _25
  using: _25@Phi(bb908)
  _2088 = _30
  using: _30@Phi(bb634)
  _2090 = _24
  using: _24@Phi(bb908)
  _2089 = move _2090 as isize (IntToInt)
  using: _2090@Mir(bb915[2])
  _2087 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2088, move _2089) -> bb919
  using: _2088@Mir(bb915[1]), _2089@Mir(bb915[3])
bb916:
  switchInt(move _2072) -> [0: bb922, otherwise: bb921]
  using: _2072@Phi(bb916)
bb917:
  _2076 = (*_2077)
  using: _2077@Mir(bb913[4])
  _2081 = CheckedSub(_2075, _2076)
  using: _2075@Mir(bb913[0]), _2076@Mir(bb917[0])
  assert(!move (_2081.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2075, move _2076) -> bb918
  using: _2081@Entry, _2075@Entry, _2076@Entry
bb918:
  _2074 = move (_2081.0: i32)
  using: _2081@Mir(bb917[1])
  _2082 = const 0_i32
  using: 
  _2073 = Lt(move _2074, move _2082)
  using: _2074@Mir(bb918[0]), _2082@Mir(bb918[1])
  switchInt(move _2073) -> [0: bb915, otherwise: bb914]
  using: _2073@Mir(bb918[2])
bb919:
  _2086 = (*_2087)
  using: _2087@Mir(bb915[4])
  _2091 = CheckedSub(_2085, _2086)
  using: _2085@Mir(bb915[0]), _2086@Mir(bb919[0])
  assert(!move (_2091.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2085, move _2086) -> bb920
  using: _2091@Entry, _2085@Entry, _2086@Entry
bb920:
  _2084 = move (_2091.0: i32)
  using: _2091@Mir(bb919[1])
  _2092 = const 258_i32
  using: 
  _2083 = Ge(move _2084, move _2092)
  using: _2084@Mir(bb920[0]), _2092@Mir(bb920[1])
  _2072 = move _2083
  using: _2083@Mir(bb920[2])
  goto -> bb916
  using: 
bb921:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb922:
  _2095 = _31
  using: _31@Phi(bb634)
  _2098 = _25
  using: _25@Phi(bb916)
  _2101 = _30
  using: _30@Phi(bb916)
  _2103 = _24
  using: _24@Phi(bb916)
  _2102 = move _2103 as isize (IntToInt)
  using: _2103@Mir(bb922[3])
  _2100 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2101, move _2102) -> bb923
  using: _2101@Mir(bb922[2]), _2102@Mir(bb922[4])
bb923:
  _2099 = (*_2100)
  using: _2100@Mir(bb922[5])
  _2104 = CheckedSub(_2098, _2099)
  using: _2098@Mir(bb922[1]), _2099@Mir(bb923[0])
  assert(!move (_2104.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2098, move _2099) -> bb924
  using: _2104@Entry, _2098@Entry, _2099@Entry
bb924:
  _2097 = move (_2104.0: i32)
  using: _2104@Mir(bb923[1])
  _2096 = move _2097 as isize (IntToInt)
  using: _2097@Mir(bb924[0])
  _2094 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2095, move _2096) -> bb925
  using: _2095@Mir(bb922[0]), _2096@Mir(bb924[1])
bb925:
  _2093 = (*_2094)
  using: _2094@Mir(bb924[2])
  _17 = move _2093
  using: _2093@Mir(bb925[0])
  _2 = const 15093386068129942558_u64
  using: 
  goto -> bb991
  using: 
bb926:
  _2105 = CheckedAdd(_24, const 1_i32)
  using: _24@Phi(bb916)
  assert(!move (_2105.1: bool), "attempt to compute `{} + {}`, which would overflow", _24, const 1_i32) -> bb927
  using: _2105@Entry, _24@Entry
bb927:
  _24 = move (_2105.0: i32)
  using: _2105@Mir(bb926[0])
  _2 = const 1050378859040334210_u64
  using: 
  goto -> bb634
  using: 
bb928:
  _2107 = _24
  using: _24@Phi(bb916)
  _2108 = const 20_i32
  using: 
  _2106 = Gt(move _2107, move _2108)
  using: _2107@Mir(bb928[0]), _2108@Mir(bb928[1])
  switchInt(move _2106) -> [0: bb930, otherwise: bb929]
  using: _2106@Mir(bb928[2])
bb929:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb930:
  _2110 = _25
  using: _25@Phi(bb916)
  _2113 = _29
  using: _29@Phi(bb634)
  _2115 = _24
  using: _24@Phi(bb916)
  _2114 = move _2115 as isize (IntToInt)
  using: _2115@Mir(bb930[2])
  _2112 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2113, move _2114) -> bb931
  using: _2113@Mir(bb930[1]), _2114@Mir(bb930[3])
bb931:
  _2111 = (*_2112)
  using: _2112@Mir(bb930[4])
  _2109 = Le(move _2110, move _2111)
  using: _2110@Mir(bb930[0]), _2111@Mir(bb931[0])
  switchInt(move _2109) -> [0: bb970, otherwise: bb932]
  using: _2109@Mir(bb931[1])
bb932:
  _2119 = _25
  using: _25@Phi(bb916)
  _2122 = _30
  using: _30@Phi(bb916)
  _2124 = _24
  using: _24@Phi(bb916)
  _2123 = move _2124 as isize (IntToInt)
  using: _2124@Mir(bb932[2])
  _2121 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2122, move _2123) -> bb936
  using: _2122@Mir(bb932[1]), _2123@Mir(bb932[3])
bb933:
  _2116 = const true
  using: 
  goto -> bb935
  using: 
bb934:
  _2129 = _25
  using: _25@Phi(bb916)
  _2132 = _30
  using: _30@Phi(bb916)
  _2134 = _24
  using: _24@Phi(bb916)
  _2133 = move _2134 as isize (IntToInt)
  using: _2134@Mir(bb934[2])
  _2131 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2132, move _2133) -> bb938
  using: _2132@Mir(bb934[1]), _2133@Mir(bb934[3])
bb935:
  switchInt(move _2116) -> [0: bb941, otherwise: bb940]
  using: _2116@Phi(bb935)
bb936:
  _2120 = (*_2121)
  using: _2121@Mir(bb932[4])
  _2125 = CheckedSub(_2119, _2120)
  using: _2119@Mir(bb932[0]), _2120@Mir(bb936[0])
  assert(!move (_2125.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2119, move _2120) -> bb937
  using: _2125@Entry, _2119@Entry, _2120@Entry
bb937:
  _2118 = move (_2125.0: i32)
  using: _2125@Mir(bb936[1])
  _2126 = const 0_i32
  using: 
  _2117 = Lt(move _2118, move _2126)
  using: _2118@Mir(bb937[0]), _2126@Mir(bb937[1])
  switchInt(move _2117) -> [0: bb934, otherwise: bb933]
  using: _2117@Mir(bb937[2])
bb938:
  _2130 = (*_2131)
  using: _2131@Mir(bb934[4])
  _2135 = CheckedSub(_2129, _2130)
  using: _2129@Mir(bb934[0]), _2130@Mir(bb938[0])
  assert(!move (_2135.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2129, move _2130) -> bb939
  using: _2135@Entry, _2129@Entry, _2130@Entry
bb939:
  _2128 = move (_2135.0: i32)
  using: _2135@Mir(bb938[1])
  _2136 = const 258_i32
  using: 
  _2127 = Ge(move _2128, move _2136)
  using: _2128@Mir(bb939[0]), _2136@Mir(bb939[1])
  _2116 = move _2127
  using: _2127@Mir(bb939[2])
  goto -> bb935
  using: 
bb940:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb941:
  _2139 = _31
  using: _31@Phi(bb634)
  _2142 = _25
  using: _25@Phi(bb935)
  _2145 = _30
  using: _30@Phi(bb935)
  _2147 = _24
  using: _24@Phi(bb935)
  _2146 = move _2147 as isize (IntToInt)
  using: _2147@Mir(bb941[3])
  _2144 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2145, move _2146) -> bb942
  using: _2145@Mir(bb941[2]), _2146@Mir(bb941[4])
bb942:
  _2143 = (*_2144)
  using: _2144@Mir(bb941[5])
  _2148 = CheckedSub(_2142, _2143)
  using: _2142@Mir(bb941[1]), _2143@Mir(bb942[0])
  assert(!move (_2148.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2142, move _2143) -> bb943
  using: _2148@Entry, _2142@Entry, _2143@Entry
bb943:
  _2141 = move (_2148.0: i32)
  using: _2148@Mir(bb942[1])
  _2140 = move _2141 as isize (IntToInt)
  using: _2141@Mir(bb943[0])
  _2138 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2139, move _2140) -> bb944
  using: _2139@Mir(bb941[0]), _2140@Mir(bb943[1])
bb944:
  _2137 = (*_2138)
  using: _2138@Mir(bb943[2])
  _17 = move _2137
  using: _2137@Mir(bb944[0])
  _2151 = _17
  using: _17@Mir(bb944[1])
  _2152 = const 0_i32
  using: 
  _2150 = Eq(move _2151, move _2152)
  using: _2151@Mir(bb944[2]), _2152@Mir(bb944[3])
  switchInt(move _2150) -> [0: bb946, otherwise: bb945]
  using: _2150@Mir(bb944[4])
bb945:
  _2149 = const true
  using: 
  goto -> bb947
  using: 
bb946:
  _2154 = _17
  using: _17@Mir(bb944[1])
  _2155 = const 1_i32
  using: 
  _2153 = Eq(move _2154, move _2155)
  using: _2154@Mir(bb946[0]), _2155@Mir(bb946[1])
  _2149 = move _2153
  using: _2153@Mir(bb946[2])
  goto -> bb947
  using: 
bb947:
  switchInt(move _2149) -> [0: bb949, otherwise: bb948]
  using: _2149@Phi(bb947)
bb948:
  _2 = const 4550729491376650574_u64
  using: 
  goto -> bb991
  using: 
bb949:
  _2156 = CheckedAdd(_20, const 1_i32)
  using: _20@Phi(bb634)
  assert(!move (_2156.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, const 1_i32) -> bb950
  using: _2156@Entry, _20@Entry
bb950:
  _20 = move (_2156.0: i32)
  using: _2156@Mir(bb949[0])
  _2162 = const 0_usize
  using: 
  _2161 = ((*_1).32: [i32; 16])[_2162]
  using: _1@Phi(bb908), _2162@Mir(bb950[1])
  _2160 = move _2161 as usize (IntToInt)
  using: _2161@Mir(bb950[2])
  _2163 = const 4096_usize
  using: 
  _2164 = Lt(_2160, _2163)
  using: _2160@Mir(bb950[3]), _2163@Mir(bb950[4])
  assert(move _2164, "index out of bounds: the length is {} but the index is {}", move _2163, _2160) -> bb951
  using: _2164@Entry, _2163@Entry, _2160@Entry
bb951:
  _2159 = ((*_1).31: [u8; 4096])[_2160]
  using: _1@Phi(bb908), _2160@Mir(bb950[3])
  _2158 = move _2159 as usize (IntToInt)
  using: _2159@Mir(bb951[0])
  _2165 = const 256_usize
  using: 
  _2166 = Lt(_2158, _2165)
  using: _2158@Mir(bb951[1]), _2165@Mir(bb951[2])
  assert(move _2166, "index out of bounds: the length is {} but the index is {}", move _2165, _2158) -> bb952
  using: _2166@Entry, _2165@Entry, _2158@Entry
bb952:
  _2157 = ((*_1).30: [u8; 256])[_2158]
  using: _1@Phi(bb908), _2158@Mir(bb951[1])
  _3 = move _2157
  using: _2157@Mir(bb952[0])
  _2167 = _20
  using: _20@Mir(bb950[0])
  _2169 = _3
  using: _3@Mir(bb952[1])
  _2168 = move _2169 as usize (IntToInt)
  using: _2169@Mir(bb952[3])
  _2170 = const 256_usize
  using: 
  _2171 = Lt(_2168, _2170)
  using: _2168@Mir(bb952[4]), _2170@Mir(bb952[5])
  assert(move _2171, "index out of bounds: the length is {} but the index is {}", move _2170, _2168) -> bb953
  using: _2171@Entry, _2170@Entry, _2168@Entry
bb953:
  _2172 = CheckedAdd(((*_1).16: [i32; 256])[_2168], _2167)
  using: _1@Phi(bb908), _2168@Mir(bb952[4]), _2167@Mir(bb952[2])
  assert(!move (_2172.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).16: [i32; 256])[_2168], move _2167) -> bb954
  using: _2172@Entry, _1@Entry, _2168@Entry, _2167@Entry
bb954:
  ((*_1).16: [i32; 256])[_2168] = move (_2172.0: i32)
  using: _1@Phi(bb908), _2168@Mir(bb952[4]), _2172@Mir(bb953[0])
  _2173 = ((*_1).10: u8)
  using: _1@Phi(bb908)
  switchInt(move _2173) -> [0: bb962, otherwise: bb955]
  using: _2173@Mir(bb954[1])
bb955:
  _2175 = _20
  using: _20@Phi(bb955)
  _2176 = const 0_i32
  using: 
  _2174 = Gt(move _2175, move _2176)
  using: _2175@Mir(bb955[0]), _2176@Mir(bb955[1])
  switchInt(move _2174) -> [0: bb969, otherwise: bb956]
  using: _2174@Mir(bb955[2])
bb956:
  _2178 = _19
  using: _19@Phi(bb955)
  _2179 = _18
  using: _18@Phi(bb955)
  _2177 = Ge(move _2178, move _2179)
  using: _2178@Mir(bb956[0]), _2179@Mir(bb956[1])
  switchInt(move _2177) -> [0: bb958, otherwise: bb957]
  using: _2177@Mir(bb956[2])
bb957:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb958:
  _2180 = _3
  using: _3@Phi(bb955)
  _2182 = ((*_1).21: *mut u16)
  using: _1@Phi(bb955)
  _2184 = _19
  using: _19@Phi(bb955)
  _2183 = move _2184 as isize (IntToInt)
  using: _2184@Mir(bb958[2])
  _2181 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2182, move _2183) -> bb959
  using: _2182@Mir(bb958[1]), _2183@Mir(bb958[3])
bb959:
  (*_2181) = move _2180 as u16 (IntToInt)
  using: _2181@Mir(bb958[4]), _2180@Mir(bb958[0])
  _2185 = CheckedAdd(_19, const 1_i32)
  using: _19@Phi(bb955)
  assert(!move (_2185.1: bool), "attempt to compute `{} + {}`, which would overflow", _19, const 1_i32) -> bb960
  using: _2185@Entry, _19@Entry
bb960:
  _19 = move (_2185.0: i32)
  using: _2185@Mir(bb959[1])
  _2186 = CheckedSub(_20, const 1_i32)
  using: _20@Phi(bb955)
  assert(!move (_2186.1: bool), "attempt to compute `{} - {}`, which would overflow", _20, const 1_i32) -> bb961
  using: _2186@Entry, _20@Entry
bb961:
  _20 = move (_2186.0: i32)
  using: _2186@Mir(bb960[1])
  goto -> bb955
  using: 
bb962:
  _2188 = _20
  using: _20@Phi(bb962)
  _2189 = const 0_i32
  using: 
  _2187 = Gt(move _2188, move _2189)
  using: _2188@Mir(bb962[0]), _2189@Mir(bb962[1])
  switchInt(move _2187) -> [0: bb969, otherwise: bb963]
  using: _2187@Mir(bb962[2])
bb963:
  _2191 = _19
  using: _19@Phi(bb962)
  _2192 = _18
  using: _18@Phi(bb962)
  _2190 = Ge(move _2191, move _2192)
  using: _2191@Mir(bb963[0]), _2192@Mir(bb963[1])
  switchInt(move _2190) -> [0: bb965, otherwise: bb964]
  using: _2190@Mir(bb963[2])
bb964:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb965:
  _2193 = _3
  using: _3@Phi(bb962)
  _2195 = ((*_1).20: *mut u32)
  using: _1@Phi(bb962)
  _2197 = _19
  using: _19@Phi(bb962)
  _2196 = move _2197 as isize (IntToInt)
  using: _2197@Mir(bb965[2])
  _2194 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _2195, move _2196) -> bb966
  using: _2195@Mir(bb965[1]), _2196@Mir(bb965[3])
bb966:
  (*_2194) = move _2193 as u32 (IntToInt)
  using: _2194@Mir(bb965[4]), _2193@Mir(bb965[0])
  _2198 = CheckedAdd(_19, const 1_i32)
  using: _19@Phi(bb962)
  assert(!move (_2198.1: bool), "attempt to compute `{} + {}`, which would overflow", _19, const 1_i32) -> bb967
  using: _2198@Entry, _19@Entry
bb967:
  _19 = move (_2198.0: i32)
  using: _2198@Mir(bb966[1])
  _2199 = CheckedSub(_20, const 1_i32)
  using: _20@Phi(bb962)
  assert(!move (_2199.1: bool), "attempt to compute `{} - {}`, which would overflow", _20, const 1_i32) -> bb968
  using: _2199@Entry, _20@Entry
bb968:
  _20 = move (_2199.0: i32)
  using: _2199@Mir(bb967[1])
  goto -> bb962
  using: 
bb969:
  _2 = const 15093386068129942558_u64
  using: 
  goto -> bb991
  using: 
bb970:
  _2200 = CheckedAdd(_24, const 1_i32)
  using: _24@Phi(bb935)
  assert(!move (_2200.1: bool), "attempt to compute `{} + {}`, which would overflow", _24, const 1_i32) -> bb971
  using: _2200@Entry, _24@Entry
bb971:
  _24 = move (_2200.0: i32)
  using: _2200@Mir(bb970[0])
  _2 = const 13999925517074022731_u64
  using: 
  goto -> bb634
  using: 
bb972:
  _2202 = _24
  using: _24@Phi(bb935)
  _2203 = const 20_i32
  using: 
  _2201 = Gt(move _2202, move _2203)
  using: _2202@Mir(bb972[0]), _2203@Mir(bb972[1])
  switchInt(move _2201) -> [0: bb974, otherwise: bb973]
  using: _2201@Mir(bb972[2])
bb973:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb974:
  _2205 = _25
  using: _25@Phi(bb935)
  _2208 = _29
  using: _29@Phi(bb634)
  _2210 = _24
  using: _24@Phi(bb935)
  _2209 = move _2210 as isize (IntToInt)
  using: _2210@Mir(bb974[2])
  _2207 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2208, move _2209) -> bb975
  using: _2208@Mir(bb974[1]), _2209@Mir(bb974[3])
bb975:
  _2206 = (*_2207)
  using: _2207@Mir(bb974[4])
  _2204 = Le(move _2205, move _2206)
  using: _2205@Mir(bb974[0]), _2206@Mir(bb975[0])
  switchInt(move _2204) -> [0: bb989, otherwise: bb976]
  using: _2204@Mir(bb975[1])
bb976:
  _2214 = _25
  using: _25@Phi(bb935)
  _2217 = _30
  using: _30@Phi(bb935)
  _2219 = _24
  using: _24@Phi(bb935)
  _2218 = move _2219 as isize (IntToInt)
  using: _2219@Mir(bb976[2])
  _2216 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2217, move _2218) -> bb980
  using: _2217@Mir(bb976[1]), _2218@Mir(bb976[3])
bb977:
  _2211 = const true
  using: 
  goto -> bb979
  using: 
bb978:
  _2224 = _25
  using: _25@Phi(bb935)
  _2227 = _30
  using: _30@Phi(bb935)
  _2229 = _24
  using: _24@Phi(bb935)
  _2228 = move _2229 as isize (IntToInt)
  using: _2229@Mir(bb978[2])
  _2226 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2227, move _2228) -> bb982
  using: _2227@Mir(bb978[1]), _2228@Mir(bb978[3])
bb979:
  switchInt(move _2211) -> [0: bb985, otherwise: bb984]
  using: _2211@Phi(bb979)
bb980:
  _2215 = (*_2216)
  using: _2216@Mir(bb976[4])
  _2220 = CheckedSub(_2214, _2215)
  using: _2214@Mir(bb976[0]), _2215@Mir(bb980[0])
  assert(!move (_2220.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2214, move _2215) -> bb981
  using: _2220@Entry, _2214@Entry, _2215@Entry
bb981:
  _2213 = move (_2220.0: i32)
  using: _2220@Mir(bb980[1])
  _2221 = const 0_i32
  using: 
  _2212 = Lt(move _2213, move _2221)
  using: _2213@Mir(bb981[0]), _2221@Mir(bb981[1])
  switchInt(move _2212) -> [0: bb978, otherwise: bb977]
  using: _2212@Mir(bb981[2])
bb982:
  _2225 = (*_2226)
  using: _2226@Mir(bb978[4])
  _2230 = CheckedSub(_2224, _2225)
  using: _2224@Mir(bb978[0]), _2225@Mir(bb982[0])
  assert(!move (_2230.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2224, move _2225) -> bb983
  using: _2230@Entry, _2224@Entry, _2225@Entry
bb983:
  _2223 = move (_2230.0: i32)
  using: _2230@Mir(bb982[1])
  _2231 = const 258_i32
  using: 
  _2222 = Ge(move _2223, move _2231)
  using: _2223@Mir(bb983[0]), _2231@Mir(bb983[1])
  _2211 = move _2222
  using: _2222@Mir(bb983[2])
  goto -> bb979
  using: 
bb984:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb985:
  _2234 = _31
  using: _31@Phi(bb634)
  _2237 = _25
  using: _25@Phi(bb979)
  _2240 = _30
  using: _30@Phi(bb979)
  _2242 = _24
  using: _24@Phi(bb979)
  _2241 = move _2242 as isize (IntToInt)
  using: _2242@Mir(bb985[3])
  _2239 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2240, move _2241) -> bb986
  using: _2240@Mir(bb985[2]), _2241@Mir(bb985[4])
bb986:
  _2238 = (*_2239)
  using: _2239@Mir(bb985[5])
  _2243 = CheckedSub(_2237, _2238)
  using: _2237@Mir(bb985[1]), _2238@Mir(bb986[0])
  assert(!move (_2243.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2237, move _2238) -> bb987
  using: _2243@Entry, _2237@Entry, _2238@Entry
bb987:
  _2236 = move (_2243.0: i32)
  using: _2243@Mir(bb986[1])
  _2235 = move _2236 as isize (IntToInt)
  using: _2236@Mir(bb987[0])
  _2233 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2234, move _2235) -> bb988
  using: _2234@Mir(bb985[0]), _2235@Mir(bb987[1])
bb988:
  _2232 = (*_2233)
  using: _2233@Mir(bb987[2])
  _17 = move _2232
  using: _2232@Mir(bb988[0])
  _2 = const 15093386068129942558_u64
  using: 
  goto -> bb991
  using: 
bb989:
  _2244 = CheckedAdd(_24, const 1_i32)
  using: _24@Phi(bb979)
  assert(!move (_2244.1: bool), "attempt to compute `{} + {}`, which would overflow", _24, const 1_i32) -> bb990
  using: _2244@Entry, _24@Entry
bb990:
  _24 = move (_2244.0: i32)
  using: _2244@Mir(bb989[0])
  _2 = const 14744029255125744966_u64
  using: 
  goto -> bb634
  using: 
bb991:
  switchInt(_2) -> [15093386068129942558: bb992, otherwise: bb1301]
  using: _2@Phi(bb991)
bb992:
  _2246 = _17
  using: _17@Phi(bb991)
  _2247 = _14
  using: _14@Phi(bb634)
  _2245 = Eq(move _2246, move _2247)
  using: _2246@Mir(bb992[0]), _2247@Mir(bb992[1])
  switchInt(move _2245) -> [0: bb994, otherwise: bb993]
  using: _2245@Mir(bb992[2])
bb993:
  _2 = const 12118509005321596519_u64
  using: 
  goto -> bb1113
  using: 
bb994:
  _2250 = _17
  using: _17@Phi(bb991)
  _2251 = const 0_i32
  using: 
  _2249 = Eq(move _2250, move _2251)
  using: _2250@Mir(bb994[0]), _2251@Mir(bb994[1])
  switchInt(move _2249) -> [0: bb996, otherwise: bb995]
  using: _2249@Mir(bb994[2])
bb995:
  _2248 = const true
  using: 
  goto -> bb997
  using: 
bb996:
  _2253 = _17
  using: _17@Phi(bb991)
  _2254 = const 1_i32
  using: 
  _2252 = Eq(move _2253, move _2254)
  using: _2253@Mir(bb996[0]), _2254@Mir(bb996[1])
  _2248 = move _2252
  using: _2252@Mir(bb996[2])
  goto -> bb997
  using: 
bb997:
  switchInt(move _2248) -> [0: bb999, otherwise: bb998]
  using: _2248@Phi(bb997)
bb998:
  _20 = const -1_i32
  using: 
  _21 = const 1_i32
  using: 
  _2 = const 4550729491376650574_u64
  using: 
  goto -> bb1113
  using: 
bb999:
  _2256 = _19
  using: _19@Phi(bb991)
  _2257 = _18
  using: _18@Phi(bb991)
  _2255 = Ge(move _2256, move _2257)
  using: _2256@Mir(bb999[0]), _2257@Mir(bb999[1])
  switchInt(move _2255) -> [0: bb1001, otherwise: bb1000]
  using: _2255@Mir(bb999[2])
bb1000:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1001:
  _2258 = const 0_i32
  using: 
  _2259 = const 0_i32
  using: 
  _2260 = const 0_i32
  using: 
  _2261 = const 0_i32
  using: 
  _2262 = const 0_i32
  using: 
  _2263 = const 0_i32
  using: 
  _2264 = const 0_u32
  using: 
  _2266 = _17
  using: _17@Phi(bb997)
  _2267 = const 1_i32
  using: 
  _2268 = CheckedSub(_2266, _2267)
  using: _2266@Mir(bb1001[7]), _2267@Mir(bb1001[8])
  assert(!move (_2268.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2266, move _2267) -> bb1002
  using: _2268@Entry, _2266@Entry, _2267@Entry
bb1002:
  _2265 = move (_2268.0: i32)
  using: _2268@Mir(bb1001[9])
  _2264 = move _2265 as u32 (IntToInt)
  using: _2265@Mir(bb1002[0])
  _2270 = _2264
  using: _2264@Mir(bb1002[1])
  _2271 = const 16_u32
  using: 
  _2269 = Lt(move _2270, move _2271)
  using: _2270@Mir(bb1002[2]), _2271@Mir(bb1002[3])
  switchInt(move _2269) -> [0: bb1035, otherwise: bb1003]
  using: _2269@Mir(bb1002[4])
bb1003:
  _2273 = const 0_usize
  using: 
  _2272 = ((*_1).32: [i32; 16])[_2273]
  using: _1@Phi(bb991), _2273@Mir(bb1003[0])
  _2261 = move _2272
  using: _2272@Mir(bb1003[1])
  _2278 = _2261
  using: _2261@Mir(bb1003[2])
  _2277 = move _2278 as u32 (IntToInt)
  using: _2278@Mir(bb1003[3])
  _2279 = _2264
  using: _2264@Mir(bb1002[1])
  _2276 = core::num::<impl u32>::wrapping_add(move _2277, move _2279) -> bb1004
  using: _2277@Mir(bb1003[4]), _2279@Mir(bb1003[5])
bb1004:
  _2275 = move _2276 as usize (IntToInt)
  using: _2276@Mir(bb1003[6])
  _2280 = const 4096_usize
  using: 
  _2281 = Lt(_2275, _2280)
  using: _2275@Mir(bb1004[0]), _2280@Mir(bb1004[1])
  assert(move _2281, "index out of bounds: the length is {} but the index is {}", move _2280, _2275) -> bb1005
  using: _2281@Entry, _2280@Entry, _2275@Entry
bb1005:
  _2274 = ((*_1).31: [u8; 4096])[_2275]
  using: _1@Phi(bb991), _2275@Mir(bb1004[0])
  _3 = move _2274
  using: _2274@Mir(bb1005[0])
  goto -> bb1006
  using: 
bb1006:
  _2283 = _2264
  using: _2264@Phi(bb1006)
  _2284 = const 3_u32
  using: 
  _2282 = Gt(move _2283, move _2284)
  using: _2283@Mir(bb1006[0]), _2284@Mir(bb1006[1])
  switchInt(move _2282) -> [0: bb1025, otherwise: bb1007]
  using: _2282@Mir(bb1006[2])
bb1007:
  _2288 = _2261
  using: _2261@Phi(bb1006)
  _2287 = move _2288 as u32 (IntToInt)
  using: _2288@Mir(bb1007[0])
  _2289 = _2264
  using: _2264@Phi(bb1006)
  _2286 = core::num::<impl u32>::wrapping_add(move _2287, move _2289) -> bb1008
  using: _2287@Mir(bb1007[1]), _2289@Mir(bb1007[2])
bb1008:
  _2285 = move _2286 as i32 (IntToInt)
  using: _2286@Mir(bb1007[3])
  _2293 = _2285
  using: _2285@Mir(bb1008[0])
  _2294 = const 1_i32
  using: 
  _2295 = CheckedSub(_2293, _2294)
  using: _2293@Mir(bb1008[1]), _2294@Mir(bb1008[2])
  assert(!move (_2295.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2293, move _2294) -> bb1009
  using: _2295@Entry, _2293@Entry, _2294@Entry
bb1009:
  _2292 = move (_2295.0: i32)
  using: _2295@Mir(bb1008[3])
  _2291 = move _2292 as usize (IntToInt)
  using: _2292@Mir(bb1009[0])
  _2296 = const 4096_usize
  using: 
  _2297 = Lt(_2291, _2296)
  using: _2291@Mir(bb1009[1]), _2296@Mir(bb1009[2])
  assert(move _2297, "index out of bounds: the length is {} but the index is {}", move _2296, _2291) -> bb1010
  using: _2297@Entry, _2296@Entry, _2291@Entry
bb1010:
  _2290 = ((*_1).31: [u8; 4096])[_2291]
  using: _1@Phi(bb1006), _2291@Mir(bb1009[1])
  _2299 = _2285
  using: _2285@Mir(bb1008[0])
  _2298 = move _2299 as usize (IntToInt)
  using: _2299@Mir(bb1010[1])
  _2300 = const 4096_usize
  using: 
  _2301 = Lt(_2298, _2300)
  using: _2298@Mir(bb1010[2]), _2300@Mir(bb1010[3])
  assert(move _2301, "index out of bounds: the length is {} but the index is {}", move _2300, _2298) -> bb1011
  using: _2301@Entry, _2300@Entry, _2298@Entry
bb1011:
  ((*_1).31: [u8; 4096])[_2298] = move _2290
  using: _1@Phi(bb1006), _2298@Mir(bb1010[2]), _2290@Mir(bb1010[0])
  _2305 = _2285
  using: _2285@Mir(bb1008[0])
  _2306 = const 2_i32
  using: 
  _2307 = CheckedSub(_2305, _2306)
  using: _2305@Mir(bb1011[1]), _2306@Mir(bb1011[2])
  assert(!move (_2307.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2305, move _2306) -> bb1012
  using: _2307@Entry, _2305@Entry, _2306@Entry
bb1012:
  _2304 = move (_2307.0: i32)
  using: _2307@Mir(bb1011[3])
  _2303 = move _2304 as usize (IntToInt)
  using: _2304@Mir(bb1012[0])
  _2308 = const 4096_usize
  using: 
  _2309 = Lt(_2303, _2308)
  using: _2303@Mir(bb1012[1]), _2308@Mir(bb1012[2])
  assert(move _2309, "index out of bounds: the length is {} but the index is {}", move _2308, _2303) -> bb1013
  using: _2309@Entry, _2308@Entry, _2303@Entry
bb1013:
  _2302 = ((*_1).31: [u8; 4096])[_2303]
  using: _1@Phi(bb1006), _2303@Mir(bb1012[1])
  _2312 = _2285
  using: _2285@Mir(bb1008[0])
  _2313 = const 1_i32
  using: 
  _2314 = CheckedSub(_2312, _2313)
  using: _2312@Mir(bb1013[1]), _2313@Mir(bb1013[2])
  assert(!move (_2314.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2312, move _2313) -> bb1014
  using: _2314@Entry, _2312@Entry, _2313@Entry
bb1014:
  _2311 = move (_2314.0: i32)
  using: _2314@Mir(bb1013[3])
  _2310 = move _2311 as usize (IntToInt)
  using: _2311@Mir(bb1014[0])
  _2315 = const 4096_usize
  using: 
  _2316 = Lt(_2310, _2315)
  using: _2310@Mir(bb1014[1]), _2315@Mir(bb1014[2])
  assert(move _2316, "index out of bounds: the length is {} but the index is {}", move _2315, _2310) -> bb1015
  using: _2316@Entry, _2315@Entry, _2310@Entry
bb1015:
  ((*_1).31: [u8; 4096])[_2310] = move _2302
  using: _1@Phi(bb1006), _2310@Mir(bb1014[1]), _2302@Mir(bb1013[0])
  _2320 = _2285
  using: _2285@Mir(bb1008[0])
  _2321 = const 3_i32
  using: 
  _2322 = CheckedSub(_2320, _2321)
  using: _2320@Mir(bb1015[1]), _2321@Mir(bb1015[2])
  assert(!move (_2322.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2320, move _2321) -> bb1016
  using: _2322@Entry, _2320@Entry, _2321@Entry
bb1016:
  _2319 = move (_2322.0: i32)
  using: _2322@Mir(bb1015[3])
  _2318 = move _2319 as usize (IntToInt)
  using: _2319@Mir(bb1016[0])
  _2323 = const 4096_usize
  using: 
  _2324 = Lt(_2318, _2323)
  using: _2318@Mir(bb1016[1]), _2323@Mir(bb1016[2])
  assert(move _2324, "index out of bounds: the length is {} but the index is {}", move _2323, _2318) -> bb1017
  using: _2324@Entry, _2323@Entry, _2318@Entry
bb1017:
  _2317 = ((*_1).31: [u8; 4096])[_2318]
  using: _1@Phi(bb1006), _2318@Mir(bb1016[1])
  _2327 = _2285
  using: _2285@Mir(bb1008[0])
  _2328 = const 2_i32
  using: 
  _2329 = CheckedSub(_2327, _2328)
  using: _2327@Mir(bb1017[1]), _2328@Mir(bb1017[2])
  assert(!move (_2329.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2327, move _2328) -> bb1018
  using: _2329@Entry, _2327@Entry, _2328@Entry
bb1018:
  _2326 = move (_2329.0: i32)
  using: _2329@Mir(bb1017[3])
  _2325 = move _2326 as usize (IntToInt)
  using: _2326@Mir(bb1018[0])
  _2330 = const 4096_usize
  using: 
  _2331 = Lt(_2325, _2330)
  using: _2325@Mir(bb1018[1]), _2330@Mir(bb1018[2])
  assert(move _2331, "index out of bounds: the length is {} but the index is {}", move _2330, _2325) -> bb1019
  using: _2331@Entry, _2330@Entry, _2325@Entry
bb1019:
  ((*_1).31: [u8; 4096])[_2325] = move _2317
  using: _1@Phi(bb1006), _2325@Mir(bb1018[1]), _2317@Mir(bb1017[0])
  _2335 = _2285
  using: _2285@Mir(bb1008[0])
  _2336 = const 4_i32
  using: 
  _2337 = CheckedSub(_2335, _2336)
  using: _2335@Mir(bb1019[1]), _2336@Mir(bb1019[2])
  assert(!move (_2337.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2335, move _2336) -> bb1020
  using: _2337@Entry, _2335@Entry, _2336@Entry
bb1020:
  _2334 = move (_2337.0: i32)
  using: _2337@Mir(bb1019[3])
  _2333 = move _2334 as usize (IntToInt)
  using: _2334@Mir(bb1020[0])
  _2338 = const 4096_usize
  using: 
  _2339 = Lt(_2333, _2338)
  using: _2333@Mir(bb1020[1]), _2338@Mir(bb1020[2])
  assert(move _2339, "index out of bounds: the length is {} but the index is {}", move _2338, _2333) -> bb1021
  using: _2339@Entry, _2338@Entry, _2333@Entry
bb1021:
  _2332 = ((*_1).31: [u8; 4096])[_2333]
  using: _1@Phi(bb1006), _2333@Mir(bb1020[1])
  _2342 = _2285
  using: _2285@Mir(bb1008[0])
  _2343 = const 3_i32
  using: 
  _2344 = CheckedSub(_2342, _2343)
  using: _2342@Mir(bb1021[1]), _2343@Mir(bb1021[2])
  assert(!move (_2344.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2342, move _2343) -> bb1022
  using: _2344@Entry, _2342@Entry, _2343@Entry
bb1022:
  _2341 = move (_2344.0: i32)
  using: _2344@Mir(bb1021[3])
  _2340 = move _2341 as usize (IntToInt)
  using: _2341@Mir(bb1022[0])
  _2345 = const 4096_usize
  using: 
  _2346 = Lt(_2340, _2345)
  using: _2340@Mir(bb1022[1]), _2345@Mir(bb1022[2])
  assert(move _2346, "index out of bounds: the length is {} but the index is {}", move _2345, _2340) -> bb1023
  using: _2346@Entry, _2345@Entry, _2340@Entry
bb1023:
  ((*_1).31: [u8; 4096])[_2340] = move _2332
  using: _1@Phi(bb1006), _2340@Mir(bb1022[1]), _2332@Mir(bb1021[0])
  _2348 = _2264
  using: _2264@Phi(bb1006)
  _2349 = const 4_u32
  using: 
  _2347 = core::num::<impl u32>::wrapping_sub(move _2348, move _2349) -> bb1024
  using: _2348@Mir(bb1023[1]), _2349@Mir(bb1023[2])
bb1024:
  _2264 = move _2347
  using: _2347@Mir(bb1023[3])
  goto -> bb1006
  using: 
bb1025:
  _2351 = _2264
  using: _2264@Phi(bb1025)
  _2352 = const 0_u32
  using: 
  _2350 = Gt(move _2351, move _2352)
  using: _2351@Mir(bb1025[0]), _2352@Mir(bb1025[1])
  switchInt(move _2350) -> [0: bb1033, otherwise: bb1026]
  using: _2350@Mir(bb1025[2])
bb1026:
  _2358 = _2261
  using: _2261@Phi(bb1025)
  _2357 = move _2358 as u32 (IntToInt)
  using: _2358@Mir(bb1026[0])
  _2359 = _2264
  using: _2264@Phi(bb1025)
  _2356 = core::num::<impl u32>::wrapping_add(move _2357, move _2359) -> bb1027
  using: _2357@Mir(bb1026[1]), _2359@Mir(bb1026[2])
bb1027:
  _2360 = const 1_u32
  using: 
  _2355 = core::num::<impl u32>::wrapping_sub(move _2356, move _2360) -> bb1028
  using: _2356@Mir(bb1026[3]), _2360@Mir(bb1027[0])
bb1028:
  _2354 = move _2355 as usize (IntToInt)
  using: _2355@Mir(bb1027[1])
  _2361 = const 4096_usize
  using: 
  _2362 = Lt(_2354, _2361)
  using: _2354@Mir(bb1028[0]), _2361@Mir(bb1028[1])
  assert(move _2362, "index out of bounds: the length is {} but the index is {}", move _2361, _2354) -> bb1029
  using: _2362@Entry, _2361@Entry, _2354@Entry
bb1029:
  _2353 = ((*_1).31: [u8; 4096])[_2354]
  using: _1@Phi(bb1025), _2354@Mir(bb1028[0])
  _2366 = _2261
  using: _2261@Phi(bb1025)
  _2365 = move _2366 as u32 (IntToInt)
  using: _2366@Mir(bb1029[1])
  _2367 = _2264
  using: _2264@Phi(bb1025)
  _2364 = core::num::<impl u32>::wrapping_add(move _2365, move _2367) -> bb1030
  using: _2365@Mir(bb1029[2]), _2367@Mir(bb1029[3])
bb1030:
  _2363 = move _2364 as usize (IntToInt)
  using: _2364@Mir(bb1029[4])
  _2368 = const 4096_usize
  using: 
  _2369 = Lt(_2363, _2368)
  using: _2363@Mir(bb1030[0]), _2368@Mir(bb1030[1])
  assert(move _2369, "index out of bounds: the length is {} but the index is {}", move _2368, _2363) -> bb1031
  using: _2369@Entry, _2368@Entry, _2363@Entry
bb1031:
  ((*_1).31: [u8; 4096])[_2363] = move _2353
  using: _1@Phi(bb1025), _2363@Mir(bb1030[0]), _2353@Mir(bb1029[0])
  _2371 = _2264
  using: _2264@Phi(bb1025)
  _2370 = core::num::<impl u32>::wrapping_sub(move _2371, const 1_u32) -> bb1032
  using: _2371@Mir(bb1031[1])
bb1032:
  _2264 = move _2370
  using: _2370@Mir(bb1031[2])
  goto -> bb1025
  using: 
bb1033:
  _2372 = _3
  using: _3@Mir(bb1005[1])
  _2374 = _2261
  using: _2261@Phi(bb1025)
  _2373 = move _2374 as usize (IntToInt)
  using: _2374@Mir(bb1033[1])
  _2375 = const 4096_usize
  using: 
  _2376 = Lt(_2373, _2375)
  using: _2373@Mir(bb1033[2]), _2375@Mir(bb1033[3])
  assert(move _2376, "index out of bounds: the length is {} but the index is {}", move _2375, _2373) -> bb1034
  using: _2376@Entry, _2375@Entry, _2373@Entry
bb1034:
  ((*_1).31: [u8; 4096])[_2373] = move _2372
  using: _1@Phi(bb1025), _2373@Mir(bb1033[2]), _2372@Mir(bb1033[0])
  goto -> bb1081
  using: 
bb1035:
  _2378 = _2264
  using: _2264@Phi(bb1025)
  _2379 = const 16_u32
  using: 
  _2377 = core::num::<impl u32>::wrapping_div(move _2378, move _2379) -> bb1036
  using: _2378@Mir(bb1035[0]), _2379@Mir(bb1035[1])
bb1036:
  _2262 = move _2377 as i32 (IntToInt)
  using: _2377@Mir(bb1035[2])
  _2381 = _2264
  using: _2264@Phi(bb1025)
  _2382 = const 16_u32
  using: 
  _2380 = core::num::<impl u32>::wrapping_rem(move _2381, move _2382) -> bb1037
  using: _2381@Mir(bb1036[1]), _2382@Mir(bb1036[2])
bb1037:
  _2263 = move _2380 as i32 (IntToInt)
  using: _2380@Mir(bb1036[3])
  _2385 = _2262
  using: _2262@Mir(bb1036[0])
  _2384 = move _2385 as usize (IntToInt)
  using: _2385@Mir(bb1037[1])
  _2386 = const 16_usize
  using: 
  _2387 = Lt(_2384, _2386)
  using: _2384@Mir(bb1037[2]), _2386@Mir(bb1037[3])
  assert(move _2387, "index out of bounds: the length is {} but the index is {}", move _2386, _2384) -> bb1038
  using: _2387@Entry, _2386@Entry, _2384@Entry
bb1038:
  _2383 = ((*_1).32: [i32; 16])[_2384]
  using: _1@Phi(bb1025), _2384@Mir(bb1037[2])
  _2388 = _2263
  using: _2263@Mir(bb1037[0])
  _2389 = CheckedAdd(_2383, _2388)
  using: _2383@Mir(bb1038[0]), _2388@Mir(bb1038[1])
  assert(!move (_2389.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2383, move _2388) -> bb1039
  using: _2389@Entry, _2383@Entry, _2388@Entry
bb1039:
  _2261 = move (_2389.0: i32)
  using: _2389@Mir(bb1038[2])
  _2392 = _2261
  using: _2261@Mir(bb1039[0])
  _2391 = move _2392 as usize (IntToInt)
  using: _2392@Mir(bb1039[1])
  _2393 = const 4096_usize
  using: 
  _2394 = Lt(_2391, _2393)
  using: _2391@Mir(bb1039[2]), _2393@Mir(bb1039[3])
  assert(move _2394, "index out of bounds: the length is {} but the index is {}", move _2393, _2391) -> bb1040
  using: _2394@Entry, _2393@Entry, _2391@Entry
bb1040:
  _2390 = ((*_1).31: [u8; 4096])[_2391]
  using: _1@Phi(bb1025), _2391@Mir(bb1039[2])
  _3 = move _2390
  using: _2390@Mir(bb1040[0])
  goto -> bb1041
  using: 
bb1041:
  _2396 = _2261
  using: _2261@Phi(bb1041)
  _2399 = _2262
  using: _2262@Mir(bb1036[0])
  _2398 = move _2399 as usize (IntToInt)
  using: _2399@Mir(bb1041[1])
  _2400 = const 16_usize
  using: 
  _2401 = Lt(_2398, _2400)
  using: _2398@Mir(bb1041[2]), _2400@Mir(bb1041[3])
  assert(move _2401, "index out of bounds: the length is {} but the index is {}", move _2400, _2398) -> bb1042
  using: _2401@Entry, _2400@Entry, _2398@Entry
bb1042:
  _2397 = ((*_1).32: [i32; 16])[_2398]
  using: _1@Phi(bb1041), _2398@Mir(bb1041[2])
  _2395 = Gt(move _2396, move _2397)
  using: _2396@Mir(bb1041[0]), _2397@Mir(bb1042[0])
  switchInt(move _2395) -> [0: bb1048, otherwise: bb1043]
  using: _2395@Mir(bb1042[1])
bb1043:
  _2405 = _2261
  using: _2261@Phi(bb1041)
  _2406 = const 1_i32
  using: 
  _2407 = CheckedSub(_2405, _2406)
  using: _2405@Mir(bb1043[0]), _2406@Mir(bb1043[1])
  assert(!move (_2407.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2405, move _2406) -> bb1044
  using: _2407@Entry, _2405@Entry, _2406@Entry
bb1044:
  _2404 = move (_2407.0: i32)
  using: _2407@Mir(bb1043[2])
  _2403 = move _2404 as usize (IntToInt)
  using: _2404@Mir(bb1044[0])
  _2408 = const 4096_usize
  using: 
  _2409 = Lt(_2403, _2408)
  using: _2403@Mir(bb1044[1]), _2408@Mir(bb1044[2])
  assert(move _2409, "index out of bounds: the length is {} but the index is {}", move _2408, _2403) -> bb1045
  using: _2409@Entry, _2408@Entry, _2403@Entry
bb1045:
  _2402 = ((*_1).31: [u8; 4096])[_2403]
  using: _1@Phi(bb1041), _2403@Mir(bb1044[1])
  _2411 = _2261
  using: _2261@Phi(bb1041)
  _2410 = move _2411 as usize (IntToInt)
  using: _2411@Mir(bb1045[1])
  _2412 = const 4096_usize
  using: 
  _2413 = Lt(_2410, _2412)
  using: _2410@Mir(bb1045[2]), _2412@Mir(bb1045[3])
  assert(move _2413, "index out of bounds: the length is {} but the index is {}", move _2412, _2410) -> bb1046
  using: _2413@Entry, _2412@Entry, _2410@Entry
bb1046:
  ((*_1).31: [u8; 4096])[_2410] = move _2402
  using: _1@Phi(bb1041), _2410@Mir(bb1045[2]), _2402@Mir(bb1045[0])
  _2414 = CheckedSub(_2261, const 1_i32)
  using: _2261@Phi(bb1041)
  assert(!move (_2414.1: bool), "attempt to compute `{} - {}`, which would overflow", _2261, const 1_i32) -> bb1047
  using: _2414@Entry, _2261@Entry
bb1047:
  _2261 = move (_2414.0: i32)
  using: _2414@Mir(bb1046[1])
  goto -> bb1041
  using: 
bb1048:
  _2416 = _2262
  using: _2262@Mir(bb1036[0])
  _2415 = move _2416 as usize (IntToInt)
  using: _2416@Mir(bb1048[0])
  _2417 = const 16_usize
  using: 
  _2418 = Lt(_2415, _2417)
  using: _2415@Mir(bb1048[1]), _2417@Mir(bb1048[2])
  assert(move _2418, "index out of bounds: the length is {} but the index is {}", move _2417, _2415) -> bb1049
  using: _2418@Entry, _2417@Entry, _2415@Entry
bb1049:
  _2419 = CheckedAdd(((*_1).32: [i32; 16])[_2415], const 1_i32)
  using: _1@Phi(bb1041), _2415@Mir(bb1048[1])
  assert(!move (_2419.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).32: [i32; 16])[_2415], const 1_i32) -> bb1050
  using: _2419@Entry, _1@Entry, _2415@Entry
bb1050:
  ((*_1).32: [i32; 16])[_2415] = move (_2419.0: i32)
  using: _1@Phi(bb1041), _2415@Mir(bb1048[1]), _2419@Mir(bb1049[0])
  goto -> bb1051
  using: 
bb1051:
  _2421 = _2262
  using: _2262@Phi(bb1051)
  _2422 = const 0_i32
  using: 
  _2420 = Gt(move _2421, move _2422)
  using: _2421@Mir(bb1051[0]), _2422@Mir(bb1051[1])
  switchInt(move _2420) -> [0: bb1063, otherwise: bb1052]
  using: _2420@Mir(bb1051[2])
bb1052:
  _2424 = _2262
  using: _2262@Phi(bb1051)
  _2423 = move _2424 as usize (IntToInt)
  using: _2424@Mir(bb1052[0])
  _2425 = const 16_usize
  using: 
  _2426 = Lt(_2423, _2425)
  using: _2423@Mir(bb1052[1]), _2425@Mir(bb1052[2])
  assert(move _2426, "index out of bounds: the length is {} but the index is {}", move _2425, _2423) -> bb1053
  using: _2426@Entry, _2425@Entry, _2423@Entry
bb1053:
  _2427 = CheckedSub(((*_1).32: [i32; 16])[_2423], const 1_i32)
  using: _1@Phi(bb1051), _2423@Mir(bb1052[1])
  assert(!move (_2427.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).32: [i32; 16])[_2423], const 1_i32) -> bb1054
  using: _2427@Entry, _1@Entry, _2423@Entry
bb1054:
  ((*_1).32: [i32; 16])[_2423] = move (_2427.0: i32)
  using: _1@Phi(bb1051), _2423@Mir(bb1052[1]), _2427@Mir(bb1053[0])
  _2435 = _2262
  using: _2262@Phi(bb1051)
  _2436 = const 1_i32
  using: 
  _2437 = CheckedSub(_2435, _2436)
  using: _2435@Mir(bb1054[1]), _2436@Mir(bb1054[2])
  assert(!move (_2437.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2435, move _2436) -> bb1055
  using: _2437@Entry, _2435@Entry, _2436@Entry
bb1055:
  _2434 = move (_2437.0: i32)
  using: _2437@Mir(bb1054[3])
  _2433 = move _2434 as usize (IntToInt)
  using: _2434@Mir(bb1055[0])
  _2438 = const 16_usize
  using: 
  _2439 = Lt(_2433, _2438)
  using: _2433@Mir(bb1055[1]), _2438@Mir(bb1055[2])
  assert(move _2439, "index out of bounds: the length is {} but the index is {}", move _2438, _2433) -> bb1056
  using: _2439@Entry, _2438@Entry, _2433@Entry
bb1056:
  _2432 = ((*_1).32: [i32; 16])[_2433]
  using: _1@Phi(bb1051), _2433@Mir(bb1055[1])
  _2440 = const 16_i32
  using: 
  _2441 = CheckedAdd(_2432, _2440)
  using: _2432@Mir(bb1056[0]), _2440@Mir(bb1056[1])
  assert(!move (_2441.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2432, move _2440) -> bb1057
  using: _2441@Entry, _2432@Entry, _2440@Entry
bb1057:
  _2431 = move (_2441.0: i32)
  using: _2441@Mir(bb1056[2])
  _2442 = const 1_i32
  using: 
  _2443 = CheckedSub(_2431, _2442)
  using: _2431@Mir(bb1057[0]), _2442@Mir(bb1057[1])
  assert(!move (_2443.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2431, move _2442) -> bb1058
  using: _2443@Entry, _2431@Entry, _2442@Entry
bb1058:
  _2430 = move (_2443.0: i32)
  using: _2443@Mir(bb1057[2])
  _2429 = move _2430 as usize (IntToInt)
  using: _2430@Mir(bb1058[0])
  _2444 = const 4096_usize
  using: 
  _2445 = Lt(_2429, _2444)
  using: _2429@Mir(bb1058[1]), _2444@Mir(bb1058[2])
  assert(move _2445, "index out of bounds: the length is {} but the index is {}", move _2444, _2429) -> bb1059
  using: _2445@Entry, _2444@Entry, _2429@Entry
bb1059:
  _2428 = ((*_1).31: [u8; 4096])[_2429]
  using: _1@Phi(bb1051), _2429@Mir(bb1058[1])
  _2449 = _2262
  using: _2262@Phi(bb1051)
  _2448 = move _2449 as usize (IntToInt)
  using: _2449@Mir(bb1059[1])
  _2450 = const 16_usize
  using: 
  _2451 = Lt(_2448, _2450)
  using: _2448@Mir(bb1059[2]), _2450@Mir(bb1059[3])
  assert(move _2451, "index out of bounds: the length is {} but the index is {}", move _2450, _2448) -> bb1060
  using: _2451@Entry, _2450@Entry, _2448@Entry
bb1060:
  _2447 = ((*_1).32: [i32; 16])[_2448]
  using: _1@Phi(bb1051), _2448@Mir(bb1059[2])
  _2446 = move _2447 as usize (IntToInt)
  using: _2447@Mir(bb1060[0])
  _2452 = const 4096_usize
  using: 
  _2453 = Lt(_2446, _2452)
  using: _2446@Mir(bb1060[1]), _2452@Mir(bb1060[2])
  assert(move _2453, "index out of bounds: the length is {} but the index is {}", move _2452, _2446) -> bb1061
  using: _2453@Entry, _2452@Entry, _2446@Entry
bb1061:
  ((*_1).31: [u8; 4096])[_2446] = move _2428
  using: _1@Phi(bb1051), _2446@Mir(bb1060[1]), _2428@Mir(bb1059[0])
  _2454 = CheckedSub(_2262, const 1_i32)
  using: _2262@Phi(bb1051)
  assert(!move (_2454.1: bool), "attempt to compute `{} - {}`, which would overflow", _2262, const 1_i32) -> bb1062
  using: _2454@Entry, _2262@Entry
bb1062:
  _2262 = move (_2454.0: i32)
  using: _2454@Mir(bb1061[1])
  goto -> bb1051
  using: 
bb1063:
  _2455 = const 0_usize
  using: 
  _2456 = CheckedSub(((*_1).32: [i32; 16])[_2455], const 1_i32)
  using: _1@Phi(bb1051), _2455@Mir(bb1063[0])
  assert(!move (_2456.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).32: [i32; 16])[_2455], const 1_i32) -> bb1064
  using: _2456@Entry, _1@Entry, _2455@Entry
bb1064:
  ((*_1).32: [i32; 16])[_2455] = move (_2456.0: i32)
  using: _1@Phi(bb1051), _2455@Mir(bb1063[0]), _2456@Mir(bb1063[1])
  _2457 = _3
  using: _3@Mir(bb1040[1])
  _2460 = const 0_usize
  using: 
  _2459 = ((*_1).32: [i32; 16])[_2460]
  using: _1@Phi(bb1051), _2460@Mir(bb1064[2])
  _2458 = move _2459 as usize (IntToInt)
  using: _2459@Mir(bb1064[3])
  _2461 = const 4096_usize
  using: 
  _2462 = Lt(_2458, _2461)
  using: _2458@Mir(bb1064[4]), _2461@Mir(bb1064[5])
  assert(move _2462, "index out of bounds: the length is {} but the index is {}", move _2461, _2458) -> bb1065
  using: _2462@Entry, _2461@Entry, _2458@Entry
bb1065:
  ((*_1).31: [u8; 4096])[_2458] = move _2457
  using: _1@Phi(bb1051), _2458@Mir(bb1064[4]), _2457@Mir(bb1064[1])
  _2465 = const 0_usize
  using: 
  _2464 = ((*_1).32: [i32; 16])[_2465]
  using: _1@Phi(bb1051), _2465@Mir(bb1065[1])
  _2466 = const 0_i32
  using: 
  _2463 = Eq(move _2464, move _2466)
  using: _2464@Mir(bb1065[2]), _2466@Mir(bb1065[3])
  switchInt(move _2463) -> [0: bb1081, otherwise: bb1066]
  using: _2463@Mir(bb1065[4])
bb1066:
  _2260 = const 4095_i32
  using: 
  _2258 = const 15_i32
  using: 
  goto -> bb1067
  using: 
bb1067:
  _2468 = _2258
  using: _2258@Phi(bb1067)
  _2469 = const 0_i32
  using: 
  _2467 = Ge(move _2468, move _2469)
  using: _2468@Mir(bb1067[0]), _2469@Mir(bb1067[1])
  switchInt(move _2467) -> [0: bb1081, otherwise: bb1068]
  using: _2467@Mir(bb1067[2])
bb1068:
  _2259 = const 15_i32
  using: 
  goto -> bb1069
  using: 
bb1069:
  _2471 = _2259
  using: _2259@Phi(bb1069)
  _2472 = const 0_i32
  using: 
  _2470 = Ge(move _2471, move _2472)
  using: _2471@Mir(bb1069[0]), _2472@Mir(bb1069[1])
  switchInt(move _2470) -> [0: bb1077, otherwise: bb1070]
  using: _2470@Mir(bb1069[2])
bb1070:
  _2478 = _2258
  using: _2258@Phi(bb1069)
  _2477 = move _2478 as usize (IntToInt)
  using: _2478@Mir(bb1070[0])
  _2479 = const 16_usize
  using: 
  _2480 = Lt(_2477, _2479)
  using: _2477@Mir(bb1070[1]), _2479@Mir(bb1070[2])
  assert(move _2480, "index out of bounds: the length is {} but the index is {}", move _2479, _2477) -> bb1071
  using: _2480@Entry, _2479@Entry, _2477@Entry
bb1071:
  _2476 = ((*_1).32: [i32; 16])[_2477]
  using: _1@Phi(bb1069), _2477@Mir(bb1070[1])
  _2481 = _2259
  using: _2259@Phi(bb1069)
  _2482 = CheckedAdd(_2476, _2481)
  using: _2476@Mir(bb1071[0]), _2481@Mir(bb1071[1])
  assert(!move (_2482.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2476, move _2481) -> bb1072
  using: _2482@Entry, _2476@Entry, _2481@Entry
bb1072:
  _2475 = move (_2482.0: i32)
  using: _2482@Mir(bb1071[2])
  _2474 = move _2475 as usize (IntToInt)
  using: _2475@Mir(bb1072[0])
  _2483 = const 4096_usize
  using: 
  _2484 = Lt(_2474, _2483)
  using: _2474@Mir(bb1072[1]), _2483@Mir(bb1072[2])
  assert(move _2484, "index out of bounds: the length is {} but the index is {}", move _2483, _2474) -> bb1073
  using: _2484@Entry, _2483@Entry, _2474@Entry
bb1073:
  _2473 = ((*_1).31: [u8; 4096])[_2474]
  using: _1@Phi(bb1069), _2474@Mir(bb1072[1])
  _2486 = _2260
  using: _2260@Phi(bb1069)
  _2485 = move _2486 as usize (IntToInt)
  using: _2486@Mir(bb1073[1])
  _2487 = const 4096_usize
  using: 
  _2488 = Lt(_2485, _2487)
  using: _2485@Mir(bb1073[2]), _2487@Mir(bb1073[3])
  assert(move _2488, "index out of bounds: the length is {} but the index is {}", move _2487, _2485) -> bb1074
  using: _2488@Entry, _2487@Entry, _2485@Entry
bb1074:
  ((*_1).31: [u8; 4096])[_2485] = move _2473
  using: _1@Phi(bb1069), _2485@Mir(bb1073[2]), _2473@Mir(bb1073[0])
  _2489 = CheckedSub(_2260, const 1_i32)
  using: _2260@Phi(bb1069)
  assert(!move (_2489.1: bool), "attempt to compute `{} - {}`, which would overflow", _2260, const 1_i32) -> bb1075
  using: _2489@Entry, _2260@Entry
bb1075:
  _2260 = move (_2489.0: i32)
  using: _2489@Mir(bb1074[1])
  _2490 = CheckedSub(_2259, const 1_i32)
  using: _2259@Phi(bb1069)
  assert(!move (_2490.1: bool), "attempt to compute `{} - {}`, which would overflow", _2259, const 1_i32) -> bb1076
  using: _2490@Entry, _2259@Entry
bb1076:
  _2259 = move (_2490.0: i32)
  using: _2490@Mir(bb1075[1])
  goto -> bb1069
  using: 
bb1077:
  _2491 = _2260
  using: _2260@Phi(bb1069)
  _2492 = const 1_i32
  using: 
  _2493 = CheckedAdd(_2491, _2492)
  using: _2491@Mir(bb1077[0]), _2492@Mir(bb1077[1])
  assert(!move (_2493.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2491, move _2492) -> bb1078
  using: _2493@Entry, _2491@Entry, _2492@Entry
bb1078:
  _2495 = _2258
  using: _2258@Phi(bb1069)
  _2494 = move _2495 as usize (IntToInt)
  using: _2495@Mir(bb1078[0])
  _2496 = const 16_usize
  using: 
  _2497 = Lt(_2494, _2496)
  using: _2494@Mir(bb1078[1]), _2496@Mir(bb1078[2])
  assert(move _2497, "index out of bounds: the length is {} but the index is {}", move _2496, _2494) -> bb1079
  using: _2497@Entry, _2496@Entry, _2494@Entry
bb1079:
  ((*_1).32: [i32; 16])[_2494] = move (_2493.0: i32)
  using: _1@Phi(bb1069), _2494@Mir(bb1078[1]), _2493@Mir(bb1077[2])
  _2498 = CheckedSub(_2258, const 1_i32)
  using: _2258@Phi(bb1069)
  assert(!move (_2498.1: bool), "attempt to compute `{} - {}`, which would overflow", _2258, const 1_i32) -> bb1080
  using: _2498@Entry, _2258@Entry
bb1080:
  _2258 = move (_2498.0: i32)
  using: _2498@Mir(bb1079[1])
  goto -> bb1067
  using: 
bb1081:
  _2502 = _3
  using: _3@Phi(bb1081)
  _2501 = move _2502 as usize (IntToInt)
  using: _2502@Mir(bb1081[0])
  _2503 = const 256_usize
  using: 
  _2504 = Lt(_2501, _2503)
  using: _2501@Mir(bb1081[1]), _2503@Mir(bb1081[2])
  assert(move _2504, "index out of bounds: the length is {} but the index is {}", move _2503, _2501) -> bb1082
  using: _2504@Entry, _2503@Entry, _2501@Entry
bb1082:
  _2500 = ((*_1).30: [u8; 256])[_2501]
  using: _1@Phi(bb1081), _2501@Mir(bb1081[1])
  _2499 = move _2500 as usize (IntToInt)
  using: _2500@Mir(bb1082[0])
  _2505 = const 256_usize
  using: 
  _2506 = Lt(_2499, _2505)
  using: _2499@Mir(bb1082[1]), _2505@Mir(bb1082[2])
  assert(move _2506, "index out of bounds: the length is {} but the index is {}", move _2505, _2499) -> bb1083
  using: _2506@Entry, _2505@Entry, _2499@Entry
bb1083:
  _2507 = CheckedAdd(((*_1).16: [i32; 256])[_2499], const 1_i32)
  using: _1@Phi(bb1081), _2499@Mir(bb1082[1])
  assert(!move (_2507.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).16: [i32; 256])[_2499], const 1_i32) -> bb1084
  using: _2507@Entry, _1@Entry, _2499@Entry
bb1084:
  ((*_1).16: [i32; 256])[_2499] = move (_2507.0: i32)
  using: _1@Phi(bb1081), _2499@Mir(bb1082[1]), _2507@Mir(bb1083[0])
  _2508 = ((*_1).10: u8)
  using: _1@Phi(bb1081)
  switchInt(move _2508) -> [0: bb1088, otherwise: bb1085]
  using: _2508@Mir(bb1084[1])
bb1085:
  _2511 = _3
  using: _3@Phi(bb1081)
  _2510 = move _2511 as usize (IntToInt)
  using: _2511@Mir(bb1085[0])
  _2512 = const 256_usize
  using: 
  _2513 = Lt(_2510, _2512)
  using: _2510@Mir(bb1085[1]), _2512@Mir(bb1085[2])
  assert(move _2513, "index out of bounds: the length is {} but the index is {}", move _2512, _2510) -> bb1086
  using: _2513@Entry, _2512@Entry, _2510@Entry
bb1086:
  _2509 = ((*_1).30: [u8; 256])[_2510]
  using: _1@Phi(bb1081), _2510@Mir(bb1085[1])
  _2515 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1081)
  _2517 = _19
  using: _19@Phi(bb991)
  _2516 = move _2517 as isize (IntToInt)
  using: _2517@Mir(bb1086[2])
  _2514 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2515, move _2516) -> bb1087
  using: _2515@Mir(bb1086[1]), _2516@Mir(bb1086[3])
bb1087:
  (*_2514) = move _2509 as u16 (IntToInt)
  using: _2514@Mir(bb1086[4]), _2509@Mir(bb1086[0])
  goto -> bb1091
  using: 
bb1088:
  _2520 = _3
  using: _3@Phi(bb1081)
  _2519 = move _2520 as usize (IntToInt)
  using: _2520@Mir(bb1088[0])
  _2521 = const 256_usize
  using: 
  _2522 = Lt(_2519, _2521)
  using: _2519@Mir(bb1088[1]), _2521@Mir(bb1088[2])
  assert(move _2522, "index out of bounds: the length is {} but the index is {}", move _2521, _2519) -> bb1089
  using: _2522@Entry, _2521@Entry, _2519@Entry
bb1089:
  _2518 = ((*_1).30: [u8; 256])[_2519]
  using: _1@Phi(bb1081), _2519@Mir(bb1088[1])
  _2524 = ((*_1).20: *mut u32)
  using: _1@Phi(bb1081)
  _2526 = _19
  using: _19@Phi(bb991)
  _2525 = move _2526 as isize (IntToInt)
  using: _2526@Mir(bb1089[2])
  _2523 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _2524, move _2525) -> bb1090
  using: _2524@Mir(bb1089[1]), _2525@Mir(bb1089[3])
bb1090:
  (*_2523) = move _2518 as u32 (IntToInt)
  using: _2523@Mir(bb1089[4]), _2518@Mir(bb1089[0])
  goto -> bb1091
  using: 
bb1091:
  _2527 = CheckedAdd(_19, const 1_i32)
  using: _19@Phi(bb1091)
  assert(!move (_2527.1: bool), "attempt to compute `{} + {}`, which would overflow", _19, const 1_i32) -> bb1092
  using: _2527@Entry, _19@Entry
bb1092:
  _19 = move (_2527.0: i32)
  using: _2527@Mir(bb1091[0])
  _2529 = _16
  using: _16@Phi(bb634)
  _2530 = const 0_i32
  using: 
  _2528 = Eq(move _2529, move _2530)
  using: _2529@Mir(bb1092[1]), _2530@Mir(bb1092[2])
  switchInt(move _2528) -> [0: bb1111, otherwise: bb1093]
  using: _2528@Mir(bb1092[3])
bb1093:
  _2531 = CheckedAdd(_15, const 1_i32)
  using: _15@Phi(bb634)
  assert(!move (_2531.1: bool), "attempt to compute `{} + {}`, which would overflow", _15, const 1_i32) -> bb1094
  using: _2531@Entry, _15@Entry
bb1094:
  _15 = move (_2531.0: i32)
  using: _2531@Mir(bb1093[0])
  _2533 = _15
  using: _15@Mir(bb1094[0])
  _2534 = _13
  using: _13@Phi(bb908)
  _2532 = Ge(move _2533, move _2534)
  using: _2533@Mir(bb1094[1]), _2534@Mir(bb1094[2])
  switchInt(move _2532) -> [0: bb1096, otherwise: bb1095]
  using: _2532@Mir(bb1094[3])
bb1095:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1096:
  _16 = const 50_i32
  using: 
  _2537 = _15
  using: _15@Mir(bb1094[0])
  _2536 = move _2537 as usize (IntToInt)
  using: _2537@Mir(bb1096[1])
  _2538 = const 18002_usize
  using: 
  _2539 = Lt(_2536, _2538)
  using: _2536@Mir(bb1096[2]), _2538@Mir(bb1096[3])
  assert(move _2539, "index out of bounds: the length is {} but the index is {}", move _2538, _2536) -> bb1097
  using: _2539@Entry, _2538@Entry, _2536@Entry
bb1097:
  _2535 = ((*_1).33: [u8; 18002])[_2536]
  using: _1@Phi(bb1091), _2536@Mir(bb1096[2])
  _27 = move _2535 as i32 (IntToInt)
  using: _2535@Mir(bb1097[0])
  _2542 = _27
  using: _27@Mir(bb1097[1])
  _2541 = move _2542 as usize (IntToInt)
  using: _2542@Mir(bb1097[2])
  _2543 = const 6_usize
  using: 
  _2544 = Lt(_2541, _2543)
  using: _2541@Mir(bb1097[3]), _2543@Mir(bb1097[4])
  assert(move _2544, "index out of bounds: the length is {} but the index is {}", move _2543, _2541) -> bb1098
  using: _2544@Entry, _2543@Entry, _2541@Entry
bb1098:
  _2540 = ((*_1).39: [i32; 6])[_2541]
  using: _1@Phi(bb1091), _2541@Mir(bb1097[3])
  _28 = move _2540
  using: _2540@Mir(bb1098[0])
  _2554 = &mut ((*_1).36: [[i32; 258]; 6])
  using: _1@Phi(bb1091)
  _2553 = move _2554 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _2554@Mir(bb1098[2])
  _2552 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _2553) -> bb1099
  using: _2553@Mir(bb1098[3])
bb1099:
  _2556 = _27
  using: _27@Mir(bb1097[1])
  _2555 = move _2556 as isize (IntToInt)
  using: _2556@Mir(bb1099[0])
  _2551 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _2552, move _2555) -> bb1100
  using: _2552@Mir(bb1098[4]), _2555@Mir(bb1099[1])
bb1100:
  _2550 = &mut (*_2551)
  using: _2551@Mir(bb1099[2])
  _2549 = move _2550 as &mut [i32] (Pointer(Unsize))
  using: _2550@Mir(bb1100[0])
  _2548 = core::slice::<impl [i32]>::as_mut_ptr(move _2549) -> bb1101
  using: _2549@Mir(bb1100[1])
bb1101:
  _2557 = const 0_isize
  using: 
  _2547 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2548, move _2557) -> bb1102
  using: _2548@Mir(bb1100[2]), _2557@Mir(bb1101[0])
bb1102:
  _2546 = &mut (*_2547)
  using: _2547@Mir(bb1101[1])
  _2545 = &raw mut (*_2546)
  using: _2546@Mir(bb1102[0])
  _29 = move _2545
  using: _2545@Mir(bb1102[1])
  _2567 = &mut ((*_1).38: [[i32; 258]; 6])
  using: _1@Phi(bb1091)
  _2566 = move _2567 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _2567@Mir(bb1102[3])
  _2565 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _2566) -> bb1103
  using: _2566@Mir(bb1102[4])
bb1103:
  _2569 = _27
  using: _27@Mir(bb1097[1])
  _2568 = move _2569 as isize (IntToInt)
  using: _2569@Mir(bb1103[0])
  _2564 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _2565, move _2568) -> bb1104
  using: _2565@Mir(bb1102[5]), _2568@Mir(bb1103[1])
bb1104:
  _2563 = &mut (*_2564)
  using: _2564@Mir(bb1103[2])
  _2562 = move _2563 as &mut [i32] (Pointer(Unsize))
  using: _2563@Mir(bb1104[0])
  _2561 = core::slice::<impl [i32]>::as_mut_ptr(move _2562) -> bb1105
  using: _2562@Mir(bb1104[1])
bb1105:
  _2570 = const 0_isize
  using: 
  _2560 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2561, move _2570) -> bb1106
  using: _2561@Mir(bb1104[2]), _2570@Mir(bb1105[0])
bb1106:
  _2559 = &mut (*_2560)
  using: _2560@Mir(bb1105[1])
  _2558 = &raw mut (*_2559)
  using: _2559@Mir(bb1106[0])
  _31 = move _2558
  using: _2558@Mir(bb1106[1])
  _2580 = &mut ((*_1).37: [[i32; 258]; 6])
  using: _1@Phi(bb1091)
  _2579 = move _2580 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _2580@Mir(bb1106[3])
  _2578 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _2579) -> bb1107
  using: _2579@Mir(bb1106[4])
bb1107:
  _2582 = _27
  using: _27@Mir(bb1097[1])
  _2581 = move _2582 as isize (IntToInt)
  using: _2582@Mir(bb1107[0])
  _2577 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _2578, move _2581) -> bb1108
  using: _2578@Mir(bb1106[5]), _2581@Mir(bb1107[1])
bb1108:
  _2576 = &mut (*_2577)
  using: _2577@Mir(bb1107[2])
  _2575 = move _2576 as &mut [i32] (Pointer(Unsize))
  using: _2576@Mir(bb1108[0])
  _2574 = core::slice::<impl [i32]>::as_mut_ptr(move _2575) -> bb1109
  using: _2575@Mir(bb1108[1])
bb1109:
  _2583 = const 0_isize
  using: 
  _2573 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _2574, move _2583) -> bb1110
  using: _2574@Mir(bb1108[2]), _2583@Mir(bb1109[0])
bb1110:
  _2572 = &mut (*_2573)
  using: _2573@Mir(bb1109[1])
  _2571 = &raw mut (*_2572)
  using: _2572@Mir(bb1110[0])
  _30 = move _2571
  using: _2571@Mir(bb1110[1])
  goto -> bb1111
  using: 
bb1111:
  _2584 = CheckedSub(_16, const 1_i32)
  using: _16@Phi(bb1111)
  assert(!move (_2584.1: bool), "attempt to compute `{} - {}`, which would overflow", _16, const 1_i32) -> bb1112
  using: _2584@Entry, _16@Entry
bb1112:
  _16 = move (_2584.0: i32)
  using: _2584@Mir(bb1111[0])
  _2585 = _28
  using: _28@Phi(bb1111)
  _24 = move _2585
  using: _2585@Mir(bb1112[1])
  _2 = const 2629672494974161066_u64
  using: 
  goto -> bb634
  using: 
bb1113:
  switchInt(_2) -> [4550729491376650574: bb1301, otherwise: bb1114]
  using: _2@Phi(bb1113)
bb1114:
  _2588 = ((*_1).13: i32)
  using: _1@Phi(bb1111)
  _2589 = const 0_i32
  using: 
  _2587 = Lt(move _2588, move _2589)
  using: _2588@Mir(bb1114[0]), _2589@Mir(bb1114[1])
  switchInt(move _2587) -> [0: bb1116, otherwise: bb1115]
  using: _2587@Mir(bb1114[2])
bb1115:
  _2586 = const true
  using: 
  goto -> bb1117
  using: 
bb1116:
  _2591 = ((*_1).13: i32)
  using: _1@Phi(bb1111)
  _2592 = _19
  using: _19@Phi(bb1091)
  _2590 = Ge(move _2591, move _2592)
  using: _2591@Mir(bb1116[0]), _2592@Mir(bb1116[1])
  _2586 = move _2590
  using: _2590@Mir(bb1116[2])
  goto -> bb1117
  using: 
bb1117:
  switchInt(move _2586) -> [0: bb1119, otherwise: bb1118]
  using: _2586@Phi(bb1117)
bb1118:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1119:
  _8 = const 0_i32
  using: 
  goto -> bb1120
  using: 
bb1120:
  _2594 = _8
  using: _8@Phi(bb1120)
  _2595 = const 255_i32
  using: 
  _2593 = Le(move _2594, move _2595)
  using: _2594@Mir(bb1120[0]), _2595@Mir(bb1120[1])
  switchInt(move _2593) -> [0: bb1130, otherwise: bb1121]
  using: _2593@Mir(bb1120[2])
bb1121:
  _2600 = _8
  using: _8@Phi(bb1120)
  _2599 = move _2600 as usize (IntToInt)
  using: _2600@Mir(bb1121[0])
  _2601 = const 256_usize
  using: 
  _2602 = Lt(_2599, _2601)
  using: _2599@Mir(bb1121[1]), _2601@Mir(bb1121[2])
  assert(move _2602, "index out of bounds: the length is {} but the index is {}", move _2601, _2599) -> bb1125
  using: _2602@Entry, _2601@Entry, _2599@Entry
bb1122:
  _2596 = const true
  using: 
  goto -> bb1124
  using: 
bb1123:
  _2607 = _8
  using: _8@Phi(bb1120)
  _2606 = move _2607 as usize (IntToInt)
  using: _2607@Mir(bb1123[0])
  _2608 = const 256_usize
  using: 
  _2609 = Lt(_2606, _2608)
  using: _2606@Mir(bb1123[1]), _2608@Mir(bb1123[2])
  assert(move _2609, "index out of bounds: the length is {} but the index is {}", move _2608, _2606) -> bb1126
  using: _2609@Entry, _2608@Entry, _2606@Entry
bb1124:
  switchInt(move _2596) -> [0: bb1128, otherwise: bb1127]
  using: _2596@Phi(bb1124)
bb1125:
  _2598 = ((*_1).16: [i32; 256])[_2599]
  using: _1@Phi(bb1120), _2599@Mir(bb1121[1])
  _2603 = const 0_i32
  using: 
  _2597 = Lt(move _2598, move _2603)
  using: _2598@Mir(bb1125[0]), _2603@Mir(bb1125[1])
  switchInt(move _2597) -> [0: bb1123, otherwise: bb1122]
  using: _2597@Mir(bb1125[2])
bb1126:
  _2605 = ((*_1).16: [i32; 256])[_2606]
  using: _1@Phi(bb1120), _2606@Mir(bb1123[1])
  _2610 = _19
  using: _19@Phi(bb1120)
  _2604 = Gt(move _2605, move _2610)
  using: _2605@Mir(bb1126[0]), _2610@Mir(bb1126[1])
  _2596 = move _2604
  using: _2604@Mir(bb1126[2])
  goto -> bb1124
  using: 
bb1127:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1128:
  _2611 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1124)
  assert(!move (_2611.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1129
  using: _2611@Entry, _8@Entry
bb1129:
  _8 = move (_2611.0: i32)
  using: _2611@Mir(bb1128[0])
  goto -> bb1120
  using: 
bb1130:
  _2612 = const 0_i32
  using: 
  _2613 = const 0_usize
  using: 
  ((*_1).18: [i32; 257])[_2613] = move _2612
  using: _1@Phi(bb1124), _2613@Mir(bb1130[1]), _2612@Mir(bb1130[0])
  _8 = const 1_i32
  using: 
  goto -> bb1131
  using: 
bb1131:
  _2615 = _8
  using: _8@Phi(bb1131)
  _2616 = const 256_i32
  using: 
  _2614 = Le(move _2615, move _2616)
  using: _2615@Mir(bb1131[0]), _2616@Mir(bb1131[1])
  switchInt(move _2614) -> [0: bb1137, otherwise: bb1132]
  using: _2614@Mir(bb1131[2])
bb1132:
  _2620 = _8
  using: _8@Phi(bb1131)
  _2621 = const 1_i32
  using: 
  _2622 = CheckedSub(_2620, _2621)
  using: _2620@Mir(bb1132[0]), _2621@Mir(bb1132[1])
  assert(!move (_2622.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2620, move _2621) -> bb1133
  using: _2622@Entry, _2620@Entry, _2621@Entry
bb1133:
  _2619 = move (_2622.0: i32)
  using: _2622@Mir(bb1132[2])
  _2618 = move _2619 as usize (IntToInt)
  using: _2619@Mir(bb1133[0])
  _2623 = const 256_usize
  using: 
  _2624 = Lt(_2618, _2623)
  using: _2618@Mir(bb1133[1]), _2623@Mir(bb1133[2])
  assert(move _2624, "index out of bounds: the length is {} but the index is {}", move _2623, _2618) -> bb1134
  using: _2624@Entry, _2623@Entry, _2618@Entry
bb1134:
  _2617 = ((*_1).16: [i32; 256])[_2618]
  using: _1@Phi(bb1131), _2618@Mir(bb1133[1])
  _2626 = _8
  using: _8@Phi(bb1131)
  _2625 = move _2626 as usize (IntToInt)
  using: _2626@Mir(bb1134[1])
  _2627 = const 257_usize
  using: 
  _2628 = Lt(_2625, _2627)
  using: _2625@Mir(bb1134[2]), _2627@Mir(bb1134[3])
  assert(move _2628, "index out of bounds: the length is {} but the index is {}", move _2627, _2625) -> bb1135
  using: _2628@Entry, _2627@Entry, _2625@Entry
bb1135:
  ((*_1).18: [i32; 257])[_2625] = move _2617
  using: _1@Phi(bb1131), _2625@Mir(bb1134[2]), _2617@Mir(bb1134[0])
  _2629 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1131)
  assert(!move (_2629.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1136
  using: _2629@Entry, _8@Entry
bb1136:
  _8 = move (_2629.0: i32)
  using: _2629@Mir(bb1135[1])
  goto -> bb1131
  using: 
bb1137:
  _8 = const 1_i32
  using: 
  goto -> bb1138
  using: 
bb1138:
  _2631 = _8
  using: _8@Phi(bb1138)
  _2632 = const 256_i32
  using: 
  _2630 = Le(move _2631, move _2632)
  using: _2631@Mir(bb1138[0]), _2632@Mir(bb1138[1])
  switchInt(move _2630) -> [0: bb1145, otherwise: bb1139]
  using: _2630@Mir(bb1138[2])
bb1139:
  _2636 = _8
  using: _8@Phi(bb1138)
  _2637 = const 1_i32
  using: 
  _2638 = CheckedSub(_2636, _2637)
  using: _2636@Mir(bb1139[0]), _2637@Mir(bb1139[1])
  assert(!move (_2638.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2636, move _2637) -> bb1140
  using: _2638@Entry, _2636@Entry, _2637@Entry
bb1140:
  _2635 = move (_2638.0: i32)
  using: _2638@Mir(bb1139[2])
  _2634 = move _2635 as usize (IntToInt)
  using: _2635@Mir(bb1140[0])
  _2639 = const 257_usize
  using: 
  _2640 = Lt(_2634, _2639)
  using: _2634@Mir(bb1140[1]), _2639@Mir(bb1140[2])
  assert(move _2640, "index out of bounds: the length is {} but the index is {}", move _2639, _2634) -> bb1141
  using: _2640@Entry, _2639@Entry, _2634@Entry
bb1141:
  _2633 = ((*_1).18: [i32; 257])[_2634]
  using: _1@Phi(bb1138), _2634@Mir(bb1140[1])
  _2642 = _8
  using: _8@Phi(bb1138)
  _2641 = move _2642 as usize (IntToInt)
  using: _2642@Mir(bb1141[1])
  _2643 = const 257_usize
  using: 
  _2644 = Lt(_2641, _2643)
  using: _2641@Mir(bb1141[2]), _2643@Mir(bb1141[3])
  assert(move _2644, "index out of bounds: the length is {} but the index is {}", move _2643, _2641) -> bb1142
  using: _2644@Entry, _2643@Entry, _2641@Entry
bb1142:
  _2645 = CheckedAdd(((*_1).18: [i32; 257])[_2641], _2633)
  using: _1@Phi(bb1138), _2641@Mir(bb1141[2]), _2633@Mir(bb1141[0])
  assert(!move (_2645.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).18: [i32; 257])[_2641], move _2633) -> bb1143
  using: _2645@Entry, _1@Entry, _2641@Entry, _2633@Entry
bb1143:
  ((*_1).18: [i32; 257])[_2641] = move (_2645.0: i32)
  using: _1@Phi(bb1138), _2641@Mir(bb1141[2]), _2645@Mir(bb1142[0])
  _2646 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1138)
  assert(!move (_2646.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1144
  using: _2646@Entry, _8@Entry
bb1144:
  _8 = move (_2646.0: i32)
  using: _2646@Mir(bb1143[1])
  goto -> bb1138
  using: 
bb1145:
  _8 = const 0_i32
  using: 
  goto -> bb1146
  using: 
bb1146:
  _2648 = _8
  using: _8@Phi(bb1146)
  _2649 = const 256_i32
  using: 
  _2647 = Le(move _2648, move _2649)
  using: _2648@Mir(bb1146[0]), _2649@Mir(bb1146[1])
  switchInt(move _2647) -> [0: bb1156, otherwise: bb1147]
  using: _2647@Mir(bb1146[2])
bb1147:
  _2654 = _8
  using: _8@Phi(bb1146)
  _2653 = move _2654 as usize (IntToInt)
  using: _2654@Mir(bb1147[0])
  _2655 = const 257_usize
  using: 
  _2656 = Lt(_2653, _2655)
  using: _2653@Mir(bb1147[1]), _2655@Mir(bb1147[2])
  assert(move _2656, "index out of bounds: the length is {} but the index is {}", move _2655, _2653) -> bb1151
  using: _2656@Entry, _2655@Entry, _2653@Entry
bb1148:
  _2650 = const true
  using: 
  goto -> bb1150
  using: 
bb1149:
  _2661 = _8
  using: _8@Phi(bb1146)
  _2660 = move _2661 as usize (IntToInt)
  using: _2661@Mir(bb1149[0])
  _2662 = const 257_usize
  using: 
  _2663 = Lt(_2660, _2662)
  using: _2660@Mir(bb1149[1]), _2662@Mir(bb1149[2])
  assert(move _2663, "index out of bounds: the length is {} but the index is {}", move _2662, _2660) -> bb1152
  using: _2663@Entry, _2662@Entry, _2660@Entry
bb1150:
  switchInt(move _2650) -> [0: bb1154, otherwise: bb1153]
  using: _2650@Phi(bb1150)
bb1151:
  _2652 = ((*_1).18: [i32; 257])[_2653]
  using: _1@Phi(bb1146), _2653@Mir(bb1147[1])
  _2657 = const 0_i32
  using: 
  _2651 = Lt(move _2652, move _2657)
  using: _2652@Mir(bb1151[0]), _2657@Mir(bb1151[1])
  switchInt(move _2651) -> [0: bb1149, otherwise: bb1148]
  using: _2651@Mir(bb1151[2])
bb1152:
  _2659 = ((*_1).18: [i32; 257])[_2660]
  using: _1@Phi(bb1146), _2660@Mir(bb1149[1])
  _2664 = _19
  using: _19@Phi(bb1146)
  _2658 = Gt(move _2659, move _2664)
  using: _2659@Mir(bb1152[0]), _2664@Mir(bb1152[1])
  _2650 = move _2658
  using: _2658@Mir(bb1152[2])
  goto -> bb1150
  using: 
bb1153:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1154:
  _2665 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1150)
  assert(!move (_2665.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1155
  using: _2665@Entry, _8@Entry
bb1155:
  _8 = move (_2665.0: i32)
  using: _2665@Mir(bb1154[0])
  goto -> bb1146
  using: 
bb1156:
  _8 = const 1_i32
  using: 
  goto -> bb1157
  using: 
bb1157:
  _2667 = _8
  using: _8@Phi(bb1157)
  _2668 = const 256_i32
  using: 
  _2666 = Le(move _2667, move _2668)
  using: _2667@Mir(bb1157[0]), _2668@Mir(bb1157[1])
  switchInt(move _2666) -> [0: bb1165, otherwise: bb1158]
  using: _2666@Mir(bb1157[2])
bb1158:
  _2673 = _8
  using: _8@Phi(bb1157)
  _2674 = const 1_i32
  using: 
  _2675 = CheckedSub(_2673, _2674)
  using: _2673@Mir(bb1158[0]), _2674@Mir(bb1158[1])
  assert(!move (_2675.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2673, move _2674) -> bb1159
  using: _2675@Entry, _2673@Entry, _2674@Entry
bb1159:
  _2672 = move (_2675.0: i32)
  using: _2675@Mir(bb1158[2])
  _2671 = move _2672 as usize (IntToInt)
  using: _2672@Mir(bb1159[0])
  _2676 = const 257_usize
  using: 
  _2677 = Lt(_2671, _2676)
  using: _2671@Mir(bb1159[1]), _2676@Mir(bb1159[2])
  assert(move _2677, "index out of bounds: the length is {} but the index is {}", move _2676, _2671) -> bb1160
  using: _2677@Entry, _2676@Entry, _2671@Entry
bb1160:
  _2670 = ((*_1).18: [i32; 257])[_2671]
  using: _1@Phi(bb1157), _2671@Mir(bb1159[1])
  _2680 = _8
  using: _8@Phi(bb1157)
  _2679 = move _2680 as usize (IntToInt)
  using: _2680@Mir(bb1160[1])
  _2681 = const 257_usize
  using: 
  _2682 = Lt(_2679, _2681)
  using: _2679@Mir(bb1160[2]), _2681@Mir(bb1160[3])
  assert(move _2682, "index out of bounds: the length is {} but the index is {}", move _2681, _2679) -> bb1161
  using: _2682@Entry, _2681@Entry, _2679@Entry
bb1161:
  _2678 = ((*_1).18: [i32; 257])[_2679]
  using: _1@Phi(bb1157), _2679@Mir(bb1160[2])
  _2669 = Gt(move _2670, move _2678)
  using: _2670@Mir(bb1160[0]), _2678@Mir(bb1161[0])
  switchInt(move _2669) -> [0: bb1163, otherwise: bb1162]
  using: _2669@Mir(bb1161[1])
bb1162:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1163:
  _2683 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1157)
  assert(!move (_2683.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1164
  using: _2683@Entry, _8@Entry
bb1164:
  _8 = move (_2683.0: i32)
  using: _2683@Mir(bb1163[0])
  goto -> bb1157
  using: 
bb1165:
  _2684 = const 0_i32
  using: 
  ((*_1).3: i32) = move _2684
  using: _1@Phi(bb1157), _2684@Mir(bb1165[0])
  _2685 = const 0_i32
  using: 
  ((*_1).2: u8) = move _2685 as u8 (IntToInt)
  using: _1@Phi(bb1157), _2685@Mir(bb1165[2])
  _2686 = const 4294967295_i64
  using: 
  ((*_1).25: u32) = move _2686 as u32 (IntToInt)
  using: _1@Phi(bb1157), _2686@Mir(bb1165[4])
  _2687 = const 2_i32
  using: 
  ((*_1).1: i32) = move _2687
  using: _1@Phi(bb1157), _2687@Mir(bb1165[6])
  _2689 = ((*_1).12: i32)
  using: _1@Phi(bb1157)
  _2690 = const 2_i32
  using: 
  _2688 = Ge(move _2689, move _2690)
  using: _2689@Mir(bb1165[8]), _2690@Mir(bb1165[9])
  switchInt(move _2688) -> [0: bb1167, otherwise: bb1166]
  using: _2688@Mir(bb1165[10])
bb1166:
  _2693 = const {alloc924: *mut *mut blocksort::__sFILE}
  using: 
  _2692 = (*_2693)
  using: _2693@Mir(bb1166[0])
  _2697 = const b"rt+rld\x00"
  using: 
  _2696 = &raw const (*_2697)
  using: _2697@Mir(bb1166[2])
  _2695 = move _2696 as *const u8 (Pointer(ArrayToPointer))
  using: _2696@Mir(bb1166[3])
  _2694 = move _2695 as *const i8 (PtrToPtr)
  using: _2695@Mir(bb1166[4])
  _2691 = decompress::fprintf(move _2692, move _2694) -> bb1167
  using: _2692@Mir(bb1166[1]), _2694@Mir(bb1166[5])
bb1167:
  _2698 = ((*_1).10: u8)
  using: _1@Phi(bb1157)
  switchInt(move _2698) -> [0: bb1264, otherwise: bb1168]
  using: _2698@Mir(bb1167[0])
bb1168:
  _8 = const 0_i32
  using: 
  goto -> bb1169
  using: 
bb1169:
  _2700 = _8
  using: _8@Phi(bb1169)
  _2701 = const 256_i32
  using: 
  _2699 = Le(move _2700, move _2701)
  using: _2700@Mir(bb1169[0]), _2701@Mir(bb1169[1])
  switchInt(move _2699) -> [0: bb1174, otherwise: bb1170]
  using: _2699@Mir(bb1169[2])
bb1170:
  _2704 = _8
  using: _8@Phi(bb1169)
  _2703 = move _2704 as usize (IntToInt)
  using: _2704@Mir(bb1170[0])
  _2705 = const 257_usize
  using: 
  _2706 = Lt(_2703, _2705)
  using: _2703@Mir(bb1170[1]), _2705@Mir(bb1170[2])
  assert(move _2706, "index out of bounds: the length is {} but the index is {}", move _2705, _2703) -> bb1171
  using: _2706@Entry, _2705@Entry, _2703@Entry
bb1171:
  _2702 = ((*_1).18: [i32; 257])[_2703]
  using: _1@Phi(bb1169), _2703@Mir(bb1170[1])
  _2708 = _8
  using: _8@Phi(bb1169)
  _2707 = move _2708 as usize (IntToInt)
  using: _2708@Mir(bb1171[1])
  _2709 = const 257_usize
  using: 
  _2710 = Lt(_2707, _2709)
  using: _2707@Mir(bb1171[2]), _2709@Mir(bb1171[3])
  assert(move _2710, "index out of bounds: the length is {} but the index is {}", move _2709, _2707) -> bb1172
  using: _2710@Entry, _2709@Entry, _2707@Entry
bb1172:
  ((*_1).19: [i32; 257])[_2707] = move _2702
  using: _1@Phi(bb1169), _2707@Mir(bb1171[2]), _2702@Mir(bb1171[0])
  _2711 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1169)
  assert(!move (_2711.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1173
  using: _2711@Entry, _8@Entry
bb1173:
  _8 = move (_2711.0: i32)
  using: _2711@Mir(bb1172[1])
  goto -> bb1169
  using: 
bb1174:
  _8 = const 0_i32
  using: 
  goto -> bb1175
  using: 
bb1175:
  _2713 = _8
  using: _8@Phi(bb1175)
  _2714 = _19
  using: _19@Phi(bb1150)
  _2712 = Lt(move _2713, move _2714)
  using: _2713@Mir(bb1175[0]), _2714@Mir(bb1175[1])
  switchInt(move _2712) -> [0: bb1199, otherwise: bb1176]
  using: _2712@Mir(bb1175[2])
bb1176:
  _2717 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1175)
  _2719 = _8
  using: _8@Phi(bb1175)
  _2718 = move _2719 as isize (IntToInt)
  using: _2719@Mir(bb1176[1])
  _2716 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2717, move _2718) -> bb1177
  using: _2717@Mir(bb1176[0]), _2718@Mir(bb1176[2])
bb1177:
  _2715 = (*_2716)
  using: _2716@Mir(bb1176[3])
  _3 = move _2715 as u8 (IntToInt)
  using: _2715@Mir(bb1177[0])
  _2723 = _3
  using: _3@Mir(bb1177[1])
  _2722 = move _2723 as usize (IntToInt)
  using: _2723@Mir(bb1177[2])
  _2724 = const 257_usize
  using: 
  _2725 = Lt(_2722, _2724)
  using: _2722@Mir(bb1177[3]), _2724@Mir(bb1177[4])
  assert(move _2725, "index out of bounds: the length is {} but the index is {}", move _2724, _2722) -> bb1178
  using: _2725@Entry, _2724@Entry, _2722@Entry
bb1178:
  _2721 = ((*_1).19: [i32; 257])[_2722]
  using: _1@Phi(bb1175), _2722@Mir(bb1177[3])
  _2726 = const 65535_i32
  using: 
  _2720 = BitAnd(move _2721, move _2726)
  using: _2721@Mir(bb1178[0]), _2726@Mir(bb1178[1])
  _2728 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1175)
  _2730 = _8
  using: _8@Phi(bb1175)
  _2729 = move _2730 as isize (IntToInt)
  using: _2730@Mir(bb1178[4])
  _2727 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2728, move _2729) -> bb1179
  using: _2728@Mir(bb1178[3]), _2729@Mir(bb1178[5])
bb1179:
  (*_2727) = move _2720 as u16 (IntToInt)
  using: _2727@Mir(bb1178[6]), _2720@Mir(bb1178[2])
  _2733 = _8
  using: _8@Phi(bb1175)
  _2734 = const 1_i32
  using: 
  _2732 = BitAnd(move _2733, move _2734)
  using: _2733@Mir(bb1179[1]), _2734@Mir(bb1179[2])
  _2735 = const 0_i32
  using: 
  _2731 = Eq(move _2732, move _2735)
  using: _2732@Mir(bb1179[3]), _2735@Mir(bb1179[4])
  switchInt(move _2731) -> [0: bb1187, otherwise: bb1180]
  using: _2731@Mir(bb1179[5])
bb1180:
  _2741 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1175)
  _2744 = _8
  using: _8@Phi(bb1175)
  _2745 = const 1_i32
  using: 
  _2746 = CheckedShr(_2744, _2745)
  using: _2744@Mir(bb1180[1]), _2745@Mir(bb1180[2])
  assert(!move (_2746.1: bool), "attempt to shift right by `{}`, which would overflow", move _2745) -> bb1181
  using: _2746@Entry, _2744@Entry, _2745@Entry
bb1181:
  _2743 = move (_2746.0: i32)
  using: _2746@Mir(bb1180[3])
  _2742 = move _2743 as isize (IntToInt)
  using: _2743@Mir(bb1181[0])
  _2740 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2741, move _2742) -> bb1182
  using: _2741@Mir(bb1180[0]), _2742@Mir(bb1181[1])
bb1182:
  _2739 = (*_2740)
  using: _2740@Mir(bb1181[2])
  _2738 = move _2739 as i32 (IntToInt)
  using: _2739@Mir(bb1182[0])
  _2747 = const 240_i32
  using: 
  _2737 = BitAnd(move _2738, move _2747)
  using: _2738@Mir(bb1182[1]), _2747@Mir(bb1182[2])
  _2751 = _3
  using: _3@Mir(bb1177[1])
  _2750 = move _2751 as usize (IntToInt)
  using: _2751@Mir(bb1182[4])
  _2752 = const 257_usize
  using: 
  _2753 = Lt(_2750, _2752)
  using: _2750@Mir(bb1182[5]), _2752@Mir(bb1182[6])
  assert(move _2753, "index out of bounds: the length is {} but the index is {}", move _2752, _2750) -> bb1183
  using: _2753@Entry, _2752@Entry, _2750@Entry
bb1183:
  _2749 = ((*_1).19: [i32; 257])[_2750]
  using: _1@Phi(bb1175), _2750@Mir(bb1182[5])
  _2754 = const 16_i32
  using: 
  _2755 = CheckedShr(_2749, _2754)
  using: _2749@Mir(bb1183[0]), _2754@Mir(bb1183[1])
  assert(!move (_2755.1: bool), "attempt to shift right by `{}`, which would overflow", move _2754) -> bb1184
  using: _2755@Entry, _2749@Entry, _2754@Entry
bb1184:
  _2748 = move (_2755.0: i32)
  using: _2755@Mir(bb1183[2])
  _2736 = BitOr(move _2737, move _2748)
  using: _2737@Mir(bb1182[3]), _2748@Mir(bb1184[0])
  _2757 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1175)
  _2760 = _8
  using: _8@Phi(bb1175)
  _2761 = const 1_i32
  using: 
  _2762 = CheckedShr(_2760, _2761)
  using: _2760@Mir(bb1184[3]), _2761@Mir(bb1184[4])
  assert(!move (_2762.1: bool), "attempt to shift right by `{}`, which would overflow", move _2761) -> bb1185
  using: _2762@Entry, _2760@Entry, _2761@Entry
bb1185:
  _2759 = move (_2762.0: i32)
  using: _2762@Mir(bb1184[5])
  _2758 = move _2759 as isize (IntToInt)
  using: _2759@Mir(bb1185[0])
  _2756 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2757, move _2758) -> bb1186
  using: _2757@Mir(bb1184[2]), _2758@Mir(bb1185[1])
bb1186:
  (*_2756) = move _2736 as u8 (IntToInt)
  using: _2756@Mir(bb1185[2]), _2736@Mir(bb1184[1])
  goto -> bb1195
  using: 
bb1187:
  _2768 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1175)
  _2771 = _8
  using: _8@Phi(bb1175)
  _2772 = const 1_i32
  using: 
  _2773 = CheckedShr(_2771, _2772)
  using: _2771@Mir(bb1187[1]), _2772@Mir(bb1187[2])
  assert(!move (_2773.1: bool), "attempt to shift right by `{}`, which would overflow", move _2772) -> bb1188
  using: _2773@Entry, _2771@Entry, _2772@Entry
bb1188:
  _2770 = move (_2773.0: i32)
  using: _2773@Mir(bb1187[3])
  _2769 = move _2770 as isize (IntToInt)
  using: _2770@Mir(bb1188[0])
  _2767 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2768, move _2769) -> bb1189
  using: _2768@Mir(bb1187[0]), _2769@Mir(bb1188[1])
bb1189:
  _2766 = (*_2767)
  using: _2767@Mir(bb1188[2])
  _2765 = move _2766 as i32 (IntToInt)
  using: _2766@Mir(bb1189[0])
  _2774 = const 15_i32
  using: 
  _2764 = BitAnd(move _2765, move _2774)
  using: _2765@Mir(bb1189[1]), _2774@Mir(bb1189[2])
  _2779 = _3
  using: _3@Mir(bb1177[1])
  _2778 = move _2779 as usize (IntToInt)
  using: _2779@Mir(bb1189[4])
  _2780 = const 257_usize
  using: 
  _2781 = Lt(_2778, _2780)
  using: _2778@Mir(bb1189[5]), _2780@Mir(bb1189[6])
  assert(move _2781, "index out of bounds: the length is {} but the index is {}", move _2780, _2778) -> bb1190
  using: _2781@Entry, _2780@Entry, _2778@Entry
bb1190:
  _2777 = ((*_1).19: [i32; 257])[_2778]
  using: _1@Phi(bb1175), _2778@Mir(bb1189[5])
  _2782 = const 16_i32
  using: 
  _2783 = CheckedShr(_2777, _2782)
  using: _2777@Mir(bb1190[0]), _2782@Mir(bb1190[1])
  assert(!move (_2783.1: bool), "attempt to shift right by `{}`, which would overflow", move _2782) -> bb1191
  using: _2783@Entry, _2777@Entry, _2782@Entry
bb1191:
  _2776 = move (_2783.0: i32)
  using: _2783@Mir(bb1190[2])
  _2784 = const 4_i32
  using: 
  _2785 = CheckedShl(_2776, _2784)
  using: _2776@Mir(bb1191[0]), _2784@Mir(bb1191[1])
  assert(!move (_2785.1: bool), "attempt to shift left by `{}`, which would overflow", move _2784) -> bb1192
  using: _2785@Entry, _2776@Entry, _2784@Entry
bb1192:
  _2775 = move (_2785.0: i32)
  using: _2785@Mir(bb1191[2])
  _2763 = BitOr(move _2764, move _2775)
  using: _2764@Mir(bb1189[3]), _2775@Mir(bb1192[0])
  _2787 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1175)
  _2790 = _8
  using: _8@Phi(bb1175)
  _2791 = const 1_i32
  using: 
  _2792 = CheckedShr(_2790, _2791)
  using: _2790@Mir(bb1192[3]), _2791@Mir(bb1192[4])
  assert(!move (_2792.1: bool), "attempt to shift right by `{}`, which would overflow", move _2791) -> bb1193
  using: _2792@Entry, _2790@Entry, _2791@Entry
bb1193:
  _2789 = move (_2792.0: i32)
  using: _2792@Mir(bb1192[5])
  _2788 = move _2789 as isize (IntToInt)
  using: _2789@Mir(bb1193[0])
  _2786 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2787, move _2788) -> bb1194
  using: _2787@Mir(bb1192[2]), _2788@Mir(bb1193[1])
bb1194:
  (*_2786) = move _2763 as u8 (IntToInt)
  using: _2786@Mir(bb1193[2]), _2763@Mir(bb1192[1])
  goto -> bb1195
  using: 
bb1195:
  _2794 = _3
  using: _3@Phi(bb1195)
  _2793 = move _2794 as usize (IntToInt)
  using: _2794@Mir(bb1195[0])
  _2795 = const 257_usize
  using: 
  _2796 = Lt(_2793, _2795)
  using: _2793@Mir(bb1195[1]), _2795@Mir(bb1195[2])
  assert(move _2796, "index out of bounds: the length is {} but the index is {}", move _2795, _2793) -> bb1196
  using: _2796@Entry, _2795@Entry, _2793@Entry
bb1196:
  _2797 = CheckedAdd(((*_1).19: [i32; 257])[_2793], const 1_i32)
  using: _1@Phi(bb1195), _2793@Mir(bb1195[1])
  assert(!move (_2797.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).19: [i32; 257])[_2793], const 1_i32) -> bb1197
  using: _2797@Entry, _1@Entry, _2793@Entry
bb1197:
  ((*_1).19: [i32; 257])[_2793] = move (_2797.0: i32)
  using: _1@Phi(bb1195), _2793@Mir(bb1195[1]), _2797@Mir(bb1196[0])
  _2798 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1195)
  assert(!move (_2798.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1198
  using: _2798@Entry, _8@Entry
bb1198:
  _8 = move (_2798.0: i32)
  using: _2798@Mir(bb1197[1])
  goto -> bb1175
  using: 
bb1199:
  _2799 = ((*_1).13: i32)
  using: _1@Phi(bb1195)
  _8 = move _2799
  using: _2799@Mir(bb1199[0])
  _2804 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1195)
  _2806 = _8
  using: _8@Mir(bb1199[1])
  _2805 = move _2806 as isize (IntToInt)
  using: _2806@Mir(bb1199[3])
  _2803 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2804, move _2805) -> bb1200
  using: _2804@Mir(bb1199[2]), _2805@Mir(bb1199[4])
bb1200:
  _2802 = (*_2803)
  using: _2803@Mir(bb1199[5])
  _2801 = move _2802 as u32 (IntToInt)
  using: _2802@Mir(bb1200[0])
  _2813 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1195)
  _2816 = _8
  using: _8@Mir(bb1199[1])
  _2817 = const 1_i32
  using: 
  _2818 = CheckedShr(_2816, _2817)
  using: _2816@Mir(bb1200[3]), _2817@Mir(bb1200[4])
  assert(!move (_2818.1: bool), "attempt to shift right by `{}`, which would overflow", move _2817) -> bb1201
  using: _2818@Entry, _2816@Entry, _2817@Entry
bb1201:
  _2815 = move (_2818.0: i32)
  using: _2818@Mir(bb1200[5])
  _2814 = move _2815 as isize (IntToInt)
  using: _2815@Mir(bb1201[0])
  _2812 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2813, move _2814) -> bb1202
  using: _2813@Mir(bb1200[2]), _2814@Mir(bb1201[1])
bb1202:
  _2811 = (*_2812)
  using: _2812@Mir(bb1201[2])
  _2810 = move _2811 as u32 (IntToInt)
  using: _2811@Mir(bb1202[0])
  _2821 = _8
  using: _8@Mir(bb1199[1])
  _2822 = const 2_i32
  using: 
  _2823 = CheckedShl(_2821, _2822)
  using: _2821@Mir(bb1202[2]), _2822@Mir(bb1202[3])
  assert(!move (_2823.1: bool), "attempt to shift left by `{}`, which would overflow", move _2822) -> bb1203
  using: _2823@Entry, _2821@Entry, _2822@Entry
bb1203:
  _2820 = move (_2823.0: i32)
  using: _2823@Mir(bb1202[4])
  _2824 = const 4_i32
  using: 
  _2819 = BitAnd(move _2820, move _2824)
  using: _2820@Mir(bb1203[0]), _2824@Mir(bb1203[1])
  _2825 = CheckedShr(_2810, _2819)
  using: _2810@Mir(bb1202[1]), _2819@Mir(bb1203[2])
  assert(!move (_2825.1: bool), "attempt to shift right by `{}`, which would overflow", move _2819) -> bb1204
  using: _2825@Entry, _2810@Entry, _2819@Entry
bb1204:
  _2809 = move (_2825.0: u32)
  using: _2825@Mir(bb1203[3])
  _2826 = const 15_u32
  using: 
  _2808 = BitAnd(move _2809, move _2826)
  using: _2809@Mir(bb1204[0]), _2826@Mir(bb1204[1])
  _2827 = const 16_i32
  using: 
  _2828 = CheckedShl(_2808, _2827)
  using: _2808@Mir(bb1204[2]), _2827@Mir(bb1204[3])
  assert(!move (_2828.1: bool), "attempt to shift left by `{}`, which would overflow", move _2827) -> bb1205
  using: _2828@Entry, _2808@Entry, _2827@Entry
bb1205:
  _2807 = move (_2828.0: u32)
  using: _2828@Mir(bb1204[4])
  _2800 = BitOr(move _2801, move _2807)
  using: _2801@Mir(bb1200[1]), _2807@Mir(bb1205[0])
  _9 = move _2800 as i32 (IntToInt)
  using: _2800@Mir(bb1205[1])
  goto -> bb1206
  using: 
bb1206:
  _2834 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1206)
  _2836 = _9
  using: _9@Phi(bb1206)
  _2835 = move _2836 as isize (IntToInt)
  using: _2836@Mir(bb1206[1])
  _2833 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2834, move _2835) -> bb1207
  using: _2834@Mir(bb1206[0]), _2835@Mir(bb1206[2])
bb1207:
  _2832 = (*_2833)
  using: _2833@Mir(bb1206[3])
  _2831 = move _2832 as u32 (IntToInt)
  using: _2832@Mir(bb1207[0])
  _2843 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1206)
  _2846 = _9
  using: _9@Phi(bb1206)
  _2847 = const 1_i32
  using: 
  _2848 = CheckedShr(_2846, _2847)
  using: _2846@Mir(bb1207[3]), _2847@Mir(bb1207[4])
  assert(!move (_2848.1: bool), "attempt to shift right by `{}`, which would overflow", move _2847) -> bb1208
  using: _2848@Entry, _2846@Entry, _2847@Entry
bb1208:
  _2845 = move (_2848.0: i32)
  using: _2848@Mir(bb1207[5])
  _2844 = move _2845 as isize (IntToInt)
  using: _2845@Mir(bb1208[0])
  _2842 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2843, move _2844) -> bb1209
  using: _2843@Mir(bb1207[2]), _2844@Mir(bb1208[1])
bb1209:
  _2841 = (*_2842)
  using: _2842@Mir(bb1208[2])
  _2840 = move _2841 as u32 (IntToInt)
  using: _2841@Mir(bb1209[0])
  _2851 = _9
  using: _9@Phi(bb1206)
  _2852 = const 2_i32
  using: 
  _2853 = CheckedShl(_2851, _2852)
  using: _2851@Mir(bb1209[2]), _2852@Mir(bb1209[3])
  assert(!move (_2853.1: bool), "attempt to shift left by `{}`, which would overflow", move _2852) -> bb1210
  using: _2853@Entry, _2851@Entry, _2852@Entry
bb1210:
  _2850 = move (_2853.0: i32)
  using: _2853@Mir(bb1209[4])
  _2854 = const 4_i32
  using: 
  _2849 = BitAnd(move _2850, move _2854)
  using: _2850@Mir(bb1210[0]), _2854@Mir(bb1210[1])
  _2855 = CheckedShr(_2840, _2849)
  using: _2840@Mir(bb1209[1]), _2849@Mir(bb1210[2])
  assert(!move (_2855.1: bool), "attempt to shift right by `{}`, which would overflow", move _2849) -> bb1211
  using: _2855@Entry, _2840@Entry, _2849@Entry
bb1211:
  _2839 = move (_2855.0: u32)
  using: _2855@Mir(bb1210[3])
  _2856 = const 15_u32
  using: 
  _2838 = BitAnd(move _2839, move _2856)
  using: _2839@Mir(bb1211[0]), _2856@Mir(bb1211[1])
  _2857 = const 16_i32
  using: 
  _2858 = CheckedShl(_2838, _2857)
  using: _2838@Mir(bb1211[2]), _2857@Mir(bb1211[3])
  assert(!move (_2858.1: bool), "attempt to shift left by `{}`, which would overflow", move _2857) -> bb1212
  using: _2858@Entry, _2838@Entry, _2857@Entry
bb1212:
  _2837 = move (_2858.0: u32)
  using: _2858@Mir(bb1211[4])
  _2830 = BitOr(move _2831, move _2837)
  using: _2831@Mir(bb1207[1]), _2837@Mir(bb1212[0])
  _2829 = move _2830 as i32 (IntToInt)
  using: _2830@Mir(bb1212[1])
  _2860 = _8
  using: _8@Phi(bb1206)
  _2861 = const 65535_i32
  using: 
  _2859 = BitAnd(move _2860, move _2861)
  using: _2860@Mir(bb1212[3]), _2861@Mir(bb1212[4])
  _2863 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1206)
  _2865 = _9
  using: _9@Phi(bb1206)
  _2864 = move _2865 as isize (IntToInt)
  using: _2865@Mir(bb1212[7])
  _2862 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2863, move _2864) -> bb1213
  using: _2863@Mir(bb1212[6]), _2864@Mir(bb1212[8])
bb1213:
  (*_2862) = move _2859 as u16 (IntToInt)
  using: _2862@Mir(bb1212[9]), _2859@Mir(bb1212[5])
  _2868 = _9
  using: _9@Phi(bb1206)
  _2869 = const 1_i32
  using: 
  _2867 = BitAnd(move _2868, move _2869)
  using: _2868@Mir(bb1213[1]), _2869@Mir(bb1213[2])
  _2870 = const 0_i32
  using: 
  _2866 = Eq(move _2867, move _2870)
  using: _2867@Mir(bb1213[3]), _2870@Mir(bb1213[4])
  switchInt(move _2866) -> [0: bb1220, otherwise: bb1214]
  using: _2866@Mir(bb1213[5])
bb1214:
  _2876 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1206)
  _2879 = _9
  using: _9@Phi(bb1206)
  _2880 = const 1_i32
  using: 
  _2881 = CheckedShr(_2879, _2880)
  using: _2879@Mir(bb1214[1]), _2880@Mir(bb1214[2])
  assert(!move (_2881.1: bool), "attempt to shift right by `{}`, which would overflow", move _2880) -> bb1215
  using: _2881@Entry, _2879@Entry, _2880@Entry
bb1215:
  _2878 = move (_2881.0: i32)
  using: _2881@Mir(bb1214[3])
  _2877 = move _2878 as isize (IntToInt)
  using: _2878@Mir(bb1215[0])
  _2875 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2876, move _2877) -> bb1216
  using: _2876@Mir(bb1214[0]), _2877@Mir(bb1215[1])
bb1216:
  _2874 = (*_2875)
  using: _2875@Mir(bb1215[2])
  _2873 = move _2874 as i32 (IntToInt)
  using: _2874@Mir(bb1216[0])
  _2882 = const 240_i32
  using: 
  _2872 = BitAnd(move _2873, move _2882)
  using: _2873@Mir(bb1216[1]), _2882@Mir(bb1216[2])
  _2884 = _8
  using: _8@Phi(bb1206)
  _2885 = const 16_i32
  using: 
  _2886 = CheckedShr(_2884, _2885)
  using: _2884@Mir(bb1216[4]), _2885@Mir(bb1216[5])
  assert(!move (_2886.1: bool), "attempt to shift right by `{}`, which would overflow", move _2885) -> bb1217
  using: _2886@Entry, _2884@Entry, _2885@Entry
bb1217:
  _2883 = move (_2886.0: i32)
  using: _2886@Mir(bb1216[6])
  _2871 = BitOr(move _2872, move _2883)
  using: _2872@Mir(bb1216[3]), _2883@Mir(bb1217[0])
  _2888 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1206)
  _2891 = _9
  using: _9@Phi(bb1206)
  _2892 = const 1_i32
  using: 
  _2893 = CheckedShr(_2891, _2892)
  using: _2891@Mir(bb1217[3]), _2892@Mir(bb1217[4])
  assert(!move (_2893.1: bool), "attempt to shift right by `{}`, which would overflow", move _2892) -> bb1218
  using: _2893@Entry, _2891@Entry, _2892@Entry
bb1218:
  _2890 = move (_2893.0: i32)
  using: _2893@Mir(bb1217[5])
  _2889 = move _2890 as isize (IntToInt)
  using: _2890@Mir(bb1218[0])
  _2887 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2888, move _2889) -> bb1219
  using: _2888@Mir(bb1217[2]), _2889@Mir(bb1218[1])
bb1219:
  (*_2887) = move _2871 as u8 (IntToInt)
  using: _2887@Mir(bb1218[2]), _2871@Mir(bb1217[1])
  goto -> bb1227
  using: 
bb1220:
  _2899 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1206)
  _2902 = _9
  using: _9@Phi(bb1206)
  _2903 = const 1_i32
  using: 
  _2904 = CheckedShr(_2902, _2903)
  using: _2902@Mir(bb1220[1]), _2903@Mir(bb1220[2])
  assert(!move (_2904.1: bool), "attempt to shift right by `{}`, which would overflow", move _2903) -> bb1221
  using: _2904@Entry, _2902@Entry, _2903@Entry
bb1221:
  _2901 = move (_2904.0: i32)
  using: _2904@Mir(bb1220[3])
  _2900 = move _2901 as isize (IntToInt)
  using: _2901@Mir(bb1221[0])
  _2898 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2899, move _2900) -> bb1222
  using: _2899@Mir(bb1220[0]), _2900@Mir(bb1221[1])
bb1222:
  _2897 = (*_2898)
  using: _2898@Mir(bb1221[2])
  _2896 = move _2897 as i32 (IntToInt)
  using: _2897@Mir(bb1222[0])
  _2905 = const 15_i32
  using: 
  _2895 = BitAnd(move _2896, move _2905)
  using: _2896@Mir(bb1222[1]), _2905@Mir(bb1222[2])
  _2908 = _8
  using: _8@Phi(bb1206)
  _2909 = const 16_i32
  using: 
  _2910 = CheckedShr(_2908, _2909)
  using: _2908@Mir(bb1222[4]), _2909@Mir(bb1222[5])
  assert(!move (_2910.1: bool), "attempt to shift right by `{}`, which would overflow", move _2909) -> bb1223
  using: _2910@Entry, _2908@Entry, _2909@Entry
bb1223:
  _2907 = move (_2910.0: i32)
  using: _2910@Mir(bb1222[6])
  _2911 = const 4_i32
  using: 
  _2912 = CheckedShl(_2907, _2911)
  using: _2907@Mir(bb1223[0]), _2911@Mir(bb1223[1])
  assert(!move (_2912.1: bool), "attempt to shift left by `{}`, which would overflow", move _2911) -> bb1224
  using: _2912@Entry, _2907@Entry, _2911@Entry
bb1224:
  _2906 = move (_2912.0: i32)
  using: _2912@Mir(bb1223[2])
  _2894 = BitOr(move _2895, move _2906)
  using: _2895@Mir(bb1222[3]), _2906@Mir(bb1224[0])
  _2914 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1206)
  _2917 = _9
  using: _9@Phi(bb1206)
  _2918 = const 1_i32
  using: 
  _2919 = CheckedShr(_2917, _2918)
  using: _2917@Mir(bb1224[3]), _2918@Mir(bb1224[4])
  assert(!move (_2919.1: bool), "attempt to shift right by `{}`, which would overflow", move _2918) -> bb1225
  using: _2919@Entry, _2917@Entry, _2918@Entry
bb1225:
  _2916 = move (_2919.0: i32)
  using: _2919@Mir(bb1224[5])
  _2915 = move _2916 as isize (IntToInt)
  using: _2916@Mir(bb1225[0])
  _2913 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2914, move _2915) -> bb1226
  using: _2914@Mir(bb1224[2]), _2915@Mir(bb1225[1])
bb1226:
  (*_2913) = move _2894 as u8 (IntToInt)
  using: _2913@Mir(bb1225[2]), _2894@Mir(bb1224[1])
  goto -> bb1227
  using: 
bb1227:
  _2920 = _9
  using: _9@Phi(bb1227)
  _8 = move _2920
  using: _2920@Mir(bb1227[0])
  _2921 = _2829
  using: _2829@Mir(bb1212[2])
  _9 = move _2921
  using: _2921@Mir(bb1227[2])
  _2924 = _8
  using: _8@Mir(bb1227[1])
  _2925 = ((*_1).13: i32)
  using: _1@Phi(bb1227)
  _2923 = Ne(move _2924, move _2925)
  using: _2924@Mir(bb1227[4]), _2925@Mir(bb1227[5])
  _2922 = Not(move _2923)
  using: _2923@Mir(bb1227[6])
  switchInt(move _2922) -> [0: bb1206, otherwise: bb1228]
  using: _2922@Mir(bb1227[7])
bb1228:
  _2926 = ((*_1).13: i32)
  using: _1@Phi(bb1227)
  ((*_1).14: u32) = move _2926 as u32 (IntToInt)
  using: _1@Phi(bb1227), _2926@Mir(bb1228[0])
  _2927 = const 0_i32
  using: 
  ((*_1).17: i32) = move _2927
  using: _1@Phi(bb1227), _2927@Mir(bb1228[2])
  _2928 = ((*_1).4: u8)
  using: _1@Phi(bb1227)
  switchInt(move _2928) -> [0: bb1230, otherwise: bb1229]
  using: _2928@Mir(bb1228[4])
bb1229:
  _2929 = const 0_i32
  using: 
  ((*_1).5: i32) = move _2929
  using: _1@Phi(bb1227), _2929@Mir(bb1229[0])
  _2930 = const 0_i32
  using: 
  ((*_1).6: i32) = move _2930
  using: _1@Phi(bb1227), _2930@Mir(bb1229[2])
  _2932 = ((*_1).14: u32)
  using: _1@Phi(bb1227)
  _2934 = const 100000_u32
  using: 
  _2936 = ((*_1).9: i32)
  using: _1@Phi(bb1227)
  _2935 = move _2936 as u32 (IntToInt)
  using: _2936@Mir(bb1229[6])
  _2933 = core::num::<impl u32>::wrapping_mul(move _2934, move _2935) -> bb1231
  using: _2934@Mir(bb1229[5]), _2935@Mir(bb1229[7])
bb1230:
  _2992 = ((*_1).14: u32)
  using: _1@Phi(bb1247)
  _2994 = const 100000_u32
  using: 
  _2996 = ((*_1).9: i32)
  using: _1@Phi(bb1247)
  _2995 = move _2996 as u32 (IntToInt)
  using: _2996@Mir(bb1230[2])
  _2993 = core::num::<impl u32>::wrapping_mul(move _2994, move _2995) -> bb1252
  using: _2994@Mir(bb1230[1]), _2995@Mir(bb1230[3])
bb1231:
  _2931 = Ge(move _2932, move _2933)
  using: _2932@Mir(bb1229[4]), _2933@Mir(bb1229[8])
  switchInt(move _2931) -> [0: bb1233, otherwise: bb1232]
  using: _2931@Mir(bb1231[0])
bb1232:
  _0 = const 1_i32
  using: 
  goto -> bb1477
  using: 
bb1233:
  _2939 = ((*_1).14: u32)
  using: _1@Phi(bb1227)
  _2938 = move _2939 as i32 (IntToInt)
  using: _2939@Mir(bb1233[0])
  _2942 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb1227)
  _2941 = move _2942 as &mut [i32] (Pointer(Unsize))
  using: _2942@Mir(bb1233[2])
  _2940 = core::slice::<impl [i32]>::as_mut_ptr(move _2941) -> bb1234
  using: _2941@Mir(bb1233[3])
bb1234:
  _2937 = bzlib::BZ2_indexIntoF(move _2938, move _2940) -> bb1235
  using: _2938@Mir(bb1233[1]), _2940@Mir(bb1233[4])
bb1235:
  ((*_1).15: i32) = move _2937
  using: _1@Phi(bb1227), _2937@Mir(bb1234[0])
  _2946 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1227)
  _2948 = ((*_1).14: u32)
  using: _1@Phi(bb1227)
  _2947 = move _2948 as isize (IntToInt)
  using: _2948@Mir(bb1235[2])
  _2945 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _2946, move _2947) -> bb1236
  using: _2946@Mir(bb1235[1]), _2947@Mir(bb1235[3])
bb1236:
  _2944 = (*_2945)
  using: _2945@Mir(bb1235[4])
  _2943 = move _2944 as u32 (IntToInt)
  using: _2944@Mir(bb1236[0])
  _2955 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1227)
  _2958 = ((*_1).14: u32)
  using: _1@Phi(bb1227)
  _2959 = const 1_i32
  using: 
  _2960 = CheckedShr(_2958, _2959)
  using: _2958@Mir(bb1236[3]), _2959@Mir(bb1236[4])
  assert(!move (_2960.1: bool), "attempt to shift right by `{}`, which would overflow", move _2959) -> bb1237
  using: _2960@Entry, _2958@Entry, _2959@Entry
bb1237:
  _2957 = move (_2960.0: u32)
  using: _2960@Mir(bb1236[5])
  _2956 = move _2957 as isize (IntToInt)
  using: _2957@Mir(bb1237[0])
  _2954 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _2955, move _2956) -> bb1238
  using: _2955@Mir(bb1236[2]), _2956@Mir(bb1237[1])
bb1238:
  _2953 = (*_2954)
  using: _2954@Mir(bb1237[2])
  _2952 = move _2953 as u32 (IntToInt)
  using: _2953@Mir(bb1238[0])
  _2963 = ((*_1).14: u32)
  using: _1@Phi(bb1227)
  _2964 = const 2_i32
  using: 
  _2965 = CheckedShl(_2963, _2964)
  using: _2963@Mir(bb1238[2]), _2964@Mir(bb1238[3])
  assert(!move (_2965.1: bool), "attempt to shift left by `{}`, which would overflow", move _2964) -> bb1239
  using: _2965@Entry, _2963@Entry, _2964@Entry
bb1239:
  _2962 = move (_2965.0: u32)
  using: _2965@Mir(bb1238[4])
  _2966 = const 4_u32
  using: 
  _2961 = BitAnd(move _2962, move _2966)
  using: _2962@Mir(bb1239[0]), _2966@Mir(bb1239[1])
  _2967 = CheckedShr(_2952, _2961)
  using: _2952@Mir(bb1238[1]), _2961@Mir(bb1239[2])
  assert(!move (_2967.1: bool), "attempt to shift right by `{}`, which would overflow", move _2961) -> bb1240
  using: _2967@Entry, _2952@Entry, _2961@Entry
bb1240:
  _2951 = move (_2967.0: u32)
  using: _2967@Mir(bb1239[3])
  _2968 = const 15_u32
  using: 
  _2950 = BitAnd(move _2951, move _2968)
  using: _2951@Mir(bb1240[0]), _2968@Mir(bb1240[1])
  _2969 = const 16_i32
  using: 
  _2970 = CheckedShl(_2950, _2969)
  using: _2950@Mir(bb1240[2]), _2969@Mir(bb1240[3])
  assert(!move (_2970.1: bool), "attempt to shift left by `{}`, which would overflow", move _2969) -> bb1241
  using: _2970@Entry, _2950@Entry, _2969@Entry
bb1241:
  _2949 = move (_2970.0: u32)
  using: _2970@Mir(bb1240[4])
  ((*_1).14: u32) = BitOr(move _2943, move _2949)
  using: _1@Phi(bb1227), _2943@Mir(bb1236[1]), _2949@Mir(bb1241[0])
  _2971 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1227)
  assert(!move (_2971.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb1242
  using: _2971@Entry, _1@Entry
bb1242:
  ((*_1).17: i32) = move (_2971.0: i32)
  using: _1@Phi(bb1227), _2971@Mir(bb1241[2])
  _2973 = ((*_1).5: i32)
  using: _1@Phi(bb1227)
  _2974 = const 0_i32
  using: 
  _2972 = Eq(move _2973, move _2974)
  using: _2973@Mir(bb1242[1]), _2974@Mir(bb1242[2])
  switchInt(move _2972) -> [0: bb1247, otherwise: bb1243]
  using: _2972@Mir(bb1242[3])
bb1243:
  _2976 = const {alloc925: *mut [i32; 512]}
  using: 
  _2978 = ((*_1).6: i32)
  using: _1@Phi(bb1227)
  _2977 = move _2978 as usize (IntToInt)
  using: _2978@Mir(bb1243[1])
  _2979 = const 512_usize
  using: 
  _2980 = Lt(_2977, _2979)
  using: _2977@Mir(bb1243[2]), _2979@Mir(bb1243[3])
  assert(move _2980, "index out of bounds: the length is {} but the index is {}", move _2979, _2977) -> bb1244
  using: _2980@Entry, _2979@Entry, _2977@Entry
bb1244:
  _2975 = (*_2976)[_2977]
  using: _2976@Mir(bb1243[0]), _2977@Mir(bb1243[2])
  ((*_1).5: i32) = move _2975
  using: _1@Phi(bb1227), _2975@Mir(bb1244[0])
  _2981 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb1227)
  assert(!move (_2981.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb1245
  using: _2981@Entry, _1@Entry
bb1245:
  ((*_1).6: i32) = move (_2981.0: i32)
  using: _1@Phi(bb1227), _2981@Mir(bb1244[2])
  _2983 = ((*_1).6: i32)
  using: _1@Phi(bb1227)
  _2984 = const 512_i32
  using: 
  _2982 = Eq(move _2983, move _2984)
  using: _2983@Mir(bb1245[1]), _2984@Mir(bb1245[2])
  switchInt(move _2982) -> [0: bb1247, otherwise: bb1246]
  using: _2982@Mir(bb1245[3])
bb1246:
  _2985 = const 0_i32
  using: 
  ((*_1).6: i32) = move _2985
  using: _1@Phi(bb1227), _2985@Mir(bb1246[0])
  goto -> bb1247
  using: 
bb1247:
  _2986 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb1247)
  assert(!move (_2986.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb1248
  using: _2986@Entry, _1@Entry
bb1248:
  ((*_1).5: i32) = move (_2986.0: i32)
  using: _1@Phi(bb1247), _2986@Mir(bb1247[0])
  _2989 = ((*_1).5: i32)
  using: _1@Phi(bb1247)
  _2990 = const 1_i32
  using: 
  _2988 = Eq(move _2989, move _2990)
  using: _2989@Mir(bb1248[1]), _2990@Mir(bb1248[2])
  switchInt(move _2988) -> [0: bb1250, otherwise: bb1249]
  using: _2988@Mir(bb1248[3])
bb1249:
  _2987 = const 1_i32
  using: 
  goto -> bb1251
  using: 
bb1250:
  _2987 = const 0_i32
  using: 
  goto -> bb1251
  using: 
bb1251:
  ((*_1).15: i32) = BitXor(((*_1).15: i32), move _2987)
  using: _1@Phi(bb1247), _1@Phi(bb1247), _2987@Phi(bb1251)
  goto -> bb1300
  using: 
bb1252:
  _2991 = Ge(move _2992, move _2993)
  using: _2992@Mir(bb1230[0]), _2993@Mir(bb1230[4])
  switchInt(move _2991) -> [0: bb1254, otherwise: bb1253]
  using: _2991@Mir(bb1252[0])
bb1253:
  _0 = const 1_i32
  using: 
  goto -> bb1477
  using: 
bb1254:
  _2999 = ((*_1).14: u32)
  using: _1@Phi(bb1247)
  _2998 = move _2999 as i32 (IntToInt)
  using: _2999@Mir(bb1254[0])
  _3002 = &mut ((*_1).18: [i32; 257])
  using: _1@Phi(bb1247)
  _3001 = move _3002 as &mut [i32] (Pointer(Unsize))
  using: _3002@Mir(bb1254[2])
  _3000 = core::slice::<impl [i32]>::as_mut_ptr(move _3001) -> bb1255
  using: _3001@Mir(bb1254[3])
bb1255:
  _2997 = bzlib::BZ2_indexIntoF(move _2998, move _3000) -> bb1256
  using: _2998@Mir(bb1254[1]), _3000@Mir(bb1254[4])
bb1256:
  ((*_1).15: i32) = move _2997
  using: _1@Phi(bb1247), _2997@Mir(bb1255[0])
  _3006 = ((*_1).21: *mut u16)
  using: _1@Phi(bb1247)
  _3008 = ((*_1).14: u32)
  using: _1@Phi(bb1247)
  _3007 = move _3008 as isize (IntToInt)
  using: _3008@Mir(bb1256[2])
  _3005 = std::ptr::mut_ptr::<impl *mut u16>::offset(move _3006, move _3007) -> bb1257
  using: _3006@Mir(bb1256[1]), _3007@Mir(bb1256[3])
bb1257:
  _3004 = (*_3005)
  using: _3005@Mir(bb1256[4])
  _3003 = move _3004 as u32 (IntToInt)
  using: _3004@Mir(bb1257[0])
  _3015 = ((*_1).22: *mut u8)
  using: _1@Phi(bb1247)
  _3018 = ((*_1).14: u32)
  using: _1@Phi(bb1247)
  _3019 = const 1_i32
  using: 
  _3020 = CheckedShr(_3018, _3019)
  using: _3018@Mir(bb1257[3]), _3019@Mir(bb1257[4])
  assert(!move (_3020.1: bool), "attempt to shift right by `{}`, which would overflow", move _3019) -> bb1258
  using: _3020@Entry, _3018@Entry, _3019@Entry
bb1258:
  _3017 = move (_3020.0: u32)
  using: _3020@Mir(bb1257[5])
  _3016 = move _3017 as isize (IntToInt)
  using: _3017@Mir(bb1258[0])
  _3014 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3015, move _3016) -> bb1259
  using: _3015@Mir(bb1257[2]), _3016@Mir(bb1258[1])
bb1259:
  _3013 = (*_3014)
  using: _3014@Mir(bb1258[2])
  _3012 = move _3013 as u32 (IntToInt)
  using: _3013@Mir(bb1259[0])
  _3023 = ((*_1).14: u32)
  using: _1@Phi(bb1247)
  _3024 = const 2_i32
  using: 
  _3025 = CheckedShl(_3023, _3024)
  using: _3023@Mir(bb1259[2]), _3024@Mir(bb1259[3])
  assert(!move (_3025.1: bool), "attempt to shift left by `{}`, which would overflow", move _3024) -> bb1260
  using: _3025@Entry, _3023@Entry, _3024@Entry
bb1260:
  _3022 = move (_3025.0: u32)
  using: _3025@Mir(bb1259[4])
  _3026 = const 4_u32
  using: 
  _3021 = BitAnd(move _3022, move _3026)
  using: _3022@Mir(bb1260[0]), _3026@Mir(bb1260[1])
  _3027 = CheckedShr(_3012, _3021)
  using: _3012@Mir(bb1259[1]), _3021@Mir(bb1260[2])
  assert(!move (_3027.1: bool), "attempt to shift right by `{}`, which would overflow", move _3021) -> bb1261
  using: _3027@Entry, _3012@Entry, _3021@Entry
bb1261:
  _3011 = move (_3027.0: u32)
  using: _3027@Mir(bb1260[3])
  _3028 = const 15_u32
  using: 
  _3010 = BitAnd(move _3011, move _3028)
  using: _3011@Mir(bb1261[0]), _3028@Mir(bb1261[1])
  _3029 = const 16_i32
  using: 
  _3030 = CheckedShl(_3010, _3029)
  using: _3010@Mir(bb1261[2]), _3029@Mir(bb1261[3])
  assert(!move (_3030.1: bool), "attempt to shift left by `{}`, which would overflow", move _3029) -> bb1262
  using: _3030@Entry, _3010@Entry, _3029@Entry
bb1262:
  _3009 = move (_3030.0: u32)
  using: _3030@Mir(bb1261[4])
  ((*_1).14: u32) = BitOr(move _3003, move _3009)
  using: _1@Phi(bb1247), _3003@Mir(bb1257[1]), _3009@Mir(bb1262[0])
  _3031 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1247)
  assert(!move (_3031.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb1263
  using: _3031@Entry, _1@Entry
bb1263:
  ((*_1).17: i32) = move (_3031.0: i32)
  using: _1@Phi(bb1247), _3031@Mir(bb1262[2])
  goto -> bb1300
  using: 
bb1264:
  _8 = const 0_i32
  using: 
  goto -> bb1265
  using: 
bb1265:
  _3033 = _8
  using: _8@Phi(bb1265)
  _3034 = _19
  using: _19@Phi(bb1150)
  _3032 = Lt(move _3033, move _3034)
  using: _3033@Mir(bb1265[0]), _3034@Mir(bb1265[1])
  switchInt(move _3032) -> [0: bb1274, otherwise: bb1266]
  using: _3032@Mir(bb1265[2])
bb1266:
  _3038 = ((*_1).20: *mut u32)
  using: _1@Phi(bb1265)
  _3040 = _8
  using: _8@Phi(bb1265)
  _3039 = move _3040 as isize (IntToInt)
  using: _3040@Mir(bb1266[1])
  _3037 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _3038, move _3039) -> bb1267
  using: _3038@Mir(bb1266[0]), _3039@Mir(bb1266[2])
bb1267:
  _3036 = (*_3037)
  using: _3037@Mir(bb1266[3])
  _3041 = const 255_u32
  using: 
  _3035 = BitAnd(move _3036, move _3041)
  using: _3036@Mir(bb1267[0]), _3041@Mir(bb1267[1])
  _3 = move _3035 as u8 (IntToInt)
  using: _3035@Mir(bb1267[2])
  _3043 = _8
  using: _8@Phi(bb1265)
  _3044 = const 8_i32
  using: 
  _3045 = CheckedShl(_3043, _3044)
  using: _3043@Mir(bb1267[4]), _3044@Mir(bb1267[5])
  assert(!move (_3045.1: bool), "attempt to shift left by `{}`, which would overflow", move _3044) -> bb1268
  using: _3045@Entry, _3043@Entry, _3044@Entry
bb1268:
  _3042 = move (_3045.0: i32)
  using: _3045@Mir(bb1267[6])
  _3047 = ((*_1).20: *mut u32)
  using: _1@Phi(bb1265)
  _3051 = _3
  using: _3@Mir(bb1267[3])
  _3050 = move _3051 as usize (IntToInt)
  using: _3051@Mir(bb1268[2])
  _3052 = const 257_usize
  using: 
  _3053 = Lt(_3050, _3052)
  using: _3050@Mir(bb1268[3]), _3052@Mir(bb1268[4])
  assert(move _3053, "index out of bounds: the length is {} but the index is {}", move _3052, _3050) -> bb1269
  using: _3053@Entry, _3052@Entry, _3050@Entry
bb1269:
  _3049 = ((*_1).18: [i32; 257])[_3050]
  using: _1@Phi(bb1265), _3050@Mir(bb1268[3])
  _3048 = move _3049 as isize (IntToInt)
  using: _3049@Mir(bb1269[0])
  _3046 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _3047, move _3048) -> bb1270
  using: _3047@Mir(bb1268[1]), _3048@Mir(bb1269[1])
bb1270:
  (*_3046) = move _3042 as u32 (IntToInt)
  using: _3046@Mir(bb1269[2]), _3042@Mir(bb1268[0])
  _3055 = _3
  using: _3@Mir(bb1267[3])
  _3054 = move _3055 as usize (IntToInt)
  using: _3055@Mir(bb1270[1])
  _3056 = const 257_usize
  using: 
  _3057 = Lt(_3054, _3056)
  using: _3054@Mir(bb1270[2]), _3056@Mir(bb1270[3])
  assert(move _3057, "index out of bounds: the length is {} but the index is {}", move _3056, _3054) -> bb1271
  using: _3057@Entry, _3056@Entry, _3054@Entry
bb1271:
  _3058 = CheckedAdd(((*_1).18: [i32; 257])[_3054], const 1_i32)
  using: _1@Phi(bb1265), _3054@Mir(bb1270[2])
  assert(!move (_3058.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).18: [i32; 257])[_3054], const 1_i32) -> bb1272
  using: _3058@Entry, _1@Entry, _3054@Entry
bb1272:
  ((*_1).18: [i32; 257])[_3054] = move (_3058.0: i32)
  using: _1@Phi(bb1265), _3054@Mir(bb1270[2]), _3058@Mir(bb1271[0])
  _3059 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1265)
  assert(!move (_3059.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1273
  using: _3059@Entry, _8@Entry
bb1273:
  _8 = move (_3059.0: i32)
  using: _3059@Mir(bb1272[1])
  goto -> bb1265
  using: 
bb1274:
  _3062 = ((*_1).20: *mut u32)
  using: _1@Phi(bb1265)
  _3064 = ((*_1).13: i32)
  using: _1@Phi(bb1265)
  _3063 = move _3064 as isize (IntToInt)
  using: _3064@Mir(bb1274[1])
  _3061 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _3062, move _3063) -> bb1275
  using: _3062@Mir(bb1274[0]), _3063@Mir(bb1274[2])
bb1275:
  _3060 = (*_3061)
  using: _3061@Mir(bb1274[3])
  _3065 = const 8_i32
  using: 
  _3066 = CheckedShr(_3060, _3065)
  using: _3060@Mir(bb1275[0]), _3065@Mir(bb1275[1])
  assert(!move (_3066.1: bool), "attempt to shift right by `{}`, which would overflow", move _3065) -> bb1276
  using: _3066@Entry, _3060@Entry, _3065@Entry
bb1276:
  ((*_1).14: u32) = move (_3066.0: u32)
  using: _1@Phi(bb1265), _3066@Mir(bb1275[2])
  _3067 = const 0_i32
  using: 
  ((*_1).17: i32) = move _3067
  using: _1@Phi(bb1265), _3067@Mir(bb1276[1])
  _3068 = ((*_1).4: u8)
  using: _1@Phi(bb1265)
  switchInt(move _3068) -> [0: bb1293, otherwise: bb1277]
  using: _3068@Mir(bb1276[3])
bb1277:
  _3069 = const 0_i32
  using: 
  ((*_1).5: i32) = move _3069
  using: _1@Phi(bb1265), _3069@Mir(bb1277[0])
  _3070 = const 0_i32
  using: 
  ((*_1).6: i32) = move _3070
  using: _1@Phi(bb1265), _3070@Mir(bb1277[2])
  _3072 = ((*_1).14: u32)
  using: _1@Phi(bb1265)
  _3074 = const 100000_u32
  using: 
  _3076 = ((*_1).9: i32)
  using: _1@Phi(bb1265)
  _3075 = move _3076 as u32 (IntToInt)
  using: _3076@Mir(bb1277[6])
  _3073 = core::num::<impl u32>::wrapping_mul(move _3074, move _3075) -> bb1278
  using: _3074@Mir(bb1277[5]), _3075@Mir(bb1277[7])
bb1278:
  _3071 = Ge(move _3072, move _3073)
  using: _3072@Mir(bb1277[4]), _3073@Mir(bb1277[8])
  switchInt(move _3071) -> [0: bb1280, otherwise: bb1279]
  using: _3071@Mir(bb1278[0])
bb1279:
  _0 = const 1_i32
  using: 
  goto -> bb1477
  using: 
bb1280:
  _3079 = ((*_1).20: *mut u32)
  using: _1@Phi(bb1265)
  _3081 = ((*_1).14: u32)
  using: _1@Phi(bb1265)
  _3080 = move _3081 as isize (IntToInt)
  using: _3081@Mir(bb1280[1])
  _3078 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _3079, move _3080) -> bb1281
  using: _3079@Mir(bb1280[0]), _3080@Mir(bb1280[2])
bb1281:
  _3077 = (*_3078)
  using: _3078@Mir(bb1280[3])
  ((*_1).14: u32) = move _3077
  using: _1@Phi(bb1265), _3077@Mir(bb1281[0])
  _3084 = ((*_1).14: u32)
  using: _1@Phi(bb1265)
  _3085 = const 255_u32
  using: 
  _3083 = BitAnd(move _3084, move _3085)
  using: _3084@Mir(bb1281[2]), _3085@Mir(bb1281[3])
  _3082 = move _3083 as u8 (IntToInt)
  using: _3083@Mir(bb1281[4])
  ((*_1).15: i32) = move _3082 as i32 (IntToInt)
  using: _1@Phi(bb1265), _3082@Mir(bb1281[5])
  _3086 = const 8_i32
  using: 
  _3087 = CheckedShr(((*_1).14: u32), _3086)
  using: _1@Phi(bb1265), _3086@Mir(bb1281[7])
  assert(!move (_3087.1: bool), "attempt to shift right by `{}`, which would overflow", move _3086) -> bb1282
  using: _3087@Entry, _1@Entry, _3086@Entry
bb1282:
  ((*_1).14: u32) = move (_3087.0: u32)
  using: _1@Phi(bb1265), _3087@Mir(bb1281[8])
  _3088 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1265)
  assert(!move (_3088.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb1283
  using: _3088@Entry, _1@Entry
bb1283:
  ((*_1).17: i32) = move (_3088.0: i32)
  using: _1@Phi(bb1265), _3088@Mir(bb1282[1])
  _3090 = ((*_1).5: i32)
  using: _1@Phi(bb1265)
  _3091 = const 0_i32
  using: 
  _3089 = Eq(move _3090, move _3091)
  using: _3090@Mir(bb1283[1]), _3091@Mir(bb1283[2])
  switchInt(move _3089) -> [0: bb1288, otherwise: bb1284]
  using: _3089@Mir(bb1283[3])
bb1284:
  _3093 = const {alloc925: *mut [i32; 512]}
  using: 
  _3095 = ((*_1).6: i32)
  using: _1@Phi(bb1265)
  _3094 = move _3095 as usize (IntToInt)
  using: _3095@Mir(bb1284[1])
  _3096 = const 512_usize
  using: 
  _3097 = Lt(_3094, _3096)
  using: _3094@Mir(bb1284[2]), _3096@Mir(bb1284[3])
  assert(move _3097, "index out of bounds: the length is {} but the index is {}", move _3096, _3094) -> bb1285
  using: _3097@Entry, _3096@Entry, _3094@Entry
bb1285:
  _3092 = (*_3093)[_3094]
  using: _3093@Mir(bb1284[0]), _3094@Mir(bb1284[2])
  ((*_1).5: i32) = move _3092
  using: _1@Phi(bb1265), _3092@Mir(bb1285[0])
  _3098 = CheckedAdd(((*_1).6: i32), const 1_i32)
  using: _1@Phi(bb1265)
  assert(!move (_3098.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).6: i32), const 1_i32) -> bb1286
  using: _3098@Entry, _1@Entry
bb1286:
  ((*_1).6: i32) = move (_3098.0: i32)
  using: _1@Phi(bb1265), _3098@Mir(bb1285[2])
  _3100 = ((*_1).6: i32)
  using: _1@Phi(bb1265)
  _3101 = const 512_i32
  using: 
  _3099 = Eq(move _3100, move _3101)
  using: _3100@Mir(bb1286[1]), _3101@Mir(bb1286[2])
  switchInt(move _3099) -> [0: bb1288, otherwise: bb1287]
  using: _3099@Mir(bb1286[3])
bb1287:
  _3102 = const 0_i32
  using: 
  ((*_1).6: i32) = move _3102
  using: _1@Phi(bb1265), _3102@Mir(bb1287[0])
  goto -> bb1288
  using: 
bb1288:
  _3103 = CheckedSub(((*_1).5: i32), const 1_i32)
  using: _1@Phi(bb1288)
  assert(!move (_3103.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).5: i32), const 1_i32) -> bb1289
  using: _3103@Entry, _1@Entry
bb1289:
  ((*_1).5: i32) = move (_3103.0: i32)
  using: _1@Phi(bb1288), _3103@Mir(bb1288[0])
  _3106 = ((*_1).5: i32)
  using: _1@Phi(bb1288)
  _3107 = const 1_i32
  using: 
  _3105 = Eq(move _3106, move _3107)
  using: _3106@Mir(bb1289[1]), _3107@Mir(bb1289[2])
  switchInt(move _3105) -> [0: bb1291, otherwise: bb1290]
  using: _3105@Mir(bb1289[3])
bb1290:
  _3104 = const 1_i32
  using: 
  goto -> bb1292
  using: 
bb1291:
  _3104 = const 0_i32
  using: 
  goto -> bb1292
  using: 
bb1292:
  ((*_1).15: i32) = BitXor(((*_1).15: i32), move _3104)
  using: _1@Phi(bb1288), _1@Phi(bb1288), _3104@Phi(bb1292)
  goto -> bb1300
  using: 
bb1293:
  _3109 = ((*_1).14: u32)
  using: _1@Phi(bb1288)
  _3111 = const 100000_u32
  using: 
  _3113 = ((*_1).9: i32)
  using: _1@Phi(bb1288)
  _3112 = move _3113 as u32 (IntToInt)
  using: _3113@Mir(bb1293[2])
  _3110 = core::num::<impl u32>::wrapping_mul(move _3111, move _3112) -> bb1294
  using: _3111@Mir(bb1293[1]), _3112@Mir(bb1293[3])
bb1294:
  _3108 = Ge(move _3109, move _3110)
  using: _3109@Mir(bb1293[0]), _3110@Mir(bb1293[4])
  switchInt(move _3108) -> [0: bb1296, otherwise: bb1295]
  using: _3108@Mir(bb1294[0])
bb1295:
  _0 = const 1_i32
  using: 
  goto -> bb1477
  using: 
bb1296:
  _3116 = ((*_1).20: *mut u32)
  using: _1@Phi(bb1288)
  _3118 = ((*_1).14: u32)
  using: _1@Phi(bb1288)
  _3117 = move _3118 as isize (IntToInt)
  using: _3118@Mir(bb1296[1])
  _3115 = std::ptr::mut_ptr::<impl *mut u32>::offset(move _3116, move _3117) -> bb1297
  using: _3116@Mir(bb1296[0]), _3117@Mir(bb1296[2])
bb1297:
  _3114 = (*_3115)
  using: _3115@Mir(bb1296[3])
  ((*_1).14: u32) = move _3114
  using: _1@Phi(bb1288), _3114@Mir(bb1297[0])
  _3121 = ((*_1).14: u32)
  using: _1@Phi(bb1288)
  _3122 = const 255_u32
  using: 
  _3120 = BitAnd(move _3121, move _3122)
  using: _3121@Mir(bb1297[2]), _3122@Mir(bb1297[3])
  _3119 = move _3120 as u8 (IntToInt)
  using: _3120@Mir(bb1297[4])
  ((*_1).15: i32) = move _3119 as i32 (IntToInt)
  using: _1@Phi(bb1288), _3119@Mir(bb1297[5])
  _3123 = const 8_i32
  using: 
  _3124 = CheckedShr(((*_1).14: u32), _3123)
  using: _1@Phi(bb1288), _3123@Mir(bb1297[7])
  assert(!move (_3124.1: bool), "attempt to shift right by `{}`, which would overflow", move _3123) -> bb1298
  using: _3124@Entry, _1@Entry, _3123@Entry
bb1298:
  ((*_1).14: u32) = move (_3124.0: u32)
  using: _1@Phi(bb1288), _3124@Mir(bb1297[8])
  _3125 = CheckedAdd(((*_1).17: i32), const 1_i32)
  using: _1@Phi(bb1288)
  assert(!move (_3125.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).17: i32), const 1_i32) -> bb1299
  using: _3125@Entry, _1@Entry
bb1299:
  ((*_1).17: i32) = move (_3125.0: i32)
  using: _1@Phi(bb1288), _3125@Mir(bb1298[1])
  goto -> bb1300
  using: 
bb1300:
  _4 = const 0_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1301:
  switchInt(_2) -> [4550729491376650574: bb1302, otherwise: bb1334]
  using: _2@Phi(bb1301)
bb1302:
  _3127 = _21
  using: _21@Phi(bb1301)
  _3128 = const 2097152_i32
  using: 
  _3126 = Ge(move _3127, move _3128)
  using: _3127@Mir(bb1302[0]), _3128@Mir(bb1302[1])
  switchInt(move _3126) -> [0: bb1304, otherwise: bb1303]
  using: _3126@Mir(bb1302[2])
bb1303:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1304:
  _3130 = _17
  using: _17@Phi(bb1301)
  _3131 = const 0_i32
  using: 
  _3129 = Eq(move _3130, move _3131)
  using: _3130@Mir(bb1304[0]), _3131@Mir(bb1304[1])
  switchInt(move _3129) -> [0: bb1308, otherwise: bb1305]
  using: _3129@Mir(bb1304[2])
bb1305:
  _3132 = _20
  using: _20@Phi(bb1301)
  _3134 = const 1_i32
  using: 
  _3135 = _21
  using: _21@Phi(bb1301)
  _3136 = CheckedMul(_3134, _3135)
  using: _3134@Mir(bb1305[1]), _3135@Mir(bb1305[2])
  assert(!move (_3136.1: bool), "attempt to compute `{} * {}`, which would overflow", move _3134, move _3135) -> bb1306
  using: _3136@Entry, _3134@Entry, _3135@Entry
bb1306:
  _3133 = move (_3136.0: i32)
  using: _3136@Mir(bb1305[3])
  _3137 = CheckedAdd(_3132, _3133)
  using: _3132@Mir(bb1305[0]), _3133@Mir(bb1306[0])
  assert(!move (_3137.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3132, move _3133) -> bb1307
  using: _3137@Entry, _3132@Entry, _3133@Entry
bb1307:
  _20 = move (_3137.0: i32)
  using: _3137@Mir(bb1306[1])
  goto -> bb1312
  using: 
bb1308:
  _3139 = _17
  using: _17@Phi(bb1301)
  _3140 = const 1_i32
  using: 
  _3138 = Eq(move _3139, move _3140)
  using: _3139@Mir(bb1308[0]), _3140@Mir(bb1308[1])
  switchInt(move _3138) -> [0: bb1312, otherwise: bb1309]
  using: _3138@Mir(bb1308[2])
bb1309:
  _3141 = _20
  using: _20@Phi(bb1301)
  _3143 = const 2_i32
  using: 
  _3144 = _21
  using: _21@Phi(bb1301)
  _3145 = CheckedMul(_3143, _3144)
  using: _3143@Mir(bb1309[1]), _3144@Mir(bb1309[2])
  assert(!move (_3145.1: bool), "attempt to compute `{} * {}`, which would overflow", move _3143, move _3144) -> bb1310
  using: _3145@Entry, _3143@Entry, _3144@Entry
bb1310:
  _3142 = move (_3145.0: i32)
  using: _3145@Mir(bb1309[3])
  _3146 = CheckedAdd(_3141, _3142)
  using: _3141@Mir(bb1309[0]), _3142@Mir(bb1310[0])
  assert(!move (_3146.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3141, move _3142) -> bb1311
  using: _3146@Entry, _3141@Entry, _3142@Entry
bb1311:
  _20 = move (_3146.0: i32)
  using: _3146@Mir(bb1310[1])
  goto -> bb1312
  using: 
bb1312:
  _3147 = _21
  using: _21@Phi(bb1312)
  _3148 = const 2_i32
  using: 
  _3149 = CheckedMul(_3147, _3148)
  using: _3147@Mir(bb1312[0]), _3148@Mir(bb1312[1])
  assert(!move (_3149.1: bool), "attempt to compute `{} * {}`, which would overflow", move _3147, move _3148) -> bb1313
  using: _3149@Entry, _3147@Entry, _3148@Entry
bb1313:
  _21 = move (_3149.0: i32)
  using: _3149@Mir(bb1312[2])
  _3151 = _16
  using: _16@Phi(bb1111)
  _3152 = const 0_i32
  using: 
  _3150 = Eq(move _3151, move _3152)
  using: _3151@Mir(bb1313[1]), _3152@Mir(bb1313[2])
  switchInt(move _3150) -> [0: bb1332, otherwise: bb1314]
  using: _3150@Mir(bb1313[3])
bb1314:
  _3153 = CheckedAdd(_15, const 1_i32)
  using: _15@Phi(bb1111)
  assert(!move (_3153.1: bool), "attempt to compute `{} + {}`, which would overflow", _15, const 1_i32) -> bb1315
  using: _3153@Entry, _15@Entry
bb1315:
  _15 = move (_3153.0: i32)
  using: _3153@Mir(bb1314[0])
  _3155 = _15
  using: _15@Mir(bb1315[0])
  _3156 = _13
  using: _13@Phi(bb1111)
  _3154 = Ge(move _3155, move _3156)
  using: _3155@Mir(bb1315[1]), _3156@Mir(bb1315[2])
  switchInt(move _3154) -> [0: bb1317, otherwise: bb1316]
  using: _3154@Mir(bb1315[3])
bb1316:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1317:
  _16 = const 50_i32
  using: 
  _3159 = _15
  using: _15@Mir(bb1315[0])
  _3158 = move _3159 as usize (IntToInt)
  using: _3159@Mir(bb1317[1])
  _3160 = const 18002_usize
  using: 
  _3161 = Lt(_3158, _3160)
  using: _3158@Mir(bb1317[2]), _3160@Mir(bb1317[3])
  assert(move _3161, "index out of bounds: the length is {} but the index is {}", move _3160, _3158) -> bb1318
  using: _3161@Entry, _3160@Entry, _3158@Entry
bb1318:
  _3157 = ((*_1).33: [u8; 18002])[_3158]
  using: _1@Phi(bb1300), _3158@Mir(bb1317[2])
  _27 = move _3157 as i32 (IntToInt)
  using: _3157@Mir(bb1318[0])
  _3164 = _27
  using: _27@Mir(bb1318[1])
  _3163 = move _3164 as usize (IntToInt)
  using: _3164@Mir(bb1318[2])
  _3165 = const 6_usize
  using: 
  _3166 = Lt(_3163, _3165)
  using: _3163@Mir(bb1318[3]), _3165@Mir(bb1318[4])
  assert(move _3166, "index out of bounds: the length is {} but the index is {}", move _3165, _3163) -> bb1319
  using: _3166@Entry, _3165@Entry, _3163@Entry
bb1319:
  _3162 = ((*_1).39: [i32; 6])[_3163]
  using: _1@Phi(bb1300), _3163@Mir(bb1318[3])
  _28 = move _3162
  using: _3162@Mir(bb1319[0])
  _3176 = &mut ((*_1).36: [[i32; 258]; 6])
  using: _1@Phi(bb1300)
  _3175 = move _3176 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3176@Mir(bb1319[2])
  _3174 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3175) -> bb1320
  using: _3175@Mir(bb1319[3])
bb1320:
  _3178 = _27
  using: _27@Mir(bb1318[1])
  _3177 = move _3178 as isize (IntToInt)
  using: _3178@Mir(bb1320[0])
  _3173 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3174, move _3177) -> bb1321
  using: _3174@Mir(bb1319[4]), _3177@Mir(bb1320[1])
bb1321:
  _3172 = &mut (*_3173)
  using: _3173@Mir(bb1320[2])
  _3171 = move _3172 as &mut [i32] (Pointer(Unsize))
  using: _3172@Mir(bb1321[0])
  _3170 = core::slice::<impl [i32]>::as_mut_ptr(move _3171) -> bb1322
  using: _3171@Mir(bb1321[1])
bb1322:
  _3179 = const 0_isize
  using: 
  _3169 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3170, move _3179) -> bb1323
  using: _3170@Mir(bb1321[2]), _3179@Mir(bb1322[0])
bb1323:
  _3168 = &mut (*_3169)
  using: _3169@Mir(bb1322[1])
  _3167 = &raw mut (*_3168)
  using: _3168@Mir(bb1323[0])
  _29 = move _3167
  using: _3167@Mir(bb1323[1])
  _3189 = &mut ((*_1).38: [[i32; 258]; 6])
  using: _1@Phi(bb1300)
  _3188 = move _3189 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3189@Mir(bb1323[3])
  _3187 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3188) -> bb1324
  using: _3188@Mir(bb1323[4])
bb1324:
  _3191 = _27
  using: _27@Mir(bb1318[1])
  _3190 = move _3191 as isize (IntToInt)
  using: _3191@Mir(bb1324[0])
  _3186 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3187, move _3190) -> bb1325
  using: _3187@Mir(bb1323[5]), _3190@Mir(bb1324[1])
bb1325:
  _3185 = &mut (*_3186)
  using: _3186@Mir(bb1324[2])
  _3184 = move _3185 as &mut [i32] (Pointer(Unsize))
  using: _3185@Mir(bb1325[0])
  _3183 = core::slice::<impl [i32]>::as_mut_ptr(move _3184) -> bb1326
  using: _3184@Mir(bb1325[1])
bb1326:
  _3192 = const 0_isize
  using: 
  _3182 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3183, move _3192) -> bb1327
  using: _3183@Mir(bb1325[2]), _3192@Mir(bb1326[0])
bb1327:
  _3181 = &mut (*_3182)
  using: _3182@Mir(bb1326[1])
  _3180 = &raw mut (*_3181)
  using: _3181@Mir(bb1327[0])
  _31 = move _3180
  using: _3180@Mir(bb1327[1])
  _3202 = &mut ((*_1).37: [[i32; 258]; 6])
  using: _1@Phi(bb1300)
  _3201 = move _3202 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3202@Mir(bb1327[3])
  _3200 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3201) -> bb1328
  using: _3201@Mir(bb1327[4])
bb1328:
  _3204 = _27
  using: _27@Mir(bb1318[1])
  _3203 = move _3204 as isize (IntToInt)
  using: _3204@Mir(bb1328[0])
  _3199 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3200, move _3203) -> bb1329
  using: _3200@Mir(bb1327[5]), _3203@Mir(bb1328[1])
bb1329:
  _3198 = &mut (*_3199)
  using: _3199@Mir(bb1328[2])
  _3197 = move _3198 as &mut [i32] (Pointer(Unsize))
  using: _3198@Mir(bb1329[0])
  _3196 = core::slice::<impl [i32]>::as_mut_ptr(move _3197) -> bb1330
  using: _3197@Mir(bb1329[1])
bb1330:
  _3205 = const 0_isize
  using: 
  _3195 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3196, move _3205) -> bb1331
  using: _3196@Mir(bb1329[2]), _3205@Mir(bb1330[0])
bb1331:
  _3194 = &mut (*_3195)
  using: _3195@Mir(bb1330[1])
  _3193 = &raw mut (*_3194)
  using: _3194@Mir(bb1331[0])
  _30 = move _3193
  using: _3193@Mir(bb1331[1])
  goto -> bb1332
  using: 
bb1332:
  _3206 = CheckedSub(_16, const 1_i32)
  using: _16@Phi(bb1332)
  assert(!move (_3206.1: bool), "attempt to compute `{} - {}`, which would overflow", _16, const 1_i32) -> bb1333
  using: _3206@Entry, _16@Entry
bb1333:
  _16 = move (_3206.0: i32)
  using: _3206@Mir(bb1332[0])
  _3207 = _28
  using: _28@Phi(bb1332)
  _24 = move _3207
  using: _3207@Mir(bb1333[1])
  _2 = const 5374617794059532979_u64
  using: 
  goto -> bb634
  using: 
bb1334:
  switchInt(_2) -> [3854024847017804838: bb1336, 6591141407893725683: bb1338, 3472349144349095221: bb1362, 17503523010989424999: bb1370, 3770765986603902964: bb1374, 5281038271658253520: bb1378, 6927328446518169316: bb1383, otherwise: bb1335]
  using: _2@Phi(bb1334)
bb1335:
  _3310 = _22
  using: _22@Phi(bb1334)
  _3311 = const 1_i32
  using: 
  _3309 = Lt(move _3310, move _3311)
  using: _3310@Mir(bb1335[0]), _3311@Mir(bb1335[1])
  switchInt(move _3309) -> [0: bb1385, otherwise: bb1384]
  using: _3309@Mir(bb1335[2])
bb1336:
  _3209 = _9
  using: _9@Phi(bb1334)
  _3210 = const 16_i32
  using: 
  _3208 = Lt(move _3209, move _3210)
  using: _3209@Mir(bb1336[0]), _3210@Mir(bb1336[1])
  switchInt(move _3208) -> [0: bb1389, otherwise: bb1337]
  using: _3208@Mir(bb1336[2])
bb1337:
  _2 = const 1422779171932145779_u64
  using: 
  goto -> bb634
  using: 
bb1338:
  _3212 = _8
  using: _8@Phi(bb1334)
  _3213 = _13
  using: _13@Phi(bb1334)
  _3211 = Lt(move _3212, move _3213)
  using: _3212@Mir(bb1338[0]), _3213@Mir(bb1338[1])
  switchInt(move _3211) -> [0: bb1340, otherwise: bb1339]
  using: _3211@Mir(bb1338[2])
bb1339:
  _9 = const 0_i32
  using: 
  _2 = const 6927328446518169316_u64
  using: 
  goto -> bb1334
  using: 
bb1340:
  _3215 = _13
  using: _13@Phi(bb1334)
  _3216 = const 18002_i32
  using: 
  _3214 = Gt(move _3215, move _3216)
  using: _3215@Mir(bb1340[0]), _3216@Mir(bb1340[1])
  switchInt(move _3214) -> [0: bb1342, otherwise: bb1341]
  using: _3214@Mir(bb1340[2])
bb1341:
  _13 = const 18002_i32
  using: 
  goto -> bb1342
  using: 
bb1342:
  _3217 = [const 0_u8; 6]
  using: 
  _3218 = const 0_u8
  using: 
  _3219 = const 0_u8
  using: 
  _3219 = const 0_u8
  using: 
  goto -> bb1343
  using: 
bb1343:
  _3222 = _3219
  using: _3219@Phi(bb1343)
  _3221 = move _3222 as i32 (IntToInt)
  using: _3222@Mir(bb1343[0])
  _3223 = _12
  using: _12@Phi(bb908)
  _3220 = Lt(move _3221, move _3223)
  using: _3221@Mir(bb1343[1]), _3223@Mir(bb1343[2])
  switchInt(move _3220) -> [0: bb1347, otherwise: bb1344]
  using: _3220@Mir(bb1343[3])
bb1344:
  _3224 = _3219
  using: _3219@Phi(bb1343)
  _3226 = _3219
  using: _3219@Phi(bb1343)
  _3225 = move _3226 as usize (IntToInt)
  using: _3226@Mir(bb1344[1])
  _3227 = const 6_usize
  using: 
  _3228 = Lt(_3225, _3227)
  using: _3225@Mir(bb1344[2]), _3227@Mir(bb1344[3])
  assert(move _3228, "index out of bounds: the length is {} but the index is {}", move _3227, _3225) -> bb1345
  using: _3228@Entry, _3227@Entry, _3225@Entry
bb1345:
  _3217[_3225] = move _3224
  using: _3225@Mir(bb1344[2]), _3224@Mir(bb1344[0])
  _3230 = _3219
  using: _3219@Phi(bb1343)
  _3229 = core::num::<impl u8>::wrapping_add(move _3230, const 1_u8) -> bb1346
  using: _3230@Mir(bb1345[1])
bb1346:
  _3219 = move _3229
  using: _3229@Mir(bb1345[2])
  goto -> bb1343
  using: 
bb1347:
  _8 = const 0_i32
  using: 
  goto -> bb1348
  using: 
bb1348:
  _3232 = _8
  using: _8@Phi(bb1348)
  _3233 = _13
  using: _13@Phi(bb1342)
  _3231 = Lt(move _3232, move _3233)
  using: _3232@Mir(bb1348[0]), _3233@Mir(bb1348[1])
  switchInt(move _3231) -> [0: bb1361, otherwise: bb1349]
  using: _3231@Mir(bb1348[2])
bb1349:
  _3236 = _8
  using: _8@Phi(bb1348)
  _3235 = move _3236 as usize (IntToInt)
  using: _3236@Mir(bb1349[0])
  _3237 = const 18002_usize
  using: 
  _3238 = Lt(_3235, _3237)
  using: _3235@Mir(bb1349[1]), _3237@Mir(bb1349[2])
  assert(move _3238, "index out of bounds: the length is {} but the index is {}", move _3237, _3235) -> bb1350
  using: _3238@Entry, _3237@Entry, _3235@Entry
bb1350:
  _3234 = ((*_1).34: [u8; 18002])[_3235]
  using: _1@Phi(bb1348), _3235@Mir(bb1349[1])
  _3219 = move _3234
  using: _3234@Mir(bb1350[0])
  _3241 = _3219
  using: _3219@Mir(bb1350[1])
  _3240 = move _3241 as usize (IntToInt)
  using: _3241@Mir(bb1350[2])
  _3242 = const 6_usize
  using: 
  _3243 = Lt(_3240, _3242)
  using: _3240@Mir(bb1350[3]), _3242@Mir(bb1350[4])
  assert(move _3243, "index out of bounds: the length is {} but the index is {}", move _3242, _3240) -> bb1351
  using: _3243@Entry, _3242@Entry, _3240@Entry
bb1351:
  _3239 = _3217[_3240]
  using: _3217@Phi(bb1348), _3240@Mir(bb1350[3])
  _3218 = move _3239
  using: _3239@Mir(bb1351[0])
  goto -> bb1352
  using: 
bb1352:
  _3246 = _3219
  using: _3219@Phi(bb1352)
  _3245 = move _3246 as i32 (IntToInt)
  using: _3246@Mir(bb1352[0])
  _3247 = const 0_i32
  using: 
  _3244 = Gt(move _3245, move _3247)
  using: _3245@Mir(bb1352[1]), _3247@Mir(bb1352[2])
  switchInt(move _3244) -> [0: bb1358, otherwise: bb1353]
  using: _3244@Mir(bb1352[3])
bb1353:
  _3252 = _3219
  using: _3219@Phi(bb1352)
  _3251 = move _3252 as i32 (IntToInt)
  using: _3252@Mir(bb1353[0])
  _3253 = const 1_i32
  using: 
  _3254 = CheckedSub(_3251, _3253)
  using: _3251@Mir(bb1353[1]), _3253@Mir(bb1353[2])
  assert(!move (_3254.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3251, move _3253) -> bb1354
  using: _3254@Entry, _3251@Entry, _3253@Entry
bb1354:
  _3250 = move (_3254.0: i32)
  using: _3254@Mir(bb1353[3])
  _3249 = move _3250 as usize (IntToInt)
  using: _3250@Mir(bb1354[0])
  _3255 = const 6_usize
  using: 
  _3256 = Lt(_3249, _3255)
  using: _3249@Mir(bb1354[1]), _3255@Mir(bb1354[2])
  assert(move _3256, "index out of bounds: the length is {} but the index is {}", move _3255, _3249) -> bb1355
  using: _3256@Entry, _3255@Entry, _3249@Entry
bb1355:
  _3248 = _3217[_3249]
  using: _3217@Phi(bb1352), _3249@Mir(bb1354[1])
  _3258 = _3219
  using: _3219@Phi(bb1352)
  _3257 = move _3258 as usize (IntToInt)
  using: _3258@Mir(bb1355[1])
  _3259 = const 6_usize
  using: 
  _3260 = Lt(_3257, _3259)
  using: _3257@Mir(bb1355[2]), _3259@Mir(bb1355[3])
  assert(move _3260, "index out of bounds: the length is {} but the index is {}", move _3259, _3257) -> bb1356
  using: _3260@Entry, _3259@Entry, _3257@Entry
bb1356:
  _3217[_3257] = move _3248
  using: _3257@Mir(bb1355[2]), _3248@Mir(bb1355[0])
  _3262 = _3219
  using: _3219@Phi(bb1352)
  _3261 = core::num::<impl u8>::wrapping_sub(move _3262, const 1_u8) -> bb1357
  using: _3262@Mir(bb1356[1])
bb1357:
  _3219 = move _3261
  using: _3261@Mir(bb1356[2])
  goto -> bb1352
  using: 
bb1358:
  _3263 = _3218
  using: _3218@Mir(bb1351[1])
  _3264 = const 0_usize
  using: 
  _3217[_3264] = move _3263
  using: _3264@Mir(bb1358[1]), _3263@Mir(bb1358[0])
  _3265 = _3218
  using: _3218@Mir(bb1351[1])
  _3267 = _8
  using: _8@Phi(bb1348)
  _3266 = move _3267 as usize (IntToInt)
  using: _3267@Mir(bb1358[4])
  _3268 = const 18002_usize
  using: 
  _3269 = Lt(_3266, _3268)
  using: _3266@Mir(bb1358[5]), _3268@Mir(bb1358[6])
  assert(move _3269, "index out of bounds: the length is {} but the index is {}", move _3268, _3266) -> bb1359
  using: _3269@Entry, _3268@Entry, _3266@Entry
bb1359:
  ((*_1).33: [u8; 18002])[_3266] = move _3265
  using: _1@Phi(bb1348), _3266@Mir(bb1358[5]), _3265@Mir(bb1358[3])
  _3270 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1348)
  assert(!move (_3270.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1360
  using: _3270@Entry, _8@Entry
bb1360:
  _8 = move (_3270.0: i32)
  using: _3270@Mir(bb1359[1])
  goto -> bb1348
  using: 
bb1361:
  _10 = const 0_i32
  using: 
  _2 = const 16916874950763617094_u64
  using: 
  goto -> bb1391
  using: 
bb1362:
  _3272 = _8
  using: _8@Mir(bb1347[0])
  _3273 = const 16_i32
  using: 
  _3271 = Lt(move _3272, move _3273)
  using: _3272@Mir(bb1362[0]), _3273@Mir(bb1362[1])
  switchInt(move _3271) -> [0: bb1366, otherwise: bb1363]
  using: _3271@Mir(bb1362[2])
bb1363:
  _3276 = _8
  using: _8@Mir(bb1347[0])
  _3275 = move _3276 as usize (IntToInt)
  using: _3276@Mir(bb1363[0])
  _3277 = const 16_usize
  using: 
  _3278 = Lt(_3275, _3277)
  using: _3275@Mir(bb1363[1]), _3277@Mir(bb1363[2])
  assert(move _3278, "index out of bounds: the length is {} but the index is {}", move _3277, _3275) -> bb1364
  using: _3278@Entry, _3277@Entry, _3275@Entry
bb1364:
  _3274 = ((*_1).29: [u8; 16])[_3275]
  using: _1@Phi(bb1348), _3275@Mir(bb1363[1])
  switchInt(move _3274) -> [0: bb1389, otherwise: bb1365]
  using: _3274@Mir(bb1364[0])
bb1365:
  _9 = const 0_i32
  using: 
  _2 = const 3854024847017804838_u64
  using: 
  goto -> bb1334
  using: 
bb1366:
  _3280 = _1
  using: _1@Phi(bb1348)
  _3279 = decompress::makeMaps_d(move _3280) -> bb1367
  using: _3280@Mir(bb1366[0])
bb1367:
  _3282 = ((*_1).27: i32)
  using: _1@Phi(bb1348)
  _3283 = const 0_i32
  using: 
  _3281 = Eq(move _3282, move _3283)
  using: _3282@Mir(bb1367[0]), _3283@Mir(bb1367[1])
  switchInt(move _3281) -> [0: bb1369, otherwise: bb1368]
  using: _3281@Mir(bb1367[2])
bb1368:
  _2 = const 11906008669688594715_u64
  using: 
  goto -> bb1391
  using: 
bb1369:
  _2 = const 7606051654693192361_u64
  using: 
  goto -> bb1391
  using: 
bb1370:
  _3284 = _22
  using: _22@Phi(bb1386)
  _3286 = _10
  using: _10@Phi(bb1334)
  _3285 = move _3286 as usize (IntToInt)
  using: _3286@Mir(bb1370[1])
  _3287 = const 6_usize
  using: 
  _3288 = Lt(_3285, _3287)
  using: _3285@Mir(bb1370[2]), _3287@Mir(bb1370[3])
  assert(move _3288, "index out of bounds: the length is {} but the index is {}", move _3287, _3285) -> bb1371
  using: _3288@Entry, _3287@Entry, _3285@Entry
bb1371:
  _3290 = _8
  using: _8@Mir(bb1347[0])
  _3289 = move _3290 as usize (IntToInt)
  using: _3290@Mir(bb1371[0])
  _3291 = const 258_usize
  using: 
  _3292 = Lt(_3289, _3291)
  using: _3289@Mir(bb1371[1]), _3291@Mir(bb1371[2])
  assert(move _3292, "index out of bounds: the length is {} but the index is {}", move _3291, _3289) -> bb1372
  using: _3292@Entry, _3291@Entry, _3289@Entry
bb1372:
  ((*_1).35: [[u8; 258]; 6])[_3285][_3289] = move _3284 as u8 (IntToInt)
  using: _1@Phi(bb1348), _3289@Mir(bb1371[1]), _3285@Mir(bb1370[2]), _3284@Mir(bb1370[0])
  _3293 = CheckedAdd(_8, const 1_i32)
  using: _8@Mir(bb1347[0])
  assert(!move (_3293.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1373
  using: _3293@Entry, _8@Entry
bb1373:
  _8 = move (_3293.0: i32)
  using: _3293@Mir(bb1372[1])
  _2 = const 3770765986603902964_u64
  using: 
  goto -> bb1334
  using: 
bb1374:
  _3295 = _8
  using: _8@Mir(bb1347[0])
  _3296 = _11
  using: _11@Phi(bb1334)
  _3294 = Lt(move _3295, move _3296)
  using: _3295@Mir(bb1374[0]), _3296@Mir(bb1374[1])
  switchInt(move _3294) -> [0: bb1376, otherwise: bb1375]
  using: _3294@Mir(bb1374[2])
bb1375:
  _2 = const 11858046780433112516_u64
  using: 
  goto -> bb1334
  using: 
bb1376:
  _3297 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb1334)
  assert(!move (_3297.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb1377
  using: _3297@Entry, _10@Entry
bb1377:
  _10 = move (_3297.0: i32)
  using: _3297@Mir(bb1376[0])
  _2 = const 16916874950763617094_u64
  using: 
  goto -> bb1391
  using: 
bb1378:
  _3299 = _8
  using: _8@Mir(bb1347[0])
  _3300 = const 18002_i32
  using: 
  _3298 = Lt(move _3299, move _3300)
  using: _3299@Mir(bb1378[0]), _3300@Mir(bb1378[1])
  switchInt(move _3298) -> [0: bb1381, otherwise: bb1379]
  using: _3298@Mir(bb1378[2])
bb1379:
  _3301 = _9
  using: _9@Phi(bb1334)
  _3303 = _8
  using: _8@Mir(bb1347[0])
  _3302 = move _3303 as usize (IntToInt)
  using: _3303@Mir(bb1379[1])
  _3304 = const 18002_usize
  using: 
  _3305 = Lt(_3302, _3304)
  using: _3302@Mir(bb1379[2]), _3304@Mir(bb1379[3])
  assert(move _3305, "index out of bounds: the length is {} but the index is {}", move _3304, _3302) -> bb1380
  using: _3305@Entry, _3304@Entry, _3302@Entry
bb1380:
  ((*_1).34: [u8; 18002])[_3302] = move _3301 as u8 (IntToInt)
  using: _1@Phi(bb1348), _3302@Mir(bb1379[2]), _3301@Mir(bb1379[0])
  goto -> bb1381
  using: 
bb1381:
  _3306 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1381)
  assert(!move (_3306.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1382
  using: _3306@Entry, _8@Entry
bb1382:
  _8 = move (_3306.0: i32)
  using: _3306@Mir(bb1381[0])
  _2 = const 6591141407893725683_u64
  using: 
  goto -> bb1334
  using: 
bb1383:
  _2 = const 4874723077730206021_u64
  using: 
  goto -> bb634
  using: 
bb1384:
  _3308 = const true
  using: 
  goto -> bb1386
  using: 
bb1385:
  _3313 = _22
  using: _22@Phi(bb1334)
  _3314 = const 20_i32
  using: 
  _3312 = Gt(move _3313, move _3314)
  using: _3313@Mir(bb1385[0]), _3314@Mir(bb1385[1])
  _3308 = move _3312
  using: _3312@Mir(bb1385[2])
  goto -> bb1386
  using: 
bb1386:
  _3307 = Not(move _3308)
  using: _3308@Phi(bb1386)
  switchInt(move _3307) -> [0: bb1388, otherwise: bb1387]
  using: _3307@Mir(bb1386[0])
bb1387:
  _2 = const 1736021991379636935_u64
  using: 
  goto -> bb634
  using: 
bb1388:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1389:
  _3315 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1389)
  assert(!move (_3315.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1390
  using: _3315@Entry, _8@Entry
bb1390:
  _8 = move (_3315.0: i32)
  using: _3315@Mir(bb1389[0])
  _2 = const 3472349144349095221_u64
  using: 
  goto -> bb1334
  using: 
bb1391:
  switchInt(_2) -> [7606051654693192361: bb1393, 11906008669688594715: bb1395, otherwise: bb1392]
  using: _2@Phi(bb1391)
bb1392:
  _3320 = _10
  using: _10@Phi(bb1391)
  _3321 = _12
  using: _12@Phi(bb1391)
  _3319 = Lt(move _3320, move _3321)
  using: _3320@Mir(bb1392[0]), _3321@Mir(bb1392[1])
  switchInt(move _3319) -> [0: bb1397, otherwise: bb1396]
  using: _3319@Mir(bb1392[2])
bb1393:
  _3316 = ((*_1).27: i32)
  using: _1@Phi(bb1475)
  _3317 = const 2_i32
  using: 
  _3318 = CheckedAdd(_3316, _3317)
  using: _3316@Mir(bb1393[0]), _3317@Mir(bb1393[1])
  assert(!move (_3318.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3316, move _3317) -> bb1394
  using: _3318@Entry, _3316@Entry, _3317@Entry
bb1394:
  _11 = move (_3318.0: i32)
  using: _3318@Mir(bb1393[2])
  _2 = const 3906616468301123675_u64
  using: 
  goto -> bb634
  using: 
bb1395:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1396:
  _2 = const 10945178116989557996_u64
  using: 
  goto -> bb634
  using: 
bb1397:
  _10 = const 0_i32
  using: 
  goto -> bb1398
  using: 
bb1398:
  _3323 = _10
  using: _10@Phi(bb1398)
  _3324 = _12
  using: _12@Phi(bb1391)
  _3322 = Lt(move _3323, move _3324)
  using: _3323@Mir(bb1398[0]), _3324@Mir(bb1398[1])
  switchInt(move _3322) -> [0: bb1435, otherwise: bb1399]
  using: _3322@Mir(bb1398[2])
bb1399:
  _5 = const 32_i32
  using: 
  _6 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  goto -> bb1400
  using: 
bb1400:
  _3326 = _8
  using: _8@Phi(bb1400)
  _3327 = _11
  using: _11@Phi(bb1398)
  _3325 = Lt(move _3326, move _3327)
  using: _3326@Mir(bb1400[0]), _3327@Mir(bb1400[1])
  switchInt(move _3325) -> [0: bb1415, otherwise: bb1401]
  using: _3325@Mir(bb1400[2])
bb1401:
  _3332 = _10
  using: _10@Phi(bb1400)
  _3331 = move _3332 as usize (IntToInt)
  using: _3332@Mir(bb1401[0])
  _3333 = const 6_usize
  using: 
  _3334 = Lt(_3331, _3333)
  using: _3331@Mir(bb1401[1]), _3333@Mir(bb1401[2])
  assert(move _3334, "index out of bounds: the length is {} but the index is {}", move _3333, _3331) -> bb1402
  using: _3334@Entry, _3333@Entry, _3331@Entry
bb1402:
  _3336 = _8
  using: _8@Phi(bb1400)
  _3335 = move _3336 as usize (IntToInt)
  using: _3336@Mir(bb1402[0])
  _3337 = const 258_usize
  using: 
  _3338 = Lt(_3335, _3337)
  using: _3335@Mir(bb1402[1]), _3337@Mir(bb1402[2])
  assert(move _3338, "index out of bounds: the length is {} but the index is {}", move _3337, _3335) -> bb1403
  using: _3338@Entry, _3337@Entry, _3335@Entry
bb1403:
  _3330 = ((*_1).35: [[u8; 258]; 6])[_3331][_3335]
  using: _1@Phi(bb1400), _3335@Mir(bb1402[1]), _3331@Mir(bb1401[1])
  _3329 = move _3330 as i32 (IntToInt)
  using: _3330@Mir(bb1403[0])
  _3339 = _6
  using: _6@Phi(bb1400)
  _3328 = Gt(move _3329, move _3339)
  using: _3329@Mir(bb1403[1]), _3339@Mir(bb1403[2])
  switchInt(move _3328) -> [0: bb1407, otherwise: bb1404]
  using: _3328@Mir(bb1403[3])
bb1404:
  _3342 = _10
  using: _10@Phi(bb1400)
  _3341 = move _3342 as usize (IntToInt)
  using: _3342@Mir(bb1404[0])
  _3343 = const 6_usize
  using: 
  _3344 = Lt(_3341, _3343)
  using: _3341@Mir(bb1404[1]), _3343@Mir(bb1404[2])
  assert(move _3344, "index out of bounds: the length is {} but the index is {}", move _3343, _3341) -> bb1405
  using: _3344@Entry, _3343@Entry, _3341@Entry
bb1405:
  _3346 = _8
  using: _8@Phi(bb1400)
  _3345 = move _3346 as usize (IntToInt)
  using: _3346@Mir(bb1405[0])
  _3347 = const 258_usize
  using: 
  _3348 = Lt(_3345, _3347)
  using: _3345@Mir(bb1405[1]), _3347@Mir(bb1405[2])
  assert(move _3348, "index out of bounds: the length is {} but the index is {}", move _3347, _3345) -> bb1406
  using: _3348@Entry, _3347@Entry, _3345@Entry
bb1406:
  _3340 = ((*_1).35: [[u8; 258]; 6])[_3341][_3345]
  using: _1@Phi(bb1400), _3345@Mir(bb1405[1]), _3341@Mir(bb1404[1])
  _6 = move _3340 as i32 (IntToInt)
  using: _3340@Mir(bb1406[0])
  goto -> bb1407
  using: 
bb1407:
  _3353 = _10
  using: _10@Phi(bb1407)
  _3352 = move _3353 as usize (IntToInt)
  using: _3353@Mir(bb1407[0])
  _3354 = const 6_usize
  using: 
  _3355 = Lt(_3352, _3354)
  using: _3352@Mir(bb1407[1]), _3354@Mir(bb1407[2])
  assert(move _3355, "index out of bounds: the length is {} but the index is {}", move _3354, _3352) -> bb1408
  using: _3355@Entry, _3354@Entry, _3352@Entry
bb1408:
  _3357 = _8
  using: _8@Phi(bb1407)
  _3356 = move _3357 as usize (IntToInt)
  using: _3357@Mir(bb1408[0])
  _3358 = const 258_usize
  using: 
  _3359 = Lt(_3356, _3358)
  using: _3356@Mir(bb1408[1]), _3358@Mir(bb1408[2])
  assert(move _3359, "index out of bounds: the length is {} but the index is {}", move _3358, _3356) -> bb1409
  using: _3359@Entry, _3358@Entry, _3356@Entry
bb1409:
  _3351 = ((*_1).35: [[u8; 258]; 6])[_3352][_3356]
  using: _1@Phi(bb1407), _3356@Mir(bb1408[1]), _3352@Mir(bb1407[1])
  _3350 = move _3351 as i32 (IntToInt)
  using: _3351@Mir(bb1409[0])
  _3360 = _5
  using: _5@Phi(bb1400)
  _3349 = Lt(move _3350, move _3360)
  using: _3350@Mir(bb1409[1]), _3360@Mir(bb1409[2])
  switchInt(move _3349) -> [0: bb1413, otherwise: bb1410]
  using: _3349@Mir(bb1409[3])
bb1410:
  _3363 = _10
  using: _10@Phi(bb1407)
  _3362 = move _3363 as usize (IntToInt)
  using: _3363@Mir(bb1410[0])
  _3364 = const 6_usize
  using: 
  _3365 = Lt(_3362, _3364)
  using: _3362@Mir(bb1410[1]), _3364@Mir(bb1410[2])
  assert(move _3365, "index out of bounds: the length is {} but the index is {}", move _3364, _3362) -> bb1411
  using: _3365@Entry, _3364@Entry, _3362@Entry
bb1411:
  _3367 = _8
  using: _8@Phi(bb1407)
  _3366 = move _3367 as usize (IntToInt)
  using: _3367@Mir(bb1411[0])
  _3368 = const 258_usize
  using: 
  _3369 = Lt(_3366, _3368)
  using: _3366@Mir(bb1411[1]), _3368@Mir(bb1411[2])
  assert(move _3369, "index out of bounds: the length is {} but the index is {}", move _3368, _3366) -> bb1412
  using: _3369@Entry, _3368@Entry, _3366@Entry
bb1412:
  _3361 = ((*_1).35: [[u8; 258]; 6])[_3362][_3366]
  using: _1@Phi(bb1407), _3366@Mir(bb1411[1]), _3362@Mir(bb1410[1])
  _5 = move _3361 as i32 (IntToInt)
  using: _3361@Mir(bb1412[0])
  goto -> bb1413
  using: 
bb1413:
  _3370 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1413)
  assert(!move (_3370.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1414
  using: _3370@Entry, _8@Entry
bb1414:
  _8 = move (_3370.0: i32)
  using: _3370@Mir(bb1413[0])
  goto -> bb1400
  using: 
bb1415:
  _3381 = &mut ((*_1).36: [[i32; 258]; 6])
  using: _1@Phi(bb1413)
  _3380 = move _3381 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3381@Mir(bb1415[0])
  _3379 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3380) -> bb1416
  using: _3380@Mir(bb1415[1])
bb1416:
  _3383 = _10
  using: _10@Phi(bb1413)
  _3382 = move _3383 as isize (IntToInt)
  using: _3383@Mir(bb1416[0])
  _3378 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3379, move _3382) -> bb1417
  using: _3379@Mir(bb1415[2]), _3382@Mir(bb1416[1])
bb1417:
  _3377 = &mut (*_3378)
  using: _3378@Mir(bb1416[2])
  _3376 = move _3377 as &mut [i32] (Pointer(Unsize))
  using: _3377@Mir(bb1417[0])
  _3375 = core::slice::<impl [i32]>::as_mut_ptr(move _3376) -> bb1418
  using: _3376@Mir(bb1417[1])
bb1418:
  _3384 = const 0_isize
  using: 
  _3374 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3375, move _3384) -> bb1419
  using: _3375@Mir(bb1417[2]), _3384@Mir(bb1418[0])
bb1419:
  _3373 = &mut (*_3374)
  using: _3374@Mir(bb1418[1])
  _3372 = &raw mut (*_3373)
  using: _3373@Mir(bb1419[0])
  _3394 = &mut ((*_1).37: [[i32; 258]; 6])
  using: _1@Phi(bb1413)
  _3393 = move _3394 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3394@Mir(bb1419[2])
  _3392 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3393) -> bb1420
  using: _3393@Mir(bb1419[3])
bb1420:
  _3396 = _10
  using: _10@Phi(bb1413)
  _3395 = move _3396 as isize (IntToInt)
  using: _3396@Mir(bb1420[0])
  _3391 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3392, move _3395) -> bb1421
  using: _3392@Mir(bb1419[4]), _3395@Mir(bb1420[1])
bb1421:
  _3390 = &mut (*_3391)
  using: _3391@Mir(bb1420[2])
  _3389 = move _3390 as &mut [i32] (Pointer(Unsize))
  using: _3390@Mir(bb1421[0])
  _3388 = core::slice::<impl [i32]>::as_mut_ptr(move _3389) -> bb1422
  using: _3389@Mir(bb1421[1])
bb1422:
  _3397 = const 0_isize
  using: 
  _3387 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3388, move _3397) -> bb1423
  using: _3388@Mir(bb1421[2]), _3397@Mir(bb1422[0])
bb1423:
  _3386 = &mut (*_3387)
  using: _3387@Mir(bb1422[1])
  _3385 = &raw mut (*_3386)
  using: _3386@Mir(bb1423[0])
  _3407 = &mut ((*_1).38: [[i32; 258]; 6])
  using: _1@Phi(bb1413)
  _3406 = move _3407 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3407@Mir(bb1423[2])
  _3405 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3406) -> bb1424
  using: _3406@Mir(bb1423[3])
bb1424:
  _3409 = _10
  using: _10@Phi(bb1413)
  _3408 = move _3409 as isize (IntToInt)
  using: _3409@Mir(bb1424[0])
  _3404 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3405, move _3408) -> bb1425
  using: _3405@Mir(bb1423[4]), _3408@Mir(bb1424[1])
bb1425:
  _3403 = &mut (*_3404)
  using: _3404@Mir(bb1424[2])
  _3402 = move _3403 as &mut [i32] (Pointer(Unsize))
  using: _3403@Mir(bb1425[0])
  _3401 = core::slice::<impl [i32]>::as_mut_ptr(move _3402) -> bb1426
  using: _3402@Mir(bb1425[1])
bb1426:
  _3410 = const 0_isize
  using: 
  _3400 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3401, move _3410) -> bb1427
  using: _3401@Mir(bb1425[2]), _3410@Mir(bb1426[0])
bb1427:
  _3399 = &mut (*_3400)
  using: _3400@Mir(bb1426[1])
  _3398 = &raw mut (*_3399)
  using: _3399@Mir(bb1427[0])
  _3420 = &mut ((*_1).35: [[u8; 258]; 6])
  using: _1@Phi(bb1413)
  _3419 = move _3420 as &mut [[u8; 258]] (Pointer(Unsize))
  using: _3420@Mir(bb1427[2])
  _3418 = core::slice::<impl [[u8; 258]]>::as_mut_ptr(move _3419) -> bb1428
  using: _3419@Mir(bb1427[3])
bb1428:
  _3422 = _10
  using: _10@Phi(bb1413)
  _3421 = move _3422 as isize (IntToInt)
  using: _3422@Mir(bb1428[0])
  _3417 = std::ptr::mut_ptr::<impl *mut [u8; 258]>::offset(move _3418, move _3421) -> bb1429
  using: _3418@Mir(bb1427[4]), _3421@Mir(bb1428[1])
bb1429:
  _3416 = &mut (*_3417)
  using: _3417@Mir(bb1428[2])
  _3415 = move _3416 as &mut [u8] (Pointer(Unsize))
  using: _3416@Mir(bb1429[0])
  _3414 = core::slice::<impl [u8]>::as_mut_ptr(move _3415) -> bb1430
  using: _3415@Mir(bb1429[1])
bb1430:
  _3423 = const 0_isize
  using: 
  _3413 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _3414, move _3423) -> bb1431
  using: _3414@Mir(bb1429[2]), _3423@Mir(bb1430[0])
bb1431:
  _3412 = &mut (*_3413)
  using: _3413@Mir(bb1430[1])
  _3411 = &raw mut (*_3412)
  using: _3412@Mir(bb1431[0])
  _3424 = _5
  using: _5@Phi(bb1413)
  _3425 = _6
  using: _6@Phi(bb1407)
  _3426 = _11
  using: _11@Phi(bb1398)
  _3371 = huffman::BZ2_hbCreateDecodeTables(move _3372, move _3385, move _3398, move _3411, move _3424, move _3425, move _3426) -> bb1432
  using: _3372@Mir(bb1419[1]), _3385@Mir(bb1423[1]), _3398@Mir(bb1427[1]), _3411@Mir(bb1431[1]), _3424@Mir(bb1431[2]), _3425@Mir(bb1431[3]), _3426@Mir(bb1431[4])
bb1432:
  _3427 = _5
  using: _5@Phi(bb1413)
  _3429 = _10
  using: _10@Phi(bb1413)
  _3428 = move _3429 as usize (IntToInt)
  using: _3429@Mir(bb1432[1])
  _3430 = const 6_usize
  using: 
  _3431 = Lt(_3428, _3430)
  using: _3428@Mir(bb1432[2]), _3430@Mir(bb1432[3])
  assert(move _3431, "index out of bounds: the length is {} but the index is {}", move _3430, _3428) -> bb1433
  using: _3431@Entry, _3430@Entry, _3428@Entry
bb1433:
  ((*_1).39: [i32; 6])[_3428] = move _3427
  using: _1@Phi(bb1413), _3428@Mir(bb1432[2]), _3427@Mir(bb1432[0])
  _3432 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb1413)
  assert(!move (_3432.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb1434
  using: _3432@Entry, _10@Entry
bb1434:
  _10 = move (_3432.0: i32)
  using: _3432@Mir(bb1433[1])
  goto -> bb1398
  using: 
bb1435:
  _3433 = ((*_1).27: i32)
  using: _1@Phi(bb1413)
  _3434 = const 1_i32
  using: 
  _3435 = CheckedAdd(_3433, _3434)
  using: _3433@Mir(bb1435[0]), _3434@Mir(bb1435[1])
  assert(!move (_3435.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3433, move _3434) -> bb1436
  using: _3435@Entry, _3433@Entry, _3434@Entry
bb1436:
  _14 = move (_3435.0: i32)
  using: _3435@Mir(bb1435[2])
  _3436 = const 100000_i32
  using: 
  _3437 = ((*_1).9: i32)
  using: _1@Phi(bb1413)
  _3438 = CheckedMul(_3436, _3437)
  using: _3436@Mir(bb1436[1]), _3437@Mir(bb1436[2])
  assert(!move (_3438.1: bool), "attempt to compute `{} * {}`, which would overflow", move _3436, move _3437) -> bb1437
  using: _3438@Entry, _3436@Entry, _3437@Entry
bb1437:
  _18 = move (_3438.0: i32)
  using: _3438@Mir(bb1436[3])
  _15 = const -1_i32
  using: 
  _16 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  goto -> bb1438
  using: 
bb1438:
  _3440 = _8
  using: _8@Phi(bb1438)
  _3441 = const 255_i32
  using: 
  _3439 = Le(move _3440, move _3441)
  using: _3440@Mir(bb1438[0]), _3441@Mir(bb1438[1])
  switchInt(move _3439) -> [0: bb1442, otherwise: bb1439]
  using: _3439@Mir(bb1438[2])
bb1439:
  _3442 = const 0_i32
  using: 
  _3444 = _8
  using: _8@Phi(bb1438)
  _3443 = move _3444 as usize (IntToInt)
  using: _3444@Mir(bb1439[1])
  _3445 = const 256_usize
  using: 
  _3446 = Lt(_3443, _3445)
  using: _3443@Mir(bb1439[2]), _3445@Mir(bb1439[3])
  assert(move _3446, "index out of bounds: the length is {} but the index is {}", move _3445, _3443) -> bb1440
  using: _3446@Entry, _3445@Entry, _3443@Entry
bb1440:
  ((*_1).16: [i32; 256])[_3443] = move _3442
  using: _1@Phi(bb1438), _3443@Mir(bb1439[2]), _3442@Mir(bb1439[0])
  _3447 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb1438)
  assert(!move (_3447.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb1441
  using: _3447@Entry, _8@Entry
bb1441:
  _8 = move (_3447.0: i32)
  using: _3447@Mir(bb1440[1])
  goto -> bb1438
  using: 
bb1442:
  _3448 = const 0_i32
  using: 
  _3449 = const 0_i32
  using: 
  _3450 = const 0_i32
  using: 
  _3450 = const 4095_i32
  using: 
  _3448 = const 15_i32
  using: 
  goto -> bb1443
  using: 
bb1443:
  _3452 = _3448
  using: _3448@Phi(bb1443)
  _3453 = const 0_i32
  using: 
  _3451 = Ge(move _3452, move _3453)
  using: _3452@Mir(bb1443[0]), _3453@Mir(bb1443[1])
  switchInt(move _3451) -> [0: bb1456, otherwise: bb1444]
  using: _3451@Mir(bb1443[2])
bb1444:
  _3449 = const 15_i32
  using: 
  goto -> bb1445
  using: 
bb1445:
  _3455 = _3449
  using: _3449@Phi(bb1445)
  _3456 = const 0_i32
  using: 
  _3454 = Ge(move _3455, move _3456)
  using: _3455@Mir(bb1445[0]), _3456@Mir(bb1445[1])
  switchInt(move _3454) -> [0: bb1452, otherwise: bb1446]
  using: _3454@Mir(bb1445[2])
bb1446:
  _3459 = _3448
  using: _3448@Phi(bb1445)
  _3460 = const 16_i32
  using: 
  _3461 = CheckedMul(_3459, _3460)
  using: _3459@Mir(bb1446[0]), _3460@Mir(bb1446[1])
  assert(!move (_3461.1: bool), "attempt to compute `{} * {}`, which would overflow", move _3459, move _3460) -> bb1447
  using: _3461@Entry, _3459@Entry, _3460@Entry
bb1447:
  _3458 = move (_3461.0: i32)
  using: _3461@Mir(bb1446[2])
  _3462 = _3449
  using: _3449@Phi(bb1445)
  _3463 = CheckedAdd(_3458, _3462)
  using: _3458@Mir(bb1447[0]), _3462@Mir(bb1447[1])
  assert(!move (_3463.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3458, move _3462) -> bb1448
  using: _3463@Entry, _3458@Entry, _3462@Entry
bb1448:
  _3457 = move (_3463.0: i32)
  using: _3463@Mir(bb1447[2])
  _3465 = _3450
  using: _3450@Phi(bb1445)
  _3464 = move _3465 as usize (IntToInt)
  using: _3465@Mir(bb1448[1])
  _3466 = const 4096_usize
  using: 
  _3467 = Lt(_3464, _3466)
  using: _3464@Mir(bb1448[2]), _3466@Mir(bb1448[3])
  assert(move _3467, "index out of bounds: the length is {} but the index is {}", move _3466, _3464) -> bb1449
  using: _3467@Entry, _3466@Entry, _3464@Entry
bb1449:
  ((*_1).31: [u8; 4096])[_3464] = move _3457 as u8 (IntToInt)
  using: _1@Phi(bb1445), _3464@Mir(bb1448[2]), _3457@Mir(bb1448[0])
  _3468 = CheckedSub(_3450, const 1_i32)
  using: _3450@Phi(bb1445)
  assert(!move (_3468.1: bool), "attempt to compute `{} - {}`, which would overflow", _3450, const 1_i32) -> bb1450
  using: _3468@Entry, _3450@Entry
bb1450:
  _3450 = move (_3468.0: i32)
  using: _3468@Mir(bb1449[1])
  _3469 = CheckedSub(_3449, const 1_i32)
  using: _3449@Phi(bb1445)
  assert(!move (_3469.1: bool), "attempt to compute `{} - {}`, which would overflow", _3449, const 1_i32) -> bb1451
  using: _3469@Entry, _3449@Entry
bb1451:
  _3449 = move (_3469.0: i32)
  using: _3469@Mir(bb1450[1])
  goto -> bb1445
  using: 
bb1452:
  _3470 = _3450
  using: _3450@Phi(bb1445)
  _3471 = const 1_i32
  using: 
  _3472 = CheckedAdd(_3470, _3471)
  using: _3470@Mir(bb1452[0]), _3471@Mir(bb1452[1])
  assert(!move (_3472.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3470, move _3471) -> bb1453
  using: _3472@Entry, _3470@Entry, _3471@Entry
bb1453:
  _3474 = _3448
  using: _3448@Phi(bb1445)
  _3473 = move _3474 as usize (IntToInt)
  using: _3474@Mir(bb1453[0])
  _3475 = const 16_usize
  using: 
  _3476 = Lt(_3473, _3475)
  using: _3473@Mir(bb1453[1]), _3475@Mir(bb1453[2])
  assert(move _3476, "index out of bounds: the length is {} but the index is {}", move _3475, _3473) -> bb1454
  using: _3476@Entry, _3475@Entry, _3473@Entry
bb1454:
  ((*_1).32: [i32; 16])[_3473] = move (_3472.0: i32)
  using: _1@Phi(bb1445), _3473@Mir(bb1453[1]), _3472@Mir(bb1452[2])
  _3477 = CheckedSub(_3448, const 1_i32)
  using: _3448@Phi(bb1445)
  assert(!move (_3477.1: bool), "attempt to compute `{} - {}`, which would overflow", _3448, const 1_i32) -> bb1455
  using: _3477@Entry, _3448@Entry
bb1455:
  _3448 = move (_3477.0: i32)
  using: _3477@Mir(bb1454[1])
  goto -> bb1443
  using: 
bb1456:
  _19 = const 0_i32
  using: 
  _3479 = _16
  using: _16@Mir(bb1437[2])
  _3480 = const 0_i32
  using: 
  _3478 = Eq(move _3479, move _3480)
  using: _3479@Mir(bb1456[1]), _3480@Mir(bb1456[2])
  switchInt(move _3478) -> [0: bb1475, otherwise: bb1457]
  using: _3478@Mir(bb1456[3])
bb1457:
  _3481 = CheckedAdd(_15, const 1_i32)
  using: _15@Mir(bb1437[1])
  assert(!move (_3481.1: bool), "attempt to compute `{} + {}`, which would overflow", _15, const 1_i32) -> bb1458
  using: _3481@Entry, _15@Entry
bb1458:
  _15 = move (_3481.0: i32)
  using: _3481@Mir(bb1457[0])
  _3483 = _15
  using: _15@Mir(bb1458[0])
  _3484 = _13
  using: _13@Phi(bb1391)
  _3482 = Ge(move _3483, move _3484)
  using: _3483@Mir(bb1458[1]), _3484@Mir(bb1458[2])
  switchInt(move _3482) -> [0: bb1460, otherwise: bb1459]
  using: _3482@Mir(bb1458[3])
bb1459:
  _4 = const -4_i32
  using: 
  _2 = const 15885526978618306830_u64
  using: 
  goto -> bb634
  using: 
bb1460:
  _16 = const 50_i32
  using: 
  _3487 = _15
  using: _15@Mir(bb1458[0])
  _3486 = move _3487 as usize (IntToInt)
  using: _3487@Mir(bb1460[1])
  _3488 = const 18002_usize
  using: 
  _3489 = Lt(_3486, _3488)
  using: _3486@Mir(bb1460[2]), _3488@Mir(bb1460[3])
  assert(move _3489, "index out of bounds: the length is {} but the index is {}", move _3488, _3486) -> bb1461
  using: _3489@Entry, _3488@Entry, _3486@Entry
bb1461:
  _3485 = ((*_1).33: [u8; 18002])[_3486]
  using: _1@Phi(bb1445), _3486@Mir(bb1460[2])
  _27 = move _3485 as i32 (IntToInt)
  using: _3485@Mir(bb1461[0])
  _3492 = _27
  using: _27@Mir(bb1461[1])
  _3491 = move _3492 as usize (IntToInt)
  using: _3492@Mir(bb1461[2])
  _3493 = const 6_usize
  using: 
  _3494 = Lt(_3491, _3493)
  using: _3491@Mir(bb1461[3]), _3493@Mir(bb1461[4])
  assert(move _3494, "index out of bounds: the length is {} but the index is {}", move _3493, _3491) -> bb1462
  using: _3494@Entry, _3493@Entry, _3491@Entry
bb1462:
  _3490 = ((*_1).39: [i32; 6])[_3491]
  using: _1@Phi(bb1445), _3491@Mir(bb1461[3])
  _28 = move _3490
  using: _3490@Mir(bb1462[0])
  _3504 = &mut ((*_1).36: [[i32; 258]; 6])
  using: _1@Phi(bb1445)
  _3503 = move _3504 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3504@Mir(bb1462[2])
  _3502 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3503) -> bb1463
  using: _3503@Mir(bb1462[3])
bb1463:
  _3506 = _27
  using: _27@Mir(bb1461[1])
  _3505 = move _3506 as isize (IntToInt)
  using: _3506@Mir(bb1463[0])
  _3501 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3502, move _3505) -> bb1464
  using: _3502@Mir(bb1462[4]), _3505@Mir(bb1463[1])
bb1464:
  _3500 = &mut (*_3501)
  using: _3501@Mir(bb1463[2])
  _3499 = move _3500 as &mut [i32] (Pointer(Unsize))
  using: _3500@Mir(bb1464[0])
  _3498 = core::slice::<impl [i32]>::as_mut_ptr(move _3499) -> bb1465
  using: _3499@Mir(bb1464[1])
bb1465:
  _3507 = const 0_isize
  using: 
  _3497 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3498, move _3507) -> bb1466
  using: _3498@Mir(bb1464[2]), _3507@Mir(bb1465[0])
bb1466:
  _3496 = &mut (*_3497)
  using: _3497@Mir(bb1465[1])
  _3495 = &raw mut (*_3496)
  using: _3496@Mir(bb1466[0])
  _29 = move _3495
  using: _3495@Mir(bb1466[1])
  _3517 = &mut ((*_1).38: [[i32; 258]; 6])
  using: _1@Phi(bb1445)
  _3516 = move _3517 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3517@Mir(bb1466[3])
  _3515 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3516) -> bb1467
  using: _3516@Mir(bb1466[4])
bb1467:
  _3519 = _27
  using: _27@Mir(bb1461[1])
  _3518 = move _3519 as isize (IntToInt)
  using: _3519@Mir(bb1467[0])
  _3514 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3515, move _3518) -> bb1468
  using: _3515@Mir(bb1466[5]), _3518@Mir(bb1467[1])
bb1468:
  _3513 = &mut (*_3514)
  using: _3514@Mir(bb1467[2])
  _3512 = move _3513 as &mut [i32] (Pointer(Unsize))
  using: _3513@Mir(bb1468[0])
  _3511 = core::slice::<impl [i32]>::as_mut_ptr(move _3512) -> bb1469
  using: _3512@Mir(bb1468[1])
bb1469:
  _3520 = const 0_isize
  using: 
  _3510 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3511, move _3520) -> bb1470
  using: _3511@Mir(bb1468[2]), _3520@Mir(bb1469[0])
bb1470:
  _3509 = &mut (*_3510)
  using: _3510@Mir(bb1469[1])
  _3508 = &raw mut (*_3509)
  using: _3509@Mir(bb1470[0])
  _31 = move _3508
  using: _3508@Mir(bb1470[1])
  _3530 = &mut ((*_1).37: [[i32; 258]; 6])
  using: _1@Phi(bb1445)
  _3529 = move _3530 as &mut [[i32; 258]] (Pointer(Unsize))
  using: _3530@Mir(bb1470[3])
  _3528 = core::slice::<impl [[i32; 258]]>::as_mut_ptr(move _3529) -> bb1471
  using: _3529@Mir(bb1470[4])
bb1471:
  _3532 = _27
  using: _27@Mir(bb1461[1])
  _3531 = move _3532 as isize (IntToInt)
  using: _3532@Mir(bb1471[0])
  _3527 = std::ptr::mut_ptr::<impl *mut [i32; 258]>::offset(move _3528, move _3531) -> bb1472
  using: _3528@Mir(bb1470[5]), _3531@Mir(bb1471[1])
bb1472:
  _3526 = &mut (*_3527)
  using: _3527@Mir(bb1471[2])
  _3525 = move _3526 as &mut [i32] (Pointer(Unsize))
  using: _3526@Mir(bb1472[0])
  _3524 = core::slice::<impl [i32]>::as_mut_ptr(move _3525) -> bb1473
  using: _3525@Mir(bb1472[1])
bb1473:
  _3533 = const 0_isize
  using: 
  _3523 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _3524, move _3533) -> bb1474
  using: _3524@Mir(bb1472[2]), _3533@Mir(bb1473[0])
bb1474:
  _3522 = &mut (*_3523)
  using: _3523@Mir(bb1473[1])
  _3521 = &raw mut (*_3522)
  using: _3522@Mir(bb1474[0])
  _30 = move _3521
  using: _3521@Mir(bb1474[1])
  goto -> bb1475
  using: 
bb1475:
  _3534 = CheckedSub(_16, const 1_i32)
  using: _16@Phi(bb1475)
  assert(!move (_3534.1: bool), "attempt to compute `{} - {}`, which would overflow", _16, const 1_i32) -> bb1476
  using: _3534@Entry, _16@Entry
bb1476:
  _16 = move (_3534.0: i32)
  using: _3534@Mir(bb1475[0])
  _3535 = _28
  using: _28@Phi(bb1475)
  _24 = move _3535
  using: _3535@Mir(bb1476[1])
  _2 = const 16722720626876144162_u64
  using: 
  goto -> bb634
  using: 
bb1477:
  return
  using: _0@Phi(bb1477)
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:186:65: 186:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:188:47: 188:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:190:52: 190:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:194:56: 194:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:286:65: 286:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:288:47: 288:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:290:52: 290:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:294:56: 294:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:338:65: 338:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:340:47: 340:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:342:52: 342:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:346:56: 346:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:390:65: 390:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:392:47: 392:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:394:52: 394:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:398:56: 398:71 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/decompress.rs:415:49: 415:84 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/decompress.rs:422:126: 422:157 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/bzip2/rust/decompress.rs:422:113: 424:144 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/decompress.rs:432:49: 432:84 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/decompress.rs:447:126: 447:156 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/bzip2/rust/decompress.rs:447:113: 449:144 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/bzip2/rust/decompress.rs:462:49: 462:84 (#0) by default
rewrite call std::mem::size_of @ workspace/bzip2/rust/decompress.rs:469:126: 469:156 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/bzip2/rust/decompress.rs:469:113: 471:144 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:517:65: 517:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:519:47: 519:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:521:52: 521:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:525:56: 525:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:571:65: 571:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:573:47: 573:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:575:52: 575:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:579:56: 579:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:620:65: 620:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:622:47: 622:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:624:52: 624:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:628:56: 628:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:672:65: 672:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:674:47: 674:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:676:52: 676:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:680:56: 680:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:721:65: 721:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:723:47: 723:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:725:52: 725:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:729:56: 729:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:773:65: 773:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:775:47: 775:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:777:52: 777:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:781:56: 781:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:822:65: 822:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:824:47: 824:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:826:52: 826:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:830:56: 830:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:874:65: 874:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:876:47: 876:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:878:52: 878:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:882:56: 882:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:923:65: 923:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:925:47: 925:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:927:52: 927:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:931:56: 931:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:975:65: 975:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:977:47: 977:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:979:52: 979:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:983:56: 983:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1027:65: 1027:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1029:47: 1029:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1031:52: 1031:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1035:56: 1035:71 (#0) by default
rewrite call decompress::fprintf @ workspace/bzip2/rust/decompress.rs:1048:29: 1051:54 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1089:65: 1089:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1091:47: 1091:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1093:52: 1093:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1097:56: 1097:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1138:65: 1138:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1140:47: 1140:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1142:52: 1142:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1146:56: 1146:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1190:65: 1190:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1192:47: 1192:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1194:52: 1194:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1198:56: 1198:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1239:65: 1239:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1241:47: 1241:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1243:52: 1243:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1247:56: 1247:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1291:65: 1291:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1293:47: 1293:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1295:52: 1295:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1299:56: 1299:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1340:65: 1340:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1342:47: 1342:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1344:52: 1344:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1348:56: 1348:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1392:65: 1392:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1394:47: 1394:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1396:52: 1396:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1400:56: 1400:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1441:65: 1441:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1443:47: 1443:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1445:52: 1445:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1449:56: 1449:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1495:65: 1495:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1497:47: 1497:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1499:52: 1499:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1503:56: 1503:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1545:65: 1545:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1547:47: 1547:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1549:52: 1549:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1553:56: 1553:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1596:65: 1596:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1598:47: 1598:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1600:52: 1600:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1604:56: 1604:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1647:65: 1647:74 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1649:47: 1649:62 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1651:52: 1651:67 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1655:56: 1655:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1711:54: 1711:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1713:55: 1713:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1715:60: 1715:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1719:64: 1719:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1750:54: 1750:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1752:55: 1752:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1754:60: 1754:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1758:64: 1758:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1789:54: 1789:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1791:55: 1791:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1793:60: 1793:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1797:64: 1797:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1828:54: 1828:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1830:55: 1830:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1832:60: 1832:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1836:64: 1836:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1867:54: 1867:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1869:55: 1869:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1871:60: 1871:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1875:64: 1875:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1906:54: 1906:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1908:55: 1908:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1910:60: 1910:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1914:64: 1914:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1948:54: 1948:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1950:55: 1950:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1952:60: 1952:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1956:64: 1956:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:1991:54: 1991:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:1993:55: 1993:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1995:60: 1995:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:1999:64: 1999:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2031:54: 2031:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2033:55: 2033:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2035:60: 2035:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2039:64: 2039:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2079:54: 2079:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2081:55: 2081:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2083:60: 2083:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2087:64: 2087:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2125:54: 2125:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2127:55: 2127:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2129:60: 2129:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2133:64: 2133:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2171:54: 2171:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2173:55: 2173:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2175:60: 2175:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2179:64: 2179:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2228:54: 2228:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2230:55: 2230:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2232:60: 2232:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2236:64: 2236:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2274:54: 2274:63 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2276:55: 2276:70 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2278:60: 2278:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2282:64: 2282:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2296:47: 2296:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2297:42: 2297:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2299:46: 2299:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2307:59: 2307:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2306:40: 2308:60 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2322:47: 2322:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2323:42: 2323:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2325:46: 2325:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2333:59: 2333:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2332:40: 2334:60 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2357:56: 2357:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2371:54: 2371:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2392:47: 2392:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2393:42: 2393:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2395:46: 2395:65 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2403:59: 2403:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2402:40: 2404:60 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2446:78: 2446:94 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2453:72: 2453:88 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2472:72: 2476:102 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2486:82: 2486:98 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2486:99: 2490:129 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/decompress.rs:2483:78: 2483:94 (#0) by default
rewrite call core::num::<impl u32>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:2492:49: 2492:64 (#0) by default
rewrite call core::num::<impl u32>::wrapping_div @ workspace/bzip2/rust/decompress.rs:2498:44: 2499:82 (#0) by default
rewrite call core::num::<impl u32>::wrapping_rem @ workspace/bzip2/rust/decompress.rs:2502:44: 2503:82 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2566:48: 2566:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2569:46: 2569:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2586:77: 2588:94 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2588:109: 2592:126 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2595:76: 2597:93 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2597:108: 2601:125 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2604:76: 2606:93 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2606:108: 2610:125 (#0) by default
rewrite call decompress::fprintf @ workspace/bzip2/rust/decompress.rs:2693:37: 2695:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2709:56: 2709:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2711:52: 2711:70 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2721:60: 2725:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2717:55: 2720:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2737:60: 2741:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2733:55: 2736:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2757:53: 2757:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2759:57: 2762:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2771:57: 2771:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2773:61: 2777:78 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2786:52: 2786:70 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2795:60: 2799:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2791:55: 2794:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2809:60: 2813:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2805:55: 2808:75 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/decompress.rs:2831:61: 2833:85 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/decompress.rs:2880:61: 2882:85 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2842:56: 2843:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2845:60: 2850:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2891:56: 2892:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2894:60: 2899:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2916:55: 2916:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2919:50: 2921:74 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2927:50: 2927:79 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/decompress.rs:2935:61: 2937:85 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2943:54: 2944:71 (#0) by default
rewrite call core::num::<impl u32>::wrapping_mul @ workspace/bzip2/rust/decompress.rs:2971:61: 2973:85 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:2979:54: 2980:71 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3035:69: 3037:86 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3037:101: 3041:118 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3044:68: 3046:85 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3046:100: 3050:117 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3053:68: 3055:85 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3055:100: 3059:117 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_u8; 6] is not supported
rewrite call core::num::<impl u8>::wrapping_add @ workspace/bzip2/rust/decompress.rs:3101:45: 3101:60 (#0) by default
rewrite call core::num::<impl u8>::wrapping_sub @ workspace/bzip2/rust/decompress.rs:3111:49: 3111:64 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3229:98: 3231:99 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3231:114: 3235:131 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3236:81: 3238:98 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3238:113: 3242:130 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3243:81: 3245:98 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3245:113: 3249:130 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3250:80: 3252:97 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3252:112: 3256:129 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3303:65: 3304:82 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3304:97: 3308:114 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3311:64: 3312:81 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3312:96: 3316:113 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3319:64: 3320:81 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/decompress.rs:3320:96: 3324:113 (#0) by default
@DefId(0:466 ~ c2rust_lib[1043]::huffman::BZ2_hbMakeCodeLengths)
bb0:
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _12 = const 0_u8
  using: 
  _13 = [const 0_i32; 260]
  using: 
  _14 = [const 0_i32; 516]
  using: 
  _15 = [const 0_i32; 516]
  using: 
  _9 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _17 = _9
  using: _9@Phi(bb1)
  _18 = _3
  using: _3@Entry
  _16 = Lt(move _17, move _18)
  using: _17@Mir(bb1[0]), _18@Mir(bb1[1])
  switchInt(move _16) -> [0: bb12, otherwise: bb2]
  using: _16@Mir(bb1[2])
bb2:
  _23 = _2
  using: _2@Phi(bb1)
  _25 = _9
  using: _9@Phi(bb1)
  _24 = move _25 as isize (IntToInt)
  using: _25@Mir(bb2[1])
  _22 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _23, move _24) -> bb3
  using: _23@Mir(bb2[0]), _24@Mir(bb2[2])
bb3:
  _21 = (*_22)
  using: _22@Mir(bb2[3])
  _26 = const 0_i32
  using: 
  _20 = Eq(move _21, move _26)
  using: _21@Mir(bb3[0]), _26@Mir(bb3[1])
  switchInt(move _20) -> [0: bb5, otherwise: bb4]
  using: _20@Mir(bb3[2])
bb4:
  _19 = const 1_i32
  using: 
  goto -> bb7
  using: 
bb5:
  _28 = _2
  using: _2@Phi(bb1)
  _30 = _9
  using: _9@Phi(bb1)
  _29 = move _30 as isize (IntToInt)
  using: _30@Mir(bb5[1])
  _27 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _28, move _29) -> bb6
  using: _28@Mir(bb5[0]), _29@Mir(bb5[2])
bb6:
  _19 = (*_27)
  using: _27@Mir(bb5[3])
  goto -> bb7
  using: 
bb7:
  _31 = const 8_i32
  using: 
  _32 = CheckedShl(_19, _31)
  using: _19@Phi(bb7), _31@Mir(bb7[0])
  assert(!move (_32.1: bool), "attempt to shift left by `{}`, which would overflow", move _31) -> bb8
  using: _32@Entry, _19@Entry, _31@Entry
bb8:
  _35 = _9
  using: _9@Phi(bb7)
  _36 = const 1_i32
  using: 
  _37 = CheckedAdd(_35, _36)
  using: _35@Mir(bb8[0]), _36@Mir(bb8[1])
  assert(!move (_37.1: bool), "attempt to compute `{} + {}`, which would overflow", move _35, move _36) -> bb9
  using: _37@Entry, _35@Entry, _36@Entry
bb9:
  _34 = move (_37.0: i32)
  using: _37@Mir(bb8[2])
  _33 = move _34 as usize (IntToInt)
  using: _34@Mir(bb9[0])
  _38 = const 516_usize
  using: 
  _39 = Lt(_33, _38)
  using: _33@Mir(bb9[1]), _38@Mir(bb9[2])
  assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _33) -> bb10
  using: _39@Entry, _38@Entry, _33@Entry
bb10:
  _14[_33] = move (_32.0: i32)
  using: _33@Mir(bb9[1]), _32@Mir(bb7[1])
  _40 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb7)
  assert(!move (_40.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb11
  using: _40@Entry, _9@Entry
bb11:
  _9 = move (_40.0: i32)
  using: _40@Mir(bb10[1])
  goto -> bb1
  using: 
bb12:
  _41 = _3
  using: _3@Phi(bb12)
  _5 = move _41
  using: _41@Mir(bb12[0])
  _6 = const 0_i32
  using: 
  _42 = const 0_i32
  using: 
  _43 = const 0_usize
  using: 
  _13[_43] = move _42
  using: _43@Mir(bb12[4]), _42@Mir(bb12[3])
  _44 = const 0_i32
  using: 
  _45 = const 0_usize
  using: 
  _14[_45] = move _44
  using: _45@Mir(bb12[7]), _44@Mir(bb12[6])
  _46 = const 2_i32
  using: 
  _47 = const 0_usize
  using: 
  _15[_47] = Neg(move _46)
  using: _47@Mir(bb12[10]), _46@Mir(bb12[9])
  _9 = const 1_i32
  using: 
  goto -> bb13
  using: 
bb13:
  _49 = _9
  using: _9@Phi(bb13)
  _50 = _3
  using: _3@Phi(bb12)
  _48 = Le(move _49, move _50)
  using: _49@Mir(bb13[0]), _50@Mir(bb13[1])
  switchInt(move _48) -> [0: bb32, otherwise: bb14]
  using: _48@Mir(bb13[2])
bb14:
  _51 = const 1_i32
  using: 
  _53 = _9
  using: _9@Phi(bb13)
  _52 = move _53 as usize (IntToInt)
  using: _53@Mir(bb14[1])
  _54 = const 516_usize
  using: 
  _55 = Lt(_52, _54)
  using: _52@Mir(bb14[2]), _54@Mir(bb14[3])
  assert(move _55, "index out of bounds: the length is {} but the index is {}", move _54, _52) -> bb15
  using: _55@Entry, _54@Entry, _52@Entry
bb15:
  _15[_52] = Neg(move _51)
  using: _52@Mir(bb14[2]), _51@Mir(bb14[0])
  _56 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb13)
  assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb16
  using: _56@Entry, _6@Entry
bb16:
  _6 = move (_56.0: i32)
  using: _56@Mir(bb15[1])
  _57 = _9
  using: _9@Phi(bb13)
  _59 = _6
  using: _6@Mir(bb16[0])
  _58 = move _59 as usize (IntToInt)
  using: _59@Mir(bb16[2])
  _60 = const 260_usize
  using: 
  _61 = Lt(_58, _60)
  using: _58@Mir(bb16[3]), _60@Mir(bb16[4])
  assert(move _61, "index out of bounds: the length is {} but the index is {}", move _60, _58) -> bb17
  using: _61@Entry, _60@Entry, _58@Entry
bb17:
  _13[_58] = move _57
  using: _58@Mir(bb16[3]), _57@Mir(bb16[1])
  _62 = const 0_i32
  using: 
  _63 = const 0_i32
  using: 
  _64 = _6
  using: _6@Mir(bb16[0])
  _62 = move _64
  using: _64@Mir(bb17[3])
  _67 = _62
  using: _62@Mir(bb17[4])
  _66 = move _67 as usize (IntToInt)
  using: _67@Mir(bb17[5])
  _68 = const 260_usize
  using: 
  _69 = Lt(_66, _68)
  using: _66@Mir(bb17[6]), _68@Mir(bb17[7])
  assert(move _69, "index out of bounds: the length is {} but the index is {}", move _68, _66) -> bb18
  using: _69@Entry, _68@Entry, _66@Entry
bb18:
  _65 = _13[_66]
  using: _13@Phi(bb13), _66@Mir(bb17[6])
  _63 = move _65
  using: _65@Mir(bb18[0])
  goto -> bb19
  using: 
bb19:
  _73 = _63
  using: _63@Mir(bb18[1])
  _72 = move _73 as usize (IntToInt)
  using: _73@Mir(bb19[0])
  _74 = const 516_usize
  using: 
  _75 = Lt(_72, _74)
  using: _72@Mir(bb19[1]), _74@Mir(bb19[2])
  assert(move _75, "index out of bounds: the length is {} but the index is {}", move _74, _72) -> bb20
  using: _75@Entry, _74@Entry, _72@Entry
bb20:
  _71 = _14[_72]
  using: _14@Phi(bb19), _72@Mir(bb19[1])
  _81 = _62
  using: _62@Phi(bb19)
  _82 = const 1_i32
  using: 
  _83 = CheckedShr(_81, _82)
  using: _81@Mir(bb20[1]), _82@Mir(bb20[2])
  assert(!move (_83.1: bool), "attempt to shift right by `{}`, which would overflow", move _82) -> bb21
  using: _83@Entry, _81@Entry, _82@Entry
bb21:
  _80 = move (_83.0: i32)
  using: _83@Mir(bb20[3])
  _79 = move _80 as usize (IntToInt)
  using: _80@Mir(bb21[0])
  _84 = const 260_usize
  using: 
  _85 = Lt(_79, _84)
  using: _79@Mir(bb21[1]), _84@Mir(bb21[2])
  assert(move _85, "index out of bounds: the length is {} but the index is {}", move _84, _79) -> bb22
  using: _85@Entry, _84@Entry, _79@Entry
bb22:
  _78 = _13[_79]
  using: _13@Phi(bb19), _79@Mir(bb21[1])
  _77 = move _78 as usize (IntToInt)
  using: _78@Mir(bb22[0])
  _86 = const 516_usize
  using: 
  _87 = Lt(_77, _86)
  using: _77@Mir(bb22[1]), _86@Mir(bb22[2])
  assert(move _87, "index out of bounds: the length is {} but the index is {}", move _86, _77) -> bb23
  using: _87@Entry, _86@Entry, _77@Entry
bb23:
  _76 = _14[_77]
  using: _14@Phi(bb19), _77@Mir(bb22[1])
  _70 = Lt(move _71, move _76)
  using: _71@Mir(bb20[0]), _76@Mir(bb23[0])
  switchInt(move _70) -> [0: bb29, otherwise: bb24]
  using: _70@Mir(bb23[1])
bb24:
  _91 = _62
  using: _62@Phi(bb19)
  _92 = const 1_i32
  using: 
  _93 = CheckedShr(_91, _92)
  using: _91@Mir(bb24[0]), _92@Mir(bb24[1])
  assert(!move (_93.1: bool), "attempt to shift right by `{}`, which would overflow", move _92) -> bb25
  using: _93@Entry, _91@Entry, _92@Entry
bb25:
  _90 = move (_93.0: i32)
  using: _93@Mir(bb24[2])
  _89 = move _90 as usize (IntToInt)
  using: _90@Mir(bb25[0])
  _94 = const 260_usize
  using: 
  _95 = Lt(_89, _94)
  using: _89@Mir(bb25[1]), _94@Mir(bb25[2])
  assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _89) -> bb26
  using: _95@Entry, _94@Entry, _89@Entry
bb26:
  _88 = _13[_89]
  using: _13@Phi(bb19), _89@Mir(bb25[1])
  _97 = _62
  using: _62@Phi(bb19)
  _96 = move _97 as usize (IntToInt)
  using: _97@Mir(bb26[1])
  _98 = const 260_usize
  using: 
  _99 = Lt(_96, _98)
  using: _96@Mir(bb26[2]), _98@Mir(bb26[3])
  assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _96) -> bb27
  using: _99@Entry, _98@Entry, _96@Entry
bb27:
  _13[_96] = move _88
  using: _96@Mir(bb26[2]), _88@Mir(bb26[0])
  _100 = const 1_i32
  using: 
  _101 = CheckedShr(_62, _100)
  using: _62@Phi(bb19), _100@Mir(bb27[1])
  assert(!move (_101.1: bool), "attempt to shift right by `{}`, which would overflow", move _100) -> bb28
  using: _101@Entry, _62@Entry, _100@Entry
bb28:
  _62 = move (_101.0: i32)
  using: _101@Mir(bb27[2])
  goto -> bb19
  using: 
bb29:
  _102 = _63
  using: _63@Mir(bb18[1])
  _104 = _62
  using: _62@Phi(bb19)
  _103 = move _104 as usize (IntToInt)
  using: _104@Mir(bb29[1])
  _105 = const 260_usize
  using: 
  _106 = Lt(_103, _105)
  using: _103@Mir(bb29[2]), _105@Mir(bb29[3])
  assert(move _106, "index out of bounds: the length is {} but the index is {}", move _105, _103) -> bb30
  using: _106@Entry, _105@Entry, _103@Entry
bb30:
  _13[_103] = move _102
  using: _103@Mir(bb29[2]), _102@Mir(bb29[0])
  _107 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb13)
  assert(!move (_107.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb31
  using: _107@Entry, _9@Entry
bb31:
  _9 = move (_107.0: i32)
  using: _107@Mir(bb30[1])
  goto -> bb13
  using: 
bb32:
  _110 = _6
  using: _6@Phi(bb13)
  _111 = const 260_i32
  using: 
  _109 = Lt(move _110, move _111)
  using: _110@Mir(bb32[0]), _111@Mir(bb32[1])
  _108 = Not(move _109)
  using: _109@Mir(bb32[2])
  switchInt(move _108) -> [0: bb34, otherwise: bb33]
  using: _108@Mir(bb32[3])
bb33:
  _113 = const 2001_i32
  using: 
  _112 = bzlib::BZ2_bz__AssertH__fail(move _113) -> bb34
  using: _113@Mir(bb33[0])
bb34:
  _115 = _6
  using: _6@Phi(bb34)
  _116 = const 1_i32
  using: 
  _114 = Gt(move _115, move _116)
  using: _115@Mir(bb34[0]), _116@Mir(bb34[1])
  switchInt(move _114) -> [0: bb116, otherwise: bb35]
  using: _114@Mir(bb34[2])
bb35:
  _118 = const 1_usize
  using: 
  _117 = _13[_118]
  using: _13@Phi(bb34), _118@Mir(bb35[0])
  _7 = move _117
  using: _117@Mir(bb35[1])
  _121 = _6
  using: _6@Phi(bb34)
  _120 = move _121 as usize (IntToInt)
  using: _121@Mir(bb35[3])
  _122 = const 260_usize
  using: 
  _123 = Lt(_120, _122)
  using: _120@Mir(bb35[4]), _122@Mir(bb35[5])
  assert(move _123, "index out of bounds: the length is {} but the index is {}", move _122, _120) -> bb36
  using: _123@Entry, _122@Entry, _120@Entry
bb36:
  _119 = _13[_120]
  using: _13@Phi(bb34), _120@Mir(bb35[4])
  _124 = const 1_usize
  using: 
  _13[_124] = move _119
  using: _124@Mir(bb36[1]), _119@Mir(bb36[0])
  _125 = CheckedSub(_6, const 1_i32)
  using: _6@Phi(bb34)
  assert(!move (_125.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> bb37
  using: _125@Entry, _6@Entry
bb37:
  _6 = move (_125.0: i32)
  using: _125@Mir(bb36[3])
  _126 = const 0_i32
  using: 
  _127 = const 0_i32
  using: 
  _128 = const 0_i32
  using: 
  _126 = const 1_i32
  using: 
  _130 = const 1_usize
  using: 
  _129 = _13[_130]
  using: _13@Phi(bb34), _130@Mir(bb37[5])
  _128 = move _129
  using: _129@Mir(bb37[6])
  goto -> bb38
  using: 
bb38:
  _131 = _126
  using: _126@Phi(bb38)
  _132 = const 1_i32
  using: 
  _133 = CheckedShl(_131, _132)
  using: _131@Mir(bb38[0]), _132@Mir(bb38[1])
  assert(!move (_133.1: bool), "attempt to shift left by `{}`, which would overflow", move _132) -> bb39
  using: _133@Entry, _131@Entry, _132@Entry
bb39:
  _127 = move (_133.0: i32)
  using: _133@Mir(bb38[2])
  _135 = _127
  using: _127@Mir(bb39[0])
  _136 = _6
  using: _6@Phi(bb38)
  _134 = Gt(move _135, move _136)
  using: _135@Mir(bb39[1]), _136@Mir(bb39[2])
  switchInt(move _134) -> [0: bb40, otherwise: bb58]
  using: _134@Mir(bb39[3])
bb40:
  _139 = _127
  using: _127@Mir(bb39[0])
  _140 = _6
  using: _6@Phi(bb38)
  _138 = Lt(move _139, move _140)
  using: _139@Mir(bb40[0]), _140@Mir(bb40[1])
  switchInt(move _138) -> [0: bb41, otherwise: bb42]
  using: _138@Mir(bb40[2])
bb41:
  _137 = const false
  using: 
  goto -> bb43
  using: 
bb42:
  _147 = _127
  using: _127@Mir(bb39[0])
  _148 = const 1_i32
  using: 
  _149 = CheckedAdd(_147, _148)
  using: _147@Mir(bb42[0]), _148@Mir(bb42[1])
  assert(!move (_149.1: bool), "attempt to compute `{} + {}`, which would overflow", move _147, move _148) -> bb44
  using: _149@Entry, _147@Entry, _148@Entry
bb43:
  switchInt(move _137) -> [0: bb51, otherwise: bb49]
  using: _137@Phi(bb43)
bb44:
  _146 = move (_149.0: i32)
  using: _149@Mir(bb42[2])
  _145 = move _146 as usize (IntToInt)
  using: _146@Mir(bb44[0])
  _150 = const 260_usize
  using: 
  _151 = Lt(_145, _150)
  using: _145@Mir(bb44[1]), _150@Mir(bb44[2])
  assert(move _151, "index out of bounds: the length is {} but the index is {}", move _150, _145) -> bb45
  using: _151@Entry, _150@Entry, _145@Entry
bb45:
  _144 = _13[_145]
  using: _13@Phi(bb38), _145@Mir(bb44[1])
  _143 = move _144 as usize (IntToInt)
  using: _144@Mir(bb45[0])
  _152 = const 516_usize
  using: 
  _153 = Lt(_143, _152)
  using: _143@Mir(bb45[1]), _152@Mir(bb45[2])
  assert(move _153, "index out of bounds: the length is {} but the index is {}", move _152, _143) -> bb46
  using: _153@Entry, _152@Entry, _143@Entry
bb46:
  _142 = _14[_143]
  using: _14@Phi(bb38), _143@Mir(bb45[1])
  _158 = _127
  using: _127@Mir(bb39[0])
  _157 = move _158 as usize (IntToInt)
  using: _158@Mir(bb46[1])
  _159 = const 260_usize
  using: 
  _160 = Lt(_157, _159)
  using: _157@Mir(bb46[2]), _159@Mir(bb46[3])
  assert(move _160, "index out of bounds: the length is {} but the index is {}", move _159, _157) -> bb47
  using: _160@Entry, _159@Entry, _157@Entry
bb47:
  _156 = _13[_157]
  using: _13@Phi(bb38), _157@Mir(bb46[2])
  _155 = move _156 as usize (IntToInt)
  using: _156@Mir(bb47[0])
  _161 = const 516_usize
  using: 
  _162 = Lt(_155, _161)
  using: _155@Mir(bb47[1]), _161@Mir(bb47[2])
  assert(move _162, "index out of bounds: the length is {} but the index is {}", move _161, _155) -> bb48
  using: _162@Entry, _161@Entry, _155@Entry
bb48:
  _154 = _14[_155]
  using: _14@Phi(bb38), _155@Mir(bb47[1])
  _141 = Lt(move _142, move _154)
  using: _142@Mir(bb46[0]), _154@Mir(bb48[0])
  _137 = move _141
  using: _141@Mir(bb48[1])
  goto -> bb43
  using: 
bb49:
  _163 = CheckedAdd(_127, const 1_i32)
  using: _127@Phi(bb43)
  assert(!move (_163.1: bool), "attempt to compute `{} + {}`, which would overflow", _127, const 1_i32) -> bb50
  using: _163@Entry, _127@Entry
bb50:
  _127 = move (_163.0: i32)
  using: _163@Mir(bb49[0])
  goto -> bb51
  using: 
bb51:
  _167 = _128
  using: _128@Phi(bb38)
  _166 = move _167 as usize (IntToInt)
  using: _167@Mir(bb51[0])
  _168 = const 516_usize
  using: 
  _169 = Lt(_166, _168)
  using: _166@Mir(bb51[1]), _168@Mir(bb51[2])
  assert(move _169, "index out of bounds: the length is {} but the index is {}", move _168, _166) -> bb52
  using: _169@Entry, _168@Entry, _166@Entry
bb52:
  _165 = _14[_166]
  using: _14@Phi(bb43), _166@Mir(bb51[1])
  _174 = _127
  using: _127@Phi(bb51)
  _173 = move _174 as usize (IntToInt)
  using: _174@Mir(bb52[1])
  _175 = const 260_usize
  using: 
  _176 = Lt(_173, _175)
  using: _173@Mir(bb52[2]), _175@Mir(bb52[3])
  assert(move _176, "index out of bounds: the length is {} but the index is {}", move _175, _173) -> bb53
  using: _176@Entry, _175@Entry, _173@Entry
bb53:
  _172 = _13[_173]
  using: _13@Phi(bb43), _173@Mir(bb52[2])
  _171 = move _172 as usize (IntToInt)
  using: _172@Mir(bb53[0])
  _177 = const 516_usize
  using: 
  _178 = Lt(_171, _177)
  using: _171@Mir(bb53[1]), _177@Mir(bb53[2])
  assert(move _178, "index out of bounds: the length is {} but the index is {}", move _177, _171) -> bb54
  using: _178@Entry, _177@Entry, _171@Entry
bb54:
  _170 = _14[_171]
  using: _14@Phi(bb43), _171@Mir(bb53[1])
  _164 = Lt(move _165, move _170)
  using: _165@Mir(bb52[0]), _170@Mir(bb54[0])
  switchInt(move _164) -> [0: bb55, otherwise: bb58]
  using: _164@Mir(bb54[1])
bb55:
  _181 = _127
  using: _127@Phi(bb51)
  _180 = move _181 as usize (IntToInt)
  using: _181@Mir(bb55[0])
  _182 = const 260_usize
  using: 
  _183 = Lt(_180, _182)
  using: _180@Mir(bb55[1]), _182@Mir(bb55[2])
  assert(move _183, "index out of bounds: the length is {} but the index is {}", move _182, _180) -> bb56
  using: _183@Entry, _182@Entry, _180@Entry
bb56:
  _179 = _13[_180]
  using: _13@Phi(bb43), _180@Mir(bb55[1])
  _185 = _126
  using: _126@Phi(bb38)
  _184 = move _185 as usize (IntToInt)
  using: _185@Mir(bb56[1])
  _186 = const 260_usize
  using: 
  _187 = Lt(_184, _186)
  using: _184@Mir(bb56[2]), _186@Mir(bb56[3])
  assert(move _187, "index out of bounds: the length is {} but the index is {}", move _186, _184) -> bb57
  using: _187@Entry, _186@Entry, _184@Entry
bb57:
  _13[_184] = move _179
  using: _184@Mir(bb56[2]), _179@Mir(bb56[0])
  _188 = _127
  using: _127@Phi(bb51)
  _126 = move _188
  using: _188@Mir(bb57[1])
  goto -> bb38
  using: 
bb58:
  _189 = _128
  using: _128@Phi(bb58)
  _191 = _126
  using: _126@Phi(bb38)
  _190 = move _191 as usize (IntToInt)
  using: _191@Mir(bb58[1])
  _192 = const 260_usize
  using: 
  _193 = Lt(_190, _192)
  using: _190@Mir(bb58[2]), _192@Mir(bb58[3])
  assert(move _193, "index out of bounds: the length is {} but the index is {}", move _192, _190) -> bb59
  using: _193@Entry, _192@Entry, _190@Entry
bb59:
  _13[_190] = move _189
  using: _190@Mir(bb58[2]), _189@Mir(bb58[0])
  _195 = const 1_usize
  using: 
  _194 = _13[_195]
  using: _13@Phi(bb58), _195@Mir(bb59[1])
  _8 = move _194
  using: _194@Mir(bb59[2])
  _198 = _6
  using: _6@Phi(bb58)
  _197 = move _198 as usize (IntToInt)
  using: _198@Mir(bb59[4])
  _199 = const 260_usize
  using: 
  _200 = Lt(_197, _199)
  using: _197@Mir(bb59[5]), _199@Mir(bb59[6])
  assert(move _200, "index out of bounds: the length is {} but the index is {}", move _199, _197) -> bb60
  using: _200@Entry, _199@Entry, _197@Entry
bb60:
  _196 = _13[_197]
  using: _13@Phi(bb58), _197@Mir(bb59[5])
  _201 = const 1_usize
  using: 
  _13[_201] = move _196
  using: _201@Mir(bb60[1]), _196@Mir(bb60[0])
  _202 = CheckedSub(_6, const 1_i32)
  using: _6@Phi(bb58)
  assert(!move (_202.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> bb61
  using: _202@Entry, _6@Entry
bb61:
  _6 = move (_202.0: i32)
  using: _202@Mir(bb60[3])
  _203 = const 0_i32
  using: 
  _204 = const 0_i32
  using: 
  _205 = const 0_i32
  using: 
  _203 = const 1_i32
  using: 
  _207 = const 1_usize
  using: 
  _206 = _13[_207]
  using: _13@Phi(bb58), _207@Mir(bb61[5])
  _205 = move _206
  using: _206@Mir(bb61[6])
  goto -> bb62
  using: 
bb62:
  _208 = _203
  using: _203@Phi(bb62)
  _209 = const 1_i32
  using: 
  _210 = CheckedShl(_208, _209)
  using: _208@Mir(bb62[0]), _209@Mir(bb62[1])
  assert(!move (_210.1: bool), "attempt to shift left by `{}`, which would overflow", move _209) -> bb63
  using: _210@Entry, _208@Entry, _209@Entry
bb63:
  _204 = move (_210.0: i32)
  using: _210@Mir(bb62[2])
  _212 = _204
  using: _204@Mir(bb63[0])
  _213 = _6
  using: _6@Phi(bb62)
  _211 = Gt(move _212, move _213)
  using: _212@Mir(bb63[1]), _213@Mir(bb63[2])
  switchInt(move _211) -> [0: bb64, otherwise: bb82]
  using: _211@Mir(bb63[3])
bb64:
  _216 = _204
  using: _204@Mir(bb63[0])
  _217 = _6
  using: _6@Phi(bb62)
  _215 = Lt(move _216, move _217)
  using: _216@Mir(bb64[0]), _217@Mir(bb64[1])
  switchInt(move _215) -> [0: bb65, otherwise: bb66]
  using: _215@Mir(bb64[2])
bb65:
  _214 = const false
  using: 
  goto -> bb67
  using: 
bb66:
  _224 = _204
  using: _204@Mir(bb63[0])
  _225 = const 1_i32
  using: 
  _226 = CheckedAdd(_224, _225)
  using: _224@Mir(bb66[0]), _225@Mir(bb66[1])
  assert(!move (_226.1: bool), "attempt to compute `{} + {}`, which would overflow", move _224, move _225) -> bb68
  using: _226@Entry, _224@Entry, _225@Entry
bb67:
  switchInt(move _214) -> [0: bb75, otherwise: bb73]
  using: _214@Phi(bb67)
bb68:
  _223 = move (_226.0: i32)
  using: _226@Mir(bb66[2])
  _222 = move _223 as usize (IntToInt)
  using: _223@Mir(bb68[0])
  _227 = const 260_usize
  using: 
  _228 = Lt(_222, _227)
  using: _222@Mir(bb68[1]), _227@Mir(bb68[2])
  assert(move _228, "index out of bounds: the length is {} but the index is {}", move _227, _222) -> bb69
  using: _228@Entry, _227@Entry, _222@Entry
bb69:
  _221 = _13[_222]
  using: _13@Phi(bb62), _222@Mir(bb68[1])
  _220 = move _221 as usize (IntToInt)
  using: _221@Mir(bb69[0])
  _229 = const 516_usize
  using: 
  _230 = Lt(_220, _229)
  using: _220@Mir(bb69[1]), _229@Mir(bb69[2])
  assert(move _230, "index out of bounds: the length is {} but the index is {}", move _229, _220) -> bb70
  using: _230@Entry, _229@Entry, _220@Entry
bb70:
  _219 = _14[_220]
  using: _14@Phi(bb62), _220@Mir(bb69[1])
  _235 = _204
  using: _204@Mir(bb63[0])
  _234 = move _235 as usize (IntToInt)
  using: _235@Mir(bb70[1])
  _236 = const 260_usize
  using: 
  _237 = Lt(_234, _236)
  using: _234@Mir(bb70[2]), _236@Mir(bb70[3])
  assert(move _237, "index out of bounds: the length is {} but the index is {}", move _236, _234) -> bb71
  using: _237@Entry, _236@Entry, _234@Entry
bb71:
  _233 = _13[_234]
  using: _13@Phi(bb62), _234@Mir(bb70[2])
  _232 = move _233 as usize (IntToInt)
  using: _233@Mir(bb71[0])
  _238 = const 516_usize
  using: 
  _239 = Lt(_232, _238)
  using: _232@Mir(bb71[1]), _238@Mir(bb71[2])
  assert(move _239, "index out of bounds: the length is {} but the index is {}", move _238, _232) -> bb72
  using: _239@Entry, _238@Entry, _232@Entry
bb72:
  _231 = _14[_232]
  using: _14@Phi(bb62), _232@Mir(bb71[1])
  _218 = Lt(move _219, move _231)
  using: _219@Mir(bb70[0]), _231@Mir(bb72[0])
  _214 = move _218
  using: _218@Mir(bb72[1])
  goto -> bb67
  using: 
bb73:
  _240 = CheckedAdd(_204, const 1_i32)
  using: _204@Phi(bb67)
  assert(!move (_240.1: bool), "attempt to compute `{} + {}`, which would overflow", _204, const 1_i32) -> bb74
  using: _240@Entry, _204@Entry
bb74:
  _204 = move (_240.0: i32)
  using: _240@Mir(bb73[0])
  goto -> bb75
  using: 
bb75:
  _244 = _205
  using: _205@Phi(bb62)
  _243 = move _244 as usize (IntToInt)
  using: _244@Mir(bb75[0])
  _245 = const 516_usize
  using: 
  _246 = Lt(_243, _245)
  using: _243@Mir(bb75[1]), _245@Mir(bb75[2])
  assert(move _246, "index out of bounds: the length is {} but the index is {}", move _245, _243) -> bb76
  using: _246@Entry, _245@Entry, _243@Entry
bb76:
  _242 = _14[_243]
  using: _14@Phi(bb67), _243@Mir(bb75[1])
  _251 = _204
  using: _204@Phi(bb75)
  _250 = move _251 as usize (IntToInt)
  using: _251@Mir(bb76[1])
  _252 = const 260_usize
  using: 
  _253 = Lt(_250, _252)
  using: _250@Mir(bb76[2]), _252@Mir(bb76[3])
  assert(move _253, "index out of bounds: the length is {} but the index is {}", move _252, _250) -> bb77
  using: _253@Entry, _252@Entry, _250@Entry
bb77:
  _249 = _13[_250]
  using: _13@Phi(bb67), _250@Mir(bb76[2])
  _248 = move _249 as usize (IntToInt)
  using: _249@Mir(bb77[0])
  _254 = const 516_usize
  using: 
  _255 = Lt(_248, _254)
  using: _248@Mir(bb77[1]), _254@Mir(bb77[2])
  assert(move _255, "index out of bounds: the length is {} but the index is {}", move _254, _248) -> bb78
  using: _255@Entry, _254@Entry, _248@Entry
bb78:
  _247 = _14[_248]
  using: _14@Phi(bb67), _248@Mir(bb77[1])
  _241 = Lt(move _242, move _247)
  using: _242@Mir(bb76[0]), _247@Mir(bb78[0])
  switchInt(move _241) -> [0: bb79, otherwise: bb82]
  using: _241@Mir(bb78[1])
bb79:
  _258 = _204
  using: _204@Phi(bb75)
  _257 = move _258 as usize (IntToInt)
  using: _258@Mir(bb79[0])
  _259 = const 260_usize
  using: 
  _260 = Lt(_257, _259)
  using: _257@Mir(bb79[1]), _259@Mir(bb79[2])
  assert(move _260, "index out of bounds: the length is {} but the index is {}", move _259, _257) -> bb80
  using: _260@Entry, _259@Entry, _257@Entry
bb80:
  _256 = _13[_257]
  using: _13@Phi(bb67), _257@Mir(bb79[1])
  _262 = _203
  using: _203@Phi(bb62)
  _261 = move _262 as usize (IntToInt)
  using: _262@Mir(bb80[1])
  _263 = const 260_usize
  using: 
  _264 = Lt(_261, _263)
  using: _261@Mir(bb80[2]), _263@Mir(bb80[3])
  assert(move _264, "index out of bounds: the length is {} but the index is {}", move _263, _261) -> bb81
  using: _264@Entry, _263@Entry, _261@Entry
bb81:
  _13[_261] = move _256
  using: _261@Mir(bb80[2]), _256@Mir(bb80[0])
  _265 = _204
  using: _204@Phi(bb75)
  _203 = move _265
  using: _265@Mir(bb81[1])
  goto -> bb62
  using: 
bb82:
  _266 = _205
  using: _205@Phi(bb82)
  _268 = _203
  using: _203@Phi(bb62)
  _267 = move _268 as usize (IntToInt)
  using: _268@Mir(bb82[1])
  _269 = const 260_usize
  using: 
  _270 = Lt(_267, _269)
  using: _267@Mir(bb82[2]), _269@Mir(bb82[3])
  assert(move _270, "index out of bounds: the length is {} but the index is {}", move _269, _267) -> bb83
  using: _270@Entry, _269@Entry, _267@Entry
bb83:
  _13[_267] = move _266
  using: _267@Mir(bb82[2]), _266@Mir(bb82[0])
  _271 = CheckedAdd(_5, const 1_i32)
  using: _5@Phi(bb34)
  assert(!move (_271.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> bb84
  using: _271@Entry, _5@Entry
bb84:
  _5 = move (_271.0: i32)
  using: _271@Mir(bb83[1])
  _272 = _5
  using: _5@Mir(bb84[0])
  _274 = _8
  using: _8@Mir(bb59[3])
  _273 = move _274 as usize (IntToInt)
  using: _274@Mir(bb84[2])
  _275 = const 516_usize
  using: 
  _276 = Lt(_273, _275)
  using: _273@Mir(bb84[3]), _275@Mir(bb84[4])
  assert(move _276, "index out of bounds: the length is {} but the index is {}", move _275, _273) -> bb85
  using: _276@Entry, _275@Entry, _273@Entry
bb85:
  _15[_273] = move _272
  using: _273@Mir(bb84[3]), _272@Mir(bb84[1])
  _279 = _8
  using: _8@Mir(bb59[3])
  _278 = move _279 as usize (IntToInt)
  using: _279@Mir(bb85[1])
  _280 = const 516_usize
  using: 
  _281 = Lt(_278, _280)
  using: _278@Mir(bb85[2]), _280@Mir(bb85[3])
  assert(move _281, "index out of bounds: the length is {} but the index is {}", move _280, _278) -> bb86
  using: _281@Entry, _280@Entry, _278@Entry
bb86:
  _277 = _15[_278]
  using: _15@Phi(bb34), _278@Mir(bb85[2])
  _283 = _7
  using: _7@Mir(bb35[2])
  _282 = move _283 as usize (IntToInt)
  using: _283@Mir(bb86[1])
  _284 = const 516_usize
  using: 
  _285 = Lt(_282, _284)
  using: _282@Mir(bb86[2]), _284@Mir(bb86[3])
  assert(move _285, "index out of bounds: the length is {} but the index is {}", move _284, _282) -> bb87
  using: _285@Entry, _284@Entry, _282@Entry
bb87:
  _15[_282] = move _277
  using: _282@Mir(bb86[2]), _277@Mir(bb86[0])
  _292 = _7
  using: _7@Mir(bb35[2])
  _291 = move _292 as usize (IntToInt)
  using: _292@Mir(bb87[1])
  _293 = const 516_usize
  using: 
  _294 = Lt(_291, _293)
  using: _291@Mir(bb87[2]), _293@Mir(bb87[3])
  assert(move _294, "index out of bounds: the length is {} but the index is {}", move _293, _291) -> bb88
  using: _294@Entry, _293@Entry, _291@Entry
bb88:
  _290 = _14[_291]
  using: _14@Phi(bb82), _291@Mir(bb87[2])
  _289 = move _290 as u32 (IntToInt)
  using: _290@Mir(bb88[0])
  _295 = const 4294967040_u32
  using: 
  _288 = BitAnd(move _289, move _295)
  using: _289@Mir(bb88[1]), _295@Mir(bb88[2])
  _300 = _8
  using: _8@Mir(bb59[3])
  _299 = move _300 as usize (IntToInt)
  using: _300@Mir(bb88[4])
  _301 = const 516_usize
  using: 
  _302 = Lt(_299, _301)
  using: _299@Mir(bb88[5]), _301@Mir(bb88[6])
  assert(move _302, "index out of bounds: the length is {} but the index is {}", move _301, _299) -> bb89
  using: _302@Entry, _301@Entry, _299@Entry
bb89:
  _298 = _14[_299]
  using: _14@Phi(bb82), _299@Mir(bb88[5])
  _297 = move _298 as u32 (IntToInt)
  using: _298@Mir(bb89[0])
  _303 = const 4294967040_u32
  using: 
  _296 = BitAnd(move _297, move _303)
  using: _297@Mir(bb89[1]), _303@Mir(bb89[2])
  _287 = core::num::<impl u32>::wrapping_add(move _288, move _296) -> bb90
  using: _288@Mir(bb88[3]), _296@Mir(bb89[3])
bb90:
  _306 = const 1_i32
  using: 
  _312 = _7
  using: _7@Mir(bb35[2])
  _311 = move _312 as usize (IntToInt)
  using: _312@Mir(bb90[1])
  _313 = const 516_usize
  using: 
  _314 = Lt(_311, _313)
  using: _311@Mir(bb90[2]), _313@Mir(bb90[3])
  assert(move _314, "index out of bounds: the length is {} but the index is {}", move _313, _311) -> bb91
  using: _314@Entry, _313@Entry, _311@Entry
bb91:
  _310 = _14[_311]
  using: _14@Phi(bb82), _311@Mir(bb90[2])
  _315 = const 255_i32
  using: 
  _309 = BitAnd(move _310, move _315)
  using: _310@Mir(bb91[0]), _315@Mir(bb91[1])
  _319 = _8
  using: _8@Mir(bb59[3])
  _318 = move _319 as usize (IntToInt)
  using: _319@Mir(bb91[3])
  _320 = const 516_usize
  using: 
  _321 = Lt(_318, _320)
  using: _318@Mir(bb91[4]), _320@Mir(bb91[5])
  assert(move _321, "index out of bounds: the length is {} but the index is {}", move _320, _318) -> bb92
  using: _321@Entry, _320@Entry, _318@Entry
bb92:
  _317 = _14[_318]
  using: _14@Phi(bb82), _318@Mir(bb91[4])
  _322 = const 255_i32
  using: 
  _316 = BitAnd(move _317, move _322)
  using: _317@Mir(bb92[0]), _322@Mir(bb92[1])
  _308 = Gt(move _309, move _316)
  using: _309@Mir(bb91[2]), _316@Mir(bb92[2])
  switchInt(move _308) -> [0: bb95, otherwise: bb93]
  using: _308@Mir(bb92[3])
bb93:
  _325 = _7
  using: _7@Mir(bb35[2])
  _324 = move _325 as usize (IntToInt)
  using: _325@Mir(bb93[0])
  _326 = const 516_usize
  using: 
  _327 = Lt(_324, _326)
  using: _324@Mir(bb93[1]), _326@Mir(bb93[2])
  assert(move _327, "index out of bounds: the length is {} but the index is {}", move _326, _324) -> bb94
  using: _327@Entry, _326@Entry, _324@Entry
bb94:
  _323 = _14[_324]
  using: _14@Phi(bb82), _324@Mir(bb93[1])
  _328 = const 255_i32
  using: 
  _307 = BitAnd(move _323, move _328)
  using: _323@Mir(bb94[0]), _328@Mir(bb94[1])
  goto -> bb97
  using: 
bb95:
  _331 = _8
  using: _8@Mir(bb59[3])
  _330 = move _331 as usize (IntToInt)
  using: _331@Mir(bb95[0])
  _332 = const 516_usize
  using: 
  _333 = Lt(_330, _332)
  using: _330@Mir(bb95[1]), _332@Mir(bb95[2])
  assert(move _333, "index out of bounds: the length is {} but the index is {}", move _332, _330) -> bb96
  using: _333@Entry, _332@Entry, _330@Entry
bb96:
  _329 = _14[_330]
  using: _14@Phi(bb82), _330@Mir(bb95[1])
  _334 = const 255_i32
  using: 
  _307 = BitAnd(move _329, move _334)
  using: _329@Mir(bb96[0]), _334@Mir(bb96[1])
  goto -> bb97
  using: 
bb97:
  _335 = CheckedAdd(_306, _307)
  using: _306@Mir(bb90[0]), _307@Phi(bb97)
  assert(!move (_335.1: bool), "attempt to compute `{} + {}`, which would overflow", move _306, move _307) -> bb98
  using: _335@Entry, _306@Entry, _307@Entry
bb98:
  _305 = move (_335.0: i32)
  using: _335@Mir(bb97[0])
  _304 = move _305 as u32 (IntToInt)
  using: _305@Mir(bb98[0])
  _286 = BitOr(move _287, move _304)
  using: _287@Mir(bb89[4]), _304@Mir(bb98[1])
  _337 = _5
  using: _5@Mir(bb84[0])
  _336 = move _337 as usize (IntToInt)
  using: _337@Mir(bb98[3])
  _338 = const 516_usize
  using: 
  _339 = Lt(_336, _338)
  using: _336@Mir(bb98[4]), _338@Mir(bb98[5])
  assert(move _339, "index out of bounds: the length is {} but the index is {}", move _338, _336) -> bb99
  using: _339@Entry, _338@Entry, _336@Entry
bb99:
  _14[_336] = move _286 as i32 (IntToInt)
  using: _336@Mir(bb98[4]), _286@Mir(bb98[2])
  _340 = const 1_i32
  using: 
  _342 = _5
  using: _5@Mir(bb84[0])
  _341 = move _342 as usize (IntToInt)
  using: _342@Mir(bb99[2])
  _343 = const 516_usize
  using: 
  _344 = Lt(_341, _343)
  using: _341@Mir(bb99[3]), _343@Mir(bb99[4])
  assert(move _344, "index out of bounds: the length is {} but the index is {}", move _343, _341) -> bb100
  using: _344@Entry, _343@Entry, _341@Entry
bb100:
  _15[_341] = Neg(move _340)
  using: _341@Mir(bb99[3]), _340@Mir(bb99[1])
  _345 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb82)
  assert(!move (_345.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb101
  using: _345@Entry, _6@Entry
bb101:
  _6 = move (_345.0: i32)
  using: _345@Mir(bb100[1])
  _346 = _5
  using: _5@Mir(bb84[0])
  _348 = _6
  using: _6@Mir(bb101[0])
  _347 = move _348 as usize (IntToInt)
  using: _348@Mir(bb101[2])
  _349 = const 260_usize
  using: 
  _350 = Lt(_347, _349)
  using: _347@Mir(bb101[3]), _349@Mir(bb101[4])
  assert(move _350, "index out of bounds: the length is {} but the index is {}", move _349, _347) -> bb102
  using: _350@Entry, _349@Entry, _347@Entry
bb102:
  _13[_347] = move _346
  using: _347@Mir(bb101[3]), _346@Mir(bb101[1])
  _351 = const 0_i32
  using: 
  _352 = const 0_i32
  using: 
  _353 = _6
  using: _6@Mir(bb101[0])
  _351 = move _353
  using: _353@Mir(bb102[3])
  _356 = _351
  using: _351@Mir(bb102[4])
  _355 = move _356 as usize (IntToInt)
  using: _356@Mir(bb102[5])
  _357 = const 260_usize
  using: 
  _358 = Lt(_355, _357)
  using: _355@Mir(bb102[6]), _357@Mir(bb102[7])
  assert(move _358, "index out of bounds: the length is {} but the index is {}", move _357, _355) -> bb103
  using: _358@Entry, _357@Entry, _355@Entry
bb103:
  _354 = _13[_355]
  using: _13@Phi(bb82), _355@Mir(bb102[6])
  _352 = move _354
  using: _354@Mir(bb103[0])
  goto -> bb104
  using: 
bb104:
  _362 = _352
  using: _352@Mir(bb103[1])
  _361 = move _362 as usize (IntToInt)
  using: _362@Mir(bb104[0])
  _363 = const 516_usize
  using: 
  _364 = Lt(_361, _363)
  using: _361@Mir(bb104[1]), _363@Mir(bb104[2])
  assert(move _364, "index out of bounds: the length is {} but the index is {}", move _363, _361) -> bb105
  using: _364@Entry, _363@Entry, _361@Entry
bb105:
  _360 = _14[_361]
  using: _14@Phi(bb104), _361@Mir(bb104[1])
  _370 = _351
  using: _351@Phi(bb104)
  _371 = const 1_i32
  using: 
  _372 = CheckedShr(_370, _371)
  using: _370@Mir(bb105[1]), _371@Mir(bb105[2])
  assert(!move (_372.1: bool), "attempt to shift right by `{}`, which would overflow", move _371) -> bb106
  using: _372@Entry, _370@Entry, _371@Entry
bb106:
  _369 = move (_372.0: i32)
  using: _372@Mir(bb105[3])
  _368 = move _369 as usize (IntToInt)
  using: _369@Mir(bb106[0])
  _373 = const 260_usize
  using: 
  _374 = Lt(_368, _373)
  using: _368@Mir(bb106[1]), _373@Mir(bb106[2])
  assert(move _374, "index out of bounds: the length is {} but the index is {}", move _373, _368) -> bb107
  using: _374@Entry, _373@Entry, _368@Entry
bb107:
  _367 = _13[_368]
  using: _13@Phi(bb104), _368@Mir(bb106[1])
  _366 = move _367 as usize (IntToInt)
  using: _367@Mir(bb107[0])
  _375 = const 516_usize
  using: 
  _376 = Lt(_366, _375)
  using: _366@Mir(bb107[1]), _375@Mir(bb107[2])
  assert(move _376, "index out of bounds: the length is {} but the index is {}", move _375, _366) -> bb108
  using: _376@Entry, _375@Entry, _366@Entry
bb108:
  _365 = _14[_366]
  using: _14@Phi(bb104), _366@Mir(bb107[1])
  _359 = Lt(move _360, move _365)
  using: _360@Mir(bb105[0]), _365@Mir(bb108[0])
  switchInt(move _359) -> [0: bb114, otherwise: bb109]
  using: _359@Mir(bb108[1])
bb109:
  _380 = _351
  using: _351@Phi(bb104)
  _381 = const 1_i32
  using: 
  _382 = CheckedShr(_380, _381)
  using: _380@Mir(bb109[0]), _381@Mir(bb109[1])
  assert(!move (_382.1: bool), "attempt to shift right by `{}`, which would overflow", move _381) -> bb110
  using: _382@Entry, _380@Entry, _381@Entry
bb110:
  _379 = move (_382.0: i32)
  using: _382@Mir(bb109[2])
  _378 = move _379 as usize (IntToInt)
  using: _379@Mir(bb110[0])
  _383 = const 260_usize
  using: 
  _384 = Lt(_378, _383)
  using: _378@Mir(bb110[1]), _383@Mir(bb110[2])
  assert(move _384, "index out of bounds: the length is {} but the index is {}", move _383, _378) -> bb111
  using: _384@Entry, _383@Entry, _378@Entry
bb111:
  _377 = _13[_378]
  using: _13@Phi(bb104), _378@Mir(bb110[1])
  _386 = _351
  using: _351@Phi(bb104)
  _385 = move _386 as usize (IntToInt)
  using: _386@Mir(bb111[1])
  _387 = const 260_usize
  using: 
  _388 = Lt(_385, _387)
  using: _385@Mir(bb111[2]), _387@Mir(bb111[3])
  assert(move _388, "index out of bounds: the length is {} but the index is {}", move _387, _385) -> bb112
  using: _388@Entry, _387@Entry, _385@Entry
bb112:
  _13[_385] = move _377
  using: _385@Mir(bb111[2]), _377@Mir(bb111[0])
  _389 = const 1_i32
  using: 
  _390 = CheckedShr(_351, _389)
  using: _351@Phi(bb104), _389@Mir(bb112[1])
  assert(!move (_390.1: bool), "attempt to shift right by `{}`, which would overflow", move _389) -> bb113
  using: _390@Entry, _351@Entry, _389@Entry
bb113:
  _351 = move (_390.0: i32)
  using: _390@Mir(bb112[2])
  goto -> bb104
  using: 
bb114:
  _391 = _352
  using: _352@Mir(bb103[1])
  _393 = _351
  using: _351@Phi(bb104)
  _392 = move _393 as usize (IntToInt)
  using: _393@Mir(bb114[1])
  _394 = const 260_usize
  using: 
  _395 = Lt(_392, _394)
  using: _392@Mir(bb114[2]), _394@Mir(bb114[3])
  assert(move _395, "index out of bounds: the length is {} but the index is {}", move _394, _392) -> bb115
  using: _395@Entry, _394@Entry, _392@Entry
bb115:
  _13[_392] = move _391
  using: _392@Mir(bb114[2]), _391@Mir(bb114[0])
  goto -> bb34
  using: 
bb116:
  _398 = _5
  using: _5@Phi(bb34)
  _399 = const 516_i32
  using: 
  _397 = Lt(move _398, move _399)
  using: _398@Mir(bb116[0]), _399@Mir(bb116[1])
  _396 = Not(move _397)
  using: _397@Mir(bb116[2])
  switchInt(move _396) -> [0: bb118, otherwise: bb117]
  using: _396@Mir(bb116[3])
bb117:
  _401 = const 2002_i32
  using: 
  _400 = bzlib::BZ2_bz__AssertH__fail(move _401) -> bb118
  using: _401@Mir(bb117[0])
bb118:
  _12 = const 0_u8
  using: 
  _9 = const 1_i32
  using: 
  goto -> bb119
  using: 
bb119:
  _403 = _9
  using: _9@Phi(bb119)
  _404 = _3
  using: _3@Phi(bb12)
  _402 = Le(move _403, move _404)
  using: _403@Mir(bb119[0]), _404@Mir(bb119[1])
  switchInt(move _402) -> [0: bb132, otherwise: bb120]
  using: _402@Mir(bb119[2])
bb120:
  _10 = const 0_i32
  using: 
  _405 = _9
  using: _9@Phi(bb119)
  _11 = move _405
  using: _405@Mir(bb120[1])
  goto -> bb121
  using: 
bb121:
  _409 = _11
  using: _11@Phi(bb121)
  _408 = move _409 as usize (IntToInt)
  using: _409@Mir(bb121[0])
  _410 = const 516_usize
  using: 
  _411 = Lt(_408, _410)
  using: _408@Mir(bb121[1]), _410@Mir(bb121[2])
  assert(move _411, "index out of bounds: the length is {} but the index is {}", move _410, _408) -> bb122
  using: _411@Entry, _410@Entry, _408@Entry
bb122:
  _407 = _15[_408]
  using: _15@Phi(bb121), _408@Mir(bb121[1])
  _412 = const 0_i32
  using: 
  _406 = Ge(move _407, move _412)
  using: _407@Mir(bb122[0]), _412@Mir(bb122[1])
  switchInt(move _406) -> [0: bb126, otherwise: bb123]
  using: _406@Mir(bb122[2])
bb123:
  _415 = _11
  using: _11@Phi(bb121)
  _414 = move _415 as usize (IntToInt)
  using: _415@Mir(bb123[0])
  _416 = const 516_usize
  using: 
  _417 = Lt(_414, _416)
  using: _414@Mir(bb123[1]), _416@Mir(bb123[2])
  assert(move _417, "index out of bounds: the length is {} but the index is {}", move _416, _414) -> bb124
  using: _417@Entry, _416@Entry, _414@Entry
bb124:
  _413 = _15[_414]
  using: _15@Phi(bb121), _414@Mir(bb123[1])
  _11 = move _413
  using: _413@Mir(bb124[0])
  _418 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb121)
  assert(!move (_418.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb125
  using: _418@Entry, _10@Entry
bb125:
  _10 = move (_418.0: i32)
  using: _418@Mir(bb124[2])
  goto -> bb121
  using: 
bb126:
  _419 = _10
  using: _10@Phi(bb121)
  _421 = _1
  using: _1@Phi(bb119)
  _424 = _9
  using: _9@Phi(bb119)
  _425 = const 1_i32
  using: 
  _426 = CheckedSub(_424, _425)
  using: _424@Mir(bb126[2]), _425@Mir(bb126[3])
  assert(!move (_426.1: bool), "attempt to compute `{} - {}`, which would overflow", move _424, move _425) -> bb127
  using: _426@Entry, _424@Entry, _425@Entry
bb127:
  _423 = move (_426.0: i32)
  using: _426@Mir(bb126[4])
  _422 = move _423 as isize (IntToInt)
  using: _423@Mir(bb127[0])
  _420 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _421, move _422) -> bb128
  using: _421@Mir(bb126[1]), _422@Mir(bb127[1])
bb128:
  (*_420) = move _419 as u8 (IntToInt)
  using: _420@Mir(bb127[2]), _419@Mir(bb126[0])
  _428 = _10
  using: _10@Phi(bb121)
  _429 = _4
  using: _4@Phi(bb119)
  _427 = Gt(move _428, move _429)
  using: _428@Mir(bb128[1]), _429@Mir(bb128[2])
  switchInt(move _427) -> [0: bb130, otherwise: bb129]
  using: _427@Mir(bb128[3])
bb129:
  _12 = const 1_u8
  using: 
  goto -> bb130
  using: 
bb130:
  _430 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb119)
  assert(!move (_430.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb131
  using: _430@Entry, _9@Entry
bb131:
  _9 = move (_430.0: i32)
  using: _430@Mir(bb130[0])
  goto -> bb119
  using: 
bb132:
  _431 = _12
  using: _12@Phi(bb130)
  switchInt(move _431) -> [0: bb143, otherwise: bb133]
  using: _431@Mir(bb132[0])
bb133:
  _9 = const 1_i32
  using: 
  goto -> bb134
  using: 
bb134:
  _433 = _9
  using: _9@Phi(bb134)
  _434 = _3
  using: _3@Phi(bb12)
  _432 = Le(move _433, move _434)
  using: _433@Mir(bb134[0]), _434@Mir(bb134[1])
  switchInt(move _432) -> [0: bb12, otherwise: bb135]
  using: _432@Mir(bb134[2])
bb135:
  _437 = _9
  using: _9@Phi(bb134)
  _436 = move _437 as usize (IntToInt)
  using: _437@Mir(bb135[0])
  _438 = const 516_usize
  using: 
  _439 = Lt(_436, _438)
  using: _436@Mir(bb135[1]), _438@Mir(bb135[2])
  assert(move _439, "index out of bounds: the length is {} but the index is {}", move _438, _436) -> bb136
  using: _439@Entry, _438@Entry, _436@Entry
bb136:
  _435 = _14[_436]
  using: _14@Phi(bb134), _436@Mir(bb135[1])
  _440 = const 8_i32
  using: 
  _441 = CheckedShr(_435, _440)
  using: _435@Mir(bb136[0]), _440@Mir(bb136[1])
  assert(!move (_441.1: bool), "attempt to shift right by `{}`, which would overflow", move _440) -> bb137
  using: _441@Entry, _435@Entry, _440@Entry
bb137:
  _10 = move (_441.0: i32)
  using: _441@Mir(bb136[2])
  _442 = const 1_i32
  using: 
  _444 = _10
  using: _10@Mir(bb137[0])
  _445 = const 2_i32
  using: 
  _446 = const false
  using: 
  _447 = Eq(_444, const i32::MIN)
  using: _444@Mir(bb137[2])
  _448 = BitAnd(move _446, move _447)
  using: _446@Mir(bb137[4]), _447@Mir(bb137[5])
  assert(!move _448, "attempt to compute `{} / {}`, which would overflow", _444, _445) -> bb138
  using: _448@Entry, _444@Entry, _445@Entry
bb138:
  _443 = Div(move _444, move _445)
  using: _444@Mir(bb137[2]), _445@Mir(bb137[3])
  _449 = CheckedAdd(_442, _443)
  using: _442@Mir(bb137[1]), _443@Mir(bb138[0])
  assert(!move (_449.1: bool), "attempt to compute `{} + {}`, which would overflow", move _442, move _443) -> bb139
  using: _449@Entry, _442@Entry, _443@Entry
bb139:
  _10 = move (_449.0: i32)
  using: _449@Mir(bb138[1])
  _450 = _10
  using: _10@Mir(bb139[0])
  _451 = const 8_i32
  using: 
  _452 = CheckedShl(_450, _451)
  using: _450@Mir(bb139[1]), _451@Mir(bb139[2])
  assert(!move (_452.1: bool), "attempt to shift left by `{}`, which would overflow", move _451) -> bb140
  using: _452@Entry, _450@Entry, _451@Entry
bb140:
  _454 = _9
  using: _9@Phi(bb134)
  _453 = move _454 as usize (IntToInt)
  using: _454@Mir(bb140[0])
  _455 = const 516_usize
  using: 
  _456 = Lt(_453, _455)
  using: _453@Mir(bb140[1]), _455@Mir(bb140[2])
  assert(move _456, "index out of bounds: the length is {} but the index is {}", move _455, _453) -> bb141
  using: _456@Entry, _455@Entry, _453@Entry
bb141:
  _14[_453] = move (_452.0: i32)
  using: _453@Mir(bb140[1]), _452@Mir(bb139[3])
  _457 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb134)
  assert(!move (_457.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb142
  using: _457@Entry, _9@Entry
bb142:
  _9 = move (_457.0: i32)
  using: _457@Mir(bb141[1])
  goto -> bb134
  using: 
bb143:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 260] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 516] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i32; 516] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:33:23: 33:41 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:35:29: 35:47 (#0) by default
rewrite call core::num::<impl u32>::wrapping_add @ workspace/bzip2/rust/huffman.rs:121:49: 124:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:160:18: 160:65 (#0) by default
@DefId(0:473 ~ c2rust_lib[1043]::huffman::BZ2_hbAssignCodes)
bb0:
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _9 = _3
  using: _3@Entry
  _6 = move _9
  using: _9@Mir(bb0[4])
  goto -> bb1
  using: 
bb1:
  _11 = _6
  using: _6@Phi(bb1)
  _12 = _4
  using: _4@Entry
  _10 = Le(move _11, move _12)
  using: _11@Mir(bb1[0]), _12@Mir(bb1[1])
  switchInt(move _10) -> [0: bb14, otherwise: bb2]
  using: _10@Mir(bb1[2])
bb2:
  _8 = const 0_i32
  using: 
  goto -> bb3
  using: 
bb3:
  _14 = _8
  using: _8@Phi(bb3)
  _15 = _5
  using: _5@Phi(bb1)
  _13 = Lt(move _14, move _15)
  using: _14@Mir(bb3[0]), _15@Mir(bb3[1])
  switchInt(move _13) -> [0: bb11, otherwise: bb4]
  using: _13@Mir(bb3[2])
bb4:
  _20 = _2
  using: _2@Phi(bb3)
  _22 = _8
  using: _8@Phi(bb3)
  _21 = move _22 as isize (IntToInt)
  using: _22@Mir(bb4[1])
  _19 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _20, move _21) -> bb5
  using: _20@Mir(bb4[0]), _21@Mir(bb4[2])
bb5:
  _18 = (*_19)
  using: _19@Mir(bb4[3])
  _17 = move _18 as i32 (IntToInt)
  using: _18@Mir(bb5[0])
  _23 = _6
  using: _6@Phi(bb3)
  _16 = Eq(move _17, move _23)
  using: _17@Mir(bb5[1]), _23@Mir(bb5[2])
  switchInt(move _16) -> [0: bb9, otherwise: bb6]
  using: _16@Mir(bb5[3])
bb6:
  _24 = _7
  using: _7@Phi(bb3)
  _26 = _1
  using: _1@Phi(bb3)
  _28 = _8
  using: _8@Phi(bb3)
  _27 = move _28 as isize (IntToInt)
  using: _28@Mir(bb6[2])
  _25 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _26, move _27) -> bb7
  using: _26@Mir(bb6[1]), _27@Mir(bb6[3])
bb7:
  (*_25) = move _24
  using: _25@Mir(bb6[4]), _24@Mir(bb6[0])
  _29 = CheckedAdd(_7, const 1_i32)
  using: _7@Phi(bb3)
  assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> bb8
  using: _29@Entry, _7@Entry
bb8:
  _7 = move (_29.0: i32)
  using: _29@Mir(bb7[1])
  goto -> bb9
  using: 
bb9:
  _30 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb9)
  assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb10
  using: _30@Entry, _8@Entry
bb10:
  _8 = move (_30.0: i32)
  using: _30@Mir(bb9[0])
  goto -> bb3
  using: 
bb11:
  _31 = const 1_i32
  using: 
  _32 = CheckedShl(_7, _31)
  using: _7@Phi(bb9), _31@Mir(bb11[0])
  assert(!move (_32.1: bool), "attempt to shift left by `{}`, which would overflow", move _31) -> bb12
  using: _32@Entry, _7@Entry, _31@Entry
bb12:
  _7 = move (_32.0: i32)
  using: _32@Mir(bb11[1])
  _33 = CheckedAdd(_6, const 1_i32)
  using: _6@Phi(bb3)
  assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> bb13
  using: _33@Entry, _6@Entry
bb13:
  _6 = move (_33.0: i32)
  using: _33@Mir(bb12[1])
  goto -> bb1
  using: 
bb14:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:205:24: 205:42 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:206:23: 206:41 (#0) by default
@DefId(0:474 ~ c2rust_lib[1043]::huffman::BZ2_hbCreateDecodeTables)
bb0:
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  _8 = const 0_i32
  using: 
  _12 = _5
  using: _5@Entry
  _9 = move _12
  using: _12@Mir(bb0[5])
  goto -> bb1
  using: 
bb1:
  _14 = _9
  using: _9@Phi(bb1)
  _15 = _6
  using: _6@Entry
  _13 = Le(move _14, move _15)
  using: _14@Mir(bb1[0]), _15@Mir(bb1[1])
  switchInt(move _13) -> [0: bb13, otherwise: bb2]
  using: _13@Mir(bb1[2])
bb2:
  _10 = const 0_i32
  using: 
  goto -> bb3
  using: 
bb3:
  _17 = _10
  using: _10@Phi(bb3)
  _18 = _7
  using: _7@Phi(bb1)
  _16 = Lt(move _17, move _18)
  using: _17@Mir(bb3[0]), _18@Mir(bb3[1])
  switchInt(move _16) -> [0: bb11, otherwise: bb4]
  using: _16@Mir(bb3[2])
bb4:
  _23 = _4
  using: _4@Phi(bb3)
  _25 = _10
  using: _10@Phi(bb3)
  _24 = move _25 as isize (IntToInt)
  using: _25@Mir(bb4[1])
  _22 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _23, move _24) -> bb5
  using: _23@Mir(bb4[0]), _24@Mir(bb4[2])
bb5:
  _21 = (*_22)
  using: _22@Mir(bb4[3])
  _20 = move _21 as i32 (IntToInt)
  using: _21@Mir(bb5[0])
  _26 = _9
  using: _9@Phi(bb3)
  _19 = Eq(move _20, move _26)
  using: _20@Mir(bb5[1]), _26@Mir(bb5[2])
  switchInt(move _19) -> [0: bb9, otherwise: bb6]
  using: _19@Mir(bb5[3])
bb6:
  _27 = _10
  using: _10@Phi(bb3)
  _29 = _3
  using: _3@Phi(bb3)
  _31 = _8
  using: _8@Phi(bb3)
  _30 = move _31 as isize (IntToInt)
  using: _31@Mir(bb6[2])
  _28 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _29, move _30) -> bb7
  using: _29@Mir(bb6[1]), _30@Mir(bb6[3])
bb7:
  (*_28) = move _27
  using: _28@Mir(bb6[4]), _27@Mir(bb6[0])
  _32 = CheckedAdd(_8, const 1_i32)
  using: _8@Phi(bb3)
  assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, const 1_i32) -> bb8
  using: _32@Entry, _8@Entry
bb8:
  _8 = move (_32.0: i32)
  using: _32@Mir(bb7[1])
  goto -> bb9
  using: 
bb9:
  _33 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb9)
  assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb10
  using: _33@Entry, _10@Entry
bb10:
  _10 = move (_33.0: i32)
  using: _33@Mir(bb9[0])
  goto -> bb3
  using: 
bb11:
  _34 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb3)
  assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb12
  using: _34@Entry, _9@Entry
bb12:
  _9 = move (_34.0: i32)
  using: _34@Mir(bb11[0])
  goto -> bb1
  using: 
bb13:
  _9 = const 0_i32
  using: 
  goto -> bb14
  using: 
bb14:
  _36 = _9
  using: _9@Phi(bb14)
  _37 = const 23_i32
  using: 
  _35 = Lt(move _36, move _37)
  using: _36@Mir(bb14[0]), _37@Mir(bb14[1])
  switchInt(move _35) -> [0: bb18, otherwise: bb15]
  using: _35@Mir(bb14[2])
bb15:
  _38 = const 0_i32
  using: 
  _40 = _2
  using: _2@Phi(bb14)
  _42 = _9
  using: _9@Phi(bb14)
  _41 = move _42 as isize (IntToInt)
  using: _42@Mir(bb15[2])
  _39 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _40, move _41) -> bb16
  using: _40@Mir(bb15[1]), _41@Mir(bb15[3])
bb16:
  (*_39) = move _38
  using: _39@Mir(bb15[4]), _38@Mir(bb15[0])
  _43 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb14)
  assert(!move (_43.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb17
  using: _43@Entry, _9@Entry
bb17:
  _9 = move (_43.0: i32)
  using: _43@Mir(bb16[1])
  goto -> bb14
  using: 
bb18:
  _9 = const 0_i32
  using: 
  goto -> bb19
  using: 
bb19:
  _45 = _9
  using: _9@Phi(bb19)
  _46 = _7
  using: _7@Phi(bb1)
  _44 = Lt(move _45, move _46)
  using: _45@Mir(bb19[0]), _46@Mir(bb19[1])
  switchInt(move _44) -> [0: bb26, otherwise: bb20]
  using: _44@Mir(bb19[2])
bb20:
  _48 = _2
  using: _2@Phi(bb19)
  _54 = _4
  using: _4@Phi(bb19)
  _56 = _9
  using: _9@Phi(bb19)
  _55 = move _56 as isize (IntToInt)
  using: _56@Mir(bb20[2])
  _53 = std::ptr::mut_ptr::<impl *mut u8>::offset(move _54, move _55) -> bb21
  using: _54@Mir(bb20[1]), _55@Mir(bb20[3])
bb21:
  _52 = (*_53)
  using: _53@Mir(bb20[4])
  _51 = move _52 as i32 (IntToInt)
  using: _52@Mir(bb21[0])
  _57 = const 1_i32
  using: 
  _58 = CheckedAdd(_51, _57)
  using: _51@Mir(bb21[1]), _57@Mir(bb21[2])
  assert(!move (_58.1: bool), "attempt to compute `{} + {}`, which would overflow", move _51, move _57) -> bb22
  using: _58@Entry, _51@Entry, _57@Entry
bb22:
  _50 = move (_58.0: i32)
  using: _58@Mir(bb21[3])
  _49 = move _50 as isize (IntToInt)
  using: _50@Mir(bb22[0])
  _47 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _48, move _49) -> bb23
  using: _48@Mir(bb20[0]), _49@Mir(bb22[1])
bb23:
  _59 = CheckedAdd((*_47), const 1_i32)
  using: _47@Mir(bb22[2])
  assert(!move (_59.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_47), const 1_i32) -> bb24
  using: _59@Entry, _47@Entry
bb24:
  (*_47) = move (_59.0: i32)
  using: _47@Mir(bb22[2]), _59@Mir(bb23[0])
  _60 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb19)
  assert(!move (_60.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb25
  using: _60@Entry, _9@Entry
bb25:
  _9 = move (_60.0: i32)
  using: _60@Mir(bb24[1])
  goto -> bb19
  using: 
bb26:
  _9 = const 1_i32
  using: 
  goto -> bb27
  using: 
bb27:
  _62 = _9
  using: _9@Phi(bb27)
  _63 = const 23_i32
  using: 
  _61 = Lt(move _62, move _63)
  using: _62@Mir(bb27[0]), _63@Mir(bb27[1])
  switchInt(move _61) -> [0: bb34, otherwise: bb28]
  using: _61@Mir(bb27[2])
bb28:
  _66 = _2
  using: _2@Phi(bb27)
  _69 = _9
  using: _9@Phi(bb27)
  _70 = const 1_i32
  using: 
  _71 = CheckedSub(_69, _70)
  using: _69@Mir(bb28[1]), _70@Mir(bb28[2])
  assert(!move (_71.1: bool), "attempt to compute `{} - {}`, which would overflow", move _69, move _70) -> bb29
  using: _71@Entry, _69@Entry, _70@Entry
bb29:
  _68 = move (_71.0: i32)
  using: _71@Mir(bb28[3])
  _67 = move _68 as isize (IntToInt)
  using: _68@Mir(bb29[0])
  _65 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _66, move _67) -> bb30
  using: _66@Mir(bb28[0]), _67@Mir(bb29[1])
bb30:
  _64 = (*_65)
  using: _65@Mir(bb29[2])
  _73 = _2
  using: _2@Phi(bb27)
  _75 = _9
  using: _9@Phi(bb27)
  _74 = move _75 as isize (IntToInt)
  using: _75@Mir(bb30[2])
  _72 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _73, move _74) -> bb31
  using: _73@Mir(bb30[1]), _74@Mir(bb30[3])
bb31:
  _76 = CheckedAdd((*_72), _64)
  using: _72@Mir(bb30[4]), _64@Mir(bb30[0])
  assert(!move (_76.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_72), move _64) -> bb32
  using: _76@Entry, _72@Entry, _64@Entry
bb32:
  (*_72) = move (_76.0: i32)
  using: _72@Mir(bb30[4]), _76@Mir(bb31[0])
  _77 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb27)
  assert(!move (_77.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb33
  using: _77@Entry, _9@Entry
bb33:
  _9 = move (_77.0: i32)
  using: _77@Mir(bb32[1])
  goto -> bb27
  using: 
bb34:
  _9 = const 0_i32
  using: 
  goto -> bb35
  using: 
bb35:
  _79 = _9
  using: _9@Phi(bb35)
  _80 = const 23_i32
  using: 
  _78 = Lt(move _79, move _80)
  using: _79@Mir(bb35[0]), _80@Mir(bb35[1])
  switchInt(move _78) -> [0: bb39, otherwise: bb36]
  using: _78@Mir(bb35[2])
bb36:
  _81 = const 0_i32
  using: 
  _83 = _1
  using: _1@Phi(bb35)
  _85 = _9
  using: _9@Phi(bb35)
  _84 = move _85 as isize (IntToInt)
  using: _85@Mir(bb36[2])
  _82 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _83, move _84) -> bb37
  using: _83@Mir(bb36[1]), _84@Mir(bb36[3])
bb37:
  (*_82) = move _81
  using: _82@Mir(bb36[4]), _81@Mir(bb36[0])
  _86 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb35)
  assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb38
  using: _86@Entry, _9@Entry
bb38:
  _9 = move (_86.0: i32)
  using: _86@Mir(bb37[1])
  goto -> bb35
  using: 
bb39:
  _11 = const 0_i32
  using: 
  _87 = _5
  using: _5@Entry
  _9 = move _87
  using: _87@Mir(bb39[1])
  goto -> bb40
  using: 
bb40:
  _89 = _9
  using: _9@Phi(bb40)
  _90 = _6
  using: _6@Entry
  _88 = Le(move _89, move _90)
  using: _89@Mir(bb40[0]), _90@Mir(bb40[1])
  switchInt(move _88) -> [0: bb51, otherwise: bb41]
  using: _88@Mir(bb40[2])
bb41:
  _94 = _2
  using: _2@Phi(bb40)
  _97 = _9
  using: _9@Phi(bb40)
  _98 = const 1_i32
  using: 
  _99 = CheckedAdd(_97, _98)
  using: _97@Mir(bb41[1]), _98@Mir(bb41[2])
  assert(!move (_99.1: bool), "attempt to compute `{} + {}`, which would overflow", move _97, move _98) -> bb42
  using: _99@Entry, _97@Entry, _98@Entry
bb42:
  _96 = move (_99.0: i32)
  using: _99@Mir(bb41[3])
  _95 = move _96 as isize (IntToInt)
  using: _96@Mir(bb42[0])
  _93 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _94, move _95) -> bb43
  using: _94@Mir(bb41[0]), _95@Mir(bb42[1])
bb43:
  _92 = (*_93)
  using: _93@Mir(bb42[2])
  _102 = _2
  using: _2@Phi(bb40)
  _104 = _9
  using: _9@Phi(bb40)
  _103 = move _104 as isize (IntToInt)
  using: _104@Mir(bb43[2])
  _101 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _102, move _103) -> bb44
  using: _102@Mir(bb43[1]), _103@Mir(bb43[3])
bb44:
  _100 = (*_101)
  using: _101@Mir(bb43[4])
  _105 = CheckedSub(_92, _100)
  using: _92@Mir(bb43[0]), _100@Mir(bb44[0])
  assert(!move (_105.1: bool), "attempt to compute `{} - {}`, which would overflow", move _92, move _100) -> bb45
  using: _105@Entry, _92@Entry, _100@Entry
bb45:
  _91 = move (_105.0: i32)
  using: _105@Mir(bb44[1])
  _106 = CheckedAdd(_11, _91)
  using: _11@Phi(bb40), _91@Mir(bb45[0])
  assert(!move (_106.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, move _91) -> bb46
  using: _106@Entry, _11@Entry, _91@Entry
bb46:
  _11 = move (_106.0: i32)
  using: _106@Mir(bb45[1])
  _107 = _11
  using: _11@Mir(bb46[0])
  _108 = const 1_i32
  using: 
  _109 = CheckedSub(_107, _108)
  using: _107@Mir(bb46[1]), _108@Mir(bb46[2])
  assert(!move (_109.1: bool), "attempt to compute `{} - {}`, which would overflow", move _107, move _108) -> bb47
  using: _109@Entry, _107@Entry, _108@Entry
bb47:
  _111 = _1
  using: _1@Phi(bb40)
  _113 = _9
  using: _9@Phi(bb40)
  _112 = move _113 as isize (IntToInt)
  using: _113@Mir(bb47[1])
  _110 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _111, move _112) -> bb48
  using: _111@Mir(bb47[0]), _112@Mir(bb47[2])
bb48:
  (*_110) = move (_109.0: i32)
  using: _110@Mir(bb47[3]), _109@Mir(bb46[3])
  _114 = const 1_i32
  using: 
  _115 = CheckedShl(_11, _114)
  using: _11@Mir(bb46[0]), _114@Mir(bb48[1])
  assert(!move (_115.1: bool), "attempt to shift left by `{}`, which would overflow", move _114) -> bb49
  using: _115@Entry, _11@Entry, _114@Entry
bb49:
  _11 = move (_115.0: i32)
  using: _115@Mir(bb48[2])
  _116 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb40)
  assert(!move (_116.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb50
  using: _116@Entry, _9@Entry
bb50:
  _9 = move (_116.0: i32)
  using: _116@Mir(bb49[1])
  goto -> bb40
  using: 
bb51:
  _117 = _5
  using: _5@Entry
  _118 = const 1_i32
  using: 
  _119 = CheckedAdd(_117, _118)
  using: _117@Mir(bb51[0]), _118@Mir(bb51[1])
  assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", move _117, move _118) -> bb52
  using: _119@Entry, _117@Entry, _118@Entry
bb52:
  _9 = move (_119.0: i32)
  using: _119@Mir(bb51[2])
  goto -> bb53
  using: 
bb53:
  _121 = _9
  using: _9@Phi(bb53)
  _122 = _6
  using: _6@Entry
  _120 = Le(move _121, move _122)
  using: _121@Mir(bb53[0]), _122@Mir(bb53[1])
  switchInt(move _120) -> [0: bb63, otherwise: bb54]
  using: _120@Mir(bb53[2])
bb54:
  _127 = _1
  using: _1@Phi(bb53)
  _130 = _9
  using: _9@Phi(bb53)
  _131 = const 1_i32
  using: 
  _132 = CheckedSub(_130, _131)
  using: _130@Mir(bb54[1]), _131@Mir(bb54[2])
  assert(!move (_132.1: bool), "attempt to compute `{} - {}`, which would overflow", move _130, move _131) -> bb55
  using: _132@Entry, _130@Entry, _131@Entry
bb55:
  _129 = move (_132.0: i32)
  using: _132@Mir(bb54[3])
  _128 = move _129 as isize (IntToInt)
  using: _129@Mir(bb55[0])
  _126 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _127, move _128) -> bb56
  using: _127@Mir(bb54[0]), _128@Mir(bb55[1])
bb56:
  _125 = (*_126)
  using: _126@Mir(bb55[2])
  _133 = const 1_i32
  using: 
  _134 = CheckedAdd(_125, _133)
  using: _125@Mir(bb56[0]), _133@Mir(bb56[1])
  assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", move _125, move _133) -> bb57
  using: _134@Entry, _125@Entry, _133@Entry
bb57:
  _124 = move (_134.0: i32)
  using: _134@Mir(bb56[2])
  _135 = const 1_i32
  using: 
  _136 = CheckedShl(_124, _135)
  using: _124@Mir(bb57[0]), _135@Mir(bb57[1])
  assert(!move (_136.1: bool), "attempt to shift left by `{}`, which would overflow", move _135) -> bb58
  using: _136@Entry, _124@Entry, _135@Entry
bb58:
  _123 = move (_136.0: i32)
  using: _136@Mir(bb57[2])
  _139 = _2
  using: _2@Phi(bb53)
  _141 = _9
  using: _9@Phi(bb53)
  _140 = move _141 as isize (IntToInt)
  using: _141@Mir(bb58[2])
  _138 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _139, move _140) -> bb59
  using: _139@Mir(bb58[1]), _140@Mir(bb58[3])
bb59:
  _137 = (*_138)
  using: _138@Mir(bb58[4])
  _142 = CheckedSub(_123, _137)
  using: _123@Mir(bb58[0]), _137@Mir(bb59[0])
  assert(!move (_142.1: bool), "attempt to compute `{} - {}`, which would overflow", move _123, move _137) -> bb60
  using: _142@Entry, _123@Entry, _137@Entry
bb60:
  _144 = _2
  using: _2@Phi(bb53)
  _146 = _9
  using: _9@Phi(bb53)
  _145 = move _146 as isize (IntToInt)
  using: _146@Mir(bb60[1])
  _143 = std::ptr::mut_ptr::<impl *mut i32>::offset(move _144, move _145) -> bb61
  using: _144@Mir(bb60[0]), _145@Mir(bb60[2])
bb61:
  (*_143) = move (_142.0: i32)
  using: _143@Mir(bb60[3]), _142@Mir(bb59[1])
  _147 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb53)
  assert(!move (_147.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb62
  using: _147@Entry, _9@Entry
bb62:
  _9 = move (_147.0: i32)
  using: _147@Mir(bb61[1])
  goto -> bb53
  using: 
bb63:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:233:24: 233:42 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:234:23: 234:42 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:243:15: 243:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:248:31: 248:49 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:248:15: 249:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:254:43: 254:90 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:254:15: 254:33 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:259:16: 259:34 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:266:19: 266:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:267:23: 267:41 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:268:16: 268:34 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:275:22: 275:69 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:277:23: 277:41 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/bzip2/rust/huffman.rs:274:15: 274:33 (#0) by default

extern "C" {
    pub type __sFILEX;
    #[no_mangle]
    static mut __stderrp: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    
    
    #[no_mangle]
    static mut BZ2_rNums: [Int32; 512];
    
    
    
    
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor16;
impl Default for ErasedByPreprocessor16 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor17;
impl Default for ErasedByPreprocessor17 {fn default() -> Self {Self {
}}}

pub type FILE = crate::blocksort::__sFILE;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor18;
impl Default for ErasedByPreprocessor18 {fn default() -> Self {Self {
}}}

pub type Bool = std::os::raw::c_uchar;
pub type UChar = std::os::raw::c_uchar;
pub type Int32 = std::os::raw::c_int;
pub type UInt32 = std::os::raw::c_uint;
pub type UInt16 = std::os::raw::c_ushort;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor19;
impl Default for ErasedByPreprocessor19 {fn default() -> Self {Self {
}}}

/*-------------------------------------------------------------*/
/*--- Decompression machinery                               ---*/
/*---                                          decompress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
   This file is part of bzip2/libbzip2, a program and library for
   lossless, block-sorting data compression.

   bzip2/libbzip2 version 1.0.8 of 13 July 2019
   Copyright (C) 1996-2019 Julian Seward <jseward@acm.org>

   Please read the WARNING, DISCLAIMER and PATENTS sections in the 
   README file.

   This program is released under the terms of the license contained
   in the file LICENSE.
   ------------------------------------------------------------------ */
/*---------------------------------------------------*/
unsafe extern "C" fn makeMaps_d(mut s: Option<&mut crate::bzlib::DState>) {
    let mut i: Int32 = 0;
    (*s.as_deref_mut().unwrap()).nInUse= 0 as std::os::raw::c_int;
    i= 0 as std::os::raw::c_int;
    while i < 256 as std::os::raw::c_int {
        if (*s.as_deref().unwrap()).inUse[i as usize] != 0 {
            (*s.as_deref_mut().unwrap()).seqToUnseq[(*s.as_deref().unwrap()).nInUse as usize] = i as UChar;
            (*s.as_deref_mut().unwrap()).nInUse+= 1
        }
        i+= 1
    };
}
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/* the longest code */
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_decompress(mut s: *mut crate::bzlib::DState) -> Int32 {
    let mut current_block: u64;
    let mut uc: UChar = 0;
    let mut retVal: Int32 = 0;
    let mut minLen: Int32 = 0;
    let mut maxLen: Int32 = 0;
    let mut strm: *mut crate::blocksort::bz_stream = (*s).strm;
    /* stuff that needs to be saved/restored */
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut t: Int32 = 0;
    let mut alphaSize: Int32 = 0;
    let mut nGroups: Int32 = 0;
    let mut nSelectors: Int32 = 0;
    let mut EOB: Int32 = 0;
    let mut groupNo: Int32 = 0;
    let mut groupPos: Int32 = 0;
    let mut nextSym: Int32 = 0;
    let mut nblockMAX: Int32 = 0;
    let mut nblock: Int32 = 0;
    let mut es: Int32 = 0;
    let mut N: Int32 = 0;
    let mut curr: Int32 = 0;
    let mut zt: Int32 = 0;
    let mut zn: Int32 = 0;
    let mut zvec: Int32 = 0;
    let mut zj: Int32 = 0;
    let mut gSel: Int32 = 0;
    let mut gMinlen: Int32 = 0;
    let mut gLimit: *mut Int32 = 0 as *mut Int32;
    let mut gBase: *mut Int32 = 0 as *mut Int32;
    let mut gPerm: *mut Int32 = 0 as *mut Int32;
    if (*s).state == 10 as std::os::raw::c_int {
        /*initialise the save area*/
        (*s).save_i= 0 as std::os::raw::c_int;
        (*s).save_j= 0 as std::os::raw::c_int;
        (*s).save_t= 0 as std::os::raw::c_int;
        (*s).save_alphaSize= 0 as std::os::raw::c_int;
        (*s).save_nGroups= 0 as std::os::raw::c_int;
        (*s).save_nSelectors= 0 as std::os::raw::c_int;
        (*s).save_EOB= 0 as std::os::raw::c_int;
        (*s).save_groupNo= 0 as std::os::raw::c_int;
        (*s).save_groupPos= 0 as std::os::raw::c_int;
        (*s).save_nextSym= 0 as std::os::raw::c_int;
        (*s).save_nblockMAX= 0 as std::os::raw::c_int;
        (*s).save_nblock= 0 as std::os::raw::c_int;
        (*s).save_es= 0 as std::os::raw::c_int;
        (*s).save_N= 0 as std::os::raw::c_int;
        (*s).save_curr= 0 as std::os::raw::c_int;
        (*s).save_zt= 0 as std::os::raw::c_int;
        (*s).save_zn= 0 as std::os::raw::c_int;
        (*s).save_zvec= 0 as std::os::raw::c_int;
        (*s).save_zj= 0 as std::os::raw::c_int;
        (*s).save_gSel= 0 as std::os::raw::c_int;
        (*s).save_gMinlen= 0 as std::os::raw::c_int;
        (*s).save_gLimit= 0 as *mut Int32;
        (*s).save_gBase= 0 as *mut Int32;
        (*s).save_gPerm= 0 as *mut Int32
    }
    /*restore from the save area*/
    i= (*s).save_i;
    j= (*s).save_j;
    t= (*s).save_t;
    alphaSize= (*s).save_alphaSize;
    nGroups= (*s).save_nGroups;
    nSelectors= (*s).save_nSelectors;
    EOB= (*s).save_EOB;
    groupNo= (*s).save_groupNo;
    groupPos= (*s).save_groupPos;
    nextSym= (*s).save_nextSym;
    nblockMAX= (*s).save_nblockMAX;
    nblock= (*s).save_nblock;
    es= (*s).save_es;
    N= (*s).save_N;
    curr= (*s).save_curr;
    zt= (*s).save_zt;
    zn= (*s).save_zn;
    zvec= (*s).save_zvec;
    zj= (*s).save_zj;
    gSel= (*s).save_gSel;
    gMinlen= (*s).save_gMinlen;
    gLimit= (*s).save_gLimit;
    gBase= (*s).save_gBase;
    gPerm= (*s).save_gPerm;
    retVal= 0 as std::os::raw::c_int;
    match (*s).state {
        10 => {
            (*s).state= 10 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 5658374378798827547;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v: UInt32 = 0;
                    v=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v as UChar;
                    current_block= 5658374378798827547;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x42 as std::os::raw::c_int {
                        retVal= -(5 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 12259750428863723923; }
                }
            }
        }
        11 => { current_block= 12259750428863723923; }
        12 => { current_block= 15146946972525368609; }
        13 => { current_block= 13504760517129887221; }
        14 => { current_block= 7948568793456312728; }
        15 => { current_block= 16703841960874917807; }
        16 => { current_block= 12231332282017165356; }
        17 => { current_block= 7286555771988341860; }
        18 => { current_block= 6656868271313165664; }
        19 => { current_block= 15902903523132075486; }
        20 => { current_block= 16204949703499709801; }
        21 => { current_block= 5505795673017046993; }
        22 => { current_block= 14563596112884461881; }
        23 => { current_block= 12051594319698232578; }
        24 => { current_block= 14315698657705028467; }
        25 => { current_block= 640681092829779800; }
        26 => { current_block= 588075840077989673; }
        27 => { current_block= 34749046854646975; }
        28 => { current_block= 16487873541482693172; }
        29 => { current_block= 1422779171932145779; }
        30 => { current_block= 3906616468301123675; }
        31 => { current_block= 5769007513321684282; }
        32 => { current_block= 4874723077730206021; }
        33 => { current_block= 10945178116989557996; }
        34 => { current_block= 1736021991379636935; }
        35 => { current_block= 5008197131544113214; }
        36 => { current_block= 16722720626876144162; }
        37 => { current_block= 14744029255125744966; }
        38 => { current_block= 5374617794059532979; }
        39 => { current_block= 13999925517074022731; }
        40 => { current_block= 2629672494974161066; }
        41 => { current_block= 1050378859040334210; }
        42 => { current_block= 10200488719709598753; }
        43 => { current_block= 9864403379770423142; }
        44 => { current_block= 8489059574810375089; }
        45 => { current_block= 12998570369541158573; }
        46 => { current_block= 10541196509243133637; }
        47 => { current_block= 8760950161942609538; }
        48 => { current_block= 3131443096645543054; }
        49 => { current_block= 1975408140333322065; }
        50 => { current_block= 15818179691129344165; }
        _ => {
            if 0 as std::os::raw::c_int as Bool == 0 {
                crate::bzlib::BZ2_bz__AssertH__fail(4001 as std::os::raw::c_int);
            }
            if 0 as std::os::raw::c_int as Bool == 0 {
                crate::bzlib::BZ2_bz__AssertH__fail(4002 as std::os::raw::c_int);
            }
            current_block= 15885526978618306830;
        }
    }
    match current_block {
        12259750428863723923 => {
            (*s).state= 11 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 1658462350791934405;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_0: UInt32 = 0;
                    v_0=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_0 as UChar;
                    current_block= 1658462350791934405;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x5a as std::os::raw::c_int {
                        retVal= -(5 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 15146946972525368609; }
                }
            }
        }
        _ => { }
    }
    match current_block {
        15146946972525368609 => {
            (*s).state= 12 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 16314074004867283505;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_1: UInt32 = 0;
                    v_1=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_1 as UChar;
                    current_block= 16314074004867283505;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x68 as std::os::raw::c_int {
                        retVal= -(5 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 13504760517129887221; }
                }
            }
        }
        _ => { }
    }
    match current_block {
        13504760517129887221 => {
            (*s).state= 13 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 1915186496383530739;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_2: UInt32 = 0;
                    v_2=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    (*s).blockSize100k= v_2 as Int32;
                    current_block= 1915186496383530739;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if (*s).blockSize100k <
                           0x30 as std::os::raw::c_int + 1 as std::os::raw::c_int ||
                           (*s).blockSize100k >
                               0x30 as std::os::raw::c_int + 9 as std::os::raw::c_int {
                        retVal= -(5 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else {
                        (*s).blockSize100k-= 0x30 as std::os::raw::c_int;
                        if (*s).smallDecompress != 0 {
                            (*s).ll16=
                                (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                                                    (((*s).blockSize100k
                                                                                          *
                                                                                          100000
                                                                                              as
                                                                                              std::os::raw::c_int)
                                                                                         as
                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt16>()
                                                                                                                         as
                                                                                                                         std::os::raw::c_ulong)
                                                                                        as
                                                                                        std::os::raw::c_int,
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int)
                                    as *mut UInt16;
                            (*s).ll4=
                                (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                                                    ((1
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          +
                                                                                          (*s).blockSize100k
                                                                                              *
                                                                                              100000
                                                                                                  as
                                                                                                  std::os::raw::c_int
                                                                                          >>
                                                                                          1
                                                                                              as
                                                                                              std::os::raw::c_int)
                                                                                         as
                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UChar>()
                                                                                                                         as
                                                                                                                         std::os::raw::c_ulong)
                                                                                        as
                                                                                        std::os::raw::c_int,
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int)
                                    as *mut UChar;
                            if (*s).ll16.is_null() || (*s).ll4.is_null() {
                                retVal= -(3 as std::os::raw::c_int);
                                current_block= 15885526978618306830;
                            } else { current_block= 7948568793456312728; }
                        } else {
                            (*s).tt=
                                (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                                                    (((*s).blockSize100k
                                                                                          *
                                                                                          100000
                                                                                              as
                                                                                              std::os::raw::c_int)
                                                                                         as
                                                                                         std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<Int32>()
                                                                                                                         as
                                                                                                                         std::os::raw::c_ulong)
                                                                                        as
                                                                                        std::os::raw::c_int,
                                                                                    1
                                                                                        as
                                                                                        std::os::raw::c_int)
                                    as *mut UInt32;
                            if (*s).tt.is_null() {();
                                retVal= -(3 as std::os::raw::c_int);
                                current_block= 15885526978618306830;
                            } else { current_block= 7948568793456312728; }
                        }
                    }
                }
            }
        }
        _ => { }
    }
    match current_block {
        7948568793456312728 => {
            (*s).state= 14 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 9846950269610550213;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_3: UInt32 = 0;
                    v_3=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_3 as UChar;
                    current_block= 9846950269610550213;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int == 0x17 as std::os::raw::c_int {
                        current_block= 10200488719709598753;
                    } else if uc as std::os::raw::c_int != 0x31 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 16703841960874917807; }
                }
            }
        }
        _ => { }
    }
    match current_block {
        10200488719709598753 => {
            (*s).state= 42 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 13262463590990658200;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_32: UInt32 = 0;
                    v_32=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_32 as UChar;
                    current_block= 13262463590990658200;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x72 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 9864403379770423142; }
                }
            }
        }
        16703841960874917807 => {
            (*s).state= 15 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 3569141194949357899;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_4: UInt32 = 0;
                    v_4=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_4 as UChar;
                    current_block= 3569141194949357899;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x41 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 12231332282017165356; }
                }
            }
        }
        _ => { }
    }
    match current_block {
        9864403379770423142 => {
            (*s).state= 43 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 10756506701594629759;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_33: UInt32 = 0;
                    v_33=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_33 as UChar;
                    current_block= 10756506701594629759;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x45 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 8489059574810375089; }
                }
            }
        }
        12231332282017165356 => {
            (*s).state= 16 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 16517180880614114163;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_5: UInt32 = 0;
                    v_5=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_5 as UChar;
                    current_block= 16517180880614114163;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x59 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 7286555771988341860; }
                }
            }
        }
        _ => { }
    }
    match current_block {
        8489059574810375089 => {
            (*s).state= 44 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 9819403752380335018;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_34: UInt32 = 0;
                    v_34=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_34 as UChar;
                    current_block= 9819403752380335018;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x38 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 12998570369541158573; }
                }
            }
        }
        7286555771988341860 => {
            (*s).state= 17 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 2606663910910355487;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_6: UInt32 = 0;
                    v_6=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_6 as UChar;
                    current_block= 2606663910910355487;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x26 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 6656868271313165664; }
                }
            }
        }
        _ => { }
    }
    match current_block {
        12998570369541158573 => {
            (*s).state= 45 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 9454797012561717444;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_35: UInt32 = 0;
                    v_35=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_35 as UChar;
                    current_block= 9454797012561717444;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x50 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 10541196509243133637; }
                }
            }
        }
        6656868271313165664 => {
            (*s).state= 18 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 8125779086361653720;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_7: UInt32 = 0;
                    v_7=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_7 as UChar;
                    current_block= 8125779086361653720;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x53 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else { current_block= 15902903523132075486; }
                }
            }
        }
        _ => { }
    }
    match current_block {
        10541196509243133637 => {
            (*s).state= 46 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 724777313732190959;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_36: UInt32 = 0;
                    v_36=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_36 as UChar;
                    current_block= 724777313732190959;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x90 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else {
                        (*s).storedCombinedCRC= 0 as std::os::raw::c_int as UInt32;
                        current_block= 8760950161942609538;
                    }
                }
            }
        }
        15902903523132075486 => {
            (*s).state= 19 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 958128786106592581;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_8: UInt32 = 0;
                    v_8=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_8 as UChar;
                    current_block= 958128786106592581;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    if uc as std::os::raw::c_int != 0x59 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else {
                        (*s).currBlockNo+= 1;
                        if (*s).verbosity >= 2 as std::os::raw::c_int {
                            fprintf(__stderrp,
                                    b"\n    [%d: huff+mtf \x00" as *const u8
                                        as *const std::os::raw::c_char,
                                    (*s).currBlockNo);
                        }
                        (*s).storedBlockCRC= 0 as std::os::raw::c_int as UInt32;
                        current_block= 16204949703499709801;
                    }
                }
            }
        }
        _ => { }
    }
    match current_block {
        8760950161942609538 => {
            (*s).state= 47 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 14486187473704332379;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_37: UInt32 = 0;
                    v_37=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_37 as UChar;
                    current_block= 14486187473704332379;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedCombinedCRC=
                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    current_block= 3131443096645543054;
                }
            }
        }
        16204949703499709801 => {
            (*s).state= 20 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 3790734079518302164;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_9: UInt32 = 0;
                    v_9=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_9 as UChar;
                    current_block= 3790734079518302164;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedBlockCRC=
                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    current_block= 5505795673017046993;
                }
            }
        }
        _ => { }
    }
    match current_block {
        3131443096645543054 => {
            (*s).state= 48 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 3659807904093622879;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_38: UInt32 = 0;
                    v_38=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_38 as UChar;
                    current_block= 3659807904093622879;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedCombinedCRC=
                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    current_block= 1975408140333322065;
                }
            }
        }
        5505795673017046993 => {
            (*s).state= 21 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 16711521214030637000;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_10: UInt32 = 0;
                    v_10=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_10 as UChar;
                    current_block= 16711521214030637000;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedBlockCRC=
                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    current_block= 14563596112884461881;
                }
            }
        }
        _ => { }
    }
    match current_block {
        1975408140333322065 => {
            (*s).state= 49 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 2394045633138979148;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_39: UInt32 = 0;
                    v_39=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_39 as UChar;
                    current_block= 2394045633138979148;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedCombinedCRC=
                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    current_block= 15818179691129344165;
                }
            }
        }
        14563596112884461881 => {
            (*s).state= 22 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 17870985093275900527;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_11: UInt32 = 0;
                    v_11=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_11 as UChar;
                    current_block= 17870985093275900527;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedBlockCRC=
                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    current_block= 12051594319698232578;
                }
            }
        }
        _ => { }
    }
    match current_block {
        12051594319698232578 => {
            (*s).state= 23 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 13734492969709581318;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_12: UInt32 = 0;
                    v_12=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_12 as UChar;
                    current_block= 13734492969709581318;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedBlockCRC=
                        (*s).storedBlockCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    current_block= 14315698657705028467;
                }
            }
        }
        15818179691129344165 => {
            (*s).state= 50 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 1904329045571868869;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_40: UInt32 = 0;
                    v_40=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_40 as UChar;
                    current_block= 1904329045571868869;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).storedCombinedCRC=
                        (*s).storedCombinedCRC << 8 as std::os::raw::c_int |
                            uc as UInt32;
                    (*s).state= 1 as std::os::raw::c_int;
                    retVal= 4 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                }
            }
        }
        _ => { }
    }
    match current_block {
        14315698657705028467 => {
            (*s).state= 24 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 15030729790988239748;
                    break ;
                }
                if (*s).bsLive >= 1 as std::os::raw::c_int {
                    let mut v_13: UInt32 = 0;
                    v_13=
                        (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 1 as std::os::raw::c_int;
                    (*s).blockRandomised= v_13 as Bool;
                    current_block= 15030729790988239748;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).origPtr= 0 as std::os::raw::c_int;
                    current_block= 640681092829779800;
                }
            }
        }
        _ => { }
    }
    match current_block {
        640681092829779800 => {
            (*s).state= 25 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 8260322496947496197;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_14: UInt32 = 0;
                    v_14=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_14 as UChar;
                    current_block= 8260322496947496197;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).origPtr=
                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;
                    current_block= 588075840077989673;
                }
            }
        }
        _ => { }
    }
    match current_block {
        588075840077989673 => {
            (*s).state= 26 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 5561851013817067674;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_15: UInt32 = 0;
                    v_15=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_15 as UChar;
                    current_block= 5561851013817067674;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).origPtr=
                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;
                    current_block= 34749046854646975;
                }
            }
        }
        _ => { }
    }
    match current_block {
        34749046854646975 => {
            (*s).state= 27 as std::os::raw::c_int;
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 10471999855724930313;
                    break ;
                }
                if (*s).bsLive >= 8 as std::os::raw::c_int {
                    let mut v_16: UInt32 = 0;
                    v_16=
                        (*s).bsBuff >> (*s).bsLive - 8 as std::os::raw::c_int &
                            (((1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) -
                                 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                    (*s).bsLive-= 8 as std::os::raw::c_int;
                    uc= v_16 as UChar;
                    current_block= 10471999855724930313;
                    break ;
                } else if (*(*s).strm).avail_in ==
                              0 as std::os::raw::c_int as std::os::raw::c_uint {
                    retVal= 0 as std::os::raw::c_int;
                    current_block= 15885526978618306830;
                    break ;
                } else {
                    (*s).bsBuff=
                        (*s).bsBuff << 8 as std::os::raw::c_int |
                            *((*(*s).strm).next_in as *mut UChar) as UInt32;
                    (*s).bsLive+= 8 as std::os::raw::c_int;
                    (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
                    (*(*s).strm).avail_in=
                        (*(*s).strm).avail_in.wrapping_sub(1);
                    (*(*s).strm).total_in_lo32=
                        (*(*s).strm).total_in_lo32.wrapping_add(1);
                    if (*(*s).strm).total_in_lo32 ==
                           0 as std::os::raw::c_int as std::os::raw::c_uint {
                        (*(*s).strm).total_in_hi32=
                            (*(*s).strm).total_in_hi32.wrapping_add(1)
                    }
                }
            }
            match current_block {
                15885526978618306830 => { }
                _ => {
                    (*s).origPtr=
                        (*s).origPtr << 8 as std::os::raw::c_int | uc as Int32;
                    if (*s).origPtr < 0 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else if (*s).origPtr >
                                  10 as std::os::raw::c_int +
                                      100000 as std::os::raw::c_int *
                                          (*s).blockSize100k {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                    } else {
                        /*--- Receive the mapping table ---*/
                        i= 0 as std::os::raw::c_int;
                        current_block= 17262312153619709241;
                    }
                }
            }
        }
        _ => { }
    }
    'c_10532:
        loop  {
            match current_block {
                15885526978618306830 => { (*s).save_i= i; break ; }
                2629672494974161066 => {
                    (*s).state= 40 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= zn {
                            let mut v_30: UInt32 = 0;
                            v_30=
                                (*s).bsBuff >> (*s).bsLive - zn &
                                    (((1 as std::os::raw::c_int) << zn) -
                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= zn;
                            zvec= v_30 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    current_block= 9078889872071895942;
                }
                13999925517074022731 => {
                    (*s).state= 39 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_29: UInt32 = 0;
                            v_29=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            zj= v_29 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    zvec= zvec << 1 as std::os::raw::c_int | zj;
                    current_block= 13605767259572914371;
                }
                5374617794059532979 => {
                    (*s).state= 38 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= zn {
                            let mut v_28: UInt32 = 0;
                            v_28=
                                (*s).bsBuff >> (*s).bsLive - zn &
                                    (((1 as std::os::raw::c_int) << zn) -
                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= zn;
                            zvec= v_28 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    current_block= 13605767259572914371;
                }
                14744029255125744966 => {
                    (*s).state= 37 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_27: UInt32 = 0;
                            v_27=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            zj= v_27 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    zvec= zvec << 1 as std::os::raw::c_int | zj;
                    current_block= 1550405138573481750;
                }
                16722720626876144162 => {
                    (*s).state= 36 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= zn {
                            let mut v_26: UInt32 = 0;
                            v_26=
                                (*s).bsBuff >> (*s).bsLive - zn &
                                    (((1 as std::os::raw::c_int) << zn) -
                                         1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= zn;
                            zvec= v_26 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    current_block= 1550405138573481750;
                }
                5008197131544113214 => {
                    (*s).state= 35 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_25: UInt32 = 0;
                            v_25=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            uc= v_25 as UChar;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    if uc as std::os::raw::c_int == 0 as std::os::raw::c_int {
                        curr+= 1
                    } else { curr-= 1 }
                    current_block= 11858046780433112516;
                }
                1736021991379636935 => {
                    (*s).state= 34 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_24: UInt32 = 0;
                            v_24=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            uc= v_24 as UChar;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    if !(uc as std::os::raw::c_int == 0 as std::os::raw::c_int) {
                        current_block= 5008197131544113214;
                        continue ;
                    }
                    current_block= 17503523010989424999;
                }
                10945178116989557996 => {
                    (*s).state= 33 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 5 as std::os::raw::c_int {
                            let mut v_23: UInt32 = 0;
                            v_23=
                                (*s).bsBuff >> (*s).bsLive - 5 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 5 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 5 as std::os::raw::c_int;
                            curr= v_23 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    i= 0 as std::os::raw::c_int;
                    current_block= 3770765986603902964;
                }
                4874723077730206021 => {
                    (*s).state= 32 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_21: UInt32 = 0;
                            v_21=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            uc= v_21 as UChar;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    if uc as std::os::raw::c_int == 0 as std::os::raw::c_int {
                        current_block= 5281038271658253520;
                    } else {
                        j+= 1;
                        if j >= nGroups {
                            retVal= -(4 as std::os::raw::c_int);
                            current_block= 15885526978618306830;
                            continue ;
                        } else { current_block= 6927328446518169316; }
                    }
                }
                5769007513321684282 => {
                    (*s).state= 31 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 15 as std::os::raw::c_int {
                            let mut v_20: UInt32 = 0;
                            v_20=
                                (*s).bsBuff >> (*s).bsLive - 15 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 15 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 15 as std::os::raw::c_int;
                            nSelectors= v_20 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    if nSelectors < 1 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                        continue ;
                    } else { i= 0 as std::os::raw::c_int }
                    current_block= 6591141407893725683;
                }
                3906616468301123675 =>
                /*--- Now the selectors ---*/
                {
                    (*s).state= 30 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 3 as std::os::raw::c_int {
                            let mut v_19: UInt32 = 0;
                            v_19=
                                (*s).bsBuff >> (*s).bsLive - 3 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 3 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 3 as std::os::raw::c_int;
                            nGroups= v_19 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    if !(nGroups < 2 as std::os::raw::c_int ||
                             nGroups > 6 as std::os::raw::c_int) {
                        current_block= 5769007513321684282;
                        continue ;
                    }
                    retVal= -(4 as std::os::raw::c_int);
                    current_block= 15885526978618306830;
                    continue ;
                }
                1422779171932145779 => {
                    (*s).state= 29 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_18: UInt32 = 0;
                            v_18=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            uc= v_18 as UChar;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    if uc as std::os::raw::c_int == 1 as std::os::raw::c_int {
                        (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] =
                            1 as std::os::raw::c_int as Bool
                    }
                    j+= 1;
                    current_block= 3854024847017804838;
                }
                17262312153619709241 => {
                    if i < 16 as std::os::raw::c_int {
                        current_block= 16487873541482693172;
                        continue ;
                    }
                    i= 0 as std::os::raw::c_int;
                    while i < 256 as std::os::raw::c_int {
                        (*s).inUse[i as usize] = 0 as std::os::raw::c_int as Bool;
                        i+= 1
                    }
                    i= 0 as std::os::raw::c_int;
                    current_block= 3472349144349095221;
                }
                16487873541482693172 => {
                    (*s).state= 28 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_17: UInt32 = 0;
                            v_17=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            uc= v_17 as UChar;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    if uc as std::os::raw::c_int == 1 as std::os::raw::c_int {
                        (*s).inUse16[i as usize] = 1 as std::os::raw::c_int as Bool
                    } else {
                        (*s).inUse16[i as usize] = 0 as std::os::raw::c_int as Bool
                    }
                    i+= 1;
                    current_block= 17262312153619709241;
                    continue ;
                }
                _ => {
                    (*s).state= 41 as std::os::raw::c_int;
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if (*s).bsLive >= 1 as std::os::raw::c_int {
                            let mut v_31: UInt32 = 0;
                            v_31=
                                (*s).bsBuff >> (*s).bsLive - 1 as std::os::raw::c_int
                                    &
                                    (((1 as std::os::raw::c_int) << 1 as std::os::raw::c_int)
                                         - 1 as std::os::raw::c_int) as std::os::raw::c_uint;
                            (*s).bsLive-= 1 as std::os::raw::c_int;
                            zj= v_31 as Int32;
                            break ;
                        } else if (*(*s).strm).avail_in ==
                                      0 as std::os::raw::c_int as std::os::raw::c_uint {
                            retVal= 0 as std::os::raw::c_int;
                            current_block= 15885526978618306830;
                            continue 'c_10532 ;
                        } else {
                            (*s).bsBuff=
                                (*s).bsBuff << 8 as std::os::raw::c_int |
                                    *((*(*s).strm).next_in as *mut UChar) as
                                        UInt32;
                            (*s).bsLive+= 8 as std::os::raw::c_int;
                            (*(*s).strm).next_in=
                                (*(*s).strm).next_in.offset(1);
                            (*(*s).strm).avail_in=
                                (*(*s).strm).avail_in.wrapping_sub(1);
                            (*(*s).strm).total_in_lo32=
                                (*(*s).strm).total_in_lo32.wrapping_add(1);
                            if (*(*s).strm).total_in_lo32 ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                (*(*s).strm).total_in_hi32=
                                    (*(*s).strm).total_in_hi32.wrapping_add(1)
                            }
                        }
                    }
                    zvec= zvec << 1 as std::os::raw::c_int | zj;
                    current_block= 9078889872071895942;
                }
            }
            match current_block {
                9078889872071895942 => {
                    if zn > 20 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                        continue ;
                    } else if zvec <= *gLimit.offset(zn as isize) {
                        if zvec - *gBase.offset(zn as isize) <
                               0 as std::os::raw::c_int ||
                               zvec - *gBase.offset(zn as isize) >=
                                   258 as std::os::raw::c_int {
                            retVal= -(4 as std::os::raw::c_int);
                            current_block= 15885526978618306830;
                            continue ;
                        } else {
                            nextSym=
                                *gPerm.offset((zvec -
                                                   *gBase.offset(zn as isize))
                                                  as isize)
                        }
                    } else {
                        zn+= 1;
                        current_block= 1050378859040334210;
                        continue ;
                    }
                    current_block= 15093386068129942558;
                }
                13605767259572914371 => {
                    if zn > 20 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                        continue ;
                    } else if zvec <= *gLimit.offset(zn as isize) {
                        if zvec - *gBase.offset(zn as isize) <
                               0 as std::os::raw::c_int ||
                               zvec - *gBase.offset(zn as isize) >=
                                   258 as std::os::raw::c_int {
                            retVal= -(4 as std::os::raw::c_int);
                            current_block= 15885526978618306830;
                            continue ;
                        } else {
                            nextSym=
                                *gPerm.offset((zvec -
                                                   *gBase.offset(zn as isize))
                                                  as isize);
                            if nextSym == 0 as std::os::raw::c_int ||
                                   nextSym == 1 as std::os::raw::c_int {
                                current_block= 4550729491376650574;
                            } else {
                                es+= 1;
                                uc=
                                    (*s).seqToUnseq[(*s).mtfa[(*s).mtfbase[0
                                                                               as
                                                                               std::os::raw::c_int
                                                                               as
                                                                               usize]
                                                                  as usize] as
                                                        usize];
                                (*s).unzftab[uc as usize] += es;
                                if (*s).smallDecompress != 0 {
                                    while es > 0 as std::os::raw::c_int {
                                        if nblock >= nblockMAX {
                                            retVal= -(4 as std::os::raw::c_int);
                                            current_block=
                                                15885526978618306830;
                                            continue 'c_10532 ;
                                        } else {
                                            *(*s).ll16.offset(nblock as isize)
                                                = uc as UInt16;
                                            nblock+= 1;
                                            es-= 1
                                        }
                                    }
                                } else {
                                    while es > 0 as std::os::raw::c_int {
                                        if nblock >= nblockMAX {
                                            retVal= -(4 as std::os::raw::c_int);
                                            current_block=
                                                15885526978618306830;
                                            continue 'c_10532 ;
                                        } else {
                                            *(*s).tt.offset(nblock as isize) =
                                                uc as UInt32;
                                            nblock+= 1;
                                            es-= 1
                                        }
                                    }
                                }
                                current_block= 15093386068129942558;
                            }
                        }
                    } else {
                        zn+= 1;
                        current_block= 13999925517074022731;
                        continue ;
                    }
                }
                1550405138573481750 => {
                    if zn > 20 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                        continue ;
                    } else if zvec <= *gLimit.offset(zn as isize) {
                        if zvec - *gBase.offset(zn as isize) <
                               0 as std::os::raw::c_int ||
                               zvec - *gBase.offset(zn as isize) >=
                                   258 as std::os::raw::c_int {
                            retVal= -(4 as std::os::raw::c_int);
                            current_block= 15885526978618306830;
                            continue ;
                        } else {
                            nextSym=
                                *gPerm.offset((zvec -
                                                   *gBase.offset(zn as isize))
                                                  as isize)
                        }
                    } else {
                        zn+= 1;
                        current_block= 14744029255125744966;
                        continue ;
                    }
                    current_block= 15093386068129942558;
                }
                _ => { }
            }
            match current_block {
                15093386068129942558 => {
                    if 1 as std::os::raw::c_int as Bool != 0 {
                        if nextSym == EOB {
                            current_block= 12118509005321596519;
                        } else {
                            if nextSym == 0 as std::os::raw::c_int ||
                                   nextSym == 1 as std::os::raw::c_int {
                                es= -(1 as std::os::raw::c_int);
                                N= 1 as std::os::raw::c_int
                            } else if nblock >= nblockMAX {
                                retVal= -(4 as std::os::raw::c_int);
                                current_block= 15885526978618306830;
                                continue ;
                            } else {
                                /*-- uc = MTF ( nextSym-1 ) --*/
                                let mut ii_0: Int32 = 0;
                                let mut jj_0: Int32 = 0;
                                let mut kk_0: Int32 = 0;
                                let mut pp: Int32 = 0;
                                let mut lno: Int32 = 0;
                                let mut off: Int32 = 0;
                                let mut nn: UInt32 = 0;
                                nn= (nextSym - 1 as std::os::raw::c_int) as UInt32;
                                if nn < 16 as std::os::raw::c_int as std::os::raw::c_uint {
                                    /* avoid general-case expense */
                                    pp=
                                        (*s).mtfbase[0 as std::os::raw::c_int as
                                                         usize];
                                    uc=
                                        (*s).mtfa[(pp as
                                                       std::os::raw::c_uint).wrapping_add(nn)
                                                      as usize];
                                    while nn >
                                              3 as std::os::raw::c_int as std::os::raw::c_uint
                                          {
                                        let mut z: Int32 =
                                            (pp as
                                                 std::os::raw::c_uint).wrapping_add(nn)
                                                as Int32;
                                        (*s).mtfa[z as usize] =
                                            (*s).mtfa[(z - 1 as std::os::raw::c_int)
                                                          as usize];
                                        (*s).mtfa[(z - 1 as std::os::raw::c_int) as
                                                      usize] =
                                            (*s).mtfa[(z - 2 as std::os::raw::c_int)
                                                          as usize];
                                        (*s).mtfa[(z - 2 as std::os::raw::c_int) as
                                                      usize] =
                                            (*s).mtfa[(z - 3 as std::os::raw::c_int)
                                                          as usize];
                                        (*s).mtfa[(z - 3 as std::os::raw::c_int) as
                                                      usize] =
                                            (*s).mtfa[(z - 4 as std::os::raw::c_int)
                                                          as usize];
                                        nn=
                                            (nn as
                                                 std::os::raw::c_uint).wrapping_sub(4
                                                                                as
                                                                                std::os::raw::c_int
                                                                                as
                                                                                std::os::raw::c_uint)
                                                as UInt32 as UInt32
                                    }
                                    while nn >
                                              0 as std::os::raw::c_int as std::os::raw::c_uint
                                          {
                                        (*s).mtfa[(pp as
                                                       std::os::raw::c_uint).wrapping_add(nn)
                                                      as usize] =
                                            (*s).mtfa[(pp as
                                                           std::os::raw::c_uint).wrapping_add(nn).wrapping_sub(1
                                                                                                           as
                                                                                                           std::os::raw::c_int
                                                                                                           as
                                                                                                           std::os::raw::c_uint)
                                                          as usize];
                                        nn= nn.wrapping_sub(1)
                                    }
                                    (*s).mtfa[pp as usize] = uc
                                } else {
                                    /* general case */
                                    lno=
                                        nn.wrapping_div(16 as std::os::raw::c_int as
                                                            std::os::raw::c_uint) as
                                            Int32;
                                    off=
                                        nn.wrapping_rem(16 as std::os::raw::c_int as
                                                            std::os::raw::c_uint) as
                                            Int32;
                                    pp= (*s).mtfbase[lno as usize] + off;
                                    uc= (*s).mtfa[pp as usize];
                                    while pp > (*s).mtfbase[lno as usize] {
                                        (*s).mtfa[pp as usize] =
                                            (*s).mtfa[(pp - 1 as std::os::raw::c_int)
                                                          as usize];
                                        pp-= 1
                                    }
                                    (*s).mtfbase[lno as usize] += 1;
                                    while lno > 0 as std::os::raw::c_int {
                                        (*s).mtfbase[lno as usize] -= 1;
                                        (*s).mtfa[(*s).mtfbase[lno as usize]
                                                      as usize] =
                                            (*s).mtfa[((*s).mtfbase[(lno -
                                                                         1 as
                                                                             std::os::raw::c_int)
                                                                        as
                                                                        usize]
                                                           + 16 as std::os::raw::c_int
                                                           - 1 as std::os::raw::c_int)
                                                          as usize];
                                        lno-= 1
                                    }
                                    (*s).mtfbase[0 as std::os::raw::c_int as usize] -=
                                        1;
                                    (*s).mtfa[(*s).mtfbase[0 as std::os::raw::c_int as
                                                               usize] as
                                                  usize] = uc;
                                    if (*s).mtfbase[0 as std::os::raw::c_int as usize]
                                           == 0 as std::os::raw::c_int {
                                        kk_0=
                                            4096 as std::os::raw::c_int -
                                                1 as std::os::raw::c_int;
                                        ii_0=
                                            256 as std::os::raw::c_int /
                                                16 as std::os::raw::c_int -
                                                1 as std::os::raw::c_int;
                                        while ii_0 >= 0 as std::os::raw::c_int {
                                            jj_0=
                                                16 as std::os::raw::c_int -
                                                    1 as std::os::raw::c_int;
                                            while jj_0 >= 0 as std::os::raw::c_int {
                                                (*s).mtfa[kk_0 as usize] =
                                                    (*s).mtfa[((*s).mtfbase[ii_0
                                                                                as
                                                                                usize]
                                                                   + jj_0) as
                                                                  usize];
                                                kk_0-= 1;
                                                jj_0-= 1
                                            }
                                            (*s).mtfbase[ii_0 as usize] =
                                                kk_0 + 1 as std::os::raw::c_int;
                                            ii_0-= 1
                                        }
                                    }
                                }
                                /*-- end uc = MTF ( nextSym-1 ) --*/
                                (*s).unzftab[(*s).seqToUnseq[uc as usize] as
                                                 usize] += 1;
                                if (*s).smallDecompress != 0 {
                                    *(*s).ll16.offset(nblock as isize) =
                                        (*s).seqToUnseq[uc as usize] as UInt16
                                } else {
                                    *(*s).tt.offset(nblock as isize) =
                                        (*s).seqToUnseq[uc as usize] as UInt32
                                }
                                nblock+= 1;
                                if groupPos == 0 as std::os::raw::c_int {
                                    groupNo+= 1;
                                    if groupNo >= nSelectors {
                                        retVal= -(4 as std::os::raw::c_int);
                                        current_block= 15885526978618306830;
                                        continue ;
                                    } else {
                                        groupPos= 50 as std::os::raw::c_int;
                                        gSel=
                                            (*s).selector[groupNo as usize] as
                                                Int32;
                                        gMinlen= (*s).minLens[gSel as usize];
                                        gLimit=
                                            &mut *(*(*s).limit.as_mut_ptr().offset(gSel
                                                                                       as
                                                                                       isize)).as_mut_ptr().offset(0
                                                                                                                       as
                                                                                                                       std::os::raw::c_int
                                                                                                                       as
                                                                                                                       isize)
                                                as *mut Int32;
                                        gPerm=
                                            &mut *(*(*s).perm.as_mut_ptr().offset(gSel
                                                                                      as
                                                                                      isize)).as_mut_ptr().offset(0
                                                                                                                      as
                                                                                                                      std::os::raw::c_int
                                                                                                                      as
                                                                                                                      isize)
                                                as *mut Int32;
                                        gBase=
                                            &mut *(*(*s).base.as_mut_ptr().offset(gSel
                                                                                      as
                                                                                      isize)).as_mut_ptr().offset(0
                                                                                                                      as
                                                                                                                      std::os::raw::c_int
                                                                                                                      as
                                                                                                                      isize)
                                                as *mut Int32
                                    }
                                }
                                groupPos-= 1;
                                zn= gMinlen;
                                current_block= 2629672494974161066;
                                continue ;
                            }
                            current_block= 4550729491376650574;
                        }
                    } else { current_block = 12118509005321596519; }
                    match current_block {
                        4550729491376650574 => { }
                        _ =>
                        /* Now we know what nblock is, we can do a better sanity
         check on s->origPtr.
      */
                        {
                            if (*s).origPtr < 0 as std::os::raw::c_int ||
                                   (*s).origPtr >= nblock {
                                retVal= -(4 as std::os::raw::c_int);
                                current_block= 15885526978618306830;
                                continue ;
                            } else {
                                /*-- Set up cftab to facilitate generation of T^(-1) --*/
      /* Check: unzftab entries in range. */
                                i= 0 as std::os::raw::c_int;
                                while i <= 255 as std::os::raw::c_int {
                                    if (*s).unzftab[i as usize] <
                                           0 as std::os::raw::c_int ||
                                           (*s).unzftab[i as usize] > nblock {
                                        retVal= -(4 as std::os::raw::c_int);
                                        current_block= 15885526978618306830;
                                        continue 'c_10532 ;
                                    } else { i+= 1 }
                                }
                                /* Actually generate cftab. */
                                (*s).cftab[0 as std::os::raw::c_int as usize] =
                                    0 as std::os::raw::c_int;
                                i= 1 as std::os::raw::c_int;
                                while i <= 256 as std::os::raw::c_int {
                                    (*s).cftab[i as usize] =
                                        (*s).unzftab[(i - 1 as std::os::raw::c_int) as
                                                         usize];
                                    i+= 1
                                }
                                i= 1 as std::os::raw::c_int;
                                while i <= 256 as std::os::raw::c_int {
                                    (*s).cftab[i as usize] +=
                                        (*s).cftab[(i - 1 as std::os::raw::c_int) as
                                                       usize];
                                    i+= 1
                                }
                                /* Check: cftab entries in range. */
                                i= 0 as std::os::raw::c_int;
                                while i <= 256 as std::os::raw::c_int {
                                    if (*s).cftab[i as usize] <
                                           0 as std::os::raw::c_int ||
                                           (*s).cftab[i as usize] > nblock {
                                        /* s->cftab[i] can legitimately be == nblock */
                                        retVal= -(4 as std::os::raw::c_int);
                                        current_block= 15885526978618306830;
                                        continue 'c_10532 ;
                                    } else { i+= 1 }
                                }
                                /* Check: cftab entries non-descending. */
                                i= 1 as std::os::raw::c_int;
                                while i <= 256 as std::os::raw::c_int {
                                    if (*s).cftab[(i - 1 as std::os::raw::c_int) as
                                                      usize] >
                                           (*s).cftab[i as usize] {
                                        retVal= -(4 as std::os::raw::c_int);
                                        current_block= 15885526978618306830;
                                        continue 'c_10532 ;
                                    } else { i+= 1 }
                                }
                                (*s).state_out_len= 0 as std::os::raw::c_int;
                                (*s).state_out_ch= 0 as std::os::raw::c_int as UChar;
                                (*s).calculatedBlockCRC=
                                    0xffffffff as std::os::raw::c_long as UInt32;
                                (*s).state= 2 as std::os::raw::c_int;
                                if (*s).verbosity >= 2 as std::os::raw::c_int {
                                    fprintf(__stderrp,
                                            b"rt+rld\x00" as *const u8 as
                                                *const std::os::raw::c_char);
                                }
                                if (*s).smallDecompress != 0 {
                                    /*-- Make a copy of cftab, used in generation of T --*/
                                    i= 0 as std::os::raw::c_int;
                                    while i <= 256 as std::os::raw::c_int {
                                        (*s).cftabCopy[i as usize] =
                                            (*s).cftab[i as usize];
                                        i+= 1
                                    }
                                    /*-- compute the T vector --*/
                                    i= 0 as std::os::raw::c_int;
                                    while i < nblock {
                                        uc=
                                            *(*s).ll16.offset(i as isize) as
                                                UChar;
                                        *(*s).ll16.offset(i as isize) =
                                            ((*s).cftabCopy[uc as usize] &
                                                 0xffff as std::os::raw::c_int) as
                                                UInt16;
                                        if i & 0x1 as std::os::raw::c_int ==
                                               0 as std::os::raw::c_int {
                                            *(*s).ll4.offset((i >>
                                                                  1 as
                                                                      std::os::raw::c_int)
                                                                 as isize) =
                                                (*(*s).ll4.offset((i >>
                                                                       1 as
                                                                           std::os::raw::c_int)
                                                                      as
                                                                      isize)
                                                     as std::os::raw::c_int &
                                                     0xf0 as std::os::raw::c_int |
                                                     (*s).cftabCopy[uc as
                                                                        usize]
                                                         >> 16 as std::os::raw::c_int)
                                                    as UChar
                                        } else {
                                            *(*s).ll4.offset((i >>
                                                                  1 as
                                                                      std::os::raw::c_int)
                                                                 as isize) =
                                                (*(*s).ll4.offset((i >>
                                                                       1 as
                                                                           std::os::raw::c_int)
                                                                      as
                                                                      isize)
                                                     as std::os::raw::c_int &
                                                     0xf as std::os::raw::c_int |
                                                     ((*s).cftabCopy[uc as
                                                                         usize]
                                                          >>
                                                          16 as std::os::raw::c_int)
                                                         << 4 as std::os::raw::c_int)
                                                    as UChar
                                        }
                                        (*s).cftabCopy[uc as usize] += 1;
                                        i+= 1
                                    }
                                    /*-- Compute T^(-1) by pointer reversal on T --*/
                                    i= (*s).origPtr;
                                    j=
                                        (*(*s).ll16.offset(i as isize) as
                                             UInt32 |
                                             (*(*s).ll4.offset((i >>
                                                                    1 as
                                                                        std::os::raw::c_int)
                                                                   as isize)
                                                  as UInt32 >>
                                                  (i << 2 as std::os::raw::c_int &
                                                       0x4 as std::os::raw::c_int) &
                                                  0xf as std::os::raw::c_int as
                                                      std::os::raw::c_uint) <<
                                                 16 as std::os::raw::c_int) as Int32;
                                    loop  {
                                        let mut tmp_0: Int32 =
                                            (*(*s).ll16.offset(j as isize) as
                                                 UInt32 |
                                                 (*(*s).ll4.offset((j >>
                                                                        1 as
                                                                            std::os::raw::c_int)
                                                                       as
                                                                       isize)
                                                      as UInt32 >>
                                                      (j << 2 as std::os::raw::c_int &
                                                           0x4 as std::os::raw::c_int)
                                                      &
                                                      0xf as std::os::raw::c_int as
                                                          std::os::raw::c_uint) <<
                                                     16 as std::os::raw::c_int) as
                                                Int32;
                                        *(*s).ll16.offset(j as isize) =
                                            (i & 0xffff as std::os::raw::c_int) as
                                                UInt16;
                                        if j & 0x1 as std::os::raw::c_int ==
                                               0 as std::os::raw::c_int {
                                            *(*s).ll4.offset((j >>
                                                                  1 as
                                                                      std::os::raw::c_int)
                                                                 as isize) =
                                                (*(*s).ll4.offset((j >>
                                                                       1 as
                                                                           std::os::raw::c_int)
                                                                      as
                                                                      isize)
                                                     as std::os::raw::c_int &
                                                     0xf0 as std::os::raw::c_int |
                                                     i >> 16 as std::os::raw::c_int)
                                                    as UChar
                                        } else {
                                            *(*s).ll4.offset((j >>
                                                                  1 as
                                                                      std::os::raw::c_int)
                                                                 as isize) =
                                                (*(*s).ll4.offset((j >>
                                                                       1 as
                                                                           std::os::raw::c_int)
                                                                      as
                                                                      isize)
                                                     as std::os::raw::c_int &
                                                     0xf as std::os::raw::c_int |
                                                     (i >> 16 as std::os::raw::c_int)
                                                         << 4 as std::os::raw::c_int)
                                                    as UChar
                                        }
                                        i= j;
                                        j= tmp_0;
                                        if !(i != (*s).origPtr) { break ; }
                                    }
                                    (*s).tPos= (*s).origPtr as UInt32;
                                    (*s).nblock_used= 0 as std::os::raw::c_int;
                                    if (*s).blockRandomised != 0 {
                                        (*s).rNToGo= 0 as std::os::raw::c_int;
                                        (*s).rTPos= 0 as std::os::raw::c_int;
                                        if (*s).tPos >=
                                               (100000 as std::os::raw::c_int as
                                                    UInt32).wrapping_mul((*s).blockSize100k
                                                                             as
                                                                             UInt32)
                                           {
                                            return 1 as std::os::raw::c_int as Bool as
                                                       Int32
                                        }
                                        (*s).k0=
                                            crate::bzlib::BZ2_indexIntoF((*s).tPos as Int32,
                                                           (*s).cftab.as_mut_ptr());
                                        (*s).tPos=
                                            *(*s).ll16.offset((*s).tPos as
                                                                  isize) as
                                                UInt32 |
                                                (*(*s).ll4.offset(((*s).tPos
                                                                       >>
                                                                       1 as
                                                                           std::os::raw::c_int)
                                                                      as
                                                                      isize)
                                                     as UInt32 >>
                                                     ((*s).tPos <<
                                                          2 as std::os::raw::c_int &
                                                          0x4 as std::os::raw::c_int
                                                              as std::os::raw::c_uint)
                                                     &
                                                     0xf as std::os::raw::c_int as
                                                         std::os::raw::c_uint) <<
                                                    16 as std::os::raw::c_int;
                                        (*s).nblock_used+= 1;
                                        if (*s).rNToGo == 0 as std::os::raw::c_int {
                                            (*s).rNToGo=
                                                BZ2_rNums[(*s).rTPos as
                                                              usize];
                                            (*s).rTPos+= 1;
                                            if (*s).rTPos ==
                                                   512 as std::os::raw::c_int {
                                                (*s).rTPos= 0 as std::os::raw::c_int
                                            }
                                        }
                                        (*s).rNToGo-= 1;
                                        (*s).k0
                                    } else {
                                        if (*s).tPos >=
                                               (100000 as std::os::raw::c_int as
                                                    UInt32).wrapping_mul((*s).blockSize100k
                                                                             as
                                                                             UInt32)
                                           {
                                            return 1 as std::os::raw::c_int as Bool as
                                                       Int32
                                        }
                                        (*s).k0=
                                            crate::bzlib::BZ2_indexIntoF((*s).tPos as Int32,
                                                           (*s).cftab.as_mut_ptr());
                                        (*s).tPos=
                                            *(*s).ll16.offset((*s).tPos as
                                                                  isize) as
                                                UInt32 |
                                                (*(*s).ll4.offset(((*s).tPos
                                                                       >>
                                                                       1 as
                                                                           std::os::raw::c_int)
                                                                      as
                                                                      isize)
                                                     as UInt32 >>
                                                     ((*s).tPos <<
                                                          2 as std::os::raw::c_int &
                                                          0x4 as std::os::raw::c_int
                                                              as std::os::raw::c_uint)
                                                     &
                                                     0xf as std::os::raw::c_int as
                                                         std::os::raw::c_uint) <<
                                                    16 as std::os::raw::c_int;
                                        (*s).nblock_used+= 1
                                    }
                                } else {
                                    /*-- compute the T^(-1) vector --*/
                                    i= 0 as std::os::raw::c_int;
                                    while i < nblock {
                                        uc=
                                            (*(*s).tt.offset(i as isize) &
                                                 0xff as std::os::raw::c_int as
                                                     std::os::raw::c_uint) as UChar;
                                        *(*s).tt.offset((*s).cftab[uc as
                                                                           usize]
                                                                as isize) = (i << 8 as std::os::raw::c_int) as
                                                std::os::raw::c_uint;
                                        (*s).cftab[uc as usize] += 1;
                                        i+= 1
                                    }
                                    (*s).tPos=
                                        *(*s).tt.offset((*s).origPtr as isize)
                                            >> 8 as std::os::raw::c_int;
                                    (*s).nblock_used= 0 as std::os::raw::c_int;
                                    if (*s).blockRandomised != 0 {
                                        (*s).rNToGo= 0 as std::os::raw::c_int;
                                        (*s).rTPos= 0 as std::os::raw::c_int;
                                        if (*s).tPos >=
                                               (100000 as std::os::raw::c_int as
                                                    UInt32).wrapping_mul((*s).blockSize100k
                                                                             as
                                                                             UInt32)
                                           {
                                            return 1 as std::os::raw::c_int as Bool as
                                                       Int32
                                        }
                                        (*s).tPos=
                                            *(*s).tt.offset((*s).tPos as
                                                                isize);
                                        (*s).k0=
                                            ((*s).tPos &
                                                 0xff as std::os::raw::c_int as
                                                     std::os::raw::c_uint) as UChar as
                                                Int32;
                                        (*s).tPos>>= 8 as std::os::raw::c_int;
                                        (*s).nblock_used+= 1;
                                        if (*s).rNToGo == 0 as std::os::raw::c_int {
                                            (*s).rNToGo=
                                                BZ2_rNums[(*s).rTPos as
                                                              usize];
                                            (*s).rTPos+= 1;
                                            if (*s).rTPos ==
                                                   512 as std::os::raw::c_int {
                                                (*s).rTPos= 0 as std::os::raw::c_int
                                            }
                                        }
                                        (*s).rNToGo-= 1;
                                        (*s).k0
                                    } else {
                                        if (*s).tPos >=
                                               (100000 as std::os::raw::c_int as
                                                    UInt32).wrapping_mul((*s).blockSize100k
                                                                             as
                                                                             UInt32)
                                           {
                                            return 1 as std::os::raw::c_int as Bool as
                                                       Int32
                                        }
                                        (*s).tPos=
                                            *(*s).tt.offset((*s).tPos as
                                                                isize);
                                        (*s).k0=
                                            ((*s).tPos &
                                                 0xff as std::os::raw::c_int as
                                                     std::os::raw::c_uint) as UChar as
                                                Int32;
                                        (*s).tPos>>= 8 as std::os::raw::c_int;
                                        (*s).nblock_used+= 1
                                    }
                                }
                                retVal= 0 as std::os::raw::c_int;
                                current_block= 15885526978618306830;
                                continue ;
                            }
                        }
                    }
                }
                _ => { }
            }
            match current_block {
                4550729491376650574 =>
                /* Check that N doesn't get too big, so that es doesn't
                  go negative.  The maximum value that can be
                  RUNA/RUNB encoded is equal to the block size (post
                  the initial RLE), viz, 900k, so bounding N at 2
                  million should guard against overflow without
                  rejecting any legitimate inputs. */
                {
                    if N >=
                           2 as std::os::raw::c_int * 1024 as std::os::raw::c_int *
                               1024 as std::os::raw::c_int {
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                        continue ;
                    } else {
                        if nextSym == 0 as std::os::raw::c_int {
                            es=
                                es + (0 as std::os::raw::c_int + 1 as std::os::raw::c_int) * N
                        } else if nextSym == 1 as std::os::raw::c_int {
                            es=
                                es + (1 as std::os::raw::c_int + 1 as std::os::raw::c_int) * N
                        }
                        N= N * 2 as std::os::raw::c_int;
                        if groupPos == 0 as std::os::raw::c_int {
                            groupNo+= 1;
                            if groupNo >= nSelectors {
                                retVal= -(4 as std::os::raw::c_int);
                                current_block= 15885526978618306830;
                                continue ;
                            } else {
                                groupPos= 50 as std::os::raw::c_int;
                                gSel=
                                    (*s).selector[groupNo as usize] as Int32;
                                gMinlen= (*s).minLens[gSel as usize];
                                gLimit=
                                    &mut *(*(*s).limit.as_mut_ptr().offset(gSel
                                                                               as
                                                                               isize)).as_mut_ptr().offset(0
                                                                                                               as
                                                                                                               std::os::raw::c_int
                                                                                                               as
                                                                                                               isize)
                                        as *mut Int32;
                                gPerm=
                                    &mut *(*(*s).perm.as_mut_ptr().offset(gSel
                                                                              as
                                                                              isize)).as_mut_ptr().offset(0
                                                                                                              as
                                                                                                              std::os::raw::c_int
                                                                                                              as
                                                                                                              isize)
                                        as *mut Int32;
                                gBase=
                                    &mut *(*(*s).base.as_mut_ptr().offset(gSel
                                                                              as
                                                                              isize)).as_mut_ptr().offset(0
                                                                                                              as
                                                                                                              std::os::raw::c_int
                                                                                                              as
                                                                                                              isize)
                                        as *mut Int32
                            }
                        }
                        groupPos-= 1;
                        zn= gMinlen;
                        current_block= 5374617794059532979;
                        continue ;
                    }
                }
                _ => { }
            }
            loop  {
                match current_block {
                    3854024847017804838 => {
                        if j < 16 as std::os::raw::c_int {
                            current_block= 1422779171932145779;
                            continue 'c_10532 ;
                        }
                    }
                    6591141407893725683 => {
                        if i < nSelectors {
                            j= 0 as std::os::raw::c_int;
                            current_block= 6927328446518169316;
                            continue ;
                        } else {
                            if nSelectors >
                                   2 as std::os::raw::c_int +
                                       900000 as std::os::raw::c_int /
                                           50 as std::os::raw::c_int {
                                nSelectors=
                                    2 as std::os::raw::c_int +
                                        900000 as std::os::raw::c_int /
                                            50 as std::os::raw::c_int
                            }
                            /*--- Undo the MTF values for the selectors. ---*/
                            let mut pos: [UChar; 6] = [0; 6];
                            let mut tmp: UChar = 0;
                            let mut v_22: UChar = 0;
                            v_22= 0 as std::os::raw::c_int as UChar;
                            while (v_22 as std::os::raw::c_int) < nGroups {
                                pos[v_22 as usize] = v_22;
                                v_22= v_22.wrapping_add(1)
                            }
                            i= 0 as std::os::raw::c_int;
                            while i < nSelectors {
                                v_22= (*s).selectorMtf[i as usize];
                                tmp= pos[v_22 as usize];
                                while v_22 as std::os::raw::c_int > 0 as std::os::raw::c_int {
                                    pos[v_22 as usize] =
                                        pos[(v_22 as std::os::raw::c_int -
                                                 1 as std::os::raw::c_int) as usize];
                                    v_22= v_22.wrapping_sub(1)
                                }
                                pos[0 as std::os::raw::c_int as usize] = tmp;
                                (*s).selector[i as usize] = tmp;
                                i+= 1
                            }
                            /*--- Now the coding tables ---*/
                            t= 0 as std::os::raw::c_int;
                            current_block= 16916874950763617094;
                            break ;
                        }
                    }
                    3472349144349095221 => {
                        if i < 16 as std::os::raw::c_int {
                            if (*s).inUse16[i as usize] != 0 {
                                j= 0 as std::os::raw::c_int;
                                current_block= 3854024847017804838;
                                continue ;
                            }
                        } else {
                            makeMaps_d(s.as_mut());
                            if (*s).nInUse == 0 as std::os::raw::c_int {
                                current_block= 11906008669688594715;
                                break ;
                            } else {
                                current_block= 7606051654693192361;
                                break ;
                            }
                        }
                    }
                    17503523010989424999 => {
                        (*s).len[t as usize][i as usize] = curr as UChar;
                        i+= 1;
                        current_block= 3770765986603902964;
                        continue ;
                    }
                    3770765986603902964 => {
                        if i < alphaSize {
                            current_block= 11858046780433112516;
                            continue ;
                        }
                        t+= 1;
                        current_block= 16916874950763617094;
                        break ;
                    }
                    5281038271658253520 => {
                        /* Having more than BZ_MAX_SELECTORS doesn't make much sense
            since they will never be used, but some implementations might
            "round up" the number of selectors, so just ignore those. */
                        if i <
                               2 as std::os::raw::c_int +
                                   900000 as std::os::raw::c_int / 50 as std::os::raw::c_int {
                            (*s).selectorMtf[i as usize] = j as UChar
                        }
                        i+= 1;
                        current_block= 6591141407893725683;
                        continue ;
                    }
                    6927328446518169316 => {
                        if 1 as std::os::raw::c_int as Bool != 0 {
                            current_block= 4874723077730206021;
                            continue 'c_10532 ;
                        } else {
                            current_block = 5281038271658253520;
                            continue ;
                        }
                    }
                    _ => {
                        if !(1 as std::os::raw::c_int as Bool != 0) {
                            current_block = 17503523010989424999;
                            continue ;
                        }
                        if !(curr < 1 as std::os::raw::c_int ||
                                 curr > 20 as std::os::raw::c_int) {
                            current_block= 1736021991379636935;
                            continue 'c_10532 ;
                        }
                        retVal= -(4 as std::os::raw::c_int);
                        current_block= 15885526978618306830;
                        continue 'c_10532 ;
                    }
                }
                i+= 1;
                current_block= 3472349144349095221;
            }
            match current_block {
                7606051654693192361 => {
                    alphaSize= (*s).nInUse + 2 as std::os::raw::c_int;
                    current_block= 3906616468301123675;
                }
                11906008669688594715 => {
                    retVal= -(4 as std::os::raw::c_int);
                    current_block= 15885526978618306830;
                }
                _ => {
                    if t < nGroups {
                        current_block= 10945178116989557996;
                        continue ;
                    }
                    /*--- Create the Huffman decoding tables ---*/
                    t= 0 as std::os::raw::c_int;
                    while t < nGroups {
                        minLen= 32 as std::os::raw::c_int;
                        maxLen= 0 as std::os::raw::c_int;
                        i= 0 as std::os::raw::c_int;
                        while i < alphaSize {
                            if (*s).len[t as usize][i as usize] as std::os::raw::c_int
                                   > maxLen {
                                maxLen=
                                    (*s).len[t as usize][i as usize] as Int32
                            }
                            if ((*s).len[t as usize][i as usize] as
                                    std::os::raw::c_int) < minLen {
                                minLen=
                                    (*s).len[t as usize][i as usize] as Int32
                            }
                            i+= 1
                        }
                        crate::huffman::BZ2_hbCreateDecodeTables(&mut *(*(*s).limit.as_mut_ptr().offset(t
                                                                                            as
                                                                                            isize)).as_mut_ptr().offset(0
                                                                                                                            as
                                                                                                                            std::os::raw::c_int
                                                                                                                            as
                                                                                                                            isize),
                                                 &mut *(*(*s).base.as_mut_ptr().offset(t
                                                                                           as
                                                                                           isize)).as_mut_ptr().offset(0
                                                                                                                           as
                                                                                                                           std::os::raw::c_int
                                                                                                                           as
                                                                                                                           isize),
                                                 &mut *(*(*s).perm.as_mut_ptr().offset(t
                                                                                           as
                                                                                           isize)).as_mut_ptr().offset(0
                                                                                                                           as
                                                                                                                           std::os::raw::c_int
                                                                                                                           as
                                                                                                                           isize),
                                                 &mut *(*(*s).len.as_mut_ptr().offset(t
                                                                                          as
                                                                                          isize)).as_mut_ptr().offset(0
                                                                                                                          as
                                                                                                                          std::os::raw::c_int
                                                                                                                          as
                                                                                                                          isize),
                                                 minLen, maxLen, alphaSize);
                        (*s).minLens[t as usize] = minLen;
                        t+= 1
                    }
                    /*--- Now the MTF values ---*/
                    EOB= (*s).nInUse + 1 as std::os::raw::c_int;
                    nblockMAX= 100000 as std::os::raw::c_int * (*s).blockSize100k;
                    groupNo= -(1 as std::os::raw::c_int);
                    groupPos= 0 as std::os::raw::c_int;
                    i= 0 as std::os::raw::c_int;
                    while i <= 255 as std::os::raw::c_int {
                        (*s).unzftab[i as usize] = 0 as std::os::raw::c_int;
                        i+= 1
                    }
                    /*-- MTF init --*/
                    let mut ii: Int32 = 0;
                    let mut jj: Int32 = 0;
                    let mut kk: Int32 = 0;
                    kk= 4096 as std::os::raw::c_int - 1 as std::os::raw::c_int;
                    ii=
                        256 as std::os::raw::c_int / 16 as std::os::raw::c_int -
                            1 as std::os::raw::c_int;
                    while ii >= 0 as std::os::raw::c_int {
                        jj= 16 as std::os::raw::c_int - 1 as std::os::raw::c_int;
                        while jj >= 0 as std::os::raw::c_int {
                            (*s).mtfa[kk as usize] =
                                (ii * 16 as std::os::raw::c_int + jj) as UChar;
                            kk-= 1;
                            jj-= 1
                        }
                        (*s).mtfbase[ii as usize] = kk + 1 as std::os::raw::c_int;
                        ii-= 1
                    }
                    /*-- end MTF init --*/
                    nblock= 0 as std::os::raw::c_int;
                    if groupPos == 0 as std::os::raw::c_int {
                        groupNo+= 1;
                        if groupNo >= nSelectors {
                            retVal= -(4 as std::os::raw::c_int);
                            current_block= 15885526978618306830;
                            continue ;
                        } else {
                            groupPos= 50 as std::os::raw::c_int;
                            gSel= (*s).selector[groupNo as usize] as Int32;
                            gMinlen= (*s).minLens[gSel as usize];
                            gLimit=
                                &mut *(*(*s).limit.as_mut_ptr().offset(gSel as
                                                                           isize)).as_mut_ptr().offset(0
                                                                                                           as
                                                                                                           std::os::raw::c_int
                                                                                                           as
                                                                                                           isize)
                                    as *mut Int32;
                            gPerm=
                                &mut *(*(*s).perm.as_mut_ptr().offset(gSel as
                                                                          isize)).as_mut_ptr().offset(0
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                    as *mut Int32;
                            gBase=
                                &mut *(*(*s).base.as_mut_ptr().offset(gSel as
                                                                          isize)).as_mut_ptr().offset(0
                                                                                                          as
                                                                                                          std::os::raw::c_int
                                                                                                          as
                                                                                                          isize)
                                    as *mut Int32
                        }
                    }
                    groupPos-= 1;
                    zn= gMinlen;
                    current_block= 16722720626876144162;
                }
            }
        }
    (*s).save_j= j;
    (*s).save_t= t;
    (*s).save_alphaSize= alphaSize;
    (*s).save_nGroups= nGroups;
    (*s).save_nSelectors= nSelectors;
    (*s).save_EOB= EOB;
    (*s).save_groupNo= groupNo;
    (*s).save_groupPos= groupPos;
    (*s).save_nextSym= nextSym;
    (*s).save_nblockMAX= nblockMAX;
    (*s).save_nblock= nblock;
    (*s).save_es= es;
    (*s).save_N= N;
    (*s).save_curr= curr;
    (*s).save_zt= zt;
    (*s).save_zn= zn;
    (*s).save_zvec= zvec;
    (*s).save_zj= zj;
    (*s).save_gSel= gSel;
    (*s).save_gMinlen= gMinlen;
    (*s).save_gLimit= gLimit;
    (*s).save_gBase= gBase;
    (*s).save_gPerm= gPerm;
    return retVal;
}
/*-------------------------------------------------------------*/
/*--- end                                      decompress.c ---*/
/*-------------------------------------------------------------*/

extern "C" {
    
    
}
pub type Bool = std::os::raw::c_uchar;
pub type UChar = std::os::raw::c_uchar;
pub type Int32 = std::os::raw::c_int;
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_hbMakeCodeLengths(mut len: *mut UChar,
                                               mut freq: *const Int32,
                                               mut alphaSize: Int32,
                                               mut maxLen: Int32) {
    /*--
      Nodes and heap entries run from 1.  Entry 0
      for both the heap and nodes is a sentinel.
   --*/
    let mut nNodes: Int32 = 0;
    let mut nHeap: Int32 = 0;
    let mut n1: Int32 = 0;
    let mut n2: Int32 = 0;
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut k: Int32 = 0;
    let mut tooLong: Bool = 0;
    let mut heap: [Int32; 260] = [0; 260];
    let mut weight: [Int32; 516] = [0; 516];
    let mut parent: [Int32; 516] = [0; 516];
    i= 0 as std::os::raw::c_int;
    while i < alphaSize {
        weight[(i + 1 as std::os::raw::c_int) as usize] =
            (if *freq.offset(i as isize) == 0 as std::os::raw::c_int {
                 1 as std::os::raw::c_int
             } else { *freq.offset(i as isize) }) << 8 as std::os::raw::c_int;
        i+= 1
    }
    while 1 as std::os::raw::c_int as Bool != 0 {
        nNodes= alphaSize;
        nHeap= 0 as std::os::raw::c_int;
        heap[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int;
        weight[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int;
        parent[0 as std::os::raw::c_int as usize] = -(2 as std::os::raw::c_int);
        i= 1 as std::os::raw::c_int;
        while i <= alphaSize {
            parent[i as usize] = -(1 as std::os::raw::c_int);
            nHeap+= 1;
            heap[nHeap as usize] = i;
            let mut zz: Int32 = 0;
            let mut tmp: Int32 = 0;
            zz= nHeap;
            tmp= heap[zz as usize];
            while weight[tmp as usize] <
                      weight[heap[(zz >> 1 as std::os::raw::c_int) as usize] as usize]
                  {
                heap[zz as usize] = heap[(zz >> 1 as std::os::raw::c_int) as usize];
                zz>>= 1 as std::os::raw::c_int
            }
            heap[zz as usize] = tmp;
            i+= 1
        }
        if !(nHeap < 258 as std::os::raw::c_int + 2 as std::os::raw::c_int) {
            crate::bzlib::BZ2_bz__AssertH__fail(2001 as std::os::raw::c_int);
        }
        while nHeap > 1 as std::os::raw::c_int {
            n1= heap[1 as std::os::raw::c_int as usize];
            heap[1 as std::os::raw::c_int as usize] = heap[nHeap as usize];
            nHeap-= 1;
            let mut zz_0: Int32 = 0;
            let mut yy: Int32 = 0;
            let mut tmp_0: Int32 = 0;
            zz_0= 1 as std::os::raw::c_int;
            tmp_0= heap[zz_0 as usize];
            while 1 as std::os::raw::c_int as Bool != 0 {
                yy= zz_0 << 1 as std::os::raw::c_int;
                if yy > nHeap { break ; }
                if yy < nHeap &&
                       weight[heap[(yy + 1 as std::os::raw::c_int) as usize] as usize]
                           < weight[heap[yy as usize] as usize] {
                    yy+= 1
                }
                if weight[tmp_0 as usize] < weight[heap[yy as usize] as usize]
                   {
                    break ;
                }
                heap[zz_0 as usize] = heap[yy as usize];
                zz_0= yy
            }
            heap[zz_0 as usize] = tmp_0;
            n2= heap[1 as std::os::raw::c_int as usize];
            heap[1 as std::os::raw::c_int as usize] = heap[nHeap as usize];
            nHeap-= 1;
            let mut zz_1: Int32 = 0;
            let mut yy_0: Int32 = 0;
            let mut tmp_1: Int32 = 0;
            zz_1= 1 as std::os::raw::c_int;
            tmp_1= heap[zz_1 as usize];
            while 1 as std::os::raw::c_int as Bool != 0 {
                yy_0= zz_1 << 1 as std::os::raw::c_int;
                if yy_0 > nHeap { break ; }
                if yy_0 < nHeap &&
                       weight[heap[(yy_0 + 1 as std::os::raw::c_int) as usize] as
                                  usize] <
                           weight[heap[yy_0 as usize] as usize] {
                    yy_0+= 1
                }
                if weight[tmp_1 as usize] <
                       weight[heap[yy_0 as usize] as usize] {
                    break ;
                }
                heap[zz_1 as usize] = heap[yy_0 as usize];
                zz_1= yy_0
            }
            heap[zz_1 as usize] = tmp_1;
            nNodes+= 1;
            parent[n2 as usize] = nNodes;
            parent[n1 as usize] = parent[n2 as usize];
            weight[nNodes as usize] =
                ((weight[n1 as usize] as std::os::raw::c_uint &
                      0xffffff00 as
                          std::os::raw::c_uint).wrapping_add(weight[n2 as usize] as
                                                         std::os::raw::c_uint &
                                                         0xffffff00 as
                                                             std::os::raw::c_uint) |
                     (1 as std::os::raw::c_int +
                          (if weight[n1 as usize] & 0xff as std::os::raw::c_int >
                                  weight[n2 as usize] & 0xff as std::os::raw::c_int {
                               (weight[n1 as usize]) & 0xff as std::os::raw::c_int
                           } else {
                               (weight[n2 as usize]) & 0xff as std::os::raw::c_int
                           })) as std::os::raw::c_uint) as Int32;
            parent[nNodes as usize] = -(1 as std::os::raw::c_int);
            nHeap+= 1;
            heap[nHeap as usize] = nNodes;
            let mut zz_2: Int32 = 0;
            let mut tmp_2: Int32 = 0;
            zz_2= nHeap;
            tmp_2= heap[zz_2 as usize];
            while weight[tmp_2 as usize] <
                      weight[heap[(zz_2 >> 1 as std::os::raw::c_int) as usize] as
                                 usize] {
                heap[zz_2 as usize] =
                    heap[(zz_2 >> 1 as std::os::raw::c_int) as usize];
                zz_2>>= 1 as std::os::raw::c_int
            }
            heap[zz_2 as usize] = tmp_2
        }
        if !(nNodes < 258 as std::os::raw::c_int * 2 as std::os::raw::c_int) {
            crate::bzlib::BZ2_bz__AssertH__fail(2002 as std::os::raw::c_int);
        }
        tooLong= 0 as std::os::raw::c_int as Bool;
        i= 1 as std::os::raw::c_int;
        while i <= alphaSize {
            j= 0 as std::os::raw::c_int;
            k= i;
            while parent[k as usize] >= 0 as std::os::raw::c_int {
                k= parent[k as usize];
                j+= 1
            }
            *len.offset((i - 1 as std::os::raw::c_int) as isize) = j as UChar;
            if j > maxLen { tooLong= 1 as std::os::raw::c_int as Bool }
            i+= 1
        }
        if tooLong == 0 { break ; }
        /* 17 Oct 04: keep-going condition for the following loop used
         to be 'i < alphaSize', which missed the last element,
         theoretically leading to the possibility of the compressor
         looping.  However, this count-scaling step is only needed if
         one of the generated Huffman code words is longer than
         maxLen, which up to and including version 1.0.2 was 20 bits,
         which is extremely unlikely.  In version 1.0.3 maxLen was
         changed to 17 bits, which has minimal effect on compression
         ratio, but does mean this scaling step is used from time to
         time, enough to verify that it works.

         This means that bzip2-1.0.3 and later will only produce
         Huffman codes with a maximum length of 17 bits.  However, in
         order to preserve backwards compatibility with bitstreams
         produced by versions pre-1.0.3, the decompressor must still
         handle lengths of up to 20. */
        i= 1 as std::os::raw::c_int;
        while i <= alphaSize {
            j= weight[i as usize] >> 8 as std::os::raw::c_int;
            j= 1 as std::os::raw::c_int + j / 2 as std::os::raw::c_int;
            weight[i as usize] = j << 8 as std::os::raw::c_int;
            i+= 1
        }
    };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_hbAssignCodes(mut code: *mut Int32,
                                           mut length: *const UChar,
                                           mut minLen: Int32,
                                           mut maxLen: Int32,
                                           mut alphaSize: Int32) {
    let mut n: Int32 = 0;
    let mut vec: Int32 = 0;
    let mut i: Int32 = 0;
    vec= 0 as std::os::raw::c_int;
    n= minLen;
    while n <= maxLen {
        i= 0 as std::os::raw::c_int;
        while i < alphaSize {
            if *length.offset(i as isize) as std::os::raw::c_int == n {
                *code.offset(i as isize) = vec;
                vec+= 1
            }
            i+= 1
        }
        vec<<= 1 as std::os::raw::c_int;
        n+= 1
    };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_hbCreateDecodeTables(mut limit: *mut Int32,
                                                  mut base: *mut Int32,
                                                  mut perm: *mut Int32,
                                                  mut length: *const UChar,
                                                  mut minLen: Int32,
                                                  mut maxLen: Int32,
                                                  mut alphaSize: Int32) {
    let mut pp: Int32 = 0;
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut vec: Int32 = 0;
    pp= 0 as std::os::raw::c_int;
    i= minLen;
    while i <= maxLen {
        j= 0 as std::os::raw::c_int;
        while j < alphaSize {
            if *length.offset(j as isize) as std::os::raw::c_int == i {
                *perm.offset(pp as isize) = j;
                pp+= 1
            }
            j+= 1
        }
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < 23 as std::os::raw::c_int {
        *base.offset(i as isize) = 0 as std::os::raw::c_int;
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < alphaSize {
        *base.offset((*length.offset(i as isize) as std::os::raw::c_int +
                              1 as std::os::raw::c_int) as isize) += 1;
        i+= 1
    }
    i= 1 as std::os::raw::c_int;
    while i < 23 as std::os::raw::c_int {
        *base.offset(i as isize) += *base.offset((i - 1 as std::os::raw::c_int) as isize);
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < 23 as std::os::raw::c_int {
        *limit.offset(i as isize) = 0 as std::os::raw::c_int;
        i+= 1
    }
    vec= 0 as std::os::raw::c_int;
    i= minLen;
    while i <= maxLen {
        vec+=
            *base.offset((i + 1 as std::os::raw::c_int) as isize) -
                *base.offset(i as isize);
        *limit.offset(i as isize) = vec - 1 as std::os::raw::c_int;
        vec<<= 1 as std::os::raw::c_int;
        i+= 1
    }
    i= minLen + 1 as std::os::raw::c_int;
    while i <= maxLen {
        *base.offset(i as isize) =
            ((*limit.offset((i - 1 as std::os::raw::c_int) as isize) +
                  1 as std::os::raw::c_int) << 1 as std::os::raw::c_int) -
                *base.offset(i as isize);
        i+= 1
    };
}
/*-------------------------------------------------------------*/
/*--- end                                         huffman.c ---*/
/*-------------------------------------------------------------*/

extern "C" {
    
    #[no_mangle]
    static mut __stdinp: *mut FILE;
    #[no_mangle]
    static mut __stdoutp: *mut FILE;
    #[no_mangle]
    static mut __stderrp: *mut FILE;
    #[no_mangle]
    fn fclose(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn ferror(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fflush(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fgetc(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fopen(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn fread(_: *mut std::os::raw::c_void, _: std::os::raw::c_ulong, _: std::os::raw::c_ulong,
             _: *mut FILE) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn fwrite(_: *const std::os::raw::c_void, _: std::os::raw::c_ulong, _: std::os::raw::c_ulong,
              _: *mut FILE) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn perror(_: *const std::os::raw::c_char);
    #[no_mangle]
    fn remove(_: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn rewind(_: *mut FILE);
    #[no_mangle]
    fn ungetc(_: std::os::raw::c_int, _: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fdopen(_: std::os::raw::c_int, _: *const std::os::raw::c_char) -> *mut FILE;
    #[no_mangle]
    fn fileno(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn exit(_: std::os::raw::c_int) -> !;
    #[no_mangle]
    fn getenv(_: *const std::os::raw::c_char) -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn malloc(_: std::os::raw::c_ulong) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn free(_: *mut std::os::raw::c_void);
    #[no_mangle]
    fn signal(_: std::os::raw::c_int,
              _: Option<unsafe extern "C" fn(_: std::os::raw::c_int) -> ()>)
     -> Option<unsafe extern "C" fn(_: std::os::raw::c_int) -> ()>;
    #[no_mangle]
    fn strcmp(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn strcpy(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strerror(_: std::os::raw::c_int) -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn strncmp(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char,
               _: std::os::raw::c_ulong) -> std::os::raw::c_int;
    #[no_mangle]
    fn strncpy(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strstr(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strcat(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn __error() -> *mut std::os::raw::c_int;
    #[no_mangle]
    fn __maskrune(_: __darwin_ct_rune_t, _: std::os::raw::c_ulong) -> std::os::raw::c_int;
    #[no_mangle]
    static mut _DefaultRuneLocale: _RuneLocale;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[no_mangle]
    fn open(_: *const std::os::raw::c_char, _: std::os::raw::c_int, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn utime(_: *const std::os::raw::c_char, _: *const utimbuf) -> std::os::raw::c_int;
    #[no_mangle]
    fn _exit(_: std::os::raw::c_int) -> !;
    #[no_mangle]
    fn close(_: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn isatty(_: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn write(__fd: std::os::raw::c_int, __buf: *const std::os::raw::c_void, __nbyte: size_t)
     -> ssize_t;
    #[no_mangle]
    fn fchown(_: std::os::raw::c_int, _: uid_t, _: gid_t) -> std::os::raw::c_int;
    #[no_mangle]
    fn fchmod(_: std::os::raw::c_int, _: mode_t) -> std::os::raw::c_int;
    #[no_mangle]
    fn lstat(_: *const std::os::raw::c_char, _: *mut stat) -> std::os::raw::c_int;
    #[no_mangle]
    fn stat(_: *const std::os::raw::c_char, _: *mut stat) -> std::os::raw::c_int;
}
pub type __uint16_t = std::os::raw::c_ushort;
pub type __int32_t = std::os::raw::c_int;
pub type __uint32_t = std::os::raw::c_uint;
pub type __int64_t = std::os::raw::c_longlong;
pub type __uint64_t = std::os::raw::c_ulonglong;
pub type __darwin_ct_rune_t = std::os::raw::c_int;
pub type __darwin_size_t = std::os::raw::c_ulong;
pub type __darwin_wchar_t = std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_ssize_t = std::os::raw::c_long;
pub type __darwin_time_t = std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_uid_t = __uint32_t;
pub type size_t = __darwin_size_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor0;
impl Default for ErasedByPreprocessor0 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor1;
impl Default for ErasedByPreprocessor1 {fn default() -> Self {Self {
}}}

pub type FILE = crate::blocksort::__sFILE;
pub type off_t = __darwin_off_t;
pub type ssize_t = __darwin_ssize_t;
pub type uid_t = __darwin_uid_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *const __uint32_t,
}
impl Default for _RuneEntry {fn default() -> Self {Self {
__min: Default::default(),
__max: Default::default(),
__map: Default::default(),
__types: std::ptr::null_mut(),
}}}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneRange {
    pub __nranges: std::os::raw::c_int,
    pub __ranges: *const _RuneEntry,
}
impl Default for _RuneRange {fn default() -> Self {Self {
__nranges: Default::default(),
__ranges: std::ptr::null_mut(),
}}}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneCharClass {
    pub __name: [std::os::raw::c_char; 14],
    pub __mask: __uint32_t,
}
impl Default for _RuneCharClass {fn default() -> Self {Self {
__name: Default::default(),
__mask: Default::default(),
}}}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneLocale {
    pub __magic: [std::os::raw::c_char; 8],
    pub __encoding: [std::os::raw::c_char; 32],
    pub __sgetrune: Option<unsafe extern "C" fn(_: *const std::os::raw::c_char,
                                                _: __darwin_size_t,
                                                _: *mut *const std::os::raw::c_char)
                               -> __darwin_rune_t>,
    pub __sputrune: Option<unsafe extern "C" fn(_: __darwin_rune_t,
                                                _: *mut std::os::raw::c_char,
                                                _: __darwin_size_t,
                                                _: *mut *mut std::os::raw::c_char)
                               -> std::os::raw::c_int>,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256],
    pub __maplower: [__darwin_rune_t; 256],
    pub __mapupper: [__darwin_rune_t; 256],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *const std::os::raw::c_void,
    pub __variable_len: std::os::raw::c_int,
    pub __ncharclasses: std::os::raw::c_int,
    pub __charclasses: *const _RuneCharClass,
}
impl Default for _RuneLocale {fn default() -> Self {Self {
__magic: Default::default(),
__encoding: Default::default(),
__sgetrune: Default::default(),
__sputrune: Default::default(),
__invalid_rune: Default::default(),
__runetype: Default::default(),
__maplower: Default::default(),
__mapupper: Default::default(),
__runetype_ext: Default::default(),
__maplower_ext: Default::default(),
__mapupper_ext: Default::default(),
__variable: std::ptr::null_mut(),
__variable_len: Default::default(),
__ncharclasses: Default::default(),
__charclasses: std::ptr::null_mut(),
}}}

pub type BZFILE = ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: std::os::raw::c_long,
}
impl Default for timespec {fn default() -> Self {Self {
tv_sec: Default::default(),
tv_nsec: Default::default(),
}}}

pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type nlink_t = __uint16_t;
pub type time_t = __darwin_time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct utimbuf {
    pub actime: time_t,
    pub modtime: time_t,
}
impl Default for utimbuf {fn default() -> Self {Self {
actime: Default::default(),
modtime: Default::default(),
}}}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2],
}
impl Default for stat {fn default() -> Self {Self {
st_dev: Default::default(),
st_mode: Default::default(),
st_nlink: Default::default(),
st_ino: Default::default(),
st_uid: Default::default(),
st_gid: Default::default(),
st_rdev: Default::default(),
st_atimespec: Default::default(),
st_mtimespec: Default::default(),
st_ctimespec: Default::default(),
st_birthtimespec: Default::default(),
st_size: Default::default(),
st_blocks: Default::default(),
st_blksize: Default::default(),
st_flags: Default::default(),
st_gen: Default::default(),
st_lspare: Default::default(),
st_qspare: Default::default(),
}}}

/* */
/* BZ_UNIX */
/* BZ_LCCWIN32 */
/*---------------------------------------------*/
/*--
  Some more stuff for all platforms :-)
--*/
pub type Char = std::os::raw::c_char;
pub type Bool = std::os::raw::c_uchar;
pub type UChar = std::os::raw::c_uchar;
pub type Int32 = std::os::raw::c_int;
pub type UInt32 = std::os::raw::c_uint;
pub type Int16 = std::os::raw::c_short;
pub type UInt16 = std::os::raw::c_ushort;
/*--
  IntNative is your platform's `native' int size.
  Only here to avoid probs with 64-bit platforms.
--*/
pub type IntNative = std::os::raw::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UInt64 {
    pub b: [UChar; 8],
}
impl Default for UInt64 {fn default() -> Self {Self {
b: Default::default(),
}}}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct zzzz {
    pub name: *mut Char,
    pub link: *mut zzzz,
}
impl Default for zzzz {fn default() -> Self {Self {
name: std::ptr::null_mut(),
link: std::ptr::null_mut(),
}}}

/*---------------------------------------------*/
/*--
  All the garbage from here to main() is purely to
  implement a linked list of command-line arguments,
  into which main() copies argv[1 .. argc-1].

  The purpose of this exercise is to facilitate 
  the expansion of wildcard characters * and ? in 
  filenames for OSs which don't know how to do it
  themselves, like MSDOS, Windows 95 and NT.

  The actual Dirty Work is done by the platform-
  specific macro APPEND_FILESPEC.
--*/
pub type Cell = zzzz;
#[inline]
unsafe extern "C" fn isascii(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {
    return (_c & !(0x7f as std::os::raw::c_int) == 0 as std::os::raw::c_int) as std::os::raw::c_int;
}
#[inline]
unsafe extern "C" fn __istype(mut _c: __darwin_ct_rune_t,
                              mut _f: std::os::raw::c_ulong) -> std::os::raw::c_int {
    return if isascii(_c) != 0 {
               (_DefaultRuneLocale.__runetype[_c as usize] as std::os::raw::c_ulong &
                    _f != 0) as std::os::raw::c_int
           } else { (__maskrune(_c, _f) != 0) as std::os::raw::c_int };
}
#[no_mangle]
#[inline]
#[linkage = "external"]
pub unsafe extern "C" fn isspace(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {
    return __istype(_c, 0x4000 as std::os::raw::c_long as std::os::raw::c_ulong);
}
/*---------------------------------------------------*/
/*--- Misc (file handling) data decls             ---*/
/*---------------------------------------------------*/
#[no_mangle]
pub static mut verbosity: Int32 = 0;
#[no_mangle]
pub static mut keepInputFiles: Bool = 0;
#[no_mangle]
pub static mut smallMode: Bool = 0;
#[no_mangle]
pub static mut deleteOutputOnInterrupt: Bool = 0;
#[no_mangle]
pub static mut forceOverwrite: Bool = 0;
#[no_mangle]
pub static mut testFailsExist: Bool = 0;
#[no_mangle]
pub static mut unzFailsExist: Bool = 0;
#[no_mangle]
pub static mut noisy: Bool = 0;
#[no_mangle]
pub static mut numFileNames: Int32 = 0;
#[no_mangle]
pub static mut numFilesProcessed: Int32 = 0;
#[no_mangle]
pub static mut blockSize100k: Int32 = 0;
#[no_mangle]
pub static mut exitValue: Int32 = 0;
#[no_mangle]
pub static mut opMode: Int32 = 0;
#[no_mangle]
pub static mut srcMode: Int32 = 0;
#[no_mangle]
pub static mut longestFileName: Int32 = 0;
#[no_mangle]
pub static mut inName: [Char; 1034] = [0; 1034];
#[no_mangle]
pub static mut outName: [Char; 1034] = [0; 1034];
#[no_mangle]
pub static mut tmpName: [Char; 1034] = [0; 1034];
#[no_mangle]
pub static mut progName: *mut Char = 0 as *const Char as *mut Char;
#[no_mangle]
pub static mut progNameReally: [Char; 1034] = [0; 1034];
#[no_mangle]
pub static mut outputHandleJustInCase: *mut FILE =
    0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut workFactor: Int32 = 0;
unsafe extern "C" fn uInt64_from_UInt32s(mut n: Option<&mut UInt64>, mut lo32: UInt32,
                                         mut hi32: UInt32) {
    (*n.as_deref_mut().unwrap()).b[7 as std::os::raw::c_int as usize] =
        (hi32 >> 24 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
            UChar;
    (*n.as_deref_mut().unwrap()).b[6 as std::os::raw::c_int as usize] =
        (hi32 >> 16 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
            UChar;
    (*n.as_deref_mut().unwrap()).b[5 as std::os::raw::c_int as usize] =
        (hi32 >> 8 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
            UChar;
    (*n.as_deref_mut().unwrap()).b[4 as std::os::raw::c_int as usize] =
        (hi32 & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;
    (*n.as_deref_mut().unwrap()).b[3 as std::os::raw::c_int as usize] =
        (lo32 >> 24 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
            UChar;
    (*n.as_deref_mut().unwrap()).b[2 as std::os::raw::c_int as usize] =
        (lo32 >> 16 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
            UChar;
    (*n.as_deref_mut().unwrap()).b[1 as std::os::raw::c_int as usize] =
        (lo32 >> 8 as std::os::raw::c_int & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
            UChar;
    (*n.as_deref_mut().unwrap()).b[0 as std::os::raw::c_int as usize] =
        (lo32 & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;
}
unsafe extern "C" fn uInt64_to_double(mut n: *const UInt64) -> std::os::raw::c_double {
    let mut i: Int32 = 0;
    let mut base: std::os::raw::c_double = 1.0f64;
    let mut sum: std::os::raw::c_double = 0.0f64;
    i= 0 as std::os::raw::c_int;
    while i < 8 as std::os::raw::c_int {
        sum+= base * (*n).b[i as usize] as std::os::raw::c_double;
        base*= 256.0f64;
        i+= 1
    }
    return sum;
}
unsafe extern "C" fn uInt64_isZero(mut n: *const UInt64) -> Bool {
    let mut i: Int32 = 0;
    i= 0 as std::os::raw::c_int;
    while i < 8 as std::os::raw::c_int {
        if (*n).b[i as usize] as std::os::raw::c_int != 0 as std::os::raw::c_int {
            return 0 as std::os::raw::c_int as Bool
        }
        i+= 1
    }
    return 1 as std::os::raw::c_int as Bool;
}
/* Divide *n by 10, and return the remainder.  */
unsafe extern "C" fn uInt64_qrm10(mut n: Option<&mut UInt64>) -> Int32 {
    let mut rem: UInt32 = 0;
    let mut tmp: UInt32 = 0;
    let mut i: Int32 = 0;
    rem= 0 as std::os::raw::c_int as UInt32;
    i= 7 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        tmp=
            rem.wrapping_mul(256 as std::os::raw::c_int as
                                 std::os::raw::c_uint).wrapping_add((*n.as_deref().unwrap()).b[i as usize]
                                                                as
                                                                std::os::raw::c_uint);
        (*n.as_deref_mut().unwrap()).b[i as usize] =
            tmp.wrapping_div(10 as std::os::raw::c_int as std::os::raw::c_uint) as UChar;
        rem= tmp.wrapping_rem(10 as std::os::raw::c_int as std::os::raw::c_uint);
        i-= 1
    }
    return rem as Int32;
}
/* ... and the Whole Entire Point of all this UInt64 stuff is
   so that we can supply the following function.
*/
unsafe extern "C" fn uInt64_toAscii(mut outbuf: *mut std::os::raw::c_char,
                                    mut n: *const UInt64) {
    let mut i: Int32 = 0;
    let mut q: Int32 = 0;
    let mut buf: [UChar; 32] = [0; 32];
    let mut nBuf: Int32 = 0 as std::os::raw::c_int;
    let mut n_copy: UInt64 = (*n);
    loop  {
        q= uInt64_qrm10(&mut n_copy);
        buf[nBuf as usize] = (q + '0' as i32) as UChar;
        nBuf+= 1;
        if !(uInt64_isZero(&mut n_copy) == 0) { break ; }
    }
    *outbuf.offset(nBuf as isize) = 0 as std::os::raw::c_int as std::os::raw::c_char;
    i= 0 as std::os::raw::c_int;
    while i < nBuf {
        *outbuf.offset(i as isize) =
            buf[(nBuf - i - 1 as std::os::raw::c_int) as usize] as std::os::raw::c_char;
        i+= 1
    };
}
/*---------------------------------------------------*/
/*--- Processing of complete files and streams    ---*/
/*---------------------------------------------------*/
/*---------------------------------------------*/
unsafe extern "C" fn myfeof(mut f: *mut FILE) -> Bool {
    let mut c: Int32 = fgetc(f);
    if c == -(1 as std::os::raw::c_int) { return 1 as std::os::raw::c_int as Bool }
    ungetc(c, f);
    return 0 as std::os::raw::c_int as Bool;
}
/*---------------------------------------------*/
unsafe extern "C" fn compressStream(mut stream: *mut FILE,
                                    mut zStream: *mut FILE) {
    let mut current_block: u64;
    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut ibuf: [UChar; 5000] = [0; 5000];
    let mut nIbuf: Int32 = 0;
    let mut nbytes_in_lo32: UInt32 = 0;
    let mut nbytes_in_hi32: UInt32 = 0;
    let mut nbytes_out_lo32: UInt32 = 0;
    let mut nbytes_out_hi32: UInt32 = 0;
    let mut bzerr: Int32 = 0;
    let mut bzerr_dummy: Int32 = 0;
    let mut ret: Int32 = 0;
    if !(ferror(stream) != 0) {
        if !(ferror(zStream) != 0) {
            bzf=
                crate::bzlib::BZ2_bzWriteOpen(&mut bzerr, zStream, blockSize100k, verbosity,
                                workFactor);
            if bzerr != 0 as std::os::raw::c_int {
                current_block= 660242869387099075;
            } else {
                if verbosity >= 2 as std::os::raw::c_int {
                    fprintf(__stderrp,
                            b"\n\x00" as *const u8 as *const std::os::raw::c_char);
                }
                loop  {
                    if !(1 as std::os::raw::c_int as Bool != 0) {
                        current_block = 13242334135786603907;
                        break ;
                    }
                    if myfeof(stream) != 0 {
                        current_block= 13242334135786603907;
                        break ;
                    }
                    nIbuf=
                        fread(ibuf.as_mut_ptr() as *mut std::os::raw::c_void,
                              ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,
                              5000 as std::os::raw::c_int as std::os::raw::c_ulong, stream) as
                            Int32;
                    if ferror(stream) != 0 {
                        current_block= 18225113528933273530;
                        break ;
                    }
                    if nIbuf > 0 as std::os::raw::c_int {
                        crate::bzlib::BZ2_bzWrite(&mut bzerr, bzf,
                                    ibuf.as_mut_ptr() as *mut std::os::raw::c_void,
                                    nIbuf);
                    }
                    if bzerr != 0 as std::os::raw::c_int {
                        current_block= 660242869387099075;
                        break ;
                    }
                }
                match current_block {
                    18225113528933273530 => { }
                    660242869387099075 => { }
                    _ => {
                        crate::bzlib::BZ2_bzWriteClose64(&mut bzerr, bzf, 0 as std::os::raw::c_int,
                                           &mut nbytes_in_lo32,
                                           &mut nbytes_in_hi32,
                                           &mut nbytes_out_lo32,
                                           &mut nbytes_out_hi32);
                        if bzerr != 0 as std::os::raw::c_int {
                            current_block= 660242869387099075;
                        } else if ferror(zStream) != 0 {
                            current_block= 18225113528933273530;
                        } else {
                            ret= fflush(zStream);
                            if ret == -(1 as std::os::raw::c_int) {
                                current_block= 18225113528933273530;
                            } else {
                                if zStream != __stdoutp {
                                    let mut fd: Int32 = fileno(zStream);
                                    if fd < 0 as std::os::raw::c_int {
                                        current_block= 18225113528933273530;
                                    } else {
                                        applySavedFileAttrToOutputFile(fd);
                                        ret= fclose(zStream);
                                        outputHandleJustInCase =
                                            0 as *mut FILE;
                                        if ret == -(1 as std::os::raw::c_int) {
                                            current_block=
                                                18225113528933273530;
                                        } else {
                                            current_block=
                                                17281240262373992796;
                                        }
                                    }
                                } else {
                                    current_block= 17281240262373992796;
                                }
                                match current_block {
                                    18225113528933273530 => { }
                                    _ => {
                                        outputHandleJustInCase =
                                            0 as *mut FILE;
                                        if ferror(stream) != 0 {
                                            current_block=
                                                18225113528933273530;
                                        } else {
                                            ret= fclose(stream);
                                            if ret == -(1 as std::os::raw::c_int) {
                                                current_block=
                                                    18225113528933273530;
                                            } else {
                                                if verbosity >=
                                                       1 as std::os::raw::c_int {
                                                    if nbytes_in_lo32 ==
                                                           0 as std::os::raw::c_int as
                                                               std::os::raw::c_uint &&
                                                           nbytes_in_hi32 ==
                                                               0 as
                                                                   std::os::raw::c_int
                                                                   as
                                                                   std::os::raw::c_uint
                                                       {
                                                        fprintf(__stderrp,
                                                                b" no data compressed.\n\x00"
                                                                    as
                                                                    *const u8
                                                                    as
                                                                    *const std::os::raw::c_char);
                                                    } else {
                                                        let mut buf_nin:
                                                                [Char; 32] =
                                                            [0; 32];
                                                        let mut buf_nout:
                                                                [Char; 32] =
                                                            [0; 32];
                                                        let mut nbytes_in:
                                                                UInt64 =
                                                            UInt64{b:
                                                                       [0;
                                                                           8],};
                                                        let mut nbytes_out:
                                                                UInt64 =
                                                            UInt64{b:
                                                                       [0;
                                                                           8],};
                                                        let mut nbytes_in_d:
                                                                std::os::raw::c_double =
                                                            0.;
                                                        let mut nbytes_out_d:
                                                                std::os::raw::c_double =
                                                            0.;
                                                        uInt64_from_UInt32s(&mut nbytes_in,
                                                                            nbytes_in_lo32,
                                                                            nbytes_in_hi32);
                                                        uInt64_from_UInt32s(&mut nbytes_out,
                                                                            nbytes_out_lo32,
                                                                            nbytes_out_hi32);
                                                        nbytes_in_d=
                                                            uInt64_to_double(&mut nbytes_in);
                                                        nbytes_out_d=
                                                            uInt64_to_double(&mut nbytes_out);
                                                        uInt64_toAscii(buf_nin.as_mut_ptr(),
                                                                       &mut nbytes_in);
                                                        uInt64_toAscii(buf_nout.as_mut_ptr(),
                                                                       &mut nbytes_out);
                                                        fprintf(__stderrp,
                                                                b"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %s in, %s out.\n\x00"
                                                                    as
                                                                    *const u8
                                                                    as
                                                                    *const std::os::raw::c_char,
                                                                nbytes_in_d /
                                                                    nbytes_out_d,
                                                                8.0f64 *
                                                                    nbytes_out_d
                                                                    /
                                                                    nbytes_in_d,
                                                                100.0f64 *
                                                                    (1.0f64 -
                                                                         nbytes_out_d
                                                                             /
                                                                             nbytes_in_d),
                                                                buf_nin.as_mut_ptr(),
                                                                buf_nout.as_mut_ptr());
                                                    }
                                                }
                                                return
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                18225113528933273530 => { }
                _ => {
                    crate::bzlib::BZ2_bzWriteClose64(&mut bzerr_dummy, bzf,
                                       1 as std::os::raw::c_int, &mut nbytes_in_lo32,
                                       &mut nbytes_in_hi32,
                                       &mut nbytes_out_lo32,
                                       &mut nbytes_out_hi32);
                    match bzerr {
                        -9 => {
                            current_block= 5122324059762049690;
                            match current_block {
                                4323399205346619401 => {
                                    panic(b"compress:unexpected error\x00" as
                                              *const u8 as
                                              *const std::os::raw::c_char);
                                }
                                2380987886157893679 => { outOfMemory(); }
                                _ => { configError(); }
                            }
                        }
                        -3 => {
                            current_block= 2380987886157893679;
                            match current_block {
                                4323399205346619401 => {
                                    panic(b"compress:unexpected error\x00" as
                                              *const u8 as
                                              *const std::os::raw::c_char);
                                }
                                2380987886157893679 => { outOfMemory(); }
                                _ => { configError(); }
                            }
                        }
                        -6 => { }
                        _ => {
                            current_block= 4323399205346619401;
                            match current_block {
                                4323399205346619401 => {
                                    panic(b"compress:unexpected error\x00" as
                                              *const u8 as
                                              *const std::os::raw::c_char);
                                }
                                2380987886157893679 => { outOfMemory(); }
                                _ => { configError(); }
                            }
                        }
                    }
                }
            }
        }
    }
    ioError();
    /*notreached*/
}
/*---------------------------------------------*/
unsafe extern "C" fn uncompressStream(mut zStream: *mut FILE,
                                      mut stream: *mut FILE) -> Bool {
    let mut current_block: u64;
    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut bzerr: Int32 = 0;
    let mut bzerr_dummy: Int32 = 0;
    let mut ret: Int32 = 0;
    let mut nread: Int32 = 0;
    let mut streamNo: Int32 = 0;
    let mut i: Int32 = 0;
    let mut obuf: [UChar; 5000] = [0; 5000];
    let mut unused: [UChar; 5000] = [0; 5000];
    let mut nUnused: Int32 = 0;
    let mut unusedTmpV: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut unusedTmp: *mut UChar = 0 as *mut UChar;
    nUnused= 0 as std::os::raw::c_int;
    streamNo= 0 as std::os::raw::c_int;
    if !(ferror(stream) != 0) {
        if !(ferror(zStream) != 0) {
            's_51:
                loop  {
                    if !(1 as std::os::raw::c_int as Bool != 0) {
                        current_block = 926243229934402080;
                        break ;
                    }
                    bzf=
                        crate::bzlib::BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,
                                       smallMode as std::os::raw::c_int,
                                       unused.as_mut_ptr() as
                                           *mut std::os::raw::c_void, nUnused);
                    if bzf.is_null() || bzerr != 0 as std::os::raw::c_int {
                        current_block= 673979509383251364;
                        break ;
                    }
                    streamNo+= 1;
                    while bzerr == 0 as std::os::raw::c_int {
                        nread=
                            crate::bzlib::BZ2_bzRead(&mut bzerr, bzf,
                                       obuf.as_mut_ptr() as *mut std::os::raw::c_void,
                                       5000 as std::os::raw::c_int);
                        if bzerr == -(5 as std::os::raw::c_int) {
                            current_block= 18063049917807660484;
                            break 's_51 ;
                        }
                        if (bzerr == 0 as std::os::raw::c_int ||
                                bzerr == 4 as std::os::raw::c_int) &&
                               nread > 0 as std::os::raw::c_int {
                            fwrite(obuf.as_mut_ptr() as *const std::os::raw::c_void,
                                   ::std::mem::size_of::<UChar>() as
                                       std::os::raw::c_ulong, nread as std::os::raw::c_ulong,
                                   stream);
                        }
                        if ferror(stream) != 0 {
                            current_block= 5049394217699438129;
                            break 's_51 ;
                        }
                    }
                    if bzerr != 4 as std::os::raw::c_int {
                        current_block= 673979509383251364;
                        break ;
                    }
                    crate::bzlib::BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,
                                        &mut nUnused);
                    if bzerr != 0 as std::os::raw::c_int {
                        panic(b"decompress:bzReadGetUnused\x00" as *const u8
                                  as *const std::os::raw::c_char);
                    }
                    unusedTmp= unusedTmpV as *mut UChar;
                    i= 0 as std::os::raw::c_int;
                    while i < nUnused {
                        unused[i as usize] = *unusedTmp.offset(i as isize);
                        i+= 1
                    }
                    crate::bzlib::BZ2_bzReadClose(&mut bzerr, bzf);
                    if bzerr != 0 as std::os::raw::c_int {
                        panic(b"decompress:bzReadGetUnused\x00" as *const u8
                                  as *const std::os::raw::c_char);
                    }
                    if nUnused == 0 as std::os::raw::c_int &&
                           myfeof(zStream) as std::os::raw::c_int != 0 {
                        current_block= 926243229934402080;
                        break ;
                    }
                }
            match current_block {
                5049394217699438129 => { }
                _ => {
                    match current_block {
                        18063049917807660484 => {
                            if forceOverwrite != 0 {
                                rewind(zStream);
                                loop  {
                                    if !(1 as std::os::raw::c_int as Bool != 0) {
                                        current_block = 926243229934402080;
                                        break ;
                                    }
                                    if myfeof(zStream) != 0 {
                                        current_block= 926243229934402080;
                                        break ;
                                    }
                                    nread=
                                        fread(obuf.as_mut_ptr() as
                                                  *mut std::os::raw::c_void,
                                              ::std::mem::size_of::<UChar>()
                                                  as std::os::raw::c_ulong,
                                              5000 as std::os::raw::c_int as
                                                  std::os::raw::c_ulong, zStream) as
                                            Int32;
                                    if ferror(zStream) != 0 {
                                        current_block= 5049394217699438129;
                                        break ;
                                    }
                                    if nread > 0 as std::os::raw::c_int {
                                        fwrite(obuf.as_mut_ptr() as
                                                   *const std::os::raw::c_void,
                                               ::std::mem::size_of::<UChar>()
                                                   as std::os::raw::c_ulong,
                                               nread as std::os::raw::c_ulong,
                                               stream);
                                    }
                                    if ferror(stream) != 0 {
                                        current_block= 5049394217699438129;
                                        break ;
                                    }
                                }
                            } else { current_block= 673979509383251364; }
                        }
                        _ => { }
                    }
                    match current_block {
                        5049394217699438129 => { }
                        _ => {
                            match current_block {
                                673979509383251364 => {
                                    crate::bzlib::BZ2_bzReadClose(&mut bzerr_dummy, bzf);
                                    match bzerr {
                                        -9 => {
                                            current_block=
                                                3642457097893642164;
                                            match current_block {
                                                6455255476181645667 => {
                                                    panic(b"decompress:unexpected error\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char);
                                                }
                                                3642457097893642164 => {
                                                    configError();
                                                }
                                                10766414566319669440 => {
                                                    crcError();
                                                }
                                                16178635849926953562 => {
                                                    outOfMemory();
                                                }
                                                5517467152645906530 => {
                                                    compressedStreamEOF();
                                                }
                                                _ => {
                                                    if zStream != __stdinp {
                                                        fclose(zStream);
                                                    }
                                                    if stream != __stdoutp {
                                                        fclose(stream);
                                                    }
                                                    if streamNo ==
                                                           1 as std::os::raw::c_int {
                                                        return 0 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    } else {
                                                        if noisy != 0 {
                                                            fprintf(__stderrp,
                                                                    b"\n%s: %s: trailing garbage after EOF ignored\n\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    progName,
                                                                    inName.as_mut_ptr());
                                                        }
                                                        return 1 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    }
                                                }
                                            }
                                        }
                                        -6 => { }
                                        -4 => {
                                            current_block=
                                                10766414566319669440;
                                            match current_block {
                                                6455255476181645667 => {
                                                    panic(b"decompress:unexpected error\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char);
                                                }
                                                3642457097893642164 => {
                                                    configError();
                                                }
                                                10766414566319669440 => {
                                                    crcError();
                                                }
                                                16178635849926953562 => {
                                                    outOfMemory();
                                                }
                                                5517467152645906530 => {
                                                    compressedStreamEOF();
                                                }
                                                _ => {
                                                    if zStream != __stdinp {
                                                        fclose(zStream);
                                                    }
                                                    if stream != __stdoutp {
                                                        fclose(stream);
                                                    }
                                                    if streamNo ==
                                                           1 as std::os::raw::c_int {
                                                        return 0 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    } else {
                                                        if noisy != 0 {
                                                            fprintf(__stderrp,
                                                                    b"\n%s: %s: trailing garbage after EOF ignored\n\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    progName,
                                                                    inName.as_mut_ptr());
                                                        }
                                                        return 1 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    }
                                                }
                                            }
                                        }
                                        -3 => {
                                            current_block=
                                                16178635849926953562;
                                            match current_block {
                                                6455255476181645667 => {
                                                    panic(b"decompress:unexpected error\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char);
                                                }
                                                3642457097893642164 => {
                                                    configError();
                                                }
                                                10766414566319669440 => {
                                                    crcError();
                                                }
                                                16178635849926953562 => {
                                                    outOfMemory();
                                                }
                                                5517467152645906530 => {
                                                    compressedStreamEOF();
                                                }
                                                _ => {
                                                    if zStream != __stdinp {
                                                        fclose(zStream);
                                                    }
                                                    if stream != __stdoutp {
                                                        fclose(stream);
                                                    }
                                                    if streamNo ==
                                                           1 as std::os::raw::c_int {
                                                        return 0 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    } else {
                                                        if noisy != 0 {
                                                            fprintf(__stderrp,
                                                                    b"\n%s: %s: trailing garbage after EOF ignored\n\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    progName,
                                                                    inName.as_mut_ptr());
                                                        }
                                                        return 1 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    }
                                                }
                                            }
                                        }
                                        -7 => {
                                            current_block=
                                                5517467152645906530;
                                            match current_block {
                                                6455255476181645667 => {
                                                    panic(b"decompress:unexpected error\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char);
                                                }
                                                3642457097893642164 => {
                                                    configError();
                                                }
                                                10766414566319669440 => {
                                                    crcError();
                                                }
                                                16178635849926953562 => {
                                                    outOfMemory();
                                                }
                                                5517467152645906530 => {
                                                    compressedStreamEOF();
                                                }
                                                _ => {
                                                    if zStream != __stdinp {
                                                        fclose(zStream);
                                                    }
                                                    if stream != __stdoutp {
                                                        fclose(stream);
                                                    }
                                                    if streamNo ==
                                                           1 as std::os::raw::c_int {
                                                        return 0 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    } else {
                                                        if noisy != 0 {
                                                            fprintf(__stderrp,
                                                                    b"\n%s: %s: trailing garbage after EOF ignored\n\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    progName,
                                                                    inName.as_mut_ptr());
                                                        }
                                                        return 1 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    }
                                                }
                                            }
                                        }
                                        -5 => {
                                            current_block=
                                                7372986856480808103;
                                            match current_block {
                                                6455255476181645667 => {
                                                    panic(b"decompress:unexpected error\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char);
                                                }
                                                3642457097893642164 => {
                                                    configError();
                                                }
                                                10766414566319669440 => {
                                                    crcError();
                                                }
                                                16178635849926953562 => {
                                                    outOfMemory();
                                                }
                                                5517467152645906530 => {
                                                    compressedStreamEOF();
                                                }
                                                _ => {
                                                    if zStream != __stdinp {
                                                        fclose(zStream);
                                                    }
                                                    if stream != __stdoutp {
                                                        fclose(stream);
                                                    }
                                                    if streamNo ==
                                                           1 as std::os::raw::c_int {
                                                        return 0 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    } else {
                                                        if noisy != 0 {
                                                            fprintf(__stderrp,
                                                                    b"\n%s: %s: trailing garbage after EOF ignored\n\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    progName,
                                                                    inName.as_mut_ptr());
                                                        }
                                                        return 1 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    }
                                                }
                                            }
                                        }
                                        _ => {
                                            current_block=
                                                6455255476181645667;
                                            match current_block {
                                                6455255476181645667 => {
                                                    panic(b"decompress:unexpected error\x00"
                                                              as *const u8 as
                                                              *const std::os::raw::c_char);
                                                }
                                                3642457097893642164 => {
                                                    configError();
                                                }
                                                10766414566319669440 => {
                                                    crcError();
                                                }
                                                16178635849926953562 => {
                                                    outOfMemory();
                                                }
                                                5517467152645906530 => {
                                                    compressedStreamEOF();
                                                }
                                                _ => {
                                                    if zStream != __stdinp {
                                                        fclose(zStream);
                                                    }
                                                    if stream != __stdoutp {
                                                        fclose(stream);
                                                    }
                                                    if streamNo ==
                                                           1 as std::os::raw::c_int {
                                                        return 0 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    } else {
                                                        if noisy != 0 {
                                                            fprintf(__stderrp,
                                                                    b"\n%s: %s: trailing garbage after EOF ignored\n\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const std::os::raw::c_char,
                                                                    progName,
                                                                    inName.as_mut_ptr());
                                                        }
                                                        return 1 as
                                                                   std::os::raw::c_int
                                                                   as Bool
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {
                                    if !(ferror(zStream) != 0) {
                                        if stream != __stdoutp {
                                            let mut fd: Int32 =
                                                fileno(stream);
                                            if fd < 0 as std::os::raw::c_int {
                                                current_block=
                                                    5049394217699438129;
                                            } else {
                                                applySavedFileAttrToOutputFile(fd);
                                                current_block=
                                                    14832935472441733737;
                                            }
                                        } else {
                                            current_block=
                                                14832935472441733737;
                                        }
                                        match current_block {
                                            5049394217699438129 => { }
                                            _ => {
                                                ret= fclose(zStream);
                                                if !(ret ==
                                                         -(1 as std::os::raw::c_int))
                                                   {
                                                    if !(ferror(stream) != 0)
                                                       {
                                                        ret= fflush(stream);
                                                        if !(ret !=
                                                                 0 as
                                                                     std::os::raw::c_int)
                                                           {
                                                            if stream !=
                                                                   __stdoutp {
                                                                ret=
                                                                    fclose(stream);
                                                                outputHandleJustInCase
                                                                    =
                                                                    0 as
                                                                        *mut FILE;
                                                                if ret ==
                                                                       -(1 as
                                                                             std::os::raw::c_int)
                                                                   {
                                                                    current_block=
                                                                        5049394217699438129;
                                                                } else {
                                                                    current_block=
                                                                        14775119014532381840;
                                                                }
                                                            } else {
                                                                current_block=
                                                                    14775119014532381840;
                                                            }
                                                            match current_block
                                                                {
                                                                5049394217699438129
                                                                => {
                                                                }
                                                                _ => {
                                                                    outputHandleJustInCase
                                                                        =
                                                                        0 as
                                                                            *mut FILE;
                                                                    if verbosity
                                                                           >=
                                                                           2
                                                                               as
                                                                               std::os::raw::c_int
                                                                       {
                                                                        fprintf(__stderrp,
                                                                                b"\n    \x00"
                                                                                    as
                                                                                    *const u8
                                                                                    as
                                                                                    *const std::os::raw::c_char);
                                                                    }
                                                                    return 1
                                                                               as
                                                                               std::os::raw::c_int
                                                                               as
                                                                               Bool
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    ioError();
    /*notreached*/
}
/*---------------------------------------------*/
unsafe extern "C" fn testStream(mut zStream: *mut FILE) -> Bool {
    let mut current_block: u64;
    let mut bzf: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut bzerr: Int32 = 0;
    let mut bzerr_dummy: Int32 = 0;
    let mut ret: Int32 = 0;
    let mut streamNo: Int32 = 0;
    let mut i: Int32 = 0;
    let mut obuf: [UChar; 5000] = [0; 5000];
    let mut unused: [UChar; 5000] = [0; 5000];
    let mut nUnused: Int32 = 0;
    let mut unusedTmpV: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut unusedTmp: *mut UChar = 0 as *mut UChar;
    nUnused= 0 as std::os::raw::c_int;
    streamNo= 0 as std::os::raw::c_int;
    if !(ferror(zStream) != 0) {
        's_41:
            loop  {
                if !(1 as std::os::raw::c_int as Bool != 0) {
                    current_block = 15125582407903384992;
                    break ;
                }
                bzf=
                    crate::bzlib::BZ2_bzReadOpen(&mut bzerr, zStream, verbosity,
                                   smallMode as std::os::raw::c_int,
                                   unused.as_mut_ptr() as *mut std::os::raw::c_void,
                                   nUnused);
                if bzf.is_null() || bzerr != 0 as std::os::raw::c_int {
                    current_block= 10905486111603547446;
                    break ;
                }
                streamNo+= 1;
                while bzerr == 0 as std::os::raw::c_int {
                    crate::bzlib::BZ2_bzRead(&mut bzerr, bzf,
                               obuf.as_mut_ptr() as *mut std::os::raw::c_void,
                               5000 as std::os::raw::c_int);
                    if bzerr == -(5 as std::os::raw::c_int) {
                        current_block= 10905486111603547446;
                        break 's_41 ;
                    }
                }
                if bzerr != 4 as std::os::raw::c_int {
                    current_block= 10905486111603547446;
                    break ;
                }
                crate::bzlib::BZ2_bzReadGetUnused(&mut bzerr, bzf, &mut unusedTmpV,
                                    &mut nUnused);
                if bzerr != 0 as std::os::raw::c_int {
                    panic(b"test:bzReadGetUnused\x00" as *const u8 as
                              *const std::os::raw::c_char);
                }
                unusedTmp= unusedTmpV as *mut UChar;
                i= 0 as std::os::raw::c_int;
                while i < nUnused {
                    unused[i as usize] = *unusedTmp.offset(i as isize);
                    i+= 1
                }
                crate::bzlib::BZ2_bzReadClose(&mut bzerr, bzf);
                if bzerr != 0 as std::os::raw::c_int {
                    panic(b"test:bzReadGetUnused\x00" as *const u8 as
                              *const std::os::raw::c_char);
                }
                if nUnused == 0 as std::os::raw::c_int &&
                       myfeof(zStream) as std::os::raw::c_int != 0 {
                    current_block= 15125582407903384992;
                    break ;
                }
            }
        match current_block {
            15125582407903384992 => {
                if !(ferror(zStream) != 0) {
                    ret= fclose(zStream);
                    if !(ret == -(1 as std::os::raw::c_int)) {
                        if verbosity >= 2 as std::os::raw::c_int {
                            fprintf(__stderrp,
                                    b"\n    \x00" as *const u8 as
                                        *const std::os::raw::c_char);
                        }
                        return 1 as std::os::raw::c_int as Bool
                    }
                }
            }
            _ => {
                crate::bzlib::BZ2_bzReadClose(&mut bzerr_dummy, bzf);
                if verbosity == 0 as std::os::raw::c_int {
                    fprintf(__stderrp,
                            b"%s: %s: \x00" as *const u8 as
                                *const std::os::raw::c_char, progName,
                            inName.as_mut_ptr());
                }
                match bzerr {
                    -9 => {
                        current_block= 18238374633732057650;
                        match current_block {
                            6101827300316655396 => {
                                panic(b"test:unexpected error\x00" as
                                          *const u8 as *const std::os::raw::c_char);
                            }
                            10380742613918245393 => {
                                fprintf(__stderrp,
                                        b"file ends unexpectedly\n\x00" as
                                            *const u8 as *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                            2539039579982765382 => {
                                if zStream != __stdinp { fclose(zStream); }
                                if streamNo == 1 as std::os::raw::c_int {
                                    fprintf(__stderrp,
                                            b"bad magic number (file not created by bzip2)\n\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char);
                                    return 0 as std::os::raw::c_int as Bool
                                } else {
                                    if noisy != 0 {
                                        fprintf(__stderrp,
                                                b"trailing garbage after EOF ignored\n\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char);
                                    }
                                    return 1 as std::os::raw::c_int as Bool
                                }
                            }
                            18238374633732057650 => { configError(); }
                            13802719682174684861 => { outOfMemory(); }
                            _ => {
                                fprintf(__stderrp,
                                        b"data integrity (CRC) error in data\n\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                        }
                    }
                    -6 => { }
                    -4 => {
                        current_block= 11224962462315262049;
                        match current_block {
                            6101827300316655396 => {
                                panic(b"test:unexpected error\x00" as
                                          *const u8 as *const std::os::raw::c_char);
                            }
                            10380742613918245393 => {
                                fprintf(__stderrp,
                                        b"file ends unexpectedly\n\x00" as
                                            *const u8 as *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                            2539039579982765382 => {
                                if zStream != __stdinp { fclose(zStream); }
                                if streamNo == 1 as std::os::raw::c_int {
                                    fprintf(__stderrp,
                                            b"bad magic number (file not created by bzip2)\n\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char);
                                    return 0 as std::os::raw::c_int as Bool
                                } else {
                                    if noisy != 0 {
                                        fprintf(__stderrp,
                                                b"trailing garbage after EOF ignored\n\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char);
                                    }
                                    return 1 as std::os::raw::c_int as Bool
                                }
                            }
                            18238374633732057650 => { configError(); }
                            13802719682174684861 => { outOfMemory(); }
                            _ => {
                                fprintf(__stderrp,
                                        b"data integrity (CRC) error in data\n\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                        }
                    }
                    -3 => {
                        current_block= 13802719682174684861;
                        match current_block {
                            6101827300316655396 => {
                                panic(b"test:unexpected error\x00" as
                                          *const u8 as *const std::os::raw::c_char);
                            }
                            10380742613918245393 => {
                                fprintf(__stderrp,
                                        b"file ends unexpectedly\n\x00" as
                                            *const u8 as *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                            2539039579982765382 => {
                                if zStream != __stdinp { fclose(zStream); }
                                if streamNo == 1 as std::os::raw::c_int {
                                    fprintf(__stderrp,
                                            b"bad magic number (file not created by bzip2)\n\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char);
                                    return 0 as std::os::raw::c_int as Bool
                                } else {
                                    if noisy != 0 {
                                        fprintf(__stderrp,
                                                b"trailing garbage after EOF ignored\n\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char);
                                    }
                                    return 1 as std::os::raw::c_int as Bool
                                }
                            }
                            18238374633732057650 => { configError(); }
                            13802719682174684861 => { outOfMemory(); }
                            _ => {
                                fprintf(__stderrp,
                                        b"data integrity (CRC) error in data\n\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                        }
                    }
                    -7 => {
                        current_block= 10380742613918245393;
                        match current_block {
                            6101827300316655396 => {
                                panic(b"test:unexpected error\x00" as
                                          *const u8 as *const std::os::raw::c_char);
                            }
                            10380742613918245393 => {
                                fprintf(__stderrp,
                                        b"file ends unexpectedly\n\x00" as
                                            *const u8 as *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                            2539039579982765382 => {
                                if zStream != __stdinp { fclose(zStream); }
                                if streamNo == 1 as std::os::raw::c_int {
                                    fprintf(__stderrp,
                                            b"bad magic number (file not created by bzip2)\n\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char);
                                    return 0 as std::os::raw::c_int as Bool
                                } else {
                                    if noisy != 0 {
                                        fprintf(__stderrp,
                                                b"trailing garbage after EOF ignored\n\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char);
                                    }
                                    return 1 as std::os::raw::c_int as Bool
                                }
                            }
                            18238374633732057650 => { configError(); }
                            13802719682174684861 => { outOfMemory(); }
                            _ => {
                                fprintf(__stderrp,
                                        b"data integrity (CRC) error in data\n\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                        }
                    }
                    -5 => {
                        current_block= 2539039579982765382;
                        match current_block {
                            6101827300316655396 => {
                                panic(b"test:unexpected error\x00" as
                                          *const u8 as *const std::os::raw::c_char);
                            }
                            10380742613918245393 => {
                                fprintf(__stderrp,
                                        b"file ends unexpectedly\n\x00" as
                                            *const u8 as *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                            2539039579982765382 => {
                                if zStream != __stdinp { fclose(zStream); }
                                if streamNo == 1 as std::os::raw::c_int {
                                    fprintf(__stderrp,
                                            b"bad magic number (file not created by bzip2)\n\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char);
                                    return 0 as std::os::raw::c_int as Bool
                                } else {
                                    if noisy != 0 {
                                        fprintf(__stderrp,
                                                b"trailing garbage after EOF ignored\n\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char);
                                    }
                                    return 1 as std::os::raw::c_int as Bool
                                }
                            }
                            18238374633732057650 => { configError(); }
                            13802719682174684861 => { outOfMemory(); }
                            _ => {
                                fprintf(__stderrp,
                                        b"data integrity (CRC) error in data\n\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                        }
                    }
                    _ => {
                        current_block= 6101827300316655396;
                        match current_block {
                            6101827300316655396 => {
                                panic(b"test:unexpected error\x00" as
                                          *const u8 as *const std::os::raw::c_char);
                            }
                            10380742613918245393 => {
                                fprintf(__stderrp,
                                        b"file ends unexpectedly\n\x00" as
                                            *const u8 as *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                            2539039579982765382 => {
                                if zStream != __stdinp { fclose(zStream); }
                                if streamNo == 1 as std::os::raw::c_int {
                                    fprintf(__stderrp,
                                            b"bad magic number (file not created by bzip2)\n\x00"
                                                as *const u8 as
                                                *const std::os::raw::c_char);
                                    return 0 as std::os::raw::c_int as Bool
                                } else {
                                    if noisy != 0 {
                                        fprintf(__stderrp,
                                                b"trailing garbage after EOF ignored\n\x00"
                                                    as *const u8 as
                                                    *const std::os::raw::c_char);
                                    }
                                    return 1 as std::os::raw::c_int as Bool
                                }
                            }
                            18238374633732057650 => { configError(); }
                            13802719682174684861 => { outOfMemory(); }
                            _ => {
                                fprintf(__stderrp,
                                        b"data integrity (CRC) error in data\n\x00"
                                            as *const u8 as
                                            *const std::os::raw::c_char);
                                return 0 as std::os::raw::c_int as Bool
                            }
                        }
                    }
                }
            }
        }
    }
    ioError();
    /*notreached*/
}
/*---------------------------------------------------*/
/*--- Error [non-] handling grunge                ---*/
/*---------------------------------------------------*/
/*---------------------------------------------*/
unsafe extern "C" fn setExit(mut v: Int32) {
    if v > exitValue { exitValue = v };
}
/*---------------------------------------------*/
unsafe extern "C" fn cadvise() {
    if noisy != 0 {
        fprintf(__stderrp,
                b"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n\x00"
                    as *const u8 as *const std::os::raw::c_char);
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn showFileNames() {
    if noisy != 0 {
        fprintf(__stderrp,
                b"\tInput file = %s, output file = %s\n\x00" as *const u8 as
                    *const std::os::raw::c_char, inName.as_mut_ptr(),
                outName.as_mut_ptr());
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn cleanUpAndFail(mut ec: Int32) -> ! {
    let mut retVal: IntNative = 0;
    let mut statBuf: stat =
        stat{st_dev: 0,
             st_mode: 0,
             st_nlink: 0,
             st_ino: 0,
             st_uid: 0,
             st_gid: 0,
             st_rdev: 0,
             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_size: 0,
             st_blocks: 0,
             st_blksize: 0,
             st_flags: 0,
             st_gen: 0,
             st_lspare: 0,
             st_qspare: [0; 2],};
    if srcMode == 3 as std::os::raw::c_int && opMode != 3 as std::os::raw::c_int &&
           deleteOutputOnInterrupt as std::os::raw::c_int != 0 {
        /* Check whether input file still exists.  Delete output file
         only if input exists to avoid loss of data.  Joerg Prante, 5
         January 2002.  (JRS 06-Jan-2002: other changes in 1.0.2 mean
         this is less likely to happen.  But to be ultra-paranoid, we
         do the check anyway.)  */
        retVal= stat(inName.as_mut_ptr(), &mut statBuf);
        if retVal == 0 as std::os::raw::c_int {
            if noisy != 0 {
                fprintf(__stderrp,
                        b"%s: Deleting output file %s, if it exists.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        outName.as_mut_ptr());
            }
            if !outputHandleJustInCase.is_null() {
                fclose(outputHandleJustInCase);
            }else { (); }
            retVal= remove(outName.as_mut_ptr());
            if retVal != 0 as std::os::raw::c_int {
                fprintf(__stderrp,
                        b"%s: WARNING: deletion of output file (apparently) failed.\n\x00"
                            as *const u8 as *const std::os::raw::c_char, progName);
            }
        } else {
            fprintf(__stderrp,
                    b"%s: WARNING: deletion of output file suppressed\n\x00"
                        as *const u8 as *const std::os::raw::c_char, progName);
            fprintf(__stderrp,
                    b"%s:    since input file no longer exists.  Output file\n\x00"
                        as *const u8 as *const std::os::raw::c_char, progName);
            fprintf(__stderrp,
                    b"%s:    `%s\' may be incomplete.\n\x00" as *const u8 as
                        *const std::os::raw::c_char, progName, outName.as_mut_ptr());
            fprintf(__stderrp,
                    b"%s:    I suggest doing an integrity test (bzip2 -tv) of it.\n\x00"
                        as *const u8 as *const std::os::raw::c_char, progName);
        }
    }
    if noisy as std::os::raw::c_int != 0 && numFileNames > 0 as std::os::raw::c_int &&
           numFilesProcessed < numFileNames {
        fprintf(__stderrp,
                b"%s: WARNING: some files have not been processed:\n%s:    %d specified on command line, %d not processed yet.\n\n\x00"
                    as *const u8 as *const std::os::raw::c_char, progName, progName,
                numFileNames, numFileNames - numFilesProcessed);
    }
    setExit(ec);
    exit(exitValue);
}
/*---------------------------------------------*/
unsafe extern "C" fn panic(mut s: *const Char) -> ! {
    fprintf(__stderrp,
            b"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to:\n\tbzip2-devel@sourceware.org\n\x00"
                as *const u8 as *const std::os::raw::c_char, progName, s);
    showFileNames();
    cleanUpAndFail(3 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn crcError() -> ! {
    fprintf(__stderrp,
            b"\n%s: Data integrity error when decompressing.\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName);
    showFileNames();
    cadvise();
    cleanUpAndFail(2 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn compressedStreamEOF() -> ! {
    if noisy != 0 {
        fprintf(__stderrp,
                b"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n\x00"
                    as *const u8 as *const std::os::raw::c_char, progName);
        perror(progName);
        showFileNames();
        cadvise();
    }
    cleanUpAndFail(2 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn ioError() -> ! {
    fprintf(__stderrp,
            b"\n%s: I/O or other error, bailing out.  Possible reason follows.\n\x00"
                as *const u8 as *const std::os::raw::c_char, progName);
    perror(progName);
    showFileNames();
    cleanUpAndFail(1 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn mySignalCatcher(mut n: IntNative) {
    fprintf(__stderrp,
            b"\n%s: Control-C or similar caught, quitting.\n\x00" as *const u8
                as *const std::os::raw::c_char, progName);
    cleanUpAndFail(1 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn mySIGSEGVorSIGBUScatcher(mut n: IntNative) {
    let mut msg: *const std::os::raw::c_char = 0 as *const std::os::raw::c_char;
    if opMode == 1 as std::os::raw::c_int {
        msg=
            b": Caught a SIGSEGV or SIGBUS whilst compressing.\n\n   Possible causes are (most likely first):\n   (1) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (2) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (3) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (1) and (2).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (1)\n   or (2), feel free to report it to: bzip2-devel@sourceware.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n\x00"
                as *const u8 as *const std::os::raw::c_char
    } else {
        msg=
            b": Caught a SIGSEGV or SIGBUS whilst decompressing.\n\n   Possible causes are (most likely first):\n   (1) The compressed data is corrupted, and bzip2\'s usual checks\n       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n   (2) This computer has unreliable memory or cache hardware\n       (a surprisingly common problem; try a different machine.)\n   (3) A bug in the compiler used to create this executable\n       (unlikely, if you didn\'t compile bzip2 yourself.)\n   (4) A real bug in bzip2 -- I hope this should never be the case.\n   The user\'s manual, Section 4.3, has more info on (2) and (3).\n   \n   If you suspect this is a bug in bzip2, or are unsure about (2)\n   or (3), feel free to report it to: bzip2-devel@sourceware.org.\n   Section 4.3 of the user\'s manual describes the info a useful\n   bug report should have.  If the manual is available on your\n   system, please try and read it before mailing me.  If you don\'t\n   have the manual or can\'t be bothered to read it, mail me anyway.\n\n\x00"
                as *const u8 as *const std::os::raw::c_char
    }
    write(2 as std::os::raw::c_int,
          b"\n\x00" as *const u8 as *const std::os::raw::c_char as
              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);
    write(2 as std::os::raw::c_int, progName as *const std::os::raw::c_void,
          strlen(progName));
    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));
    msg= b"\tInput file = \x00" as *const u8 as *const std::os::raw::c_char;
    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));
    write(2 as std::os::raw::c_int, inName.as_mut_ptr() as *const std::os::raw::c_void,
          strlen(inName.as_mut_ptr()));
    write(2 as std::os::raw::c_int,
          b"\n\x00" as *const u8 as *const std::os::raw::c_char as
              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);
    msg= b"\tOutput file = \x00" as *const u8 as *const std::os::raw::c_char;
    write(2 as std::os::raw::c_int, msg as *const std::os::raw::c_void, strlen(msg));
    write(2 as std::os::raw::c_int, outName.as_mut_ptr() as *const std::os::raw::c_void,
          strlen(outName.as_mut_ptr()));
    write(2 as std::os::raw::c_int,
          b"\n\x00" as *const u8 as *const std::os::raw::c_char as
              *const std::os::raw::c_void, 1 as std::os::raw::c_int as size_t);
    /* Don't call cleanupAndFail. If we ended up here something went
      terribly wrong. Trying to clean up might fail spectacularly. */
    if opMode == 1 as std::os::raw::c_int {
        setExit(3 as std::os::raw::c_int);
    } else { setExit(2 as std::os::raw::c_int); }
    _exit(exitValue);
}
/*---------------------------------------------*/
unsafe extern "C" fn outOfMemory() -> ! {
    fprintf(__stderrp,
            b"\n%s: couldn\'t allocate enough memory\n\x00" as *const u8 as
                *const std::os::raw::c_char, progName);
    showFileNames();
    cleanUpAndFail(1 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn configError() -> ! {
    fprintf(__stderrp,
            b"bzip2: I\'m not configured correctly for this platform!\n\tI require Int32, Int16 and Char to have sizes\n\tof 4, 2 and 1 bytes to run properly, and they don\'t.\n\tProbably you can fix this by defining them correctly,\n\tand recompiling.  Bye!\n\x00"
                as *const u8 as *const std::os::raw::c_char);
    setExit(3 as std::os::raw::c_int);
    exit(exitValue);
}
/*---------------------------------------------------*/
/*--- The main driver machinery                   ---*/
/*---------------------------------------------------*/
/* All rather crufty.  The main problem is that input files
   are stat()d multiple times before use.  This should be
   cleaned up. 
*/
/*---------------------------------------------*/
unsafe extern "C" fn pad(mut s: *const Char) {
    let mut i: Int32 = 0;
    if strlen(s) as Int32 >= longestFileName { return }
    i= 1 as std::os::raw::c_int;
    while i <= longestFileName - strlen(s) as Int32 {
        fprintf(__stderrp, b" \x00" as *const u8 as *const std::os::raw::c_char);
        i+= 1
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn copyFileName(mut to: *mut Char, mut from: *mut Char) {
    if strlen(from) >
           (1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as std::os::raw::c_ulong {
        fprintf(__stderrp,
                b"bzip2: file name\n`%s\'\nis suspiciously (more than %d chars) long.\nTry using a reasonable file name instead.  Sorry! :-)\n\x00"
                    as *const u8 as *const std::os::raw::c_char, from,
                1034 as std::os::raw::c_int - 10 as std::os::raw::c_int);
        setExit(1 as std::os::raw::c_int);
        exit(exitValue);
    }
    strncpy(to, from,
            (1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as std::os::raw::c_ulong);
    *to.offset((1034 as std::os::raw::c_int - 10 as std::os::raw::c_int) as isize) =
        '\u{0}' as i32 as Char;
}
/*---------------------------------------------*/
unsafe extern "C" fn fileExists(mut name: *mut Char) -> Bool {
    let mut tmp: *mut FILE =
        fopen(name, b"rb\x00" as *const u8 as *const std::os::raw::c_char);
    let mut exists: Bool =
        (tmp != 0 as *mut std::os::raw::c_void as *mut FILE) as std::os::raw::c_int as Bool;
    if !tmp.is_null() { fclose(tmp); }else { (); }
    return exists;
}
/*---------------------------------------------*/
/* Open an output file safely with O_EXCL and good permissions.
   This avoids a race condition in versions < 1.0.2, in which
   the file was first opened and then had its interim permissions
   set safely.  We instead use open() to create the file with
   the interim permissions required. (--- --- rw-).

   For non-Unix platforms, if we are not worrying about
   security issues, simple this simply behaves like fopen.
*/
unsafe extern "C" fn fopen_output_safely(mut name: *mut Char,
                                         mut mode: *const std::os::raw::c_char)
 -> *mut FILE {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut fh: IntNative = 0;
    fh=
        open(name,
             0x1 as std::os::raw::c_int | 0x200 as std::os::raw::c_int | 0x800 as std::os::raw::c_int,
             0o200 as std::os::raw::c_int | 0o400 as std::os::raw::c_int);
    if fh == -(1 as std::os::raw::c_int) { return 0 as *mut FILE }
    fp= fdopen(fh, mode);
    if fp.is_null() {(); close(fh); }
    return fp;
}
/*---------------------------------------------*/
/*--
  if in doubt, return True
--*/
unsafe extern "C" fn notAStandardFile(mut name: *mut Char) -> Bool {
    let mut i: IntNative = 0;
    let mut statBuf: stat =
        stat{st_dev: 0,
             st_mode: 0,
             st_nlink: 0,
             st_ino: 0,
             st_uid: 0,
             st_gid: 0,
             st_rdev: 0,
             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_size: 0,
             st_blocks: 0,
             st_blksize: 0,
             st_flags: 0,
             st_gen: 0,
             st_lspare: 0,
             st_qspare: [0; 2],};
    i= lstat(name, &mut statBuf);
    if i != 0 as std::os::raw::c_int { return 1 as std::os::raw::c_int as Bool }
    if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==
           0o100000 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int as Bool
    }
    return 1 as std::os::raw::c_int as Bool;
}
/*---------------------------------------------*/
/*--
  rac 11/21/98 see if file has hard links to it
--*/
unsafe extern "C" fn countHardLinks(mut name: *mut Char) -> Int32 {
    let mut i: IntNative = 0;
    let mut statBuf: stat =
        stat{st_dev: 0,
             st_mode: 0,
             st_nlink: 0,
             st_ino: 0,
             st_uid: 0,
             st_gid: 0,
             st_rdev: 0,
             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_size: 0,
             st_blocks: 0,
             st_blksize: 0,
             st_flags: 0,
             st_gen: 0,
             st_lspare: 0,
             st_qspare: [0; 2],};
    i= lstat(name, &mut statBuf);
    if i != 0 as std::os::raw::c_int { return 0 as std::os::raw::c_int }
    return statBuf.st_nlink as std::os::raw::c_int - 1 as std::os::raw::c_int;
}
/*---------------------------------------------*/
/* Copy modification date, access date, permissions and owner from the
   source to destination file.  We have to copy this meta-info off
   into fileMetaInfo before starting to compress / decompress it,
   because doing it afterwards means we get the wrong access time.

   To complicate matters, in compress() and decompress() below, the
   sequence of tests preceding the call to saveInputFileMetaInfo()
   involves calling fileExists(), which in turn establishes its result
   by attempting to fopen() the file, and if successful, immediately
   fclose()ing it again.  So we have to assume that the fopen() call
   does not cause the access time field to be updated.

   Reading of the man page for stat() (man 2 stat) on RedHat 7.2 seems
   to imply that merely doing open() will not affect the access time.
   Therefore we merely need to hope that the C library only does
   open() as a result of fopen(), and not any kind of read()-ahead
   cleverness.

   It sounds pretty fragile to me.  Whether this carries across
   robustly to arbitrary Unix-like platforms (or even works robustly
   on this one, RedHat 7.2) is unknown to me.  Nevertheless ...  
*/
static mut fileMetaInfo: stat =
    stat{st_dev: 0,
         st_mode: 0,
         st_nlink: 0,
         st_ino: 0,
         st_uid: 0,
         st_gid: 0,
         st_rdev: 0,
         st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},
         st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
         st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},
         st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
         st_size: 0,
         st_blocks: 0,
         st_blksize: 0,
         st_flags: 0,
         st_gen: 0,
         st_lspare: 0,
         st_qspare: [0; 2],};
unsafe extern "C" fn saveInputFileMetaInfo(mut srcName: *mut Char) {
    let mut retVal: IntNative = 0;
    /* Note use of stat here, not lstat. */
    retVal= stat(srcName, &mut fileMetaInfo);
    if retVal != 0 as std::os::raw::c_int { ioError(); };
}
unsafe extern "C" fn applySavedTimeInfoToOutputFile(mut dstName: *mut Char) {
    let mut retVal: IntNative = 0;
    let mut uTimBuf: utimbuf = utimbuf{actime: 0, modtime: 0,};
    uTimBuf.actime= fileMetaInfo.st_atimespec.tv_sec;
    uTimBuf.modtime= fileMetaInfo.st_mtimespec.tv_sec;
    retVal= utime(dstName, &mut uTimBuf);
    if retVal != 0 as std::os::raw::c_int { ioError(); };
}
unsafe extern "C" fn applySavedFileAttrToOutputFile(mut fd: IntNative) {
    let mut retVal: IntNative = 0;
    retVal= fchmod(fd, fileMetaInfo.st_mode);
    if retVal != 0 as std::os::raw::c_int { ioError(); }
    fchown(fd, fileMetaInfo.st_uid, fileMetaInfo.st_gid);
    /* chown() will in many cases return with EPERM, which can
      be safely ignored.
   */
}
/*---------------------------------------------*/
unsafe extern "C" fn containsDubiousChars(mut name: *const Char) -> Bool {
    /* On unix, files can contain any characters and the file expansion
    * is performed by the shell.
    */
    return 0 as std::os::raw::c_int as Bool;
    /* ! BZ_UNIX */
    /* BZ_UNIX */
}
#[no_mangle]
pub static mut zSuffix: [*const Char; 4] =
    [b".bz2\x00" as *const u8 as *const std::os::raw::c_char,
     b".bz\x00" as *const u8 as *const std::os::raw::c_char,
     b".tbz2\x00" as *const u8 as *const std::os::raw::c_char,
     b".tbz\x00" as *const u8 as *const std::os::raw::c_char];
#[no_mangle]
pub static mut unzSuffix: [*const Char; 4] =
    [b"\x00" as *const u8 as *const std::os::raw::c_char,
     b"\x00" as *const u8 as *const std::os::raw::c_char,
     b".tar\x00" as *const u8 as *const std::os::raw::c_char,
     b".tar\x00" as *const u8 as *const std::os::raw::c_char];
unsafe extern "C" fn hasSuffix(mut s: *const Char, mut suffix: *const Char)
 -> Bool {
    let mut ns: Int32 = strlen(s) as Int32;
    let mut nx: Int32 = strlen(suffix) as Int32;
    if ns < nx { return 0 as std::os::raw::c_int as Bool }
    if strcmp(s.offset(ns as isize).offset(-(nx as isize)), suffix) ==
           0 as std::os::raw::c_int {
        return 1 as std::os::raw::c_int as Bool
    }
    return 0 as std::os::raw::c_int as Bool;
}
unsafe extern "C" fn mapSuffix(mut name: *mut Char,
                               mut oldSuffix: *const Char,
                               mut newSuffix: *const Char) -> Bool {
    if hasSuffix(name, oldSuffix) == 0 { return 0 as std::os::raw::c_int as Bool }
    *name.offset(strlen(name).wrapping_sub(strlen(oldSuffix)) as isize) =
        0 as std::os::raw::c_int as Char;
    strcat(name, newSuffix);
    return 1 as std::os::raw::c_int as Bool;
}
/*---------------------------------------------*/
unsafe extern "C" fn compress(mut name: *mut Char) {
    let mut inStr: *mut FILE = 0 as *mut FILE;
    let mut outStr: *mut FILE = 0 as *mut FILE;
    let mut n: Int32 = 0;
    let mut i: Int32 = 0;
    let mut statBuf: stat =
        stat{st_dev: 0,
             st_mode: 0,
             st_nlink: 0,
             st_ino: 0,
             st_uid: 0,
             st_gid: 0,
             st_rdev: 0,
             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_size: 0,
             st_blocks: 0,
             st_blksize: 0,
             st_flags: 0,
             st_gen: 0,
             st_lspare: 0,
             st_qspare: [0; 2],};
    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
    if name.is_null() && srcMode != 1 as std::os::raw::c_int {
        panic(b"compress: bad modes\n\x00" as *const u8 as
                  *const std::os::raw::c_char);
    }
    match  srcMode {
        1 => {
            copyFileName(inName.as_mut_ptr(),
                         b"(stdin)\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut Char);
            copyFileName(outName.as_mut_ptr(),
                         b"(stdout)\x00" as *const u8 as *const std::os::raw::c_char
                             as *mut Char);
        }
        3 => {
            copyFileName(inName.as_mut_ptr(), name);
            copyFileName(outName.as_mut_ptr(), name);
            strcat(outName.as_mut_ptr(),
                   b".bz2\x00" as *const u8 as *const std::os::raw::c_char);
        }
        2 => {
            copyFileName(inName.as_mut_ptr(), name);
            copyFileName(outName.as_mut_ptr(),
                         b"(stdout)\x00" as *const u8 as *const std::os::raw::c_char
                             as *mut Char);
        }
        _ => { }
    }
    if srcMode != 1 as std::os::raw::c_int &&
           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {
        if noisy != 0 {
            fprintf(__stderrp,
                    b"%s: There are no files matching `%s\'.\n\x00" as
                        *const u8 as *const std::os::raw::c_char, progName,
                    inName.as_mut_ptr());
        }
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {
        fprintf(__stderrp,
                b"%s: Can\'t open input file %s: %s.\n\x00" as *const u8 as
                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),
                strerror(*__error()));
        setExit(1 as std::os::raw::c_int);
        return
    }
    i= 0 as std::os::raw::c_int;
    while i < 4 as std::os::raw::c_int {
        if hasSuffix(inName.as_mut_ptr(), zSuffix[i as usize]) != 0 {
            if noisy != 0 {
                fprintf(__stderrp,
                        b"%s: Input file %s already has %s suffix.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        inName.as_mut_ptr(), zSuffix[i as usize]);
            }
            setExit(1 as std::os::raw::c_int);
            return
        }
        i+= 1
    }
    if srcMode == 3 as std::os::raw::c_int || srcMode == 2 as std::os::raw::c_int {
        stat(inName.as_mut_ptr(), &mut statBuf);
        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==
               0o40000 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"%s: Input file %s is a directory.\n\x00" as *const u8 as
                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());
            setExit(1 as std::os::raw::c_int);
            return
        }
    }
    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&
           notAStandardFile(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {
        if noisy != 0 {
            fprintf(__stderrp,
                    b"%s: Input file %s is not a normal file.\n\x00" as
                        *const u8 as *const std::os::raw::c_char, progName,
                    inName.as_mut_ptr());
        }
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode == 3 as std::os::raw::c_int &&
           fileExists(outName.as_mut_ptr()) as std::os::raw::c_int != 0 {
        if forceOverwrite != 0 {
            remove(outName.as_mut_ptr());
        } else {
            fprintf(__stderrp,
                    b"%s: Output file %s already exists.\n\x00" as *const u8
                        as *const std::os::raw::c_char, progName,
                    outName.as_mut_ptr());
            setExit(1 as std::os::raw::c_int);
            return
        }
    }
    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&
           { n= countHardLinks(inName.as_mut_ptr()); n > 0 as std::os::raw::c_int }
       {
        fprintf(__stderrp,
                b"%s: Input file %s has %d other link%s.\n\x00" as *const u8
                    as *const std::os::raw::c_char, progName, inName.as_mut_ptr(), n,
                if n > 1 as std::os::raw::c_int {
                    b"s\x00" as *const u8 as *const std::os::raw::c_char
                } else { b"\x00" as *const u8 as *const std::os::raw::c_char });
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode == 3 as std::os::raw::c_int {
        /* Save the file's meta-info before we open it.  Doing it later
         means we mess up the access times. */
        saveInputFileMetaInfo(inName.as_mut_ptr());
    }
    match  srcMode {
        1 => {
            inStr= __stdinp;
            outStr= __stdoutp;
            if isatty(fileno(__stdoutp)) != 0 {
                fprintf(__stderrp,
                        b"%s: I won\'t write compressed data to a terminal.\n\x00"
                            as *const u8 as *const std::os::raw::c_char, progName);
                fprintf(__stderrp,
                        b"%s: For help, type: `%s --help\'.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        progName);
                setExit(1 as std::os::raw::c_int);
                return
            }
        }
        2 => {
            inStr=
                fopen(inName.as_mut_ptr(),
                      b"rb\x00" as *const u8 as *const std::os::raw::c_char);
            outStr= __stdoutp;
            if isatty(fileno(__stdoutp)) != 0 {
                fprintf(__stderrp,
                        b"%s: I won\'t write compressed data to a terminal.\n\x00"
                            as *const u8 as *const std::os::raw::c_char, progName);
                fprintf(__stderrp,
                        b"%s: For help, type: `%s --help\'.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        progName);
                if !inStr.is_null() { fclose(inStr); }else { (); }
                setExit(1 as std::os::raw::c_int);
                return
            }
            if inStr.is_null() {();
                fprintf(__stderrp,
                        b"%s: Can\'t open input file %s: %s.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        inName.as_mut_ptr(), strerror(*__error()));
                setExit(1 as std::os::raw::c_int);
                return
            }
        }
        3 => {
            inStr=
                fopen(inName.as_mut_ptr(),
                      b"rb\x00" as *const u8 as *const std::os::raw::c_char);
            outStr=
                fopen_output_safely(outName.as_mut_ptr(),
                                    b"wb\x00" as *const u8 as
                                        *const std::os::raw::c_char);
            if outStr.is_null() {();
                fprintf(__stderrp,
                        b"%s: Can\'t create output file %s: %s.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        outName.as_mut_ptr(), strerror(*__error()));
                if !inStr.is_null() { fclose(inStr); }else { (); }
                setExit(1 as std::os::raw::c_int);
                return
            }
            if inStr.is_null() {();
                fprintf(__stderrp,
                        b"%s: Can\'t open input file %s: %s.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        inName.as_mut_ptr(), strerror(*__error()));
                if !outStr.is_null() { fclose(outStr); }else { (); }
                setExit(1 as std::os::raw::c_int);
                return
            }
        }
        _ => {
            panic(b"compress: bad srcMode\x00" as *const u8 as
                      *const std::os::raw::c_char);
        }
    }
    if verbosity >= 1 as std::os::raw::c_int {
        fprintf(__stderrp, b"  %s: \x00" as *const u8 as *const std::os::raw::c_char,
                inName.as_mut_ptr());
        pad(inName.as_mut_ptr());
        fflush(__stderrp);
    }
    /*--- Now the input and output handles are sane.  Do the Biz. ---*/
    outputHandleJustInCase = outStr;
    deleteOutputOnInterrupt = 1 as std::os::raw::c_int as Bool;
    compressStream(inStr, outStr);
    outputHandleJustInCase = 0 as *mut FILE;
    /*--- If there was an I/O error, we won't get here. ---*/
    if srcMode == 3 as std::os::raw::c_int {
        applySavedTimeInfoToOutputFile(outName.as_mut_ptr());
        deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
        if keepInputFiles == 0 {
            let mut retVal: IntNative = remove(inName.as_mut_ptr());
            if retVal != 0 as std::os::raw::c_int { ioError(); }
        }
    }
    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
}
/*---------------------------------------------*/
unsafe extern "C" fn uncompress(mut name: *mut Char) {
    let mut current_block: u64;
    let mut inStr: *mut FILE = 0 as *mut FILE;
    let mut outStr: *mut FILE = 0 as *mut FILE;
    let mut n: Int32 = 0;
    let mut i: Int32 = 0;
    let mut magicNumberOK: Bool = 0;
    let mut cantGuess: Bool = 0;
    let mut statBuf: stat =
        stat{st_dev: 0,
             st_mode: 0,
             st_nlink: 0,
             st_ino: 0,
             st_uid: 0,
             st_gid: 0,
             st_rdev: 0,
             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_size: 0,
             st_blocks: 0,
             st_blksize: 0,
             st_flags: 0,
             st_gen: 0,
             st_lspare: 0,
             st_qspare: [0; 2],};
    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
    if name.is_null() && srcMode != 1 as std::os::raw::c_int {
        panic(b"uncompress: bad modes\n\x00" as *const u8 as
                  *const std::os::raw::c_char);
    }
    cantGuess= 0 as std::os::raw::c_int as Bool;
    match  srcMode {
        1 => {
            copyFileName(inName.as_mut_ptr(),
                         b"(stdin)\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut Char);
            copyFileName(outName.as_mut_ptr(),
                         b"(stdout)\x00" as *const u8 as *const std::os::raw::c_char
                             as *mut Char);
        }
        3 => {
            copyFileName(inName.as_mut_ptr(), name);
            copyFileName(outName.as_mut_ptr(), name);
            i= 0 as std::os::raw::c_int;
            loop  {
                if !(i < 4 as std::os::raw::c_int) {
                    current_block= 17860125682698302841;
                    break ;
                }
                if mapSuffix(outName.as_mut_ptr(), zSuffix[i as usize],
                             unzSuffix[i as usize]) != 0 {
                    current_block= 15314513098708193206;
                    break ;
                }
                i+= 1
            }
            match current_block {
                15314513098708193206 => { }
                _ => {
                    cantGuess= 1 as std::os::raw::c_int as Bool;
                    strcat(outName.as_mut_ptr(),
                           b".out\x00" as *const u8 as *const std::os::raw::c_char);
                }
            }
        }
        2 => {
            copyFileName(inName.as_mut_ptr(), name);
            copyFileName(outName.as_mut_ptr(),
                         b"(stdout)\x00" as *const u8 as *const std::os::raw::c_char
                             as *mut Char);
        }
        _ => { }
    }
    if srcMode != 1 as std::os::raw::c_int &&
           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {
        if noisy != 0 {
            fprintf(__stderrp,
                    b"%s: There are no files matching `%s\'.\n\x00" as
                        *const u8 as *const std::os::raw::c_char, progName,
                    inName.as_mut_ptr());
        }
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {
        fprintf(__stderrp,
                b"%s: Can\'t open input file %s: %s.\n\x00" as *const u8 as
                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),
                strerror(*__error()));
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode == 3 as std::os::raw::c_int || srcMode == 2 as std::os::raw::c_int {
        stat(inName.as_mut_ptr(), &mut statBuf);
        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==
               0o40000 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"%s: Input file %s is a directory.\n\x00" as *const u8 as
                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());
            setExit(1 as std::os::raw::c_int);
            return
        }
    }
    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&
           notAStandardFile(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {
        if noisy != 0 {
            fprintf(__stderrp,
                    b"%s: Input file %s is not a normal file.\n\x00" as
                        *const u8 as *const std::os::raw::c_char, progName,
                    inName.as_mut_ptr());
        }
        setExit(1 as std::os::raw::c_int);
        return
    }
    if cantGuess != 0 {
        if noisy != 0 {
            fprintf(__stderrp,
                    b"%s: Can\'t guess original name for %s -- using %s\n\x00"
                        as *const u8 as *const std::os::raw::c_char, progName,
                    inName.as_mut_ptr(), outName.as_mut_ptr());
        }
        /* just a warning, no return */
    }
    if srcMode == 3 as std::os::raw::c_int &&
           fileExists(outName.as_mut_ptr()) as std::os::raw::c_int != 0 {
        if forceOverwrite != 0 {
            remove(outName.as_mut_ptr());
        } else {
            fprintf(__stderrp,
                    b"%s: Output file %s already exists.\n\x00" as *const u8
                        as *const std::os::raw::c_char, progName,
                    outName.as_mut_ptr());
            setExit(1 as std::os::raw::c_int);
            return
        }
    }
    if srcMode == 3 as std::os::raw::c_int && forceOverwrite == 0 &&
           { n= countHardLinks(inName.as_mut_ptr()); n > 0 as std::os::raw::c_int }
       {
        fprintf(__stderrp,
                b"%s: Input file %s has %d other link%s.\n\x00" as *const u8
                    as *const std::os::raw::c_char, progName, inName.as_mut_ptr(), n,
                if n > 1 as std::os::raw::c_int {
                    b"s\x00" as *const u8 as *const std::os::raw::c_char
                } else { b"\x00" as *const u8 as *const std::os::raw::c_char });
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode == 3 as std::os::raw::c_int {
        /* Save the file's meta-info before we open it.  Doing it later
         means we mess up the access times. */
        saveInputFileMetaInfo(inName.as_mut_ptr());
    }
    match  srcMode {
        1 => {
            inStr= __stdinp;
            outStr= __stdoutp;
            if isatty(fileno(__stdinp)) != 0 {
                fprintf(__stderrp,
                        b"%s: I won\'t read compressed data from a terminal.\n\x00"
                            as *const u8 as *const std::os::raw::c_char, progName);
                fprintf(__stderrp,
                        b"%s: For help, type: `%s --help\'.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        progName);
                setExit(1 as std::os::raw::c_int);
                return
            }
        }
        2 => {
            inStr=
                fopen(inName.as_mut_ptr(),
                      b"rb\x00" as *const u8 as *const std::os::raw::c_char);
            outStr= __stdoutp;
            if inStr.is_null() {();
                fprintf(__stderrp,
                        b"%s: Can\'t open input file %s:%s.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        inName.as_mut_ptr(), strerror(*__error()));
                if !inStr.is_null() { fclose(inStr); }else { (); }
                setExit(1 as std::os::raw::c_int);
                return
            }
        }
        3 => {
            inStr=
                fopen(inName.as_mut_ptr(),
                      b"rb\x00" as *const u8 as *const std::os::raw::c_char);
            outStr=
                fopen_output_safely(outName.as_mut_ptr(),
                                    b"wb\x00" as *const u8 as
                                        *const std::os::raw::c_char);
            if outStr.is_null() {();
                fprintf(__stderrp,
                        b"%s: Can\'t create output file %s: %s.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        outName.as_mut_ptr(), strerror(*__error()));
                if !inStr.is_null() { fclose(inStr); }else { (); }
                setExit(1 as std::os::raw::c_int);
                return
            }
            if inStr.is_null() {();
                fprintf(__stderrp,
                        b"%s: Can\'t open input file %s: %s.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        inName.as_mut_ptr(), strerror(*__error()));
                if !outStr.is_null() { fclose(outStr); }else { (); }
                setExit(1 as std::os::raw::c_int);
                return
            }
        }
        _ => {
            panic(b"uncompress: bad srcMode\x00" as *const u8 as
                      *const std::os::raw::c_char);
        }
    }
    if verbosity >= 1 as std::os::raw::c_int {
        fprintf(__stderrp, b"  %s: \x00" as *const u8 as *const std::os::raw::c_char,
                inName.as_mut_ptr());
        pad(inName.as_mut_ptr());
        fflush(__stderrp);
    }
    /*--- Now the input and output handles are sane.  Do the Biz. ---*/
    outputHandleJustInCase = outStr;
    deleteOutputOnInterrupt = 1 as std::os::raw::c_int as Bool;
    magicNumberOK= uncompressStream(inStr, outStr);
    outputHandleJustInCase = 0 as *mut FILE;
    /*--- If there was an I/O error, we won't get here. ---*/
    if magicNumberOK != 0 {
        if srcMode == 3 as std::os::raw::c_int {
            applySavedTimeInfoToOutputFile(outName.as_mut_ptr());
            deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
            if keepInputFiles == 0 {
                let mut retVal: IntNative = remove(inName.as_mut_ptr());
                if retVal != 0 as std::os::raw::c_int { ioError(); }
            }
        }
    } else {
        unzFailsExist = 1 as std::os::raw::c_int as Bool;
        deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
        if srcMode == 3 as std::os::raw::c_int {
            let mut retVal_0: IntNative = remove(outName.as_mut_ptr());
            if retVal_0 != 0 as std::os::raw::c_int { ioError(); }
        }
    }
    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
    if magicNumberOK != 0 {
        if verbosity >= 1 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"done\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
    } else {
        setExit(2 as std::os::raw::c_int);
        if verbosity >= 1 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"not a bzip2 file.\n\x00" as *const u8 as
                        *const std::os::raw::c_char);
        } else {
            fprintf(__stderrp,
                    b"%s: %s is not a bzip2 file.\n\x00" as *const u8 as
                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());
        }
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn testf(mut name: *mut Char) {
    let mut inStr: *mut FILE = 0 as *mut FILE;
    let mut allOK: Bool = 0;
    let mut statBuf: stat =
        stat{st_dev: 0,
             st_mode: 0,
             st_nlink: 0,
             st_ino: 0,
             st_uid: 0,
             st_gid: 0,
             st_rdev: 0,
             st_atimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_mtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_ctimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_birthtimespec: timespec{tv_sec: 0, tv_nsec: 0,},
             st_size: 0,
             st_blocks: 0,
             st_blksize: 0,
             st_flags: 0,
             st_gen: 0,
             st_lspare: 0,
             st_qspare: [0; 2],};
    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
    if name.is_null() && srcMode != 1 as std::os::raw::c_int {
        panic(b"testf: bad modes\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    copyFileName(outName.as_mut_ptr(),
                 b"(none)\x00" as *const u8 as *const std::os::raw::c_char as
                     *mut Char);
    match  srcMode {
        1 => {
            copyFileName(inName.as_mut_ptr(),
                         b"(stdin)\x00" as *const u8 as *const std::os::raw::c_char as
                             *mut Char);
        }
        3 => { copyFileName(inName.as_mut_ptr(), name); }
        2 => { copyFileName(inName.as_mut_ptr(), name); }
        _ => { }
    }
    if srcMode != 1 as std::os::raw::c_int &&
           containsDubiousChars(inName.as_mut_ptr()) as std::os::raw::c_int != 0 {
        if noisy != 0 {
            fprintf(__stderrp,
                    b"%s: There are no files matching `%s\'.\n\x00" as
                        *const u8 as *const std::os::raw::c_char, progName,
                    inName.as_mut_ptr());
        }
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode != 1 as std::os::raw::c_int && fileExists(inName.as_mut_ptr()) == 0 {
        fprintf(__stderrp,
                b"%s: Can\'t open input %s: %s.\n\x00" as *const u8 as
                    *const std::os::raw::c_char, progName, inName.as_mut_ptr(),
                strerror(*__error()));
        setExit(1 as std::os::raw::c_int);
        return
    }
    if srcMode != 1 as std::os::raw::c_int {
        stat(inName.as_mut_ptr(), &mut statBuf);
        if statBuf.st_mode as std::os::raw::c_int & 0o170000 as std::os::raw::c_int ==
               0o40000 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"%s: Input file %s is a directory.\n\x00" as *const u8 as
                        *const std::os::raw::c_char, progName, inName.as_mut_ptr());
            setExit(1 as std::os::raw::c_int);
            return
        }
    }
    match  srcMode {
        1 => {
            if isatty(fileno(__stdinp)) != 0 {
                fprintf(__stderrp,
                        b"%s: I won\'t read compressed data from a terminal.\n\x00"
                            as *const u8 as *const std::os::raw::c_char, progName);
                fprintf(__stderrp,
                        b"%s: For help, type: `%s --help\'.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        progName);
                setExit(1 as std::os::raw::c_int);
                return
            }
            inStr= __stdinp
        }
        2 | 3 => {
            inStr=
                fopen(inName.as_mut_ptr(),
                      b"rb\x00" as *const u8 as *const std::os::raw::c_char);
            if inStr.is_null() {();
                fprintf(__stderrp,
                        b"%s: Can\'t open input file %s:%s.\n\x00" as
                            *const u8 as *const std::os::raw::c_char, progName,
                        inName.as_mut_ptr(), strerror(*__error()));
                setExit(1 as std::os::raw::c_int);
                return
            }
        }
        _ => {
            panic(b"testf: bad srcMode\x00" as *const u8 as
                      *const std::os::raw::c_char);
        }
    }
    if verbosity >= 1 as std::os::raw::c_int {
        fprintf(__stderrp, b"  %s: \x00" as *const u8 as *const std::os::raw::c_char,
                inName.as_mut_ptr());
        pad(inName.as_mut_ptr());
        fflush(__stderrp);
    }
    /*--- Now the input handle is sane.  Do the Biz. ---*/
    outputHandleJustInCase = 0 as *mut FILE;
    allOK= testStream(inStr);
    if allOK as std::os::raw::c_int != 0 && verbosity >= 1 as std::os::raw::c_int {
        fprintf(__stderrp, b"ok\n\x00" as *const u8 as *const std::os::raw::c_char);
    }
    if allOK == 0 { testFailsExist = 1 as std::os::raw::c_int as Bool };
}
/*---------------------------------------------*/
unsafe extern "C" fn license() {
    fprintf(__stderrp,
            b"bzip2, a block-sorting file compressor.  Version %s.\n   \n   Copyright (C) 1996-2019 by Julian Seward.\n   \n   This program is free software; you can redistribute it and/or modify\n   it under the terms set out in the LICENSE file, which is included\n   in the bzip2 source distribution.\n   \n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   LICENSE file for more details.\n   \n\x00"
                as *const u8 as *const std::os::raw::c_char, crate::bzlib::BZ2_bzlibVersion());
}
/*---------------------------------------------*/
unsafe extern "C" fn usage(mut fullProgName: *const Char) {
    fprintf(__stderrp,
            b"bzip2, a block-sorting file compressor.  Version %s.\n\n   usage: %s [flags and input files in any order]\n\n   -h --help           print this message\n   -d --decompress     force decompression\n   -z --compress       force compression\n   -k --keep           keep (don\'t delete) input files\n   -f --force          overwrite existing output files\n   -t --test           test compressed file integrity\n   -c --stdout         output to standard out\n   -q --quiet          suppress noncritical error messages\n   -v --verbose        be verbose (a 2nd -v gives more)\n   -L --license        display software version & license\n   -V --version        display software version & license\n   -s --small          use less memory (at most 2500k)\n   -1 .. -9            set block size to 100k .. 900k\n   --fast              alias for -1\n   --best              alias for -9\n\n   If invoked as `bzip2\', default action is to compress.\n              as `bunzip2\',  default action is to decompress.\n              as `bzcat\', default action is to decompress to stdout.\n\n   If no file names are given, bzip2 compresses or decompresses\n   from standard input to standard output.  You can combine\n   short flags, so `-v -4\' means the same as -v4 or -4v, &c.\n\n\x00"
                as *const u8 as *const std::os::raw::c_char, crate::bzlib::BZ2_bzlibVersion(),
            fullProgName);
}
/*---------------------------------------------*/
unsafe extern "C" fn redundant(mut flag: *const Char) {
    fprintf(__stderrp,
            b"%s: %s is redundant in versions 0.9.5 and above\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName, flag);
}
/*---------------------------------------------*/
unsafe extern "C" fn myMalloc(mut n: Int32) -> *mut /* owning */ std::os::raw::c_void {
    let mut p: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    p= malloc(n as size_t);
    if p.is_null() {(); outOfMemory(); }
    return p;
}
/*---------------------------------------------*/
unsafe extern "C" fn mkCell() -> Option<Box<Cell>> {
    let mut c: *mut Cell = None;
    c=
        myMalloc(::std::mem::size_of::<Cell>() as std::os::raw::c_ulong as Int32) as
            *mut Cell;
    (*c.as_deref_mut().unwrap()).name= 0 as *mut Char;
    (*c.as_deref_mut().unwrap()).link= 0 as *mut zzzz;
    return c;
}
/*---------------------------------------------*/
unsafe extern "C" fn snocString(mut root: Option<Box<Cell>>, mut name: *mut Char)
 -> Option<Box<Cell>> {
    if root.as_deref().is_none() {();
        let mut tmp: *mut Cell = mkCell();
        (*tmp.as_deref_mut().unwrap()).name=
            myMalloc((5 as std::os::raw::c_int as
                          std::os::raw::c_ulong).wrapping_add(strlen(name)) as Int32)
                as *mut Char;
        strcpy((*tmp.as_deref().unwrap()).name, name);
        return tmp
    } else {
        let mut tmp_0: *mut Cell = core::mem::transmute::<_, *mut crate::bzip2::zzzz>(root.as_deref_mut());
        while !(*tmp_0).link.is_null() { tmp_0= (*tmp_0).link }();
        (*tmp_0).link= snocString(Some(Box::from_raw((*tmp_0).link)), name);
        return root
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn addFlagsFromEnvVar(mut argList: Option<&mut Option<Box<Cell>>>,
                                        mut varName: *mut Char) {
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut k: Int32 = 0;
    let mut envbase: *mut Char = 0 as *mut Char;
    let mut p: *mut Char = 0 as *mut Char;
    envbase= getenv(varName);
    if !envbase.is_null() {
        p= envbase;
        i= 0 as std::os::raw::c_int;
        while 1 as std::os::raw::c_int as Bool != 0 {
            if *p.offset(i as isize) as std::os::raw::c_int == 0 as std::os::raw::c_int {
                break ;
            }
            p= p.offset(i as isize);
            i= 0 as std::os::raw::c_int;
            while isspace(*p.offset(0 as std::os::raw::c_int as isize) as Int32) != 0
                  {
                p= p.offset(1)
            }
            while *p.offset(i as isize) as std::os::raw::c_int != 0 as std::os::raw::c_int &&
                      isspace(*p.offset(i as isize) as Int32) == 0 {
                i+= 1
            }
            if i > 0 as std::os::raw::c_int {
                k= i;
                if k > 1034 as std::os::raw::c_int - 10 as std::os::raw::c_int {
                    k= 1034 as std::os::raw::c_int - 10 as std::os::raw::c_int
                }
                j= 0 as std::os::raw::c_int;
                while j < k {
                    tmpName[j as usize] = *p.offset(j as isize);
                    j+= 1
                }
                tmpName[k as usize] = 0 as std::os::raw::c_int as Char;
                *argList.as_deref_mut().unwrap()= snocString((*argList.as_deref_mut().unwrap()).take(), tmpName.as_mut_ptr())
            }
        }
    }else { (); };
}
unsafe fn main_0(mut argc: IntNative, mut argv: *mut *mut Char) -> IntNative {
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut tmp: *mut Char = 0 as *mut Char;
    let mut argList: *mut Cell = None;
    let mut aa: *mut Cell = None;
    let mut decode: Bool = 0;
    /*-- Be really really really paranoid :-) --*/
    if ::std::mem::size_of::<Int32>() as std::os::raw::c_ulong !=
           4 as std::os::raw::c_int as std::os::raw::c_ulong ||
           ::std::mem::size_of::<UInt32>() as std::os::raw::c_ulong !=
               4 as std::os::raw::c_int as std::os::raw::c_ulong ||
           ::std::mem::size_of::<Int16>() as std::os::raw::c_ulong !=
               2 as std::os::raw::c_int as std::os::raw::c_ulong ||
           ::std::mem::size_of::<UInt16>() as std::os::raw::c_ulong !=
               2 as std::os::raw::c_int as std::os::raw::c_ulong ||
           ::std::mem::size_of::<Char>() as std::os::raw::c_ulong !=
               1 as std::os::raw::c_int as std::os::raw::c_ulong ||
           ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong !=
               1 as std::os::raw::c_int as std::os::raw::c_ulong {
        configError();
    }
    /*-- Initialise --*/
    outputHandleJustInCase =
        0 as *mut FILE; /* avoid bogus warning from egcs-1.1.X */
    smallMode = 0 as std::os::raw::c_int as Bool;
    keepInputFiles = 0 as std::os::raw::c_int as Bool;
    forceOverwrite = 0 as std::os::raw::c_int as Bool;
    noisy = 1 as std::os::raw::c_int as Bool;
    verbosity = 0 as std::os::raw::c_int;
    blockSize100k = 9 as std::os::raw::c_int;
    testFailsExist = 0 as std::os::raw::c_int as Bool;
    unzFailsExist = 0 as std::os::raw::c_int as Bool;
    numFileNames = 0 as std::os::raw::c_int;
    numFilesProcessed = 0 as std::os::raw::c_int;
    workFactor = 30 as std::os::raw::c_int;
    deleteOutputOnInterrupt = 0 as std::os::raw::c_int as Bool;
    exitValue = 0 as std::os::raw::c_int;
    j= 0 as std::os::raw::c_int;
    i= j;
    /*-- Set up signal handlers for mem access errors --*/
    signal(11 as std::os::raw::c_int,
           Some(mySIGSEGVorSIGBUScatcher as
                    unsafe extern "C" fn(_: IntNative) -> ()));
    signal(10 as std::os::raw::c_int,
           Some(mySIGSEGVorSIGBUScatcher as
                    unsafe extern "C" fn(_: IntNative) -> ()));
    copyFileName(inName.as_mut_ptr(),
                 b"(none)\x00" as *const u8 as *const std::os::raw::c_char as
                     *mut Char);
    copyFileName(outName.as_mut_ptr(),
                 b"(none)\x00" as *const u8 as *const std::os::raw::c_char as
                     *mut Char);
    copyFileName(progNameReally.as_mut_ptr(),
                 *argv.offset(0 as std::os::raw::c_int as isize));
    progName =
        &mut *progNameReally.as_mut_ptr().offset(0 as std::os::raw::c_int as isize) as
            *mut Char;
    tmp=
        &mut *progNameReally.as_mut_ptr().offset(0 as std::os::raw::c_int as isize) as
            *mut Char;
    while (*tmp) as std::os::raw::c_int != '\u{0}' as i32 {
        if (*tmp) as std::os::raw::c_int == '/' as i32 {
            progName = tmp.offset(1 as std::os::raw::c_int as isize)
        }
        tmp= tmp.offset(1)
    }
    /*-- Copy flags from env var BZIP2, and 
        expand filename wildcards in arg list.
   --*/
    argList= None;
    addFlagsFromEnvVar(&mut argList,
                       b"BZIP2\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut Char);
    addFlagsFromEnvVar(&mut argList,
                       b"BZIP\x00" as *const u8 as *const std::os::raw::c_char as
                           *mut Char);
    i= 1 as std::os::raw::c_int;
    while i <= argc - 1 as std::os::raw::c_int {
        argList= snocString(argList, *argv.offset(i as isize));
        i+= 1
    }
    /*-- Find the length of the longest filename --*/
    longestFileName = 7 as std::os::raw::c_int;
    numFileNames = 0 as std::os::raw::c_int;
    decode= 1 as std::os::raw::c_int as Bool;
    aa= argList;
    while !aa.as_deref().is_none() {
        if strcmp((*aa.as_deref().unwrap()).name, b"--\x00" as *const u8 as *const std::os::raw::c_char)
               == 0 as std::os::raw::c_int {
            decode= 0 as std::os::raw::c_int as Bool
        } else if !(*(*aa.as_deref().unwrap()).name.offset(0 as std::os::raw::c_int as isize) as
                        std::os::raw::c_int == '-' as i32 &&
                        decode as std::os::raw::c_int != 0) {
            numFileNames += 1;
            if longestFileName < strlen((*aa.as_deref().unwrap()).name) as Int32 {
                longestFileName = strlen((*aa.as_deref().unwrap()).name) as Int32
            }
        }
        aa= Some(Box::from_raw((*aa.as_deref().unwrap()).link))
    }();
    /*-- Determine source modes; flag handling may change this too. --*/
    if numFileNames == 0 as std::os::raw::c_int {
        srcMode = 1 as std::os::raw::c_int
    } else { srcMode = 3 as std::os::raw::c_int }
    /*-- Determine what to do (compress/uncompress/test/cat). --*/
   /*-- Note that subsequent flag handling may change this. --*/
    opMode = 1 as std::os::raw::c_int;
    if !strstr(progName,
               b"unzip\x00" as *const u8 as *const std::os::raw::c_char).is_null() ||
           !strstr(progName,
                   b"UNZIP\x00" as *const u8 as *const std::os::raw::c_char).is_null()
       {
        opMode = 2 as std::os::raw::c_int
    }
    if !strstr(progName,
               b"z2cat\x00" as *const u8 as *const std::os::raw::c_char).is_null() ||
           !strstr(progName,
                   b"Z2CAT\x00" as *const u8 as *const std::os::raw::c_char).is_null()
           ||
           !strstr(progName,
                   b"zcat\x00" as *const u8 as *const std::os::raw::c_char).is_null()
           ||
           !strstr(progName,
                   b"ZCAT\x00" as *const u8 as *const std::os::raw::c_char).is_null()
       {
        opMode = 2 as std::os::raw::c_int;
        srcMode =
            if numFileNames == 0 as std::os::raw::c_int {
                1 as std::os::raw::c_int
            } else { 2 as std::os::raw::c_int }
    }
    /*-- Look at the flags. --*/
    aa= argList;
    while !aa.as_deref().is_none() {
        if strcmp((*aa.as_deref().unwrap()).name, b"--\x00" as *const u8 as *const std::os::raw::c_char)
               == 0 as std::os::raw::c_int {
            break ;
        }
        if *(*aa.as_deref().unwrap()).name.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int ==
               '-' as i32 &&
               *(*aa.as_deref().unwrap()).name.offset(1 as std::os::raw::c_int as isize) as std::os::raw::c_int !=
                   '-' as i32 {
            j= 1 as std::os::raw::c_int;
            while *(*aa.as_deref().unwrap()).name.offset(j as isize) as std::os::raw::c_int !=
                      '\u{0}' as i32 {
                match  *(*aa.as_deref().unwrap()).name.offset(j as isize) as std::os::raw::c_int {
                    99 => { srcMode = 2 as std::os::raw::c_int }
                    100 => { opMode = 2 as std::os::raw::c_int }
                    122 => { opMode = 1 as std::os::raw::c_int }
                    102 => { forceOverwrite = 1 as std::os::raw::c_int as Bool }
                    116 => { opMode = 3 as std::os::raw::c_int }
                    107 => { keepInputFiles = 1 as std::os::raw::c_int as Bool }
                    115 => { smallMode = 1 as std::os::raw::c_int as Bool }
                    113 => { noisy = 0 as std::os::raw::c_int as Bool }
                    49 => { blockSize100k = 1 as std::os::raw::c_int }
                    50 => { blockSize100k = 2 as std::os::raw::c_int }
                    51 => { blockSize100k = 3 as std::os::raw::c_int }
                    52 => { blockSize100k = 4 as std::os::raw::c_int }
                    53 => { blockSize100k = 5 as std::os::raw::c_int }
                    54 => { blockSize100k = 6 as std::os::raw::c_int }
                    55 => { blockSize100k = 7 as std::os::raw::c_int }
                    56 => { blockSize100k = 8 as std::os::raw::c_int }
                    57 => { blockSize100k = 9 as std::os::raw::c_int }
                    86 | 76 => { license(); }
                    118 => { verbosity += 1 }
                    104 => { usage(progName); exit(0 as std::os::raw::c_int); }
                    _ => {
                        fprintf(__stderrp,
                                b"%s: Bad flag `%s\'\n\x00" as *const u8 as
                                    *const std::os::raw::c_char, progName,
                                (*aa).name);
                        usage(progName);
                        exit(1 as std::os::raw::c_int);
                    }
                }
                j+= 1
            }
        }
        aa= Some(Box::from_raw((*aa.as_deref().unwrap()).link))
    }();
    /*-- And again ... --*/
    aa= argList;
    while !aa.as_deref().is_none() {
        if strcmp((*aa.as_deref().unwrap()).name, b"--\x00" as *const u8 as *const std::os::raw::c_char)
               == 0 as std::os::raw::c_int {
            break ;
        }
        if strcmp((*aa.as_deref().unwrap()).name,
                  b"--stdout\x00" as *const u8 as *const std::os::raw::c_char) ==
               0 as std::os::raw::c_int {
            srcMode = 2 as std::os::raw::c_int
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--decompress\x00" as *const u8 as
                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {
            opMode = 2 as std::os::raw::c_int
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--compress\x00" as *const u8 as
                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {
            opMode = 1 as std::os::raw::c_int
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--force\x00" as *const u8 as *const std::os::raw::c_char)
                      == 0 as std::os::raw::c_int {
            forceOverwrite = 1 as std::os::raw::c_int as Bool
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--test\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 as std::os::raw::c_int {
            opMode = 3 as std::os::raw::c_int
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--keep\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 as std::os::raw::c_int {
            keepInputFiles = 1 as std::os::raw::c_int as Bool
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--small\x00" as *const u8 as *const std::os::raw::c_char)
                      == 0 as std::os::raw::c_int {
            smallMode = 1 as std::os::raw::c_int as Bool
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--quiet\x00" as *const u8 as *const std::os::raw::c_char)
                      == 0 as std::os::raw::c_int {
            noisy = 0 as std::os::raw::c_int as Bool
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--version\x00" as *const u8 as *const std::os::raw::c_char)
                      == 0 as std::os::raw::c_int {
            license();
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--license\x00" as *const u8 as *const std::os::raw::c_char)
                      == 0 as std::os::raw::c_int {
            license();
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--exponential\x00" as *const u8 as
                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {
            workFactor = 1 as std::os::raw::c_int
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--repetitive-best\x00" as *const u8 as
                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {
            redundant((*aa.as_deref().unwrap()).name);
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--repetitive-fast\x00" as *const u8 as
                             *const std::os::raw::c_char) == 0 as std::os::raw::c_int {
            redundant((*aa.as_deref().unwrap()).name);
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--fast\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 as std::os::raw::c_int {
            blockSize100k = 1 as std::os::raw::c_int
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--best\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 as std::os::raw::c_int {
            blockSize100k = 9 as std::os::raw::c_int
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--verbose\x00" as *const u8 as *const std::os::raw::c_char)
                      == 0 as std::os::raw::c_int {
            verbosity += 1
        } else if strcmp((*aa.as_deref().unwrap()).name,
                         b"--help\x00" as *const u8 as *const std::os::raw::c_char) ==
                      0 as std::os::raw::c_int {
            usage(progName);
            exit(0 as std::os::raw::c_int);
        } else {
            if strncmp((*aa.as_deref().unwrap()).name,
                       b"--\x00" as *const u8 as *const std::os::raw::c_char,
                       2 as std::os::raw::c_int as std::os::raw::c_ulong) == 0 as std::os::raw::c_int
               {
                fprintf(__stderrp,
                        b"%s: Bad flag `%s\'\n\x00" as *const u8 as
                            *const std::os::raw::c_char, progName, (*aa).name);
                usage(progName);
                exit(1 as std::os::raw::c_int);
            }
        }
        aa= Some(Box::from_raw((*aa.as_deref().unwrap()).link))
    }();
    if verbosity > 4 as std::os::raw::c_int { verbosity = 4 as std::os::raw::c_int }
    if opMode == 1 as std::os::raw::c_int && smallMode as std::os::raw::c_int != 0 &&
           blockSize100k > 2 as std::os::raw::c_int {
        blockSize100k = 2 as std::os::raw::c_int
    }
    if opMode == 3 as std::os::raw::c_int && srcMode == 2 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"%s: -c and -t cannot be used together.\n\x00" as *const u8
                    as *const std::os::raw::c_char, progName);
        exit(1 as std::os::raw::c_int);
    }
    if srcMode == 2 as std::os::raw::c_int && numFileNames == 0 as std::os::raw::c_int {
        srcMode = 1 as std::os::raw::c_int
    }
    if opMode != 1 as std::os::raw::c_int { blockSize100k = 0 as std::os::raw::c_int }
    if srcMode == 3 as std::os::raw::c_int {
        signal(2 as std::os::raw::c_int,
               Some(mySignalCatcher as
                        unsafe extern "C" fn(_: IntNative) -> ()));
        signal(15 as std::os::raw::c_int,
               Some(mySignalCatcher as
                        unsafe extern "C" fn(_: IntNative) -> ()));
        signal(1 as std::os::raw::c_int,
               Some(mySignalCatcher as
                        unsafe extern "C" fn(_: IntNative) -> ()));
    }
    if opMode == 1 as std::os::raw::c_int {
        if srcMode == 1 as std::os::raw::c_int {
            compress(0 as *mut Char);
        } else {
            decode= 1 as std::os::raw::c_int as Bool;
            aa= argList;
            while !aa.as_deref().is_none() {
                if strcmp((*aa.as_deref().unwrap()).name,
                          b"--\x00" as *const u8 as *const std::os::raw::c_char) ==
                       0 as std::os::raw::c_int {
                    decode= 0 as std::os::raw::c_int as Bool
                } else if !(*(*aa.as_deref().unwrap()).name.offset(0 as std::os::raw::c_int as isize) as
                                std::os::raw::c_int == '-' as i32 &&
                                decode as std::os::raw::c_int != 0) {
                    numFilesProcessed += 1;
                    compress((*aa.as_deref().unwrap()).name);
                }
                aa= Some(Box::from_raw((*aa.as_deref().unwrap()).link))
            }();
        }
    } else if opMode == 2 as std::os::raw::c_int {
        unzFailsExist = 0 as std::os::raw::c_int as Bool;
        if srcMode == 1 as std::os::raw::c_int {
            uncompress(0 as *mut Char);
        } else {
            decode= 1 as std::os::raw::c_int as Bool;
            aa= argList;
            while !aa.as_deref().is_none() {
                if strcmp((*aa.as_deref().unwrap()).name,
                          b"--\x00" as *const u8 as *const std::os::raw::c_char) ==
                       0 as std::os::raw::c_int {
                    decode= 0 as std::os::raw::c_int as Bool
                } else if !(*(*aa.as_deref().unwrap()).name.offset(0 as std::os::raw::c_int as isize) as
                                std::os::raw::c_int == '-' as i32 &&
                                decode as std::os::raw::c_int != 0) {
                    numFilesProcessed += 1;
                    uncompress((*aa.as_deref().unwrap()).name);
                }
                aa= Some(Box::from_raw((*aa.as_deref().unwrap()).link))
            }();
        }
        if unzFailsExist != 0 { setExit(2 as std::os::raw::c_int); exit(exitValue); }
    } else {
        testFailsExist = 0 as std::os::raw::c_int as Bool;
        if srcMode == 1 as std::os::raw::c_int {
            testf(0 as *mut Char);
        } else {
            decode= 1 as std::os::raw::c_int as Bool;
            aa= argList;
            while !aa.as_deref().is_none() {
                if strcmp((*aa.as_deref().unwrap()).name,
                          b"--\x00" as *const u8 as *const std::os::raw::c_char) ==
                       0 as std::os::raw::c_int {
                    decode= 0 as std::os::raw::c_int as Bool
                } else if !(*(*aa.as_deref().unwrap()).name.offset(0 as std::os::raw::c_int as isize) as
                                std::os::raw::c_int == '-' as i32 &&
                                decode as std::os::raw::c_int != 0) {
                    numFilesProcessed += 1;
                    testf((*aa.as_deref().unwrap()).name);
                }
                aa= Some(Box::from_raw((*aa.as_deref().unwrap()).link))
            }();
        }
        if testFailsExist != 0 {
            if noisy != 0 {
                fprintf(__stderrp,
                        b"\nYou can use the `bzip2recover\' program to attempt to recover\ndata from undamaged sections of corrupted files.\n\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
            }
            setExit(2 as std::os::raw::c_int);
            exit(exitValue);
        }
    }
    /* Free the argument list memory to mollify leak detectors 
      (eg) Purify, Checker.  Serves no other useful purpose.
   */
    aa= argList;
    while !aa.as_deref().is_none() {
        let mut aa2: *mut Cell = Some(Box::from_raw((*aa.as_deref().unwrap()).link));
        if !(*aa.as_deref().unwrap()).name.is_null() { free((*aa.as_deref().unwrap()).name as *mut std::os::raw::c_void); }else { (); }
        ();
        aa= aa2
    }();
    return exitValue;
}
// #[main]
// pub fn main() {
//     let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
//     for arg in ::std::env::args() {
//         args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
//     };
//     args.push(::std::ptr::null_mut());
//     unsafe {
//         ::std::process::exit(main_0((args.len() - 1) as IntNative,
//                                     args.as_mut_ptr() as *mut *mut Char) as
//                                  i32)
//     }
// }
/*-----------------------------------------------------------*/
/*--- end                                         bzip2.c ---*/
/*-----------------------------------------------------------*/

extern "C" {
    
    #[no_mangle]
    static mut __stderrp: *mut FILE;
    #[no_mangle]
    fn fclose(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fflush(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fopen(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn getc(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn perror(_: *const std::os::raw::c_char);
    #[no_mangle]
    fn putc(_: std::os::raw::c_int, _: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn sprintf(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char, _: ...)
     -> std::os::raw::c_int;
    #[no_mangle]
    fn __error() -> *mut std::os::raw::c_int;
    #[no_mangle]
    fn malloc(_: std::os::raw::c_ulong) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn free(_: *mut std::os::raw::c_void);
    #[no_mangle]
    fn exit(_: std::os::raw::c_int) -> !;
    #[no_mangle]
    fn strcat(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strcpy(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn strncpy(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strrchr(_: *const std::os::raw::c_char, _: std::os::raw::c_int) -> *mut std::os::raw::c_char;
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor2;
impl Default for ErasedByPreprocessor2 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor3;
impl Default for ErasedByPreprocessor3 {fn default() -> Self {Self {
}}}

pub type FILE = crate::blocksort::__sFILE;
/*-----------------------------------------------------------*/
/*--- Block recoverer program for bzip2                   ---*/
/*---                                      bzip2recover.c ---*/
/*-----------------------------------------------------------*/
/* ------------------------------------------------------------------
   This file is part of bzip2/libbzip2, a program and library for
   lossless, block-sorting data compression.

   bzip2/libbzip2 version 1.0.8 of 13 July 2019
   Copyright (C) 1996-2019 Julian Seward <jseward@acm.org>

   Please read the WARNING, DISCLAIMER and PATENTS sections in the 
   README file.

   This program is released under the terms of the license contained
   in the file LICENSE.
   ------------------------------------------------------------------ */
/* This program is a complete hack and should be rewritten properly.
	 It isn't very complicated. */
/* This program records bit locations in the file to be recovered.
   That means that if 64-bit ints are not supported, we will not
   be able to recover .bz2 files over 512MB (2^32 bits) long.
   On GNU supported platforms, we take advantage of the 64-bit
   int support to circumvent this problem.  Ditto MSVC.

   This change occurred in version 1.0.2; all prior versions have
   the 512MB limitation.
*/
pub type MaybeUInt64 = std::os::raw::c_ulonglong;
pub type UInt32 = std::os::raw::c_uint;
pub type Int32 = std::os::raw::c_int;
pub type UChar = std::os::raw::c_uchar;
pub type Char = std::os::raw::c_char;
pub type Bool = std::os::raw::c_uchar;
#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer2;
#[repr(C)]
pub struct BitStream {
    pub handle: Option<Box<FILE>>,
    pub buffer: Int32,
    pub buffLive: Int32,
    pub mode: Char,
}
impl Default for BitStream {fn default() -> Self {Self {
handle: None,
buffer: Default::default(),
buffLive: Default::default(),
mode: Default::default(),
}}}
impl BitStream {pub fn take(&mut self) -> Self {core::mem::take(self)}}

#[no_mangle]
pub static mut inFileName: [Char; 2000] = [0; 2000];
#[no_mangle]
pub static mut outFileName: [Char; 2000] = [0; 2000];
pub static mut progName: [Char; 2000] = [0; 2000];
#[no_mangle]
pub static mut bytesOut: MaybeUInt64 = 0 as std::os::raw::c_int as MaybeUInt64;
#[no_mangle]
pub static mut bytesIn: MaybeUInt64 = 0 as std::os::raw::c_int as MaybeUInt64;
/* '0' */
/*---------------------------------------------------*/
/*--- I/O errors                                  ---*/
/*---------------------------------------------------*/
/*---------------------------------------------*/
unsafe extern "C" fn readError() {
    fprintf(__stderrp,
            b"%s: I/O error reading `%s\', possible reason follows.\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),
            inFileName.as_mut_ptr());
    perror(progName.as_mut_ptr());
    fprintf(__stderrp,
            b"%s: warning: output file(s) may be incomplete.\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());
    exit(1 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn writeError() {
    fprintf(__stderrp,
            b"%s: I/O error reading `%s\', possible reason follows.\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),
            inFileName.as_mut_ptr());
    perror(progName.as_mut_ptr());
    fprintf(__stderrp,
            b"%s: warning: output file(s) may be incomplete.\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());
    exit(1 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn mallocFail(mut n: Int32) {
    fprintf(__stderrp,
            b"%s: malloc failed on request for %d bytes.\n\x00" as *const u8
                as *const std::os::raw::c_char, progName.as_mut_ptr(), n);
    fprintf(__stderrp,
            b"%s: warning: output file(s) may be incomplete.\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());
    exit(1 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn tooManyBlocks(mut max_handled_blocks: Int32) {
    fprintf(__stderrp,
            b"%s: `%s\' appears to contain more than %d blocks\n\x00" as
                *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr(),
            inFileName.as_mut_ptr(), max_handled_blocks);
    fprintf(__stderrp,
            b"%s: and cannot be handled.  To fix, increase\n\x00" as *const u8
                as *const std::os::raw::c_char, progName.as_mut_ptr());
    fprintf(__stderrp,
            b"%s: BZ_MAX_HANDLED_BLOCKS in bzip2recover.c, and recompile.\n\x00"
                as *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());
    exit(1 as std::os::raw::c_int);
}
/*---------------------------------------------*/
unsafe extern "C" fn bsOpenReadStream(mut stream: *mut FILE)
 -> Option<Box<BitStream>> {
    let mut bs: *mut BitStream =
        Some(Box::new(<crate::bzip2recover::BitStream as Default>::default()));
    if bs.as_deref().is_none() {();
        mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as
                       Int32);
    }
    (*bs.as_deref_mut().unwrap()).handle= Some(Box::from_raw(stream));
    (*bs.as_deref_mut().unwrap()).buffer= 0 as std::os::raw::c_int;
    (*bs.as_deref_mut().unwrap()).buffLive= 0 as std::os::raw::c_int;
    (*bs.as_deref_mut().unwrap()).mode= 'r' as i32 as Char;
    return bs;
}
/*---------------------------------------------*/
unsafe extern "C" fn bsOpenWriteStream(mut stream: *mut FILE)
 -> Option<Box<BitStream>> {
    let mut bs: *mut BitStream =
        Some(Box::new(<crate::bzip2recover::BitStream as Default>::default()));
    if bs.as_deref().is_none() {();
        mallocFail(::std::mem::size_of::<BitStream>() as std::os::raw::c_ulong as
                       Int32);
    }
    (*bs.as_deref_mut().unwrap()).handle= Some(Box::from_raw(stream));
    (*bs.as_deref_mut().unwrap()).buffer= 0 as std::os::raw::c_int;
    (*bs.as_deref_mut().unwrap()).buffLive= 0 as std::os::raw::c_int;
    (*bs.as_deref_mut().unwrap()).mode= 'w' as i32 as Char;
    return bs;
}
/*---------------------------------------------*/
unsafe extern "C" fn bsPutBit(mut bs: Option<&mut BitStream>, mut bit: Int32) {
    if (*bs.as_deref().unwrap()).buffLive == 8 as std::os::raw::c_int {
        let mut retVal: Int32 =
            putc((*bs.as_deref().unwrap()).buffer as UChar as std::os::raw::c_int, core::mem::transmute::<_, *mut crate::blocksort::__sFILE>((*bs.as_deref().unwrap()).handle.as_deref_mut()));
        if retVal == -(1 as std::os::raw::c_int) { writeError(); }
        bytesOut = bytesOut.wrapping_add(1);
        (*bs.as_deref_mut().unwrap()).buffLive= 1 as std::os::raw::c_int;
        (*bs.as_deref_mut().unwrap()).buffer= bit & 0x1 as std::os::raw::c_int
    } else {
        (*bs.as_deref_mut().unwrap()).buffer=
            (*bs).buffer << 1 as std::os::raw::c_int | bit & 0x1 as std::os::raw::c_int;
        (*bs.as_deref_mut().unwrap()).buffLive+= 1
    };
}
/*---------------------------------------------*/
/*--
   Returns 0 or 1, or 2 to indicate EOF.
--*/
unsafe extern "C" fn bsGetBit(mut bs: Option<&mut BitStream>) -> Int32 {
    if (*bs.as_deref().unwrap()).buffLive > 0 as std::os::raw::c_int {
        (*bs.as_deref_mut().unwrap()).buffLive-= 1;
        return (*bs).buffer >> (*bs).buffLive & 0x1 as std::os::raw::c_int
    } else {
        let mut retVal: Int32 = getc(core::mem::transmute::<_, *mut crate::blocksort::__sFILE>((*bs.as_deref().unwrap()).handle.as_deref_mut()));
        if retVal == -(1 as std::os::raw::c_int) {
            if *__error() != 0 as std::os::raw::c_int { readError(); }
            return 2 as std::os::raw::c_int
        }
        (*bs.as_deref_mut().unwrap()).buffLive= 7 as std::os::raw::c_int;
        (*bs.as_deref_mut().unwrap()).buffer= retVal;
        return (*bs).buffer >> 7 as std::os::raw::c_int & 0x1 as std::os::raw::c_int
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn bsClose(mut bs: Option<Box<BitStream>>) {
    let mut retVal: Int32 = 0;
    if (*bs.as_deref().unwrap()).mode as std::os::raw::c_int == 'w' as i32 {
        while (*bs.as_deref().unwrap()).buffLive < 8 as std::os::raw::c_int {
            (*bs.as_deref_mut().unwrap()).buffLive+= 1;
            (*bs.as_deref_mut().unwrap()).buffer<<= 1 as std::os::raw::c_int
        }
        retVal= putc((*bs.as_deref().unwrap()).buffer as UChar as std::os::raw::c_int, core::mem::transmute::<_, *mut crate::blocksort::__sFILE>((*bs.as_deref().unwrap()).handle.as_deref_mut()));
        if retVal == -(1 as std::os::raw::c_int) { writeError(); }
        bytesOut = bytesOut.wrapping_add(1);
        retVal= fflush(core::mem::transmute::<_, *mut crate::blocksort::__sFILE>((*bs.as_deref().unwrap()).handle.as_deref_mut()));
        if retVal == -(1 as std::os::raw::c_int) { writeError(); }
    }
    retVal= fclose(core::mem::transmute::<_, *mut crate::blocksort::__sFILE>((*bs.as_deref().unwrap()).handle.as_deref_mut()));
    if retVal == -(1 as std::os::raw::c_int) {
        if (*bs.as_deref().unwrap()).mode as std::os::raw::c_int == 'w' as i32 {
            writeError();
        } else { readError(); }
    }
    ();
}
/*---------------------------------------------*/
unsafe extern "C" fn bsPutUChar(mut bs: Option<&mut BitStream>, mut c: UChar) {
    let mut i: Int32 = 0;
    i= 7 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        bsPutBit(bs.as_deref_mut(),
                 (c as UInt32 >> i & 0x1 as std::os::raw::c_int as std::os::raw::c_uint) as
                     Int32);
        i-= 1
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn bsPutUInt32(mut bs: Option<&mut BitStream>, mut c: UInt32) {
    let mut i: Int32 = 0;
    i= 31 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        bsPutBit(bs.as_deref_mut(), (c >> i & 0x1 as std::os::raw::c_int as std::os::raw::c_uint) as Int32);
        i-= 1
    };
}
/*---------------------------------------------*/
unsafe extern "C" fn endsInBz2(mut name: *const Char) -> Bool {
    let mut n: Int32 = strlen(name) as Int32;
    if n <= 4 as std::os::raw::c_int { return 0 as std::os::raw::c_int as Bool }
    return (*name.offset((n - 4 as std::os::raw::c_int) as isize) as std::os::raw::c_int ==
                '.' as i32 &&
                *name.offset((n - 3 as std::os::raw::c_int) as isize) as std::os::raw::c_int
                    == 'b' as i32 &&
                *name.offset((n - 2 as std::os::raw::c_int) as isize) as std::os::raw::c_int
                    == 'z' as i32 &&
                *name.offset((n - 1 as std::os::raw::c_int) as isize) as std::os::raw::c_int
                    == '2' as i32) as std::os::raw::c_int as Bool;
}
#[no_mangle]
pub static mut bStart: [MaybeUInt64; 50000] = [0; 50000];
#[no_mangle]
pub static mut bEnd: [MaybeUInt64; 50000] = [0; 50000];
#[no_mangle]
pub static mut rbStart: [MaybeUInt64; 50000] = [0; 50000];
#[no_mangle]
pub static mut rbEnd: [MaybeUInt64; 50000] = [0; 50000];
unsafe fn main_0(mut argc: Int32, mut argv: *mut *mut Char) -> Int32 {
    let mut inFile: *mut FILE = 0 as *mut FILE;
    let mut outFile: *mut FILE = 0 as *mut FILE;
    let mut bsIn: *mut BitStream = 0 as *mut BitStream;
    let mut bsWr: *mut BitStream = 0 as *mut BitStream;
    let mut b: Int32 = 0;
    let mut wrBlock: Int32 = 0;
    let mut currBlock: Int32 = 0;
    let mut rbCtr: Int32 = 0;
    let mut bitsRead: MaybeUInt64 = 0;
    let mut buffHi: UInt32 = 0;
    let mut buffLo: UInt32 = 0;
    let mut blockCRC: UInt32 = 0;
    let mut p: *mut Char = 0 as *mut Char;
    strncpy(progName.as_mut_ptr(), *argv.offset(0 as std::os::raw::c_int as isize),
            (2000 as std::os::raw::c_int - 1 as std::os::raw::c_int) as std::os::raw::c_ulong);
    progName[(2000 as std::os::raw::c_int - 1 as std::os::raw::c_int) as usize] =
        '\u{0}' as i32 as Char;
    outFileName[0 as std::os::raw::c_int as usize] = 0 as std::os::raw::c_int as Char;
    inFileName[0 as std::os::raw::c_int as usize] =
        outFileName[0 as std::os::raw::c_int as usize];
    fprintf(__stderrp,
            b"bzip2recover 1.0.8: extracts blocks from damaged .bz2 files.\n\x00"
                as *const u8 as *const std::os::raw::c_char);
    if argc != 2 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"%s: usage is `%s damaged_file_name\'.\n\x00" as *const u8 as
                    *const std::os::raw::c_char, progName.as_mut_ptr(),
                progName.as_mut_ptr());
        match  ::std::mem::size_of::<MaybeUInt64>() as std::os::raw::c_ulong {
            8 => {
                fprintf(__stderrp,
                        b"\trestrictions on size of recovered file: None\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
            }
            4 => {
                fprintf(__stderrp,
                        b"\trestrictions on size of recovered file: 512 MB\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
                fprintf(__stderrp,
                        b"\tto circumvent, recompile with MaybeUInt64 as an\n\tunsigned 64-bit int.\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
            }
            _ => {
                fprintf(__stderrp,
                        b"\tsizeof(MaybeUInt64) is not 4 or 8 -- configuration error.\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
            }
        }
        exit(1 as std::os::raw::c_int);
    }
    if strlen(*argv.offset(1 as std::os::raw::c_int as isize)) >=
           (2000 as std::os::raw::c_int - 20 as std::os::raw::c_int) as std::os::raw::c_ulong {
        fprintf(__stderrp,
                b"%s: supplied filename is suspiciously (>= %d chars) long.  Bye!\n\x00"
                    as *const u8 as *const std::os::raw::c_char,
                progName.as_mut_ptr(),
                strlen(*argv.offset(1 as std::os::raw::c_int as isize)) as
                    std::os::raw::c_int);
        exit(1 as std::os::raw::c_int);
    }
    strcpy(inFileName.as_mut_ptr(), *argv.offset(1 as std::os::raw::c_int as isize));
    inFile=
        fopen(inFileName.as_mut_ptr(),
              b"rb\x00" as *const u8 as *const std::os::raw::c_char);
    if inFile.is_null() {();
        fprintf(__stderrp,
                b"%s: can\'t read `%s\'\n\x00" as *const u8 as
                    *const std::os::raw::c_char, progName.as_mut_ptr(),
                inFileName.as_mut_ptr());
        exit(1 as std::os::raw::c_int);
    }
    bsIn= bsOpenReadStream(inFile);
    fprintf(__stderrp,
            b"%s: searching for block boundaries ...\n\x00" as *const u8 as
                *const std::os::raw::c_char, progName.as_mut_ptr());
    bitsRead= 0 as std::os::raw::c_int as MaybeUInt64;
    buffLo= 0 as std::os::raw::c_int as UInt32;
    buffHi= buffLo;
    currBlock= 0 as std::os::raw::c_int;
    bStart[currBlock as usize] = 0 as std::os::raw::c_int as MaybeUInt64;
    rbCtr= 0 as std::os::raw::c_int;
    while 1 as std::os::raw::c_int as Bool != 0 {
        b= bsGetBit(bsIn.as_mut());
        bitsRead= bitsRead.wrapping_add(1);
        if b == 2 as std::os::raw::c_int {
            if bitsRead >= bStart[currBlock as usize] &&
                   bitsRead.wrapping_sub(bStart[currBlock as usize]) >=
                       40 as std::os::raw::c_int as std::os::raw::c_ulonglong {
                bEnd[currBlock as usize] =
                    bitsRead.wrapping_sub(1 as std::os::raw::c_int as
                                              std::os::raw::c_ulonglong);
                if currBlock > 0 as std::os::raw::c_int {
                    fprintf(__stderrp,
                            b"   block %d runs from %Lu to %Lu (incomplete)\n\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            currBlock, bStart[currBlock as usize],
                            bEnd[currBlock as usize]);
                }
            } else { currBlock-= 1 }
            break ;
        } else {
            buffHi= buffHi << 1 as std::os::raw::c_int | buffLo >> 31 as std::os::raw::c_int;
            buffLo=
                buffLo << 1 as std::os::raw::c_int |
                    (b & 1 as std::os::raw::c_int) as std::os::raw::c_uint;
            if (buffHi & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as
                   std::os::raw::c_ulong == 0x3141 as std::os::raw::c_ulong &&
                   buffLo as std::os::raw::c_ulong == 0x59265359 as std::os::raw::c_ulong ||
                   (buffHi & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as
                       std::os::raw::c_ulong == 0x1772 as std::os::raw::c_ulong &&
                       buffLo as std::os::raw::c_ulong == 0x45385090 as std::os::raw::c_ulong
               {
                if bitsRead > 49 as std::os::raw::c_int as std::os::raw::c_ulonglong {
                    bEnd[currBlock as usize] =
                        bitsRead.wrapping_sub(49 as std::os::raw::c_int as
                                                  std::os::raw::c_ulonglong)
                } else {
                    bEnd[currBlock as usize] = 0 as std::os::raw::c_int as MaybeUInt64
                }
                if currBlock > 0 as std::os::raw::c_int &&
                       bEnd[currBlock as
                                usize].wrapping_sub(bStart[currBlock as
                                                               usize]) >=
                           130 as std::os::raw::c_int as std::os::raw::c_ulonglong {
                    fprintf(__stderrp,
                            b"   block %d runs from %Lu to %Lu\n\x00" as
                                *const u8 as *const std::os::raw::c_char,
                            rbCtr + 1 as std::os::raw::c_int,
                            bStart[currBlock as usize],
                            bEnd[currBlock as usize]);
                    rbStart[rbCtr as usize] = bStart[currBlock as usize];
                    rbEnd[rbCtr as usize] = bEnd[currBlock as usize];
                    rbCtr+= 1
                }
                if currBlock >= 50000 as std::os::raw::c_int {
                    tooManyBlocks(50000 as std::os::raw::c_int);
                }
                currBlock+= 1;
                bStart[currBlock as usize] = bitsRead
            }
        }
    }
    bsClose(Some(Box::from_raw(bsIn)));
    /*-- identified blocks run from 1 to rbCtr inclusive. --*/
    if rbCtr < 1 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"%s: sorry, I couldn\'t find any block boundaries.\n\x00" as
                    *const u8 as *const std::os::raw::c_char, progName.as_mut_ptr());
        exit(1 as std::os::raw::c_int);
    }
    fprintf(__stderrp,
            b"%s: splitting into blocks\n\x00" as *const u8 as
                *const std::os::raw::c_char, progName.as_mut_ptr());
    inFile=
        fopen(inFileName.as_mut_ptr(),
              b"rb\x00" as *const u8 as *const std::os::raw::c_char);
    if inFile.is_null() {();
        fprintf(__stderrp,
                b"%s: can\'t open `%s\'\n\x00" as *const u8 as
                    *const std::os::raw::c_char, progName.as_mut_ptr(),
                inFileName.as_mut_ptr());
        exit(1 as std::os::raw::c_int);
    }
    bsIn= bsOpenReadStream(inFile);
    /*-- placate gcc's dataflow analyser --*/
    blockCRC= 0 as std::os::raw::c_int as UInt32;
    bsWr= 0 as *mut BitStream;
    bitsRead= 0 as std::os::raw::c_int as MaybeUInt64;
    outFile= 0 as *mut FILE;
    wrBlock= 0 as std::os::raw::c_int;
    while 1 as std::os::raw::c_int as Bool != 0 {
        b= bsGetBit(bsIn.as_mut());
        if b == 2 as std::os::raw::c_int { break ; }
        buffHi= buffHi << 1 as std::os::raw::c_int | buffLo >> 31 as std::os::raw::c_int;
        buffLo=
            buffLo << 1 as std::os::raw::c_int |
                (b & 1 as std::os::raw::c_int) as std::os::raw::c_uint;
        if bitsRead ==
               (47 as std::os::raw::c_int as
                    std::os::raw::c_ulonglong).wrapping_add(rbStart[wrBlock as usize])
           {
            blockCRC=
                buffHi << 16 as std::os::raw::c_int | buffLo >> 16 as std::os::raw::c_int
        }
        if !outFile.is_null() && bitsRead >= rbStart[wrBlock as usize] &&
               bitsRead <= rbEnd[wrBlock as usize] {
            bsPutBit(bsWr.as_mut(), b);
        }
        bitsRead= bitsRead.wrapping_add(1);
        if bitsRead ==
               rbEnd[wrBlock as
                         usize].wrapping_add(1 as std::os::raw::c_int as
                                                 std::os::raw::c_ulonglong) {
            if !outFile.is_null() {
                bsPutUChar(bsWr.as_mut(), 0x17 as std::os::raw::c_int as UChar);
                bsPutUChar(bsWr.as_mut(), 0x72 as std::os::raw::c_int as UChar);
                bsPutUChar(bsWr.as_mut(), 0x45 as std::os::raw::c_int as UChar);
                bsPutUChar(bsWr.as_mut(), 0x38 as std::os::raw::c_int as UChar);
                bsPutUChar(bsWr.as_mut(), 0x50 as std::os::raw::c_int as UChar);
                bsPutUChar(bsWr.as_mut(), 0x90 as std::os::raw::c_int as UChar);
                bsPutUInt32(bsWr.as_mut(), blockCRC);
                bsClose(Some(Box::from_raw(bsWr)));
                outFile= 0 as *mut FILE
            }else { (); }
            if wrBlock >= rbCtr { break ; }
            wrBlock+= 1
        } else if bitsRead == rbStart[wrBlock as usize] {
            /* Create the output file name, correctly handling leading paths. 
            (31.10.2001 by Sergey E. Kusikov) */
            let mut split: *mut Char = 0 as *mut Char;
            let mut ofs: Int32 = 0;
            let mut k: Int32 = 0;
            k= 0 as std::os::raw::c_int;
            while k < 2000 as std::os::raw::c_int {
                outFileName[k as usize] = 0 as std::os::raw::c_int as Char;
                k+= 1
            }
            strcpy(outFileName.as_mut_ptr(), inFileName.as_mut_ptr());
            split= strrchr(outFileName.as_mut_ptr(), '/' as i32);
            if split.is_null() {();
                split= outFileName.as_mut_ptr()
            } else { split= split.offset(1) }
            /* Now split points to the start of the basename. */
            ofs=
                split.offset_from(outFileName.as_mut_ptr()) as
                    std::os::raw::c_long as Int32;
            sprintf(split, b"rec%5d\x00" as *const u8 as *const std::os::raw::c_char,
                    wrBlock + 1 as std::os::raw::c_int);
            p= split;
            while (*p) as std::os::raw::c_int != 0 as std::os::raw::c_int {
                if (*p) as std::os::raw::c_int == ' ' as i32 { *p= '0' as i32 as Char }
                p= p.offset(1)
            }
            strcat(outFileName.as_mut_ptr(),
                   inFileName.as_mut_ptr().offset(ofs as isize));
            if endsInBz2(outFileName.as_mut_ptr()) == 0 {
                strcat(outFileName.as_mut_ptr(),
                       b".bz2\x00" as *const u8 as *const std::os::raw::c_char);
            }
            fprintf(__stderrp,
                    b"   writing block %d to `%s\' ...\n\x00" as *const u8 as
                        *const std::os::raw::c_char, wrBlock + 1 as std::os::raw::c_int,
                    outFileName.as_mut_ptr());
            outFile=
                fopen(outFileName.as_mut_ptr(),
                      b"wb\x00" as *const u8 as *const std::os::raw::c_char);
            if outFile.is_null() {();
                fprintf(__stderrp,
                        b"%s: can\'t write `%s\'\n\x00" as *const u8 as
                            *const std::os::raw::c_char, progName.as_mut_ptr(),
                        outFileName.as_mut_ptr());
                exit(1 as std::os::raw::c_int);
            }
            bsWr= bsOpenWriteStream(outFile);
            bsPutUChar(bsWr.as_mut(), 0x42 as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(), 0x5a as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(), 0x68 as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(),
                       (0x30 as std::os::raw::c_int + 9 as std::os::raw::c_int) as UChar);
            bsPutUChar(bsWr.as_mut(), 0x31 as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(), 0x41 as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(), 0x59 as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(), 0x26 as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(), 0x53 as std::os::raw::c_int as UChar);
            bsPutUChar(bsWr.as_mut(), 0x59 as std::os::raw::c_int as UChar);
        }
    }
    fprintf(__stderrp,
            b"%s: finished\n\x00" as *const u8 as *const std::os::raw::c_char,
            progName.as_mut_ptr());
    return 0 as std::os::raw::c_int;
}
// #[main]
// pub fn main() {
//     let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
//     for arg in ::std::env::args() {
//         args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
//     };
//     args.push(::std::ptr::null_mut());
//     unsafe {
//         ::std::process::exit(main_0((args.len() - 1) as Int32,
//                                     args.as_mut_ptr() as *mut *mut Char) as
//                                  i32)
//     }
// }
/*-----------------------------------------------------------*/
/*--- end                                  bzip2recover.c ---*/
/*-----------------------------------------------------------*/

extern "C" {
    
    
    
    #[no_mangle]
    static mut __stderrp: *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer0;
#[repr(C)]
pub struct __sbuf {
    pub _base: Option<Box<std::os::raw::c_uchar>>,
    pub _size: std::os::raw::c_int,
}
impl Default for __sbuf {fn default() -> Self {Self {
_base: None,
_size: Default::default(),
}}}
impl __sbuf {pub fn take(&mut self) -> Self {core::mem::take(self)}}

#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer1;
#[repr(C)]
pub struct __sFILE {
    pub _p: Option<Box<std::os::raw::c_uchar>>,
    pub _r: std::os::raw::c_int,
    pub _w: std::os::raw::c_int,
    pub _flags: std::os::raw::c_short,
    pub _file: std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: std::os::raw::c_int,
    pub _cookie: Option<Box<std::os::raw::c_void>>,
    pub _close: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                           -> std::os::raw::c_int>,
    pub _read: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                           _: *mut std::os::raw::c_char,
                                           _: std::os::raw::c_int) -> std::os::raw::c_int>,
    pub _seek: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: fpos_t,
                                           _: std::os::raw::c_int) -> fpos_t>,
    pub _write: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                            _: *const std::os::raw::c_char,
                                            _: std::os::raw::c_int) -> std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: Option<Box<crate::decompress::__sFILEX>>,
    pub _ur: std::os::raw::c_int,
    pub _ubuf: [std::os::raw::c_uchar; 3],
    pub _nbuf: [std::os::raw::c_uchar; 1],
    pub _lb: __sbuf,
    pub _blksize: std::os::raw::c_int,
    pub _offset: fpos_t,
}
impl Default for __sFILE {fn default() -> Self {Self {
_p: None,
_r: Default::default(),
_w: Default::default(),
_flags: Default::default(),
_file: Default::default(),
_bf: Default::default(),
_lbfsize: Default::default(),
_cookie: None,
_close: Default::default(),
_read: Default::default(),
_seek: Default::default(),
_write: Default::default(),
_ub: Default::default(),
_extra: None,
_ur: Default::default(),
_ubuf: Default::default(),
_nbuf: Default::default(),
_lb: Default::default(),
_blksize: Default::default(),
_offset: Default::default(),
}}}
impl __sFILE {pub fn take(&mut self) -> Self {core::mem::take(self)}}

pub type FILE = __sFILE;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bz_stream {
    pub next_in: *const std::os::raw::c_char,
    pub avail_in: std::os::raw::c_uint,
    pub total_in_lo32: std::os::raw::c_uint,
    pub total_in_hi32: std::os::raw::c_uint,
    pub next_out: *mut std::os::raw::c_char,
    pub avail_out: std::os::raw::c_uint,
    pub total_out_lo32: std::os::raw::c_uint,
    pub total_out_hi32: std::os::raw::c_uint,
    pub state: *mut std::os::raw::c_void,
    pub bzalloc: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                             _: std::os::raw::c_int, _: std::os::raw::c_int)
                            -> *mut std::os::raw::c_void>,
    pub bzfree: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                            _: *mut std::os::raw::c_void) -> ()>,
    pub opaque: *mut std::os::raw::c_void,
}
impl Default for bz_stream {fn default() -> Self {Self {
next_in: std::ptr::null_mut(),
avail_in: Default::default(),
total_in_lo32: Default::default(),
total_in_hi32: Default::default(),
next_out: std::ptr::null_mut(),
avail_out: Default::default(),
total_out_lo32: Default::default(),
total_out_hi32: Default::default(),
state: std::ptr::null_mut(),
bzalloc: Default::default(),
bzfree: Default::default(),
opaque: std::ptr::null_mut(),
}}}

pub type Bool = std::os::raw::c_uchar;
pub type UChar = std::os::raw::c_uchar;
pub type Int32 = std::os::raw::c_int;
pub type UInt32 = std::os::raw::c_uint;
pub type UInt16 = std::os::raw::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EState {
    pub strm: *mut bz_stream,
    pub mode: Int32,
    pub state: Int32,
    pub avail_in_expect: UInt32,
    pub arr1: *mut UInt32,
    pub arr2: *mut UInt32,
    pub ftab: *mut UInt32,
    pub origPtr: Int32,
    pub ptr: *mut UInt32,
    pub block: *mut UChar,
    pub mtfv: *mut UInt16,
    pub zbits: *mut UChar,
    pub workFactor: Int32,
    pub state_in_ch: UInt32,
    pub state_in_len: Int32,
    pub rNToGo: Int32,
    pub rTPos: Int32,
    pub nblock: Int32,
    pub nblockMAX: Int32,
    pub numZ: Int32,
    pub state_out_pos: Int32,
    pub nInUse: Int32,
    pub inUse: [Bool; 256],
    pub unseqToSeq: [UChar; 256],
    pub bsBuff: UInt32,
    pub bsLive: Int32,
    pub blockCRC: UInt32,
    pub combinedCRC: UInt32,
    pub verbosity: Int32,
    pub blockNo: Int32,
    pub blockSize100k: Int32,
    pub nMTF: Int32,
    pub mtfFreq: [Int32; 258],
    pub selector: [UChar; 18002],
    pub selectorMtf: [UChar; 18002],
    pub len: [[UChar; 258]; 6],
    pub code: [[Int32; 258]; 6],
    pub rfreq: [[Int32; 258]; 6],
    pub len_pack: [[UInt32; 4]; 258],
}
impl Default for EState {fn default() -> Self {Self {
strm: std::ptr::null_mut(),
mode: Default::default(),
state: Default::default(),
avail_in_expect: Default::default(),
arr1: std::ptr::null_mut(),
arr2: std::ptr::null_mut(),
ftab: std::ptr::null_mut(),
origPtr: Default::default(),
ptr: std::ptr::null_mut(),
block: std::ptr::null_mut(),
mtfv: std::ptr::null_mut(),
zbits: std::ptr::null_mut(),
workFactor: Default::default(),
state_in_ch: Default::default(),
state_in_len: Default::default(),
rNToGo: Default::default(),
rTPos: Default::default(),
nblock: Default::default(),
nblockMAX: Default::default(),
numZ: Default::default(),
state_out_pos: Default::default(),
nInUse: Default::default(),
inUse: Default::default(),
unseqToSeq: Default::default(),
bsBuff: Default::default(),
bsLive: Default::default(),
blockCRC: Default::default(),
combinedCRC: Default::default(),
verbosity: Default::default(),
blockNo: Default::default(),
blockSize100k: Default::default(),
nMTF: Default::default(),
mtfFreq: Default::default(),
selector: Default::default(),
selectorMtf: Default::default(),
len: Default::default(),
code: Default::default(),
rfreq: Default::default(),
len_pack: Default::default(),
}}}

/*-------------------------------------------------------------*/
/*--- Block sorting machinery                               ---*/
/*---                                           blocksort.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
   This file is part of bzip2/libbzip2, a program and library for
   lossless, block-sorting data compression.

   bzip2/libbzip2 version 1.0.8 of 13 July 2019
   Copyright (C) 1996-2019 Julian Seward <jseward@acm.org>

   Please read the WARNING, DISCLAIMER and PATENTS sections in the 
   README file.

   This program is released under the terms of the license contained
   in the file LICENSE.
   ------------------------------------------------------------------ */
/*---------------------------------------------*/
/*--- Fallback O(N log(N)^2) sorting        ---*/
/*--- algorithm, for repetitive blocks      ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
#[inline]
unsafe extern "C" fn fallbackSimpleSort(mut fmap: *mut UInt32,
                                        mut eclass: *const UInt32,
                                        mut lo: Int32, mut hi: Int32) {
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut tmp: Int32 = 0;
    let mut ec_tmp: UInt32 = 0;
    if lo == hi { return }
    if hi - lo > 3 as std::os::raw::c_int {
        i= hi - 4 as std::os::raw::c_int;
        while i >= lo {
            tmp= *fmap.offset(i as isize) as Int32;
            ec_tmp= *eclass.offset(tmp as isize);
            j= i + 4 as std::os::raw::c_int;
            while j <= hi &&
                      ec_tmp >
                          *eclass.offset(*fmap.offset(j as isize) as isize) {
                *fmap.offset((j - 4 as std::os::raw::c_int) as isize) =
                    *fmap.offset(j as isize);
                j+= 4 as std::os::raw::c_int
            }
            *fmap.offset((j - 4 as std::os::raw::c_int) as isize) = tmp as UInt32;
            i-= 1
        }
    }
    i= hi - 1 as std::os::raw::c_int;
    while i >= lo {
        tmp= *fmap.offset(i as isize) as Int32;
        ec_tmp= *eclass.offset(tmp as isize);
        j= i + 1 as std::os::raw::c_int;
        while j <= hi &&
                  ec_tmp > *eclass.offset(*fmap.offset(j as isize) as isize) {
            *fmap.offset((j - 1 as std::os::raw::c_int) as isize) =
                *fmap.offset(j as isize);
            j+= 1
        }
        *fmap.offset((j - 1 as std::os::raw::c_int) as isize) = tmp as UInt32;
        i-= 1
    };
}
unsafe extern "C" fn fallbackQSort3(mut fmap: *mut UInt32,
                                    mut eclass: *const UInt32, mut loSt: Int32,
                                    mut hiSt: Int32) {
    let mut unLo: Int32 = 0;
    let mut unHi: Int32 = 0;
    let mut ltLo: Int32 = 0;
    let mut gtHi: Int32 = 0;
    let mut n: Int32 = 0;
    let mut m: Int32 = 0;
    let mut sp: Int32 = 0;
    let mut lo: Int32 = 0;
    let mut hi: Int32 = 0;
    let mut med: UInt32 = 0;
    let mut r: UInt32 = 0;
    let mut r3: UInt32 = 0;
    let mut stackLo: [Int32; 100] = [0; 100];
    let mut stackHi: [Int32; 100] = [0; 100];
    r= 0 as std::os::raw::c_int as UInt32;
    sp= 0 as std::os::raw::c_int;
    stackLo[sp as usize] = loSt;
    stackHi[sp as usize] = hiSt;
    sp+= 1;
    while sp > 0 as std::os::raw::c_int {
        if !(sp < 100 as std::os::raw::c_int - 1 as std::os::raw::c_int) {
            crate::bzlib::BZ2_bz__AssertH__fail(1004 as std::os::raw::c_int);
        }
        sp-= 1;
        lo= stackLo[sp as usize];
        hi= stackHi[sp as usize];
        if hi - lo < 10 as std::os::raw::c_int {
            fallbackSimpleSort(fmap, eclass, lo, hi);
        } else {
            /* Random partitioning.  Median of 3 sometimes fails to
         avoid bad cases.  Median of 9 seems to help but 
         looks rather expensive.  This too seems to work but
         is cheaper.  Guidance for the magic constants 
         7621 and 32768 is taken from Sedgewick's algorithms
         book, chapter 35.
      */
            r=
                r.wrapping_mul(7621 as std::os::raw::c_int as
                                   std::os::raw::c_uint).wrapping_add(1 as std::os::raw::c_int
                                                                  as
                                                                  std::os::raw::c_uint).wrapping_rem(32768
                                                                                                 as
                                                                                                 std::os::raw::c_int
                                                                                                 as
                                                                                                 std::os::raw::c_uint);
            r3= r.wrapping_rem(3 as std::os::raw::c_int as std::os::raw::c_uint);
            if r3 == 0 as std::os::raw::c_int as std::os::raw::c_uint {
                med= *eclass.offset(*fmap.offset(lo as isize) as isize)
            } else if r3 == 1 as std::os::raw::c_int as std::os::raw::c_uint {
                med=
                    *eclass.offset(*fmap.offset((lo + hi >> 1 as std::os::raw::c_int)
                                                    as isize) as isize)
            } else {
                med= *eclass.offset(*fmap.offset(hi as isize) as isize)
            }
            ltLo= lo;
            unLo= ltLo;
            gtHi= hi;
            unHi= gtHi;
            loop  {
                while !(unLo > unHi) {
                    n=
                        *eclass.offset(*fmap.offset(unLo as isize) as isize)
                            as Int32 - med as Int32;
                    if n == 0 as std::os::raw::c_int {
                        let mut zztmp: Int32 =
                            *fmap.offset(unLo as isize) as Int32;
                        *fmap.offset(unLo as isize) =
                            *fmap.offset(ltLo as isize);
                        *fmap.offset(ltLo as isize) = zztmp as UInt32;
                        ltLo+= 1;
                        unLo+= 1
                    } else { if n > 0 as std::os::raw::c_int { break ; } unLo+= 1 }
                }
                while !(unLo > unHi) {
                    n=
                        *eclass.offset(*fmap.offset(unHi as isize) as isize)
                            as Int32 - med as Int32;
                    if n == 0 as std::os::raw::c_int {
                        let mut zztmp_0: Int32 =
                            *fmap.offset(unHi as isize) as Int32;
                        *fmap.offset(unHi as isize) =
                            *fmap.offset(gtHi as isize);
                        *fmap.offset(gtHi as isize) = zztmp_0 as UInt32;
                        gtHi-= 1;
                        unHi-= 1
                    } else { if n < 0 as std::os::raw::c_int { break ; } unHi-= 1 }
                }
                if unLo > unHi { break ; }
                let mut zztmp_1: Int32 = *fmap.offset(unLo as isize) as Int32;
                *fmap.offset(unLo as isize) = *fmap.offset(unHi as isize);
                *fmap.offset(unHi as isize) = zztmp_1 as UInt32;
                unLo+= 1;
                unHi-= 1
            }
            if gtHi < ltLo { continue ; }
            n=
                if ltLo - lo < unLo - ltLo {
                    (ltLo) - lo
                } else { (unLo) - ltLo };
            let mut yyp1: Int32 = lo;
            let mut yyp2: Int32 = unLo - n;
            let mut yyn: Int32 = n;
            while yyn > 0 as std::os::raw::c_int {
                let mut zztmp_2: Int32 = *fmap.offset(yyp1 as isize) as Int32;
                *fmap.offset(yyp1 as isize) = *fmap.offset(yyp2 as isize);
                *fmap.offset(yyp2 as isize) = zztmp_2 as UInt32;
                yyp1+= 1;
                yyp2+= 1;
                yyn-= 1
            }
            m=
                if hi - gtHi < gtHi - unHi {
                    (hi) - gtHi
                } else { (gtHi) - unHi };
            let mut yyp1_0: Int32 = unLo;
            let mut yyp2_0: Int32 = hi - m + 1 as std::os::raw::c_int;
            let mut yyn_0: Int32 = m;
            while yyn_0 > 0 as std::os::raw::c_int {
                let mut zztmp_3: Int32 =
                    *fmap.offset(yyp1_0 as isize) as Int32;
                *fmap.offset(yyp1_0 as isize) = *fmap.offset(yyp2_0 as isize);
                *fmap.offset(yyp2_0 as isize) = zztmp_3 as UInt32;
                yyp1_0+= 1;
                yyp2_0+= 1;
                yyn_0-= 1
            }
            n= lo + unLo - ltLo - 1 as std::os::raw::c_int;
            m= hi - (gtHi - unHi) + 1 as std::os::raw::c_int;
            if n - lo > hi - m {
                stackLo[sp as usize] = lo;
                stackHi[sp as usize] = n;
                sp+= 1;
                stackLo[sp as usize] = m;
                stackHi[sp as usize] = hi;
                sp+= 1
            } else {
                stackLo[sp as usize] = m;
                stackHi[sp as usize] = hi;
                sp+= 1;
                stackLo[sp as usize] = lo;
                stackHi[sp as usize] = n;
                sp+= 1
            }
        }
    };
}
unsafe extern "C" fn fallbackSort(mut fmap: *mut UInt32,
                                  mut eclass: *mut UInt32,
                                  mut bhtab: *mut UInt32, mut nblock: Int32,
                                  mut verb: Int32) {
    let mut ftab: [Int32; 257] = [0; 257];
    let mut ftabCopy: [Int32; 256] = [0; 256];
    let mut H: Int32 = 0;
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut k: Int32 = 0;
    let mut l: Int32 = 0;
    let mut r: Int32 = 0;
    let mut cc: Int32 = 0;
    let mut cc1: Int32 = 0;
    let mut nNotDone: Int32 = 0;
    let mut nBhtab: Int32 = 0;
    let mut eclass8: *mut UChar = eclass as *mut UChar;
    /*--
      Initial 1-char radix sort to generate
      initial fmap and initial BH bits.
   --*/
    if verb >= 4 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"        bucket sorting ...\n\x00" as *const u8 as
                    *const std::os::raw::c_char);
    }
    i= 0 as std::os::raw::c_int;
    while i < 257 as std::os::raw::c_int {
        ftab[i as usize] = 0 as std::os::raw::c_int;
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < nblock {
        ftab[*eclass8.offset(i as isize) as usize] += 1;
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < 256 as std::os::raw::c_int {
        ftabCopy[i as usize] = ftab[i as usize];
        i+= 1
    }
    i= 1 as std::os::raw::c_int;
    while i < 257 as std::os::raw::c_int {
        ftab[i as usize] += ftab[(i - 1 as std::os::raw::c_int) as usize];
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < nblock {
        j= *eclass8.offset(i as isize) as Int32;
        k= ftab[j as usize] - 1 as std::os::raw::c_int;
        ftab[j as usize] = k;
        *fmap.offset(k as isize) = i as UInt32;
        i+= 1
    }
    nBhtab= 2 as std::os::raw::c_int + nblock / 32 as std::os::raw::c_int;
    i= 0 as std::os::raw::c_int;
    while i < nBhtab {
        *bhtab.offset(i as isize) = 0 as std::os::raw::c_int as UInt32;
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < 256 as std::os::raw::c_int {
        *bhtab.offset((ftab[i as usize] >> 5 as std::os::raw::c_int) as isize) = (1 as std::os::raw::c_int as UInt32) <<
                (ftab[i as usize] & 31 as std::os::raw::c_int);
        i+= 1
    }
    /*--
      Inductively refine the buckets.  Kind-of an
      "exponential radix sort" (!), inspired by the
      Manber-Myers suffix array construction algorithm.
   --*/
    /*-- set sentinel bits for block-end detection --*/
    i= 0 as std::os::raw::c_int;
    while i < 32 as std::os::raw::c_int {
        *bhtab.offset((nblock + 2 as std::os::raw::c_int * i >> 5 as std::os::raw::c_int)
                              as isize) = (1 as std::os::raw::c_int as UInt32) <<
                (nblock + 2 as std::os::raw::c_int * i & 31 as std::os::raw::c_int);
        *bhtab.offset((nblock + 2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int >>
                               5 as std::os::raw::c_int) as isize) &= !((1 as std::os::raw::c_int as UInt32) <<
                  (nblock + 2 as std::os::raw::c_int * i + 1 as std::os::raw::c_int &
                       31 as std::os::raw::c_int));
        i+= 1
    }
    /*-- the log(N) loop --*/
    H= 1 as std::os::raw::c_int;
    loop  {
        if verb >= 4 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"        depth %6d has \x00" as *const u8 as
                        *const std::os::raw::c_char, H);
        }
        j= 0 as std::os::raw::c_int;
        i= 0 as std::os::raw::c_int;
        while i < nblock {
            if *bhtab.offset((i >> 5 as std::os::raw::c_int) as isize) &
                   (1 as std::os::raw::c_int as UInt32) << (i & 31 as std::os::raw::c_int) !=
                   0 {
                j= i
            }
            k=
                (*fmap.offset(i as isize)).wrapping_sub(H as std::os::raw::c_uint) as
                    Int32;
            if k < 0 as std::os::raw::c_int { k+= nblock }
            *eclass.offset(k as isize) = j as UInt32;
            i+= 1
        }
        nNotDone= 0 as std::os::raw::c_int;
        r= -(1 as std::os::raw::c_int);
        loop  {
            /*-- find the next non-singleton bucket --*/
            k= r + 1 as std::os::raw::c_int;
            while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &
                      (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int)
                      != 0 && k & 0x1f as std::os::raw::c_int != 0 {
                k+= 1
            }
            if *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &
                   (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int) !=
                   0 {
                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) ==
                          0xffffffff as std::os::raw::c_uint {
                    k+= 32 as std::os::raw::c_int
                }
                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &
                          (1 as std::os::raw::c_int as UInt32) <<
                              (k & 31 as std::os::raw::c_int) != 0 {
                    k+= 1
                }
            }
            l= k - 1 as std::os::raw::c_int;
            if l >= nblock { break ; }
            while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &
                      (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int)
                      == 0 && k & 0x1f as std::os::raw::c_int != 0 {
                k+= 1
            }
            if *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &
                   (1 as std::os::raw::c_int as UInt32) << (k & 31 as std::os::raw::c_int) ==
                   0 {
                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) ==
                          0 as std::os::raw::c_int as std::os::raw::c_uint {
                    k+= 32 as std::os::raw::c_int
                }
                while *bhtab.offset((k >> 5 as std::os::raw::c_int) as isize) &
                          (1 as std::os::raw::c_int as UInt32) <<
                              (k & 31 as std::os::raw::c_int) == 0 {
                    k+= 1
                }
            }
            r= k - 1 as std::os::raw::c_int;
            if r >= nblock { break ; }
            /*-- now [l, r] bracket current bucket --*/
            if r > l {
                nNotDone+= r - l + 1 as std::os::raw::c_int;
                fallbackQSort3(fmap, eclass, l, r);
                /*-- scan bucket and generate header bits-- */
                cc= -(1 as std::os::raw::c_int);
                i= l;
                while i <= r {
                    cc1=
                        *eclass.offset(*fmap.offset(i as isize) as isize) as
                            Int32;
                    if cc != cc1 {
                        *bhtab.offset((i >> 5 as std::os::raw::c_int) as isize) = (1 as std::os::raw::c_int as UInt32) <<
                                (i & 31 as std::os::raw::c_int);
                        cc= cc1
                    }
                    i+= 1
                }
            }
        }
        if verb >= 4 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"%6d unresolved strings\n\x00" as *const u8 as
                        *const std::os::raw::c_char, nNotDone);
        }
        H*= 2 as std::os::raw::c_int;
        if H > nblock || nNotDone == 0 as std::os::raw::c_int { break ; }
    }
    /*-- 
      Reconstruct the original block in
      eclass8 [0 .. nblock-1], since the
      previous phase destroyed it.
   --*/
    if verb >= 4 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"        reconstructing block ...\n\x00" as *const u8 as
                    *const std::os::raw::c_char);
    }
    j= 0 as std::os::raw::c_int;
    i= 0 as std::os::raw::c_int;
    while i < nblock {
        while ftabCopy[j as usize] == 0 as std::os::raw::c_int { j+= 1 }
        ftabCopy[j as usize] -= 1;
        *eclass8.offset(*fmap.offset(i as isize) as isize) = j as UChar;
        i+= 1
    }
    if !(j < 256 as std::os::raw::c_int) {
        crate::bzlib::BZ2_bz__AssertH__fail(1005 as std::os::raw::c_int);
    };
}
/*---------------------------------------------*/
/*--- The main, O(N^2 log(N)) sorting       ---*/
/*--- algorithm.  Faster for "normal"       ---*/
/*--- non-repetitive blocks.                ---*/
/*---------------------------------------------*/
/*---------------------------------------------*/
#[inline]
unsafe extern "C" fn mainGtU(mut i1: UInt32, mut i2: UInt32,
                             mut block: *const UChar, mut quadrant: *const UInt16,
                             mut nblock: UInt32, mut budget: Option<&mut Int32>)
 -> Bool {
    let mut k: Int32 = 0;
    let mut c1: UChar = 0;
    let mut c2: UChar = 0;
    let mut s1: UInt16 = 0;
    let mut s2: UInt16 = 0;
    /* 1 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 2 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 3 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 4 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 5 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 6 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 7 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 8 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 9 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 10 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 11 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    /* 12 */
    c1= *block.offset(i1 as isize);
    c2= *block.offset(i2 as isize);
    if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
        return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as Bool
    }
    i1= i1.wrapping_add(1);
    i2= i2.wrapping_add(1);
    k= nblock.wrapping_add(8 as std::os::raw::c_int as std::os::raw::c_uint) as Int32;
    loop  {
        /* 1 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        /* 2 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        /* 3 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        /* 4 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        /* 5 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        /* 6 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        /* 7 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        /* 8 */
        c1= *block.offset(i1 as isize);
        c2= *block.offset(i2 as isize);
        if c1 as std::os::raw::c_int != c2 as std::os::raw::c_int {
            return (c1 as std::os::raw::c_int > c2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        s1= *quadrant.offset(i1 as isize);
        s2= *quadrant.offset(i2 as isize);
        if s1 as std::os::raw::c_int != s2 as std::os::raw::c_int {
            return (s1 as std::os::raw::c_int > s2 as std::os::raw::c_int) as std::os::raw::c_int as
                       Bool
        }
        i1= i1.wrapping_add(1);
        i2= i2.wrapping_add(1);
        if i1 >= nblock {
            i1= (i1 as std::os::raw::c_uint).wrapping_sub(nblock) as UInt32 as UInt32
        }
        if i2 >= nblock {
            i2= (i2 as std::os::raw::c_uint).wrapping_sub(nblock) as UInt32 as UInt32
        }
        k-= 8 as std::os::raw::c_int;
        *budget.as_deref_mut().unwrap()-= 1;
        if !(k >= 0 as std::os::raw::c_int) { break ; }
    }
    return 0 as std::os::raw::c_int as Bool;
}
/*---------------------------------------------*/
/*--
   Knuth's increments seem to work better
   than Incerpi-Sedgewick here.  Possibly
   because the number of elems to sort is
   usually small, typically <= 20.
--*/
static mut incs: [Int32; 14] =
    [1 as std::os::raw::c_int, 4 as std::os::raw::c_int, 13 as std::os::raw::c_int, 40 as std::os::raw::c_int,
     121 as std::os::raw::c_int, 364 as std::os::raw::c_int, 1093 as std::os::raw::c_int,
     3280 as std::os::raw::c_int, 9841 as std::os::raw::c_int, 29524 as std::os::raw::c_int,
     88573 as std::os::raw::c_int, 265720 as std::os::raw::c_int, 797161 as std::os::raw::c_int,
     2391484 as std::os::raw::c_int];
unsafe extern "C" fn mainSimpleSort(mut ptr: *mut UInt32,
                                    mut block: *const UChar,
                                    mut quadrant: *const UInt16,
                                    mut nblock: Int32, mut lo: Int32,
                                    mut hi: Int32, mut d: Int32,
                                    mut budget: Option<&mut Int32>) {
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut h: Int32 = 0;
    let mut bigN: Int32 = 0;
    let mut hp: Int32 = 0;
    let mut v: UInt32 = 0;
    bigN= hi - lo + 1 as std::os::raw::c_int;
    if bigN < 2 as std::os::raw::c_int { return }
    hp= 0 as std::os::raw::c_int;
    while incs[hp as usize] < bigN { hp+= 1 }
    hp-= 1;
    while hp >= 0 as std::os::raw::c_int {
        h= incs[hp as usize];
        i= lo + h;
        while 1 as std::os::raw::c_int as Bool != 0 {
            /*-- copy 1 --*/
            if i > hi { break ; }
            v= *ptr.offset(i as isize);
            j= i;
            while mainGtU((*ptr.offset((j - h) as
                                           isize)).wrapping_add(d as
                                                                    std::os::raw::c_uint),
                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,
                          nblock as UInt32, budget.as_deref_mut()) != 0 {
                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);
                j= j - h;
                if j <= lo + h - 1 as std::os::raw::c_int { break ; }
            }
            *ptr.offset(j as isize) = v;
            i+= 1;
            /*-- copy 2 --*/
            if i > hi { break ; }
            v= *ptr.offset(i as isize);
            j= i;
            while mainGtU((*ptr.offset((j - h) as
                                           isize)).wrapping_add(d as
                                                                    std::os::raw::c_uint),
                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,
                          nblock as UInt32, budget.as_deref_mut()) != 0 {
                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);
                j= j - h;
                if j <= lo + h - 1 as std::os::raw::c_int { break ; }
            }
            *ptr.offset(j as isize) = v;
            i+= 1;
            /*-- copy 3 --*/
            if i > hi { break ; }
            v= *ptr.offset(i as isize);
            j= i;
            while mainGtU((*ptr.offset((j - h) as
                                           isize)).wrapping_add(d as
                                                                    std::os::raw::c_uint),
                          v.wrapping_add(d as std::os::raw::c_uint), block, quadrant,
                          nblock as UInt32, budget.as_deref_mut()) != 0 {
                *ptr.offset(j as isize) = *ptr.offset((j - h) as isize);
                j= j - h;
                if j <= lo + h - 1 as std::os::raw::c_int { break ; }
            }
            *ptr.offset(j as isize) = v;
            i+= 1;
            if (*budget.as_deref().unwrap()) < 0 as std::os::raw::c_int { return }
        }
        hp-= 1
    };
}
/*---------------------------------------------*/
/*--
   The following is an implementation of
   an elegant 3-way quicksort for strings,
   described in a paper "Fast Algorithms for
   Sorting and Searching Strings", by Robert
   Sedgewick and Jon L. Bentley.
--*/
#[inline]
unsafe extern "C" fn mmed3(mut a: UChar, mut b: UChar, mut c: UChar)
 -> UChar {
    let mut t: UChar = 0;
    if a as std::os::raw::c_int > b as std::os::raw::c_int { t= a; a= b; b= t }
    if b as std::os::raw::c_int > c as std::os::raw::c_int {
        b= c;
        if a as std::os::raw::c_int > b as std::os::raw::c_int { b= a }
    }
    return b;
}
unsafe extern "C" fn mainQSort3(mut ptr: *mut UInt32, mut block: *const UChar,
                                mut quadrant: *const UInt16, mut nblock: Int32,
                                mut loSt: Int32, mut hiSt: Int32,
                                mut dSt: Int32, mut budget: Option<&mut Int32>) {
    let mut unLo: Int32 = 0;
    let mut unHi: Int32 = 0;
    let mut ltLo: Int32 = 0;
    let mut gtHi: Int32 = 0;
    let mut n: Int32 = 0;
    let mut m: Int32 = 0;
    let mut med: Int32 = 0;
    let mut sp: Int32 = 0;
    let mut lo: Int32 = 0;
    let mut hi: Int32 = 0;
    let mut d: Int32 = 0;
    let mut stackLo: [Int32; 100] = [0; 100];
    let mut stackHi: [Int32; 100] = [0; 100];
    let mut stackD: [Int32; 100] = [0; 100];
    let mut nextLo: [Int32; 3] = [0; 3];
    let mut nextHi: [Int32; 3] = [0; 3];
    let mut nextD: [Int32; 3] = [0; 3];
    sp= 0 as std::os::raw::c_int;
    stackLo[sp as usize] = loSt;
    stackHi[sp as usize] = hiSt;
    stackD[sp as usize] = dSt;
    sp+= 1;
    while sp > 0 as std::os::raw::c_int {
        if !(sp < 100 as std::os::raw::c_int - 2 as std::os::raw::c_int) {
            crate::bzlib::BZ2_bz__AssertH__fail(1001 as std::os::raw::c_int);
        }
        sp-= 1;
        lo= stackLo[sp as usize];
        hi= stackHi[sp as usize];
        d= stackD[sp as usize];
        if hi - lo < 20 as std::os::raw::c_int ||
               d > 2 as std::os::raw::c_int + 12 as std::os::raw::c_int {
            mainSimpleSort(ptr, block, quadrant, nblock, lo, hi, d, budget.as_deref_mut());
            if (*budget.as_deref().unwrap()) < 0 as std::os::raw::c_int { return }
        } else {
            med=
                mmed3(*block.offset((*ptr.offset(lo as
                                                     isize)).wrapping_add(d as
                                                                              std::os::raw::c_uint)
                                        as isize),
                      *block.offset((*ptr.offset(hi as
                                                     isize)).wrapping_add(d as
                                                                              std::os::raw::c_uint)
                                        as isize),
                      *block.offset((*ptr.offset((lo + hi >> 1 as std::os::raw::c_int)
                                                     as
                                                     isize)).wrapping_add(d as
                                                                              std::os::raw::c_uint)
                                        as isize)) as Int32;
            ltLo= lo;
            unLo= ltLo;
            gtHi= hi;
            unHi= gtHi;
            while 1 as std::os::raw::c_int as Bool != 0 {
                while 1 as std::os::raw::c_int as Bool != 0 {
                    if unLo > unHi { break ; }
                    n=
                        *block.offset((*ptr.offset(unLo as
                                                       isize)).wrapping_add(d
                                                                                as
                                                                                std::os::raw::c_uint)
                                          as isize) as Int32 - med;
                    if n == 0 as std::os::raw::c_int {
                        let mut zztmp: Int32 =
                            *ptr.offset(unLo as isize) as Int32;
                        *ptr.offset(unLo as isize) =
                            *ptr.offset(ltLo as isize);
                        *ptr.offset(ltLo as isize) = zztmp as UInt32;
                        ltLo+= 1;
                        unLo+= 1
                    } else { if n > 0 as std::os::raw::c_int { break ; } unLo+= 1 }
                }
                while 1 as std::os::raw::c_int as Bool != 0 {
                    if unLo > unHi { break ; }
                    n=
                        *block.offset((*ptr.offset(unHi as
                                                       isize)).wrapping_add(d
                                                                                as
                                                                                std::os::raw::c_uint)
                                          as isize) as Int32 - med;
                    if n == 0 as std::os::raw::c_int {
                        let mut zztmp_0: Int32 =
                            *ptr.offset(unHi as isize) as Int32;
                        *ptr.offset(unHi as isize) =
                            *ptr.offset(gtHi as isize);
                        *ptr.offset(gtHi as isize) = zztmp_0 as UInt32;
                        gtHi-= 1;
                        unHi-= 1
                    } else { if n < 0 as std::os::raw::c_int { break ; } unHi-= 1 }
                }
                if unLo > unHi { break ; }
                let mut zztmp_1: Int32 = *ptr.offset(unLo as isize) as Int32;
                *ptr.offset(unLo as isize) = *ptr.offset(unHi as isize);
                *ptr.offset(unHi as isize) = zztmp_1 as UInt32;
                unLo+= 1;
                unHi-= 1
            }
            if gtHi < ltLo {
                stackLo[sp as usize] = lo;
                stackHi[sp as usize] = hi;
                stackD[sp as usize] = d + 1 as std::os::raw::c_int;
                sp+= 1
            } else {
                n=
                    if ltLo - lo < unLo - ltLo {
                        (ltLo) - lo
                    } else { (unLo) - ltLo };
                let mut yyp1: Int32 = lo;
                let mut yyp2: Int32 = unLo - n;
                let mut yyn: Int32 = n;
                while yyn > 0 as std::os::raw::c_int {
                    let mut zztmp_2: Int32 =
                        *ptr.offset(yyp1 as isize) as Int32;
                    *ptr.offset(yyp1 as isize) = *ptr.offset(yyp2 as isize);
                    *ptr.offset(yyp2 as isize) = zztmp_2 as UInt32;
                    yyp1+= 1;
                    yyp2+= 1;
                    yyn-= 1
                }
                m=
                    if hi - gtHi < gtHi - unHi {
                        (hi) - gtHi
                    } else { (gtHi) - unHi };
                let mut yyp1_0: Int32 = unLo;
                let mut yyp2_0: Int32 = hi - m + 1 as std::os::raw::c_int;
                let mut yyn_0: Int32 = m;
                while yyn_0 > 0 as std::os::raw::c_int {
                    let mut zztmp_3: Int32 =
                        *ptr.offset(yyp1_0 as isize) as Int32;
                    *ptr.offset(yyp1_0 as isize) =
                        *ptr.offset(yyp2_0 as isize);
                    *ptr.offset(yyp2_0 as isize) = zztmp_3 as UInt32;
                    yyp1_0+= 1;
                    yyp2_0+= 1;
                    yyn_0-= 1
                }
                n= lo + unLo - ltLo - 1 as std::os::raw::c_int;
                m= hi - (gtHi - unHi) + 1 as std::os::raw::c_int;
                nextLo[0 as std::os::raw::c_int as usize] = lo;
                nextHi[0 as std::os::raw::c_int as usize] = n;
                nextD[0 as std::os::raw::c_int as usize] = d;
                nextLo[1 as std::os::raw::c_int as usize] = m;
                nextHi[1 as std::os::raw::c_int as usize] = hi;
                nextD[1 as std::os::raw::c_int as usize] = d;
                nextLo[2 as std::os::raw::c_int as usize] = n + 1 as std::os::raw::c_int;
                nextHi[2 as std::os::raw::c_int as usize] = m - 1 as std::os::raw::c_int;
                nextD[2 as std::os::raw::c_int as usize] = d + 1 as std::os::raw::c_int;
                if nextHi[0 as std::os::raw::c_int as usize] -
                       nextLo[0 as std::os::raw::c_int as usize] <
                       nextHi[1 as std::os::raw::c_int as usize] -
                           nextLo[1 as std::os::raw::c_int as usize] {
                    let mut tz: Int32 = 0;
                    tz= nextLo[0 as std::os::raw::c_int as usize];
                    nextLo[0 as std::os::raw::c_int as usize] =
                        nextLo[1 as std::os::raw::c_int as usize];
                    nextLo[1 as std::os::raw::c_int as usize] = tz;
                    tz= nextHi[0 as std::os::raw::c_int as usize];
                    nextHi[0 as std::os::raw::c_int as usize] =
                        nextHi[1 as std::os::raw::c_int as usize];
                    nextHi[1 as std::os::raw::c_int as usize] = tz;
                    tz= nextD[0 as std::os::raw::c_int as usize];
                    nextD[0 as std::os::raw::c_int as usize] =
                        nextD[1 as std::os::raw::c_int as usize];
                    nextD[1 as std::os::raw::c_int as usize] = tz
                }
                if nextHi[1 as std::os::raw::c_int as usize] -
                       nextLo[1 as std::os::raw::c_int as usize] <
                       nextHi[2 as std::os::raw::c_int as usize] -
                           nextLo[2 as std::os::raw::c_int as usize] {
                    let mut tz_0: Int32 = 0;
                    tz_0= nextLo[1 as std::os::raw::c_int as usize];
                    nextLo[1 as std::os::raw::c_int as usize] =
                        nextLo[2 as std::os::raw::c_int as usize];
                    nextLo[2 as std::os::raw::c_int as usize] = tz_0;
                    tz_0= nextHi[1 as std::os::raw::c_int as usize];
                    nextHi[1 as std::os::raw::c_int as usize] =
                        nextHi[2 as std::os::raw::c_int as usize];
                    nextHi[2 as std::os::raw::c_int as usize] = tz_0;
                    tz_0= nextD[1 as std::os::raw::c_int as usize];
                    nextD[1 as std::os::raw::c_int as usize] =
                        nextD[2 as std::os::raw::c_int as usize];
                    nextD[2 as std::os::raw::c_int as usize] = tz_0
                }
                if nextHi[0 as std::os::raw::c_int as usize] -
                       nextLo[0 as std::os::raw::c_int as usize] <
                       nextHi[1 as std::os::raw::c_int as usize] -
                           nextLo[1 as std::os::raw::c_int as usize] {
                    let mut tz_1: Int32 = 0;
                    tz_1= nextLo[0 as std::os::raw::c_int as usize];
                    nextLo[0 as std::os::raw::c_int as usize] =
                        nextLo[1 as std::os::raw::c_int as usize];
                    nextLo[1 as std::os::raw::c_int as usize] = tz_1;
                    tz_1= nextHi[0 as std::os::raw::c_int as usize];
                    nextHi[0 as std::os::raw::c_int as usize] =
                        nextHi[1 as std::os::raw::c_int as usize];
                    nextHi[1 as std::os::raw::c_int as usize] = tz_1;
                    tz_1= nextD[0 as std::os::raw::c_int as usize];
                    nextD[0 as std::os::raw::c_int as usize] =
                        nextD[1 as std::os::raw::c_int as usize];
                    nextD[1 as std::os::raw::c_int as usize] = tz_1
                }
                stackLo[sp as usize] = nextLo[0 as std::os::raw::c_int as usize];
                stackHi[sp as usize] = nextHi[0 as std::os::raw::c_int as usize];
                stackD[sp as usize] = nextD[0 as std::os::raw::c_int as usize];
                sp+= 1;
                stackLo[sp as usize] = nextLo[1 as std::os::raw::c_int as usize];
                stackHi[sp as usize] = nextHi[1 as std::os::raw::c_int as usize];
                stackD[sp as usize] = nextD[1 as std::os::raw::c_int as usize];
                sp+= 1;
                stackLo[sp as usize] = nextLo[2 as std::os::raw::c_int as usize];
                stackHi[sp as usize] = nextHi[2 as std::os::raw::c_int as usize];
                stackD[sp as usize] = nextD[2 as std::os::raw::c_int as usize];
                sp+= 1
            }
        }
    };
}
unsafe extern "C" fn mainSort(mut ptr: *mut UInt32, mut block: *mut UChar,
                              mut quadrant: *mut UInt16,
                              mut ftab: *mut UInt32, mut nblock: Int32,
                              mut verb: Int32, mut budget: Option<&mut Int32>) {
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut k: Int32 = 0;
    let mut ss: Int32 = 0;
    let mut sb: Int32 = 0;
    let mut runningOrder: [Int32; 256] = [0; 256];
    let mut bigDone: [Bool; 256] = [0; 256];
    let mut copyStart: [Int32; 256] = [0; 256];
    let mut copyEnd: [Int32; 256] = [0; 256];
    let mut c1: UChar = 0;
    let mut numQSorted: Int32 = 0;
    let mut s: UInt16 = 0;
    if verb >= 4 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"        main sort initialise ...\n\x00" as *const u8 as
                    *const std::os::raw::c_char);
    }
    /*-- set up the 2-byte frequency table --*/
    i= 65536 as std::os::raw::c_int;
    while i >= 0 as std::os::raw::c_int {
        *ftab.offset(i as isize) = 0 as std::os::raw::c_int as UInt32;
        i-= 1
    }
    j=
        (*block.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int) <<
            8 as std::os::raw::c_int;
    i= nblock - 1 as std::os::raw::c_int;
    while i >= 3 as std::os::raw::c_int {
        *quadrant.offset(i as isize) = 0 as std::os::raw::c_int as UInt16;
        j=
            j >> 8 as std::os::raw::c_int |
                (*block.offset(i as isize) as UInt16 as std::os::raw::c_int) <<
                    8 as std::os::raw::c_int;
        *ftab.offset(j as isize) = (*ftab.offset(j as isize)).wrapping_add(1);
        *quadrant.offset((i - 1 as std::os::raw::c_int) as isize) =
            0 as std::os::raw::c_int as UInt16;
        j=
            j >> 8 as std::os::raw::c_int |
                (*block.offset((i - 1 as std::os::raw::c_int) as isize) as UInt16 as
                     std::os::raw::c_int) << 8 as std::os::raw::c_int;
        *ftab.offset(j as isize) = (*ftab.offset(j as isize)).wrapping_add(1);
        *quadrant.offset((i - 2 as std::os::raw::c_int) as isize) =
            0 as std::os::raw::c_int as UInt16;
        j=
            j >> 8 as std::os::raw::c_int |
                (*block.offset((i - 2 as std::os::raw::c_int) as isize) as UInt16 as
                     std::os::raw::c_int) << 8 as std::os::raw::c_int;
        *ftab.offset(j as isize) = (*ftab.offset(j as isize)).wrapping_add(1);
        *quadrant.offset((i - 3 as std::os::raw::c_int) as isize) =
            0 as std::os::raw::c_int as UInt16;
        j=
            j >> 8 as std::os::raw::c_int |
                (*block.offset((i - 3 as std::os::raw::c_int) as isize) as UInt16 as
                     std::os::raw::c_int) << 8 as std::os::raw::c_int;
        *ftab.offset(j as isize) = (*ftab.offset(j as isize)).wrapping_add(1);
        i-= 4 as std::os::raw::c_int
    }
    while i >= 0 as std::os::raw::c_int {
        *quadrant.offset(i as isize) = 0 as std::os::raw::c_int as UInt16;
        j=
            j >> 8 as std::os::raw::c_int |
                (*block.offset(i as isize) as UInt16 as std::os::raw::c_int) <<
                    8 as std::os::raw::c_int;
        *ftab.offset(j as isize) = (*ftab.offset(j as isize)).wrapping_add(1);
        i-= 1
    }
    /*-- (emphasises close relationship of block & quadrant) --*/
    i= 0 as std::os::raw::c_int;
    while i <
              2 as std::os::raw::c_int + 12 as std::os::raw::c_int + 18 as std::os::raw::c_int +
                  2 as std::os::raw::c_int {
        *block.offset((nblock + i) as isize) = *block.offset(i as isize);
        *quadrant.offset((nblock + i) as isize) = 0 as std::os::raw::c_int as UInt16;
        i+= 1
    }
    if verb >= 4 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"        bucket sorting ...\n\x00" as *const u8 as
                    *const std::os::raw::c_char);
    }
    /*-- Complete the initial radix sort --*/
    i= 1 as std::os::raw::c_int;
    while i <= 65536 as std::os::raw::c_int {
        *ftab.offset(i as isize) = (*ftab.offset(i as isize) as
                 std::os::raw::c_uint).wrapping_add(*ftab.offset((i -
                                                              1 as
                                                                  std::os::raw::c_int)
                                                             as isize)) as
                UInt32 as UInt32;
        i+= 1
    }
    s=
        ((*block.offset(0 as std::os::raw::c_int as isize) as std::os::raw::c_int) <<
             8 as std::os::raw::c_int) as UInt16;
    i= nblock - 1 as std::os::raw::c_int;
    while i >= 3 as std::os::raw::c_int {
        s=
            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |
                 (*block.offset(i as isize) as std::os::raw::c_int) <<
                     8 as std::os::raw::c_int) as UInt16;
        j=
            (*ftab.offset(s as
                              isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                       std::os::raw::c_uint) as Int32;
        *ftab.offset(s as isize) = j as UInt32;
        *ptr.offset(j as isize) = i as UInt32;
        s=
            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |
                 (*block.offset((i - 1 as std::os::raw::c_int) as isize) as
                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;
        j=
            (*ftab.offset(s as
                              isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                       std::os::raw::c_uint) as Int32;
        *ftab.offset(s as isize) = j as UInt32;
        *ptr.offset(j as isize) = (i - 1 as std::os::raw::c_int) as UInt32;
        s=
            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |
                 (*block.offset((i - 2 as std::os::raw::c_int) as isize) as
                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;
        j=
            (*ftab.offset(s as
                              isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                       std::os::raw::c_uint) as Int32;
        *ftab.offset(s as isize) = j as UInt32;
        *ptr.offset(j as isize) = (i - 2 as std::os::raw::c_int) as UInt32;
        s=
            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |
                 (*block.offset((i - 3 as std::os::raw::c_int) as isize) as
                      std::os::raw::c_int) << 8 as std::os::raw::c_int) as UInt16;
        j=
            (*ftab.offset(s as
                              isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                       std::os::raw::c_uint) as Int32;
        *ftab.offset(s as isize) = j as UInt32;
        *ptr.offset(j as isize) = (i - 3 as std::os::raw::c_int) as UInt32;
        i-= 4 as std::os::raw::c_int
    }
    while i >= 0 as std::os::raw::c_int {
        s=
            (s as std::os::raw::c_int >> 8 as std::os::raw::c_int |
                 (*block.offset(i as isize) as std::os::raw::c_int) <<
                     8 as std::os::raw::c_int) as UInt16;
        j=
            (*ftab.offset(s as
                              isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                       std::os::raw::c_uint) as Int32;
        *ftab.offset(s as isize) = j as UInt32;
        *ptr.offset(j as isize) = i as UInt32;
        i-= 1
    }
    /*--
      Now ftab contains the first loc of every small bucket.
      Calculate the running order, from smallest to largest
      big bucket.
   --*/
    i= 0 as std::os::raw::c_int;
    while i <= 255 as std::os::raw::c_int {
        bigDone[i as usize] = 0 as std::os::raw::c_int as Bool;
        runningOrder[i as usize] = i;
        i+= 1
    }
    let mut vv: Int32 = 0;
    let mut h: Int32 = 1 as std::os::raw::c_int;
    loop  {
        h= 3 as std::os::raw::c_int * h + 1 as std::os::raw::c_int;
        if !(h <= 256 as std::os::raw::c_int) { break ; }
    }
    loop  {
        h= h / 3 as std::os::raw::c_int;
        i= h;
        while i <= 255 as std::os::raw::c_int {
            vv= runningOrder[i as usize];
            j= i;
            while (*ftab.offset(((runningOrder[(j - h) as usize] +
                                      1 as std::os::raw::c_int) << 8 as std::os::raw::c_int)
                                    as
                                    isize)).wrapping_sub(*ftab.offset((runningOrder[(j
                                                                                         -
                                                                                         h)
                                                                                        as
                                                                                        usize]
                                                                           <<
                                                                           8
                                                                               as
                                                                               std::os::raw::c_int)
                                                                          as
                                                                          isize))
                      >
                      (*ftab.offset(((vv + 1 as std::os::raw::c_int) <<
                                         8 as std::os::raw::c_int) as
                                        isize)).wrapping_sub(*ftab.offset((vv
                                                                               <<
                                                                               8
                                                                                   as
                                                                                   std::os::raw::c_int)
                                                                              as
                                                                              isize))
                  {
                runningOrder[j as usize] = runningOrder[(j - h) as usize];
                j= j - h;
                if j <= h - 1 as std::os::raw::c_int { break ; }
            }
            runningOrder[j as usize] = vv;
            i+= 1
        }
        if !(h != 1 as std::os::raw::c_int) { break ; }
    }
    /*--
      The main sorting loop.
   --*/
    numQSorted= 0 as std::os::raw::c_int;
    i= 0 as std::os::raw::c_int;
    while i <= 255 as std::os::raw::c_int {
        /*--
         Process big buckets, starting with the least full.
         Basically this is a 3-step process in which we call
         mainQSort3 to sort the small buckets [ss, j], but
         also make a big effort to avoid the calls if we can.
      --*/
        ss= runningOrder[i as usize];
        /*--
         Step 1:
         Complete the big bucket [ss] by quicksorting
         any unsorted small buckets [ss, j], for j != ss.  
         Hopefully previous pointer-scanning phases have already
         completed many of the small buckets [ss, j], so
         we don't have to sort them at all.
      --*/
        j= 0 as std::os::raw::c_int;
        while j <= 255 as std::os::raw::c_int {
            if j != ss {
                sb= (ss << 8 as std::os::raw::c_int) + j;
                if *ftab.offset(sb as isize) &
                       ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                           std::os::raw::c_uint == 0 {
                    let mut lo: Int32 =
                        (*ftab.offset(sb as isize) &
                             !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                                 std::os::raw::c_uint) as Int32;
                    let mut hi: Int32 =
                        (*ftab.offset((sb + 1 as std::os::raw::c_int) as isize) &
                             !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                                 std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int
                                                                as
                                                                std::os::raw::c_uint)
                            as Int32;
                    if hi > lo {
                        if verb >= 4 as std::os::raw::c_int {
                            fprintf(__stderrp,
                                    b"        qsort [0x%x, 0x%x]   done %d   this %d\n\x00"
                                        as *const u8 as *const std::os::raw::c_char,
                                    ss, j, numQSorted,
                                    hi - lo + 1 as std::os::raw::c_int);
                        }
                        mainQSort3(ptr, block, quadrant, nblock, lo, hi,
                                   2 as std::os::raw::c_int, budget.as_deref_mut());
                        numQSorted+= hi - lo + 1 as std::os::raw::c_int;
                        if (*budget.as_deref().unwrap()) < 0 as std::os::raw::c_int { return }
                    }
                }
                *ftab.offset(sb as isize) = ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint
            }
            j+= 1
        }
        if bigDone[ss as usize] != 0 {
            crate::bzlib::BZ2_bz__AssertH__fail(1006 as std::os::raw::c_int);
        }
        /*--
         Step 2:
         Now scan this big bucket [ss] so as to synthesise the
         sorted order for small buckets [t, ss] for all t,
         including, magically, the bucket [ss,ss] too.
         This will avoid doing Real Work in subsequent Step 1's.
      --*/
        j= 0 as std::os::raw::c_int;
        while j <= 255 as std::os::raw::c_int {
            copyStart[j as usize] =
                (*ftab.offset(((j << 8 as std::os::raw::c_int) + ss) as isize) &
                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                         std::os::raw::c_uint) as Int32;
            copyEnd[j as usize] =
                (*ftab.offset(((j << 8 as std::os::raw::c_int) + ss +
                                   1 as std::os::raw::c_int) as isize) &
                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                         std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int as
                                                        std::os::raw::c_uint) as
                    Int32;
            j+= 1
        }
        j=
            (*ftab.offset((ss << 8 as std::os::raw::c_int) as isize) &
                 !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint)
                as Int32;
        while j < copyStart[ss as usize] {
            k=
                (*ptr.offset(j as
                                 isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                          std::os::raw::c_uint) as
                    Int32;
            if k < 0 as std::os::raw::c_int { k+= nblock }
            c1= *block.offset(k as isize);
            if bigDone[c1 as usize] == 0 {
                let fresh11 = copyStart[c1 as usize];
                copyStart[c1 as usize] = copyStart[c1 as usize] + 1;
                *ptr.offset(fresh11 as isize) = k as UInt32
            }
            j+= 1
        }
        j=
            (*ftab.offset(((ss + 1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) as
                              isize) &
                 !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                     std::os::raw::c_uint).wrapping_sub(1 as std::os::raw::c_int as
                                                    std::os::raw::c_uint) as Int32;
        while j > copyEnd[ss as usize] {
            k=
                (*ptr.offset(j as
                                 isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                          std::os::raw::c_uint) as
                    Int32;
            if k < 0 as std::os::raw::c_int { k+= nblock }
            c1= *block.offset(k as isize);
            if bigDone[c1 as usize] == 0 {
                let fresh12 = copyEnd[c1 as usize];
                copyEnd[c1 as usize] = copyEnd[c1 as usize] - 1;
                *ptr.offset(fresh12 as isize) = k as UInt32
            }
            j-= 1
        }
        if !(copyStart[ss as usize] - 1 as std::os::raw::c_int == copyEnd[ss as usize]
                 ||
                 copyStart[ss as usize] == 0 as std::os::raw::c_int &&
                     copyEnd[ss as usize] == nblock - 1 as std::os::raw::c_int) {
            crate::bzlib::BZ2_bz__AssertH__fail(1007 as std::os::raw::c_int);
        }
        j= 0 as std::os::raw::c_int;
        while j <= 255 as std::os::raw::c_int {
            *ftab.offset(((j << 8 as std::os::raw::c_int) + ss) as isize) = ((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as std::os::raw::c_uint;
            j+= 1
        }
        /*--
         Step 3:
         The [ss] big bucket is now done.  Record this fact,
         and update the quadrant descriptors.  Remember to
         update quadrants in the overshoot area too, if
         necessary.  The "if (i < 255)" test merely skips
         this updating for the last bucket processed, since
         updating for the last bucket is pointless.

         The quadrant array provides a way to incrementally
         cache sort orderings, as they appear, so as to 
         make subsequent comparisons in fullGtU() complete
         faster.  For repetitive blocks this makes a big
         difference (but not big enough to be able to avoid
         the fallback sorting mechanism, exponential radix sort).

         The precise meaning is: at all times:

            for 0 <= i < nblock and 0 <= j <= nblock

            if block[i] != block[j], 

               then the relative values of quadrant[i] and 
                    quadrant[j] are meaningless.

               else {
                  if quadrant[i] < quadrant[j]
                     then the string starting at i lexicographically
                     precedes the string starting at j

                  else if quadrant[i] > quadrant[j]
                     then the string starting at j lexicographically
                     precedes the string starting at i

                  else
                     the relative ordering of the strings starting
                     at i and j has not yet been determined.
               }
      --*/
        bigDone[ss as usize] = 1 as std::os::raw::c_int as Bool;
        if i < 255 as std::os::raw::c_int {
            let mut bbStart: Int32 =
                (*ftab.offset((ss << 8 as std::os::raw::c_int) as isize) &
                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                         std::os::raw::c_uint) as Int32;
            let mut bbSize: Int32 =
                (*ftab.offset(((ss + 1 as std::os::raw::c_int) << 8 as std::os::raw::c_int) as
                                  isize) &
                     !((1 as std::os::raw::c_int) << 21 as std::os::raw::c_int) as
                         std::os::raw::c_uint).wrapping_sub(bbStart as std::os::raw::c_uint)
                    as Int32;
            let mut shifts: Int32 = 0 as std::os::raw::c_int;
            while bbSize >> shifts > 65534 as std::os::raw::c_int { shifts+= 1 }
            j= bbSize - 1 as std::os::raw::c_int;
            while j >= 0 as std::os::raw::c_int {
                let mut a2update: Int32 =
                    *ptr.offset((bbStart + j) as isize) as Int32;
                let mut qVal: UInt16 = (j >> shifts) as UInt16;
                *quadrant.offset(a2update as isize) = qVal;
                if a2update <
                       2 as std::os::raw::c_int + 12 as std::os::raw::c_int +
                           18 as std::os::raw::c_int + 2 as std::os::raw::c_int {
                    *quadrant.offset((a2update + nblock) as isize) = qVal
                }
                j-= 1
            }
            if !(bbSize - 1 as std::os::raw::c_int >> shifts <= 65535 as std::os::raw::c_int)
               {
                crate::bzlib::BZ2_bz__AssertH__fail(1002 as std::os::raw::c_int);
            }
        }
        i+= 1
    }
    if verb >= 4 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"        %d pointers, %d sorted, %d scanned\n\x00" as
                    *const u8 as *const std::os::raw::c_char, nblock, numQSorted,
                nblock - numQSorted);
    };
}
/*---------------------------------------------*/
/* Pre:
      nblock > 0
      arr2 exists for [0 .. nblock-1 +N_OVERSHOOT]
      ((UChar*)arr2)  [0 .. nblock-1] holds block
      arr1 exists for [0 .. nblock-1]

   Post:
      ((UChar*)arr2) [0 .. nblock-1] holds block
      All other areas of block destroyed
      ftab [ 0 .. 65536 ] destroyed
      arr1 [0 .. nblock-1] holds sorted order
*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_blockSort(mut s: *mut EState) {
    let mut ptr: *mut UInt32 = (*s).ptr;
    let mut block: *mut UChar = (*s).block;
    let mut ftab: *mut UInt32 = (*s).ftab;
    let mut nblock: Int32 = (*s).nblock;
    let mut verb: Int32 = (*s).verbosity;
    let mut wfact: Int32 = (*s).workFactor;
    let mut quadrant: *mut UInt16 = 0 as *mut UInt16;
    let mut budget: Int32 = 0;
    let mut budgetInit: Int32 = 0;
    let mut i: Int32 = 0;
    if nblock < 10000 as std::os::raw::c_int {
        fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);
    } else {
        /* Calculate the location for quadrant, remembering to get
         the alignment right.  Assumes that &(block[0]) is at least
         2-byte aligned -- this should be ok since block is really
         the first section of arr2.
      */
        i=
            nblock +
                (2 as std::os::raw::c_int + 12 as std::os::raw::c_int + 18 as std::os::raw::c_int +
                     2 as std::os::raw::c_int);
        if i & 1 as std::os::raw::c_int != 0 { i+= 1 }
        quadrant=
            &mut *block.offset(i as isize) as *mut UChar as *mut UInt16;
        /* (wfact-1) / 3 puts the default-factor-30
         transition point at very roughly the same place as 
         with v0.1 and v0.9.0.  
         Not that it particularly matters any more, since the
         resulting compressed stream is now the same regardless
         of whether or not we use the main sort or fallback sort.
      */
        if wfact < 1 as std::os::raw::c_int { wfact= 1 as std::os::raw::c_int }
        if wfact > 100 as std::os::raw::c_int { wfact= 100 as std::os::raw::c_int }
        budgetInit= nblock * ((wfact - 1 as std::os::raw::c_int) / 3 as std::os::raw::c_int);
        budget= budgetInit;
        mainSort(ptr, block, quadrant, ftab, nblock, verb, &mut budget);
        if verb >= 3 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"      %d work, %d block, ratio %5.2f\n\x00" as *const u8
                        as *const std::os::raw::c_char, budgetInit - budget, nblock,
                    ((budgetInit - budget) as std::os::raw::c_float /
                         (if nblock == 0 as std::os::raw::c_int {
                              1 as std::os::raw::c_int
                          } else { nblock }) as std::os::raw::c_float) as
                        std::os::raw::c_double);
        }
        if budget < 0 as std::os::raw::c_int {
            if verb >= 2 as std::os::raw::c_int {
                fprintf(__stderrp,
                        b"    too repetitive; using fallback sorting algorithm\n\x00"
                            as *const u8 as *const std::os::raw::c_char);
            }
            fallbackSort((*s).arr1, (*s).arr2, ftab, nblock, verb);
        }
    }
    (*s).origPtr= -(1 as std::os::raw::c_int);
    i= 0 as std::os::raw::c_int;
    while i < (*s).nblock {
        if *ptr.offset(i as isize) == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            (*s).origPtr= i;
            break ;
        } else { i+= 1 }
    }
    if !((*s).origPtr != -(1 as std::os::raw::c_int)) {
        crate::bzlib::BZ2_bz__AssertH__fail(1003 as std::os::raw::c_int);
    };
}
/*-------------------------------------------------------------*/
/*--- end                                       blocksort.c ---*/
/*-------------------------------------------------------------*/

extern "C" {
    
    #[no_mangle]
    static mut __stdinp: *mut FILE;
    #[no_mangle]
    static mut __stdoutp: *mut FILE;
    #[no_mangle]
    static mut __stderrp: *mut FILE;
    #[no_mangle]
    fn fclose(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn ferror(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fflush(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fgetc(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fopen(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> *mut FILE;
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn fread(_: *mut std::os::raw::c_void, _: std::os::raw::c_ulong, _: std::os::raw::c_ulong,
             _: *mut FILE) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn fwrite(_: *const std::os::raw::c_void, _: std::os::raw::c_ulong, _: std::os::raw::c_ulong,
              _: *mut FILE) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn ungetc(_: std::os::raw::c_int, _: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn malloc(_: std::os::raw::c_ulong) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn free(_: *mut std::os::raw::c_void);
    #[no_mangle]
    fn exit(_: std::os::raw::c_int) -> !;
    #[no_mangle]
    fn fdopen(_: std::os::raw::c_int, _: *const std::os::raw::c_char) -> *mut FILE;
    #[no_mangle]
    static mut _DefaultRuneLocale: crate::bzip2::_RuneLocale;
    #[no_mangle]
    fn strcat(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn strcmp(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> std::os::raw::c_int;
    
    
    #[no_mangle]
    static mut BZ2_crc32Table: [UInt32; 256];
    
    
    #[no_mangle]
    static mut BZ2_rNums: [Int32; 512];
}
pub type __uint32_t = std::os::raw::c_uint;
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_ct_rune_t = std::os::raw::c_int;
pub type __darwin_size_t = std::os::raw::c_ulong;
pub type __darwin_wchar_t = std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor4;
impl Default for ErasedByPreprocessor4 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor5;
impl Default for ErasedByPreprocessor5 {fn default() -> Self {Self {
}}}

pub type FILE = crate::blocksort::__sFILE;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor6;
impl Default for ErasedByPreprocessor6 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor7;
impl Default for ErasedByPreprocessor7 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor8;
impl Default for ErasedByPreprocessor8 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor9;
impl Default for ErasedByPreprocessor9 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor10;
impl Default for ErasedByPreprocessor10 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor11;
impl Default for ErasedByPreprocessor11 {fn default() -> Self {Self {
}}}

pub type UInt32 = std::os::raw::c_uint;
pub type Int32 = std::os::raw::c_int;
pub type UChar = std::os::raw::c_uchar;
pub type Bool = std::os::raw::c_uchar;
pub type UInt16 = std::os::raw::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DState {
    pub strm: *mut crate::blocksort::bz_stream,
    pub state: Int32,
    pub state_out_ch: UChar,
    pub state_out_len: Int32,
    pub blockRandomised: Bool,
    pub rNToGo: Int32,
    pub rTPos: Int32,
    pub bsBuff: UInt32,
    pub bsLive: Int32,
    pub blockSize100k: Int32,
    pub smallDecompress: Bool,
    pub currBlockNo: Int32,
    pub verbosity: Int32,
    pub origPtr: Int32,
    pub tPos: UInt32,
    pub k0: Int32,
    pub unzftab: [Int32; 256],
    pub nblock_used: Int32,
    pub cftab: [Int32; 257],
    pub cftabCopy: [Int32; 257],
    pub tt: *mut UInt32,
    pub ll16: *mut UInt16,
    pub ll4: *mut UChar,
    pub storedBlockCRC: UInt32,
    pub storedCombinedCRC: UInt32,
    pub calculatedBlockCRC: UInt32,
    pub calculatedCombinedCRC: UInt32,
    pub nInUse: Int32,
    pub inUse: [Bool; 256],
    pub inUse16: [Bool; 16],
    pub seqToUnseq: [UChar; 256],
    pub mtfa: [UChar; 4096],
    pub mtfbase: [Int32; 16],
    pub selector: [UChar; 18002],
    pub selectorMtf: [UChar; 18002],
    pub len: [[UChar; 258]; 6],
    pub limit: [[Int32; 258]; 6],
    pub base: [[Int32; 258]; 6],
    pub perm: [[Int32; 258]; 6],
    pub minLens: [Int32; 6],
    pub save_i: Int32,
    pub save_j: Int32,
    pub save_t: Int32,
    pub save_alphaSize: Int32,
    pub save_nGroups: Int32,
    pub save_nSelectors: Int32,
    pub save_EOB: Int32,
    pub save_groupNo: Int32,
    pub save_groupPos: Int32,
    pub save_nextSym: Int32,
    pub save_nblockMAX: Int32,
    pub save_nblock: Int32,
    pub save_es: Int32,
    pub save_N: Int32,
    pub save_curr: Int32,
    pub save_zt: Int32,
    pub save_zn: Int32,
    pub save_zvec: Int32,
    pub save_zj: Int32,
    pub save_gSel: Int32,
    pub save_gMinlen: Int32,
    pub save_gLimit: *const Int32,
    pub save_gBase: *const Int32,
    pub save_gPerm: *const Int32,
}
impl Default for DState {fn default() -> Self {Self {
strm: std::ptr::null_mut(),
state: Default::default(),
state_out_ch: Default::default(),
state_out_len: Default::default(),
blockRandomised: Default::default(),
rNToGo: Default::default(),
rTPos: Default::default(),
bsBuff: Default::default(),
bsLive: Default::default(),
blockSize100k: Default::default(),
smallDecompress: Default::default(),
currBlockNo: Default::default(),
verbosity: Default::default(),
origPtr: Default::default(),
tPos: Default::default(),
k0: Default::default(),
unzftab: Default::default(),
nblock_used: Default::default(),
cftab: Default::default(),
cftabCopy: Default::default(),
tt: std::ptr::null_mut(),
ll16: std::ptr::null_mut(),
ll4: std::ptr::null_mut(),
storedBlockCRC: Default::default(),
storedCombinedCRC: Default::default(),
calculatedBlockCRC: Default::default(),
calculatedCombinedCRC: Default::default(),
nInUse: Default::default(),
inUse: Default::default(),
inUse16: Default::default(),
seqToUnseq: Default::default(),
mtfa: Default::default(),
mtfbase: Default::default(),
selector: Default::default(),
selectorMtf: Default::default(),
len: Default::default(),
limit: Default::default(),
base: Default::default(),
perm: Default::default(),
minLens: Default::default(),
save_i: Default::default(),
save_j: Default::default(),
save_t: Default::default(),
save_alphaSize: Default::default(),
save_nGroups: Default::default(),
save_nSelectors: Default::default(),
save_EOB: Default::default(),
save_groupNo: Default::default(),
save_groupPos: Default::default(),
save_nextSym: Default::default(),
save_nblockMAX: Default::default(),
save_nblock: Default::default(),
save_es: Default::default(),
save_N: Default::default(),
save_curr: Default::default(),
save_zt: Default::default(),
save_zn: Default::default(),
save_zvec: Default::default(),
save_zj: Default::default(),
save_gSel: Default::default(),
save_gMinlen: Default::default(),
save_gLimit: std::ptr::null_mut(),
save_gBase: std::ptr::null_mut(),
save_gPerm: std::ptr::null_mut(),
}}}

pub type BZFILE = ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bzFile {
    pub handle: *mut FILE,
    pub buf: [Char; 5000],
    pub bufN: Int32,
    pub writing: Bool,
    pub strm: crate::blocksort::bz_stream,
    pub lastErr: Int32,
    pub initialisedOk: Bool,
}
impl Default for bzFile {fn default() -> Self {Self {
handle: std::ptr::null_mut(),
buf: Default::default(),
bufN: Default::default(),
writing: Default::default(),
strm: Default::default(),
lastErr: Default::default(),
initialisedOk: Default::default(),
}}}

pub type Char = std::os::raw::c_char;
#[inline]
unsafe extern "C" fn __isctype(mut _c: __darwin_ct_rune_t,
                               mut _f: std::os::raw::c_ulong) -> __darwin_ct_rune_t {
    return if _c < 0 as std::os::raw::c_int ||
                  _c >= (1 as std::os::raw::c_int) << 8 as std::os::raw::c_int {
               0 as std::os::raw::c_int
           } else {
               (_DefaultRuneLocale.__runetype[_c as usize] as std::os::raw::c_ulong &
                    _f != 0) as std::os::raw::c_int
           };
}
#[no_mangle]
#[inline]
#[linkage = "external"]
pub unsafe extern "C" fn isdigit(mut _c: std::os::raw::c_int) -> std::os::raw::c_int {
    return __isctype(_c, 0x400 as std::os::raw::c_long as std::os::raw::c_ulong);
}
/*-------------------------------------------------------------*/
/*--- Library top-level functions.                          ---*/
/*---                                               bzlib.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
   This file is part of bzip2/libbzip2, a program and library for
   lossless, block-sorting data compression.

   bzip2/libbzip2 version 1.0.8 of 13 July 2019
   Copyright (C) 1996-2019 Julian Seward <jseward@acm.org>

   Please read the WARNING, DISCLAIMER and PATENTS sections in the 
   README file.

   This program is released under the terms of the license contained
   in the file LICENSE.
   ------------------------------------------------------------------ */
/* CHANGES
   0.9.0    -- original version.
   0.9.0a/b -- no changes in this file.
   0.9.0c   -- made zero-length BZ_FLUSH work correctly in bzCompress().
     fixed bzWrite/bzRead to ignore zero-length requests.
     fixed bzread to correctly handle read requests after EOF.
     wrong parameter order in call to bzDecompressInit in
     bzBuffToBuffDecompress.  Fixed.
*/
/*---------------------------------------------------*/
/*--- Compression stuff                           ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bz__AssertH__fail(mut errcode: std::os::raw::c_int) {
    fprintf(__stderrp,
            b"\n\nbzip2/libbzip2: internal error number %d.\nThis is a bug in bzip2/libbzip2, %s.\nPlease report it to: bzip2-devel@sourceware.org.  If this happened\nwhen you were using some program which uses libbzip2 as a\ncomponent, you should also report this bug to the author(s)\nof that program.  Please make an effort to report this bug;\ntimely and accurate bug reports eventually lead to higher\nquality software.  Thanks.\n\n\x00"
                as *const u8 as *const std::os::raw::c_char, errcode,
            BZ2_bzlibVersion());
    if errcode == 1007 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"\n*** A special note about internal error number 1007 ***\n\nExperience suggests that a common cause of i.e. 1007\nis unreliable memory or other hardware.  The 1007 assertion\njust happens to cross-check the results of huge numbers of\nmemory reads/writes, and so acts (unintendedly) as a stress\ntest of your memory system.\n\nI suggest the following: try compressing the file again,\npossibly monitoring progress in detail with the -vv flag.\n\n* If the error cannot be reproduced, and/or happens at different\n  points in compression, you may have a flaky memory system.\n  Try a memory-test program.  I have used Memtest86\n  (www.memtest86.com).  At the time of writing it is free (GPLd).\n  Memtest86 tests memory much more thorougly than your BIOSs\n  power-on test, and may find failures that the BIOS doesn\'t.\n\n* If the error can be repeatably reproduced, this is a bug in\n  bzip2, and I would very much like to hear about it.  Please\n  let me know, and, ideally, save a copy of the file causing the\n  problem -- without which I will be unable to investigate it.\n\n\x00"
                    as *const u8 as *const std::os::raw::c_char);
    }
    exit(3 as std::os::raw::c_int);
}
/*---------------------------------------------------*/
unsafe extern "C" fn bz_config_ok() -> std::os::raw::c_int {
    if ::std::mem::size_of::<std::os::raw::c_int>() as std::os::raw::c_ulong !=
           4 as std::os::raw::c_int as std::os::raw::c_ulong {
        return 0 as std::os::raw::c_int
    }
    if ::std::mem::size_of::<std::os::raw::c_short>() as std::os::raw::c_ulong !=
           2 as std::os::raw::c_int as std::os::raw::c_ulong {
        return 0 as std::os::raw::c_int
    }
    if ::std::mem::size_of::<std::os::raw::c_char>() as std::os::raw::c_ulong !=
           1 as std::os::raw::c_int as std::os::raw::c_ulong {
        return 0 as std::os::raw::c_int
    }
    return 1 as std::os::raw::c_int;
}
/*---------------------------------------------------*/
unsafe extern "C" fn default_bzalloc(mut opaque: *const std::os::raw::c_void,
                                     mut items: Int32, mut size: Int32)
 -> Option<Box<std::os::raw::c_void>> {
    let mut v: *mut std::os::raw::c_void = malloc((items * size) as std::os::raw::c_ulong);
    return v;
}
unsafe extern "C" fn default_bzfree(mut opaque: *const std::os::raw::c_void,
                                    mut addr: Option<Box<std::os::raw::c_void>>) {
    if !addr.as_deref().is_none() { (); }else { (); };
}
/*---------------------------------------------------*/
unsafe extern "C" fn prepare_new_block(mut s: Option<&mut crate::blocksort::EState>) {
    let mut i: Int32 = 0;
    (*s.as_deref_mut().unwrap()).nblock= 0 as std::os::raw::c_int;
    (*s.as_deref_mut().unwrap()).numZ= 0 as std::os::raw::c_int;
    (*s.as_deref_mut().unwrap()).state_out_pos= 0 as std::os::raw::c_int;
    (*s.as_deref_mut().unwrap()).blockCRC= 0xffffffff as std::os::raw::c_long as UInt32;
    i= 0 as std::os::raw::c_int;
    while i < 256 as std::os::raw::c_int {
        (*s.as_deref_mut().unwrap()).inUse[i as usize] = 0 as std::os::raw::c_int as Bool;
        i+= 1
    }
    (*s.as_deref_mut().unwrap()).blockNo+= 1;
}
/*---------------------------------------------------*/
unsafe extern "C" fn init_RL(mut s: Option<&mut crate::blocksort::EState>) {
    (*s.as_deref_mut().unwrap()).state_in_ch= 256 as std::os::raw::c_int as UInt32;
    (*s.as_deref_mut().unwrap()).state_in_len= 0 as std::os::raw::c_int;
}
unsafe extern "C" fn isempty_RL(mut s: *const crate::blocksort::EState) -> Bool {
    if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint &&
           (*s).state_in_len > 0 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int as Bool
    } else { return 1 as std::os::raw::c_int as Bool };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzCompressInit(mut strm: *mut crate::blocksort::bz_stream,
                                            mut blockSize100k: std::os::raw::c_int,
                                            mut verbosity: std::os::raw::c_int,
                                            mut workFactor: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut n: Int32 = 0;
    let mut s: *mut crate::blocksort::EState = 0 as *mut crate::blocksort::EState;
    if bz_config_ok() == 0 { return -(9 as std::os::raw::c_int) }
    if strm.is_null() || blockSize100k < 1 as std::os::raw::c_int ||
           blockSize100k > 9 as std::os::raw::c_int || workFactor < 0 as std::os::raw::c_int
           || workFactor > 250 as std::os::raw::c_int {
        return -(2 as std::os::raw::c_int)
    }
    if workFactor == 0 as std::os::raw::c_int { workFactor= 30 as std::os::raw::c_int }
    if (*strm).bzalloc.is_none() {
        (*strm).bzalloc=
            Some(default_bzalloc as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: Int32,
                                          _: Int32) -> *mut std::os::raw::c_void)
    }
    if (*strm).bzfree.is_none() {
        (*strm).bzfree=
            Some(default_bzfree as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *mut std::os::raw::c_void) -> ())
    }
    s=
        (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                            ::std::mem::size_of::<crate::blocksort::EState>()
                                                                as
                                                                std::os::raw::c_ulong
                                                                as
                                                                std::os::raw::c_int,
                                                            1 as std::os::raw::c_int)
            as *mut crate::blocksort::EState;
    if s.is_null() {(); return -(3 as std::os::raw::c_int) }
    (*s).strm= strm;
    (*s).arr1= 0 as *mut UInt32;
    (*s).arr2= 0 as *mut UInt32;
    (*s).ftab= 0 as *mut UInt32;
    n= 100000 as std::os::raw::c_int * blockSize100k;
    (*s).arr1=
        (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                            (n as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong)
                                                                as
                                                                std::os::raw::c_int,
                                                            1 as std::os::raw::c_int)
            as *mut UInt32;
    (*s).arr2=
        (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                            ((n +
                                                                  (2 as
                                                                       std::os::raw::c_int
                                                                       +
                                                                       12 as
                                                                           std::os::raw::c_int
                                                                       +
                                                                       18 as
                                                                           std::os::raw::c_int
                                                                       +
                                                                       2 as
                                                                           std::os::raw::c_int))
                                                                 as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong)
                                                                as
                                                                std::os::raw::c_int,
                                                            1 as std::os::raw::c_int)
            as *mut UInt32;
    (*s).ftab=
        (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                            (65537 as
                                                                 std::os::raw::c_int
                                                                 as
                                                                 std::os::raw::c_ulong).wrapping_mul(::std::mem::size_of::<UInt32>()
                                                                                                 as
                                                                                                 std::os::raw::c_ulong)
                                                                as
                                                                std::os::raw::c_int,
                                                            1 as std::os::raw::c_int)
            as *mut UInt32;
    if (*s).arr1.is_null() || (*s).arr2.is_null() || (*s).ftab.is_null() {
        if !(*s).arr1.is_null() {
            (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                               (*s).arr1 as
                                                                   *mut std::os::raw::c_void);
        }else { (); }
        if !(*s).arr2.is_null() {
            (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                               (*s).arr2 as
                                                                   *mut std::os::raw::c_void);
        }else { (); }
        if !(*s).ftab.is_null() {
            (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                               (*s).ftab as
                                                                   *mut std::os::raw::c_void);
        }else { (); }
        if !s.is_null() {
            (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                               s as
                                                                   *mut std::os::raw::c_void);
        }else { (); }
        return -(3 as std::os::raw::c_int)
    }
    (*s).blockNo= 0 as std::os::raw::c_int;
    (*s).state= 2 as std::os::raw::c_int;
    (*s).mode= 2 as std::os::raw::c_int;
    (*s).combinedCRC= 0 as std::os::raw::c_int as UInt32;
    (*s).blockSize100k= blockSize100k;
    (*s).nblockMAX=
        100000 as std::os::raw::c_int * blockSize100k - 19 as std::os::raw::c_int;
    (*s).verbosity= verbosity;
    (*s).workFactor= workFactor;
    (*s).block= (*s).arr2 as *mut UChar;
    (*s).mtfv= (*s).arr1 as *mut UInt16;
    (*s).zbits= 0 as *mut UChar;
    (*s).ptr= (*s).arr1;
    (*strm).state= s as *mut std::os::raw::c_void;
    (*strm).total_in_lo32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*strm).total_in_hi32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*strm).total_out_lo32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*strm).total_out_hi32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    init_RL(s.as_mut());
    prepare_new_block(s.as_mut());
    return 0 as std::os::raw::c_int;
}
/*---------------------------------------------------*/
unsafe extern "C" fn add_pair_to_block(mut s: *mut crate::blocksort::EState) {
    let mut i: Int32 = 0;
    let mut ch: UChar = (*s).state_in_ch as UChar;
    i= 0 as std::os::raw::c_int;
    while i < (*s).state_in_len {
        (*s).blockCRC=
            (*s).blockCRC << 8 as std::os::raw::c_int ^
                BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^
                                    ch as std::os::raw::c_uint) as usize];
        i+= 1
    }
    (*s).inUse[(*s).state_in_ch as usize] = 1 as std::os::raw::c_int as Bool;
    match (*s).state_in_len {
        1 => {
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1
        }
        2 => {
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1;
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1
        }
        3 => {
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1;
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1;
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1
        }
        _ => {
            (*s).inUse[((*s).state_in_len - 4 as std::os::raw::c_int) as usize] =
                1 as std::os::raw::c_int as Bool;
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1;
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1;
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1;
            *(*s).block.offset((*s).nblock as isize) = ch;
            (*s).nblock+= 1;
            *(*s).block.offset((*s).nblock as isize) =
                ((*s).state_in_len - 4 as std::os::raw::c_int) as UChar;
            (*s).nblock+= 1
        }
    };
}
/*---------------------------------------------------*/
unsafe extern "C" fn flush_RL(mut s: Option<&mut crate::blocksort::EState>) {
    if (*s.as_deref().unwrap()).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {
        add_pair_to_block(core::mem::transmute::<_, *mut crate::blocksort::EState>(s.as_deref_mut()));
    }
    init_RL(s.as_deref_mut());
}
/*---------------------------------------------------*/
/*-- fast track the common case --*/
/*-- general, uncommon cases --*/
/*---------------------------------------------------*/
unsafe extern "C" fn copy_input_until_stop(mut s: *mut crate::blocksort::EState) -> Bool {
    let mut progress_in: Bool = 0 as std::os::raw::c_int as Bool;
    if (*s).mode == 2 as std::os::raw::c_int {
        /*-- fast track the common case --*/
        while 1 as std::os::raw::c_int as Bool != 0 {
            /*-- block full? --*/
            if (*s).nblock >= (*s).nblockMAX { break ; }
            /*-- no input? --*/
            if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {
                break ;
            }
            progress_in= 1 as std::os::raw::c_int as Bool;
            let mut zchh: UInt32 =
                *((*(*s).strm).next_in as *mut UChar) as UInt32;
            if zchh != (*s).state_in_ch &&
                   (*s).state_in_len == 1 as std::os::raw::c_int {
                let mut ch: UChar = (*s).state_in_ch as UChar;
                (*s).blockCRC=
                    (*s).blockCRC << 8 as std::os::raw::c_int ^
                        BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^
                                            ch as std::os::raw::c_uint) as usize];
                (*s).inUse[(*s).state_in_ch as usize] =
                    1 as std::os::raw::c_int as Bool;
                *(*s).block.offset((*s).nblock as isize) = ch;
                (*s).nblock+= 1;
                (*s).state_in_ch= zchh
            } else if zchh != (*s).state_in_ch ||
                          (*s).state_in_len == 255 as std::os::raw::c_int {
                if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {
                    add_pair_to_block(s);
                }
                (*s).state_in_ch= zchh;
                (*s).state_in_len= 1 as std::os::raw::c_int
            } else { (*s).state_in_len+= 1 }
            (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
            (*(*s).strm).avail_in= (*(*s).strm).avail_in.wrapping_sub(1);
            (*(*s).strm).total_in_lo32=
                (*(*s).strm).total_in_lo32.wrapping_add(1);
            if (*(*s).strm).total_in_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint
               {
                (*(*s).strm).total_in_hi32=
                    (*(*s).strm).total_in_hi32.wrapping_add(1)
            }
        }
    } else {
        /*-- general, uncommon case --*/
        while 1 as std::os::raw::c_int as Bool != 0 {
            /*-- block full? --*/
            if (*s).nblock >= (*s).nblockMAX { break ; }
            /*-- no input? --*/
            if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {
                break ;
            }
            /*-- flush/finish end? --*/
            if (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint {
                break ;
            }
            progress_in= 1 as std::os::raw::c_int as Bool;
            let mut zchh_0: UInt32 =
                *((*(*s).strm).next_in as *mut UChar) as UInt32;
            if zchh_0 != (*s).state_in_ch &&
                   (*s).state_in_len == 1 as std::os::raw::c_int {
                let mut ch_0: UChar = (*s).state_in_ch as UChar;
                (*s).blockCRC=
                    (*s).blockCRC << 8 as std::os::raw::c_int ^
                        BZ2_crc32Table[((*s).blockCRC >> 24 as std::os::raw::c_int ^
                                            ch_0 as std::os::raw::c_uint) as usize];
                (*s).inUse[(*s).state_in_ch as usize] =
                    1 as std::os::raw::c_int as Bool;
                *(*s).block.offset((*s).nblock as isize) = ch_0;
                (*s).nblock+= 1;
                (*s).state_in_ch= zchh_0
            } else if zchh_0 != (*s).state_in_ch ||
                          (*s).state_in_len == 255 as std::os::raw::c_int {
                if (*s).state_in_ch < 256 as std::os::raw::c_int as std::os::raw::c_uint {
                    add_pair_to_block(s);
                }
                (*s).state_in_ch= zchh_0;
                (*s).state_in_len= 1 as std::os::raw::c_int
            } else { (*s).state_in_len+= 1 }
            (*(*s).strm).next_in= (*(*s).strm).next_in.offset(1);
            (*(*s).strm).avail_in= (*(*s).strm).avail_in.wrapping_sub(1);
            (*(*s).strm).total_in_lo32=
                (*(*s).strm).total_in_lo32.wrapping_add(1);
            if (*(*s).strm).total_in_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint
               {
                (*(*s).strm).total_in_hi32=
                    (*(*s).strm).total_in_hi32.wrapping_add(1)
            }
            (*s).avail_in_expect= (*s).avail_in_expect.wrapping_sub(1)
        }
    }
    return progress_in;
}
/*---------------------------------------------------*/
unsafe extern "C" fn copy_output_until_stop(mut s: *mut crate::blocksort::EState) -> Bool {
    let mut progress_out: Bool = 0 as std::os::raw::c_int as Bool;
    while 1 as std::os::raw::c_int as Bool != 0 {
        /*-- no output space? --*/
        if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            break ;
        }
        /*-- block done? --*/
        if (*s).state_out_pos >= (*s).numZ { break ; }
        progress_out= 1 as std::os::raw::c_int as Bool;
        *(*(*s).strm).next_out=
            *(*s).zbits.offset((*s).state_out_pos as isize) as std::os::raw::c_char;
        (*s).state_out_pos+= 1;
        (*(*s).strm).avail_out= (*(*s).strm).avail_out.wrapping_sub(1);
        (*(*s).strm).next_out= (*(*s).strm).next_out.offset(1);
        (*(*s).strm).total_out_lo32=
            (*(*s).strm).total_out_lo32.wrapping_add(1);
        if (*(*s).strm).total_out_lo32 == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            (*(*s).strm).total_out_hi32=
                (*(*s).strm).total_out_hi32.wrapping_add(1)
        }
    }
    return progress_out;
}
/*---------------------------------------------------*/
unsafe extern "C" fn handle_compress(mut strm: *mut crate::blocksort::bz_stream) -> Bool {
    let mut progress_in: Bool = 0 as std::os::raw::c_int as Bool;
    let mut progress_out: Bool = 0 as std::os::raw::c_int as Bool;
    let mut s: *mut crate::blocksort::EState = (*strm).state as *mut crate::blocksort::EState;
    while 1 as std::os::raw::c_int as Bool != 0 {
        if (*s).state == 1 as std::os::raw::c_int {
            progress_out=
                (progress_out as std::os::raw::c_int |
                     copy_output_until_stop(s) as std::os::raw::c_int) as Bool;
            if (*s).state_out_pos < (*s).numZ { break ; }
            if (*s).mode == 4 as std::os::raw::c_int &&
                   (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint &&
                   isempty_RL(s) as std::os::raw::c_int != 0 {
                break ;
            }
            prepare_new_block(s.as_mut());
            (*s).state= 2 as std::os::raw::c_int;
            if (*s).mode == 3 as std::os::raw::c_int &&
                   (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint &&
                   isempty_RL(s) as std::os::raw::c_int != 0 {
                break ;
            }
        }
        if !((*s).state == 2 as std::os::raw::c_int) { continue ; }
        progress_in=
            (progress_in as std::os::raw::c_int |
                 copy_input_until_stop(s) as std::os::raw::c_int) as Bool;
        if (*s).mode != 2 as std::os::raw::c_int &&
               (*s).avail_in_expect == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            flush_RL(s.as_mut());
            crate::compress::BZ2_compressBlock(s,
                              ((*s).mode == 4 as std::os::raw::c_int) as std::os::raw::c_int
                                  as Bool);
            (*s).state= 1 as std::os::raw::c_int
        } else if (*s).nblock >= (*s).nblockMAX {
            crate::compress::BZ2_compressBlock(s, 0 as std::os::raw::c_int as Bool);
            (*s).state= 1 as std::os::raw::c_int
        } else if (*(*s).strm).avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            break ;
        }
    }
    return (progress_in as std::os::raw::c_int != 0 ||
                progress_out as std::os::raw::c_int != 0) as std::os::raw::c_int as Bool;
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzCompress(mut strm: *mut crate::blocksort::bz_stream,
                                        mut action: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut progress: Bool = 0;
    let mut s: *mut crate::blocksort::EState = 0 as *mut crate::blocksort::EState;
    if strm.is_null() {(); return -(2 as std::os::raw::c_int) }
    s= (*strm).state as *mut crate::blocksort::EState;
    if s.is_null() {(); return -(2 as std::os::raw::c_int) }
    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }
    loop  {
        match (*s).mode {
            1 => { return -(1 as std::os::raw::c_int) }
            2 => {
                if action == 0 as std::os::raw::c_int {
                    progress= handle_compress(strm);
                    return if progress as std::os::raw::c_int != 0 {
                               1 as std::os::raw::c_int
                           } else { -(2 as std::os::raw::c_int) }
                } else if action == 1 as std::os::raw::c_int {
                    (*s).avail_in_expect= (*strm).avail_in;
                    (*s).mode= 3 as std::os::raw::c_int
                } else if action == 2 as std::os::raw::c_int {
                    (*s).avail_in_expect= (*strm).avail_in;
                    (*s).mode= 4 as std::os::raw::c_int
                } else { return -(2 as std::os::raw::c_int) }
            }
            3 => {
                if action != 1 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
                if (*s).avail_in_expect != (*(*s).strm).avail_in {
                    return -(1 as std::os::raw::c_int)
                }
                progress= handle_compress(strm);
                if (*s).avail_in_expect > 0 as std::os::raw::c_int as std::os::raw::c_uint ||
                       isempty_RL(s) == 0 || (*s).state_out_pos < (*s).numZ {
                    return 2 as std::os::raw::c_int
                }
                (*s).mode= 2 as std::os::raw::c_int;
                return 1 as std::os::raw::c_int
            }
            4 => {
                if action != 2 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
                if (*s).avail_in_expect != (*(*s).strm).avail_in {
                    return -(1 as std::os::raw::c_int)
                }
                progress= handle_compress(strm);
                if progress == 0 { return -(1 as std::os::raw::c_int) }
                if (*s).avail_in_expect > 0 as std::os::raw::c_int as std::os::raw::c_uint ||
                       isempty_RL(s) == 0 || (*s).state_out_pos < (*s).numZ {
                    return 3 as std::os::raw::c_int
                }
                (*s).mode= 1 as std::os::raw::c_int;
                return 4 as std::os::raw::c_int
            }
            _ => { return 0 as std::os::raw::c_int }
        }
    };
    /*--not reached--*/
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzCompressEnd(mut strm: *mut crate::blocksort::bz_stream)
 -> std::os::raw::c_int {
    let mut s: *mut crate::blocksort::EState = 0 as *mut crate::blocksort::EState;
    if strm.is_null() {(); return -(2 as std::os::raw::c_int) }
    s= (*strm).state as *mut crate::blocksort::EState;
    if s.is_null() {(); return -(2 as std::os::raw::c_int) }
    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }
    if !(*s).arr1.is_null() {
        (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                           (*s).arr1 as
                                                               *mut std::os::raw::c_void);
    }else { (); }
    if !(*s).arr2.is_null() {
        (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                           (*s).arr2 as
                                                               *mut std::os::raw::c_void);
    }else { (); }
    if !(*s).ftab.is_null() {
        (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                           (*s).ftab as
                                                               *mut std::os::raw::c_void);
    }else { (); }
    (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                       (*strm).state);
    (*strm).state= 0 as *mut std::os::raw::c_void;
    return 0 as std::os::raw::c_int;
}
/*---------------------------------------------------*/
/*--- Decompression stuff                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzDecompressInit(mut strm: *mut crate::blocksort::bz_stream,
                                              mut verbosity: std::os::raw::c_int,
                                              mut small: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut s: *mut DState = 0 as *mut DState;
    if bz_config_ok() == 0 { return -(9 as std::os::raw::c_int) }
    if strm.is_null() {(); return -(2 as std::os::raw::c_int) }
    if small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int {
        return -(2 as std::os::raw::c_int)
    }
    if verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int {
        return -(2 as std::os::raw::c_int)
    }
    if (*strm).bzalloc.is_none() {
        (*strm).bzalloc=
            Some(default_bzalloc as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: Int32,
                                          _: Int32) -> *mut std::os::raw::c_void)
    }
    if (*strm).bzfree.is_none() {
        (*strm).bzfree=
            Some(default_bzfree as
                     unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                          _: *mut std::os::raw::c_void) -> ())
    }
    s=
        (*strm).bzalloc.expect("non-null function pointer")((*strm).opaque,
                                                            ::std::mem::size_of::<DState>()
                                                                as
                                                                std::os::raw::c_ulong
                                                                as
                                                                std::os::raw::c_int,
                                                            1 as std::os::raw::c_int)
            as *mut DState;
    if s.is_null() {(); return -(3 as std::os::raw::c_int) }
    (*s).strm= strm;
    (*strm).state= s as *mut std::os::raw::c_void;
    (*s).state= 10 as std::os::raw::c_int;
    (*s).bsLive= 0 as std::os::raw::c_int;
    (*s).bsBuff= 0 as std::os::raw::c_int as UInt32;
    (*s).calculatedCombinedCRC= 0 as std::os::raw::c_int as UInt32;
    (*strm).total_in_lo32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*strm).total_in_hi32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*strm).total_out_lo32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*strm).total_out_hi32= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*s).smallDecompress= small as Bool;
    (*s).ll4= 0 as *mut UChar;
    (*s).ll16= 0 as *mut UInt16;
    (*s).tt= 0 as *mut UInt32;
    (*s).currBlockNo= 0 as std::os::raw::c_int;
    (*s).verbosity= verbosity;
    return 0 as std::os::raw::c_int;
}
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
   Returns False if there is no problem.
*/
unsafe extern "C" fn unRLE_obuf_to_output_FAST(mut s: *mut DState) -> Bool {
    let mut current_block: u64;
    let mut k1: UChar = 0;
    if (*s).blockRandomised != 0 {
        while 1 as std::os::raw::c_int as Bool != 0 {
            /* try to finish existing run */
            while 1 as std::os::raw::c_int as Bool != 0 {
                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint
                   {
                    return 0 as std::os::raw::c_int as Bool
                }
                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }
                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;
                (*s).calculatedBlockCRC=
                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^
                        BZ2_crc32Table[((*s).calculatedBlockCRC >>
                                            24 as std::os::raw::c_int ^
                                            (*s).state_out_ch as std::os::raw::c_uint)
                                           as usize];
                (*s).state_out_len-= 1;
                (*(*s).strm).next_out= (*(*s).strm).next_out.offset(1);
                (*(*s).strm).avail_out=
                    (*(*s).strm).avail_out.wrapping_sub(1);
                (*(*s).strm).total_out_lo32=
                    (*(*s).strm).total_out_lo32.wrapping_add(1);
                if (*(*s).strm).total_out_lo32 ==
                       0 as std::os::raw::c_int as std::os::raw::c_uint {
                    (*(*s).strm).total_out_hi32=
                        (*(*s).strm).total_out_hi32.wrapping_add(1)
                }
            }
            /* can a new run be started? */
            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                return 0 as std::os::raw::c_int as Bool
            }
            /* Only caused by corrupt data stream? */
            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {
                return 1 as std::os::raw::c_int as Bool
            }
            (*s).state_out_len= 1 as std::os::raw::c_int;
            (*s).state_out_ch= (*s).k0 as UChar;
            if (*s).tPos >=
                   (100000 as std::os::raw::c_int as
                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {
                return 1 as std::os::raw::c_int as Bool
            }
            (*s).tPos= *(*s).tt.offset((*s).tPos as isize);
            k1= ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as UChar;
            (*s).tPos>>= 8 as std::os::raw::c_int;
            if (*s).rNToGo == 0 as std::os::raw::c_int {
                (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                (*s).rTPos+= 1;
                if (*s).rTPos == 512 as std::os::raw::c_int {
                    (*s).rTPos= 0 as std::os::raw::c_int
                }
            }
            (*s).rNToGo-= 1;
            k1=
                (k1 as std::os::raw::c_int ^
                     if (*s).rNToGo == 1 as std::os::raw::c_int {
                         1 as std::os::raw::c_int
                     } else { 0 as std::os::raw::c_int }) as UChar;
            (*s).nblock_used+= 1;
            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                continue ;
            }
            if k1 as std::os::raw::c_int != (*s).k0 {
                (*s).k0= k1 as Int32
            } else {
                (*s).state_out_len= 2 as std::os::raw::c_int;
                if (*s).tPos >=
                       (100000 as std::os::raw::c_int as
                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)
                   {
                    return 1 as std::os::raw::c_int as Bool
                }
                (*s).tPos= *(*s).tt.offset((*s).tPos as isize);
                k1=
                    ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
                        UChar;
                (*s).tPos>>= 8 as std::os::raw::c_int;
                if (*s).rNToGo == 0 as std::os::raw::c_int {
                    (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                    (*s).rTPos+= 1;
                    if (*s).rTPos == 512 as std::os::raw::c_int {
                        (*s).rTPos= 0 as std::os::raw::c_int
                    }
                }
                (*s).rNToGo-= 1;
                k1=
                    (k1 as std::os::raw::c_int ^
                         if (*s).rNToGo == 1 as std::os::raw::c_int {
                             1 as std::os::raw::c_int
                         } else { 0 as std::os::raw::c_int }) as UChar;
                (*s).nblock_used+= 1;
                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                    continue ;
                }
                if k1 as std::os::raw::c_int != (*s).k0 {
                    (*s).k0= k1 as Int32
                } else {
                    (*s).state_out_len= 3 as std::os::raw::c_int;
                    if (*s).tPos >=
                           (100000 as std::os::raw::c_int as
                                UInt32).wrapping_mul((*s).blockSize100k as
                                                         UInt32) {
                        return 1 as std::os::raw::c_int as Bool
                    }
                    (*s).tPos= *(*s).tt.offset((*s).tPos as isize);
                    k1=
                        ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
                            UChar;
                    (*s).tPos>>= 8 as std::os::raw::c_int;
                    if (*s).rNToGo == 0 as std::os::raw::c_int {
                        (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                        (*s).rTPos+= 1;
                        if (*s).rTPos == 512 as std::os::raw::c_int {
                            (*s).rTPos= 0 as std::os::raw::c_int
                        }
                    }
                    (*s).rNToGo-= 1;
                    k1=
                        (k1 as std::os::raw::c_int ^
                             if (*s).rNToGo == 1 as std::os::raw::c_int {
                                 1 as std::os::raw::c_int
                             } else { 0 as std::os::raw::c_int }) as UChar;
                    (*s).nblock_used+= 1;
                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int
                       {
                        continue ;
                    }
                    if k1 as std::os::raw::c_int != (*s).k0 {
                        (*s).k0= k1 as Int32
                    } else {
                        if (*s).tPos >=
                               (100000 as std::os::raw::c_int as
                                    UInt32).wrapping_mul((*s).blockSize100k as
                                                             UInt32) {
                            return 1 as std::os::raw::c_int as Bool
                        }
                        (*s).tPos= *(*s).tt.offset((*s).tPos as isize);
                        k1=
                            ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)
                                as UChar;
                        (*s).tPos>>= 8 as std::os::raw::c_int;
                        if (*s).rNToGo == 0 as std::os::raw::c_int {
                            (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                            (*s).rTPos+= 1;
                            if (*s).rTPos == 512 as std::os::raw::c_int {
                                (*s).rTPos= 0 as std::os::raw::c_int
                            }
                        }
                        (*s).rNToGo-= 1;
                        k1=
                            (k1 as std::os::raw::c_int ^
                                 if (*s).rNToGo == 1 as std::os::raw::c_int {
                                     1 as std::os::raw::c_int
                                 } else { 0 as std::os::raw::c_int }) as UChar;
                        (*s).nblock_used+= 1;
                        (*s).state_out_len= k1 as Int32 + 4 as std::os::raw::c_int;
                        if (*s).tPos >=
                               (100000 as std::os::raw::c_int as
                                    UInt32).wrapping_mul((*s).blockSize100k as
                                                             UInt32) {
                            return 1 as std::os::raw::c_int as Bool
                        }
                        (*s).tPos= *(*s).tt.offset((*s).tPos as isize);
                        (*s).k0=
                            ((*s).tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)
                                as UChar as Int32;
                        (*s).tPos>>= 8 as std::os::raw::c_int;
                        if (*s).rNToGo == 0 as std::os::raw::c_int {
                            (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                            (*s).rTPos+= 1;
                            if (*s).rTPos == 512 as std::os::raw::c_int {
                                (*s).rTPos= 0 as std::os::raw::c_int
                            }
                        }
                        (*s).rNToGo-= 1;
                        (*s).k0;
                        (*s).nblock_used+= 1
                    }
                }
            }
        }
    } else {
        /* restore */
        let mut c_calculatedBlockCRC: UInt32 = (*s).calculatedBlockCRC;
        let mut c_state_out_ch: UChar = (*s).state_out_ch;
        let mut c_state_out_len: Int32 = (*s).state_out_len;
        let mut c_nblock_used: Int32 = (*s).nblock_used;
        let mut c_k0: Int32 = (*s).k0;
        let mut c_tt: *mut UInt32 = (*s).tt;
        let mut c_tPos: UInt32 = (*s).tPos;
        let mut cs_next_out: *mut std::os::raw::c_char = (*(*s).strm).next_out;
        let mut cs_avail_out: std::os::raw::c_uint = (*(*s).strm).avail_out;
        let mut ro_blockSize100k: Int32 = (*s).blockSize100k;
        /* end restore */
        let mut avail_out_INIT: UInt32 = cs_avail_out;
        let mut s_save_nblockPP: Int32 = (*s).save_nblock + 1 as std::os::raw::c_int;
        let mut total_out_lo32_old: std::os::raw::c_uint = 0;
        's_569:
            while 1 as std::os::raw::c_int as Bool != 0 {
                /* try to finish existing run */
                if c_state_out_len > 0 as std::os::raw::c_int {
                    while 1 as std::os::raw::c_int as Bool != 0 {
                        if cs_avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {
                            break 's_569 ;
                        }
                        if c_state_out_len == 1 as std::os::raw::c_int { break ; }
                        *(cs_next_out as *mut UChar) = c_state_out_ch;
                        c_calculatedBlockCRC=
                            c_calculatedBlockCRC << 8 as std::os::raw::c_int ^
                                BZ2_crc32Table[(c_calculatedBlockCRC >>
                                                    24 as std::os::raw::c_int ^
                                                    c_state_out_ch as
                                                        std::os::raw::c_uint) as
                                                   usize];
                        c_state_out_len-= 1;
                        cs_next_out= cs_next_out.offset(1);
                        cs_avail_out= cs_avail_out.wrapping_sub(1)
                    }
                    current_block= 16910810822589621899;
                } else { current_block= 3024573345131975588; }
                loop  {
                    match current_block {
                        16910810822589621899 => {
                            if cs_avail_out ==
                                   0 as std::os::raw::c_int as std::os::raw::c_uint {
                                c_state_out_len= 1 as std::os::raw::c_int;
                                break 's_569 ;
                            } else {
                                *(cs_next_out as *mut UChar) = c_state_out_ch;
                                c_calculatedBlockCRC=
                                    c_calculatedBlockCRC << 8 as std::os::raw::c_int ^
                                        BZ2_crc32Table[(c_calculatedBlockCRC
                                                            >>
                                                            24 as std::os::raw::c_int
                                                            ^
                                                            c_state_out_ch as
                                                                std::os::raw::c_uint)
                                                           as usize];
                                cs_next_out= cs_next_out.offset(1);
                                cs_avail_out= cs_avail_out.wrapping_sub(1);
                                current_block= 3024573345131975588;
                            }
                        }
                        _ => {
                            /* Only caused by corrupt data stream? */
                            if c_nblock_used > s_save_nblockPP {
                                return 1 as std::os::raw::c_int as Bool
                            }
                            /* can a new run be started? */
                            if c_nblock_used == s_save_nblockPP {
                                c_state_out_len= 0 as std::os::raw::c_int;
                                break 's_569 ;
                            } else {
                                c_state_out_ch= c_k0 as UChar;
                                if c_tPos >=
                                       (100000 as std::os::raw::c_int as
                                            UInt32).wrapping_mul(ro_blockSize100k
                                                                     as
                                                                     UInt32) {
                                    return 1 as std::os::raw::c_int as Bool
                                }
                                c_tPos= *c_tt.offset(c_tPos as isize);
                                k1=
                                    (c_tPos &
                                         0xff as std::os::raw::c_int as std::os::raw::c_uint)
                                        as UChar;
                                c_tPos>>= 8 as std::os::raw::c_int;
                                c_nblock_used+= 1;
                                if k1 as std::os::raw::c_int != c_k0 {
                                    c_k0= k1 as Int32;
                                    current_block= 16910810822589621899;
                                } else {
                                    if c_nblock_used == s_save_nblockPP {
                                        current_block= 16910810822589621899;
                                        continue ;
                                    }
                                    c_state_out_len= 2 as std::os::raw::c_int;
                                    if c_tPos >=
                                           (100000 as std::os::raw::c_int as
                                                UInt32).wrapping_mul(ro_blockSize100k
                                                                         as
                                                                         UInt32)
                                       {
                                        return 1 as std::os::raw::c_int as Bool
                                    }
                                    c_tPos= *c_tt.offset(c_tPos as isize);
                                    k1=
                                        (c_tPos &
                                             0xff as std::os::raw::c_int as
                                                 std::os::raw::c_uint) as UChar;
                                    c_tPos>>= 8 as std::os::raw::c_int;
                                    c_nblock_used+= 1;
                                    if c_nblock_used == s_save_nblockPP {
                                        continue 's_569 ;
                                    }
                                    if k1 as std::os::raw::c_int != c_k0 {
                                        current_block= 18139099716546303047;
                                        break ;
                                    } else {
                                        current_block= 919396821984190499;
                                        break ;
                                    }
                                }
                            }
                        }
                    }
                }
                match current_block {
                    18139099716546303047 => { c_k0= k1 as Int32 }
                    _ => {
                        c_state_out_len= 3 as std::os::raw::c_int;
                        if c_tPos >=
                               (100000 as std::os::raw::c_int as
                                    UInt32).wrapping_mul(ro_blockSize100k as
                                                             UInt32) {
                            return 1 as std::os::raw::c_int as Bool
                        }
                        c_tPos= *c_tt.offset(c_tPos as isize);
                        k1=
                            (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint) as
                                UChar;
                        c_tPos>>= 8 as std::os::raw::c_int;
                        c_nblock_used+= 1;
                        if c_nblock_used == s_save_nblockPP { continue ; }
                        if k1 as std::os::raw::c_int != c_k0 {
                            c_k0= k1 as Int32
                        } else {
                            if c_tPos >=
                                   (100000 as std::os::raw::c_int as
                                        UInt32).wrapping_mul(ro_blockSize100k
                                                                 as UInt32) {
                                return 1 as std::os::raw::c_int as Bool
                            }
                            c_tPos= *c_tt.offset(c_tPos as isize);
                            k1=
                                (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)
                                    as UChar;
                            c_tPos>>= 8 as std::os::raw::c_int;
                            c_nblock_used+= 1;
                            c_state_out_len= k1 as Int32 + 4 as std::os::raw::c_int;
                            if c_tPos >=
                                   (100000 as std::os::raw::c_int as
                                        UInt32).wrapping_mul(ro_blockSize100k
                                                                 as UInt32) {
                                return 1 as std::os::raw::c_int as Bool
                            }
                            c_tPos= *c_tt.offset(c_tPos as isize);
                            c_k0=
                                (c_tPos & 0xff as std::os::raw::c_int as std::os::raw::c_uint)
                                    as UChar as Int32;
                            c_tPos>>= 8 as std::os::raw::c_int;
                            c_nblock_used+= 1
                        }
                    }
                }
            }
        total_out_lo32_old= (*(*s).strm).total_out_lo32;
        (*(*s).strm).total_out_lo32=
            (*(*s).strm).total_out_lo32.wrapping_add(avail_out_INIT.wrapping_sub(cs_avail_out));
        if (*(*s).strm).total_out_lo32 < total_out_lo32_old {
            (*(*s).strm).total_out_hi32=
                (*(*s).strm).total_out_hi32.wrapping_add(1)
        }
        /* save */
        (*s).calculatedBlockCRC= c_calculatedBlockCRC;
        (*s).state_out_ch= c_state_out_ch;
        (*s).state_out_len= c_state_out_len;
        (*s).nblock_used= c_nblock_used;
        (*s).k0= c_k0;
        (*s).tt= c_tt;
        (*s).tPos= c_tPos;
        (*(*s).strm).next_out= cs_next_out;
        (*(*s).strm).avail_out= cs_avail_out
        /* end save */
    }
    return 0 as std::os::raw::c_int as Bool;
}
/*---------------------------------------------------*/
#[no_mangle]
#[inline]
#[linkage = "external"]
pub unsafe extern "C" fn BZ2_indexIntoF(mut indx: Int32,
                                        mut cftab: *const Int32) -> Int32 {
    let mut nb: Int32 = 0;
    let mut na: Int32 = 0;
    let mut mid: Int32 = 0;
    nb= 0 as std::os::raw::c_int;
    na= 256 as std::os::raw::c_int;
    loop  {
        mid= nb + na >> 1 as std::os::raw::c_int;
        if indx >= *cftab.offset(mid as isize) { nb= mid } else { na= mid }
        if !(na - nb != 1 as std::os::raw::c_int) { break ; }
    }
    return nb;
}
/*---------------------------------------------------*/
/* Return  True iff data corruption is discovered.
   Returns False if there is no problem.
*/
unsafe extern "C" fn unRLE_obuf_to_output_SMALL(mut s: *mut DState) -> Bool {
    let mut k1: UChar = 0;
    if (*s).blockRandomised != 0 {
        while 1 as std::os::raw::c_int as Bool != 0 {
            /* try to finish existing run */
            while 1 as std::os::raw::c_int as Bool != 0 {
                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint
                   {
                    return 0 as std::os::raw::c_int as Bool
                }
                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }
                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;
                (*s).calculatedBlockCRC=
                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^
                        BZ2_crc32Table[((*s).calculatedBlockCRC >>
                                            24 as std::os::raw::c_int ^
                                            (*s).state_out_ch as std::os::raw::c_uint)
                                           as usize];
                (*s).state_out_len-= 1;
                (*(*s).strm).next_out= (*(*s).strm).next_out.offset(1);
                (*(*s).strm).avail_out=
                    (*(*s).strm).avail_out.wrapping_sub(1);
                (*(*s).strm).total_out_lo32=
                    (*(*s).strm).total_out_lo32.wrapping_add(1);
                if (*(*s).strm).total_out_lo32 ==
                       0 as std::os::raw::c_int as std::os::raw::c_uint {
                    (*(*s).strm).total_out_hi32=
                        (*(*s).strm).total_out_hi32.wrapping_add(1)
                }
            }
            /* can a new run be started? */
            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                return 0 as std::os::raw::c_int as Bool
            }
            /* Only caused by corrupt data stream? */
            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {
                return 1 as std::os::raw::c_int as Bool
            }
            (*s).state_out_len= 1 as std::os::raw::c_int;
            (*s).state_out_ch= (*s).k0 as UChar;
            if (*s).tPos >=
                   (100000 as std::os::raw::c_int as
                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {
                return 1 as std::os::raw::c_int as Bool
            }
            k1=
                BZ2_indexIntoF((*s).tPos as Int32, (*s).cftab.as_mut_ptr()) as
                    UChar;
            (*s).tPos=
                *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                    (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as
                                          isize) as UInt32 >>
                         ((*s).tPos << 2 as std::os::raw::c_int &
                              0x4 as std::os::raw::c_int as std::os::raw::c_uint) &
                         0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                        16 as std::os::raw::c_int;
            if (*s).rNToGo == 0 as std::os::raw::c_int {
                (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                (*s).rTPos+= 1;
                if (*s).rTPos == 512 as std::os::raw::c_int {
                    (*s).rTPos= 0 as std::os::raw::c_int
                }
            }
            (*s).rNToGo-= 1;
            k1=
                (k1 as std::os::raw::c_int ^
                     if (*s).rNToGo == 1 as std::os::raw::c_int {
                         1 as std::os::raw::c_int
                     } else { 0 as std::os::raw::c_int }) as UChar;
            (*s).nblock_used+= 1;
            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                continue ;
            }
            if k1 as std::os::raw::c_int != (*s).k0 {
                (*s).k0= k1 as Int32
            } else {
                (*s).state_out_len= 2 as std::os::raw::c_int;
                if (*s).tPos >=
                       (100000 as std::os::raw::c_int as
                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)
                   {
                    return 1 as std::os::raw::c_int as Bool
                }
                k1=
                    BZ2_indexIntoF((*s).tPos as Int32,
                                   (*s).cftab.as_mut_ptr()) as UChar;
                (*s).tPos=
                    *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                        (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as
                                              isize) as UInt32 >>
                             ((*s).tPos << 2 as std::os::raw::c_int &
                                  0x4 as std::os::raw::c_int as std::os::raw::c_uint) &
                             0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                            16 as std::os::raw::c_int;
                if (*s).rNToGo == 0 as std::os::raw::c_int {
                    (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                    (*s).rTPos+= 1;
                    if (*s).rTPos == 512 as std::os::raw::c_int {
                        (*s).rTPos= 0 as std::os::raw::c_int
                    }
                }
                (*s).rNToGo-= 1;
                k1=
                    (k1 as std::os::raw::c_int ^
                         if (*s).rNToGo == 1 as std::os::raw::c_int {
                             1 as std::os::raw::c_int
                         } else { 0 as std::os::raw::c_int }) as UChar;
                (*s).nblock_used+= 1;
                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                    continue ;
                }
                if k1 as std::os::raw::c_int != (*s).k0 {
                    (*s).k0= k1 as Int32
                } else {
                    (*s).state_out_len= 3 as std::os::raw::c_int;
                    if (*s).tPos >=
                           (100000 as std::os::raw::c_int as
                                UInt32).wrapping_mul((*s).blockSize100k as
                                                         UInt32) {
                        return 1 as std::os::raw::c_int as Bool
                    }
                    k1=
                        BZ2_indexIntoF((*s).tPos as Int32,
                                       (*s).cftab.as_mut_ptr()) as UChar;
                    (*s).tPos=
                        *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                            (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int)
                                                  as isize) as UInt32 >>
                                 ((*s).tPos << 2 as std::os::raw::c_int &
                                      0x4 as std::os::raw::c_int as std::os::raw::c_uint) &
                                 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                                16 as std::os::raw::c_int;
                    if (*s).rNToGo == 0 as std::os::raw::c_int {
                        (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                        (*s).rTPos+= 1;
                        if (*s).rTPos == 512 as std::os::raw::c_int {
                            (*s).rTPos= 0 as std::os::raw::c_int
                        }
                    }
                    (*s).rNToGo-= 1;
                    k1=
                        (k1 as std::os::raw::c_int ^
                             if (*s).rNToGo == 1 as std::os::raw::c_int {
                                 1 as std::os::raw::c_int
                             } else { 0 as std::os::raw::c_int }) as UChar;
                    (*s).nblock_used+= 1;
                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int
                       {
                        continue ;
                    }
                    if k1 as std::os::raw::c_int != (*s).k0 {
                        (*s).k0= k1 as Int32
                    } else {
                        if (*s).tPos >=
                               (100000 as std::os::raw::c_int as
                                    UInt32).wrapping_mul((*s).blockSize100k as
                                                             UInt32) {
                            return 1 as std::os::raw::c_int as Bool
                        }
                        k1=
                            BZ2_indexIntoF((*s).tPos as Int32,
                                           (*s).cftab.as_mut_ptr()) as UChar;
                        (*s).tPos=
                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                                (*(*s).ll4.offset(((*s).tPos >>
                                                       1 as std::os::raw::c_int) as
                                                      isize) as UInt32 >>
                                     ((*s).tPos << 2 as std::os::raw::c_int &
                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)
                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                                    16 as std::os::raw::c_int;
                        if (*s).rNToGo == 0 as std::os::raw::c_int {
                            (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                            (*s).rTPos+= 1;
                            if (*s).rTPos == 512 as std::os::raw::c_int {
                                (*s).rTPos= 0 as std::os::raw::c_int
                            }
                        }
                        (*s).rNToGo-= 1;
                        k1=
                            (k1 as std::os::raw::c_int ^
                                 if (*s).rNToGo == 1 as std::os::raw::c_int {
                                     1 as std::os::raw::c_int
                                 } else { 0 as std::os::raw::c_int }) as UChar;
                        (*s).nblock_used+= 1;
                        (*s).state_out_len= k1 as Int32 + 4 as std::os::raw::c_int;
                        if (*s).tPos >=
                               (100000 as std::os::raw::c_int as
                                    UInt32).wrapping_mul((*s).blockSize100k as
                                                             UInt32) {
                            return 1 as std::os::raw::c_int as Bool
                        }
                        (*s).k0=
                            BZ2_indexIntoF((*s).tPos as Int32,
                                           (*s).cftab.as_mut_ptr());
                        (*s).tPos=
                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                                (*(*s).ll4.offset(((*s).tPos >>
                                                       1 as std::os::raw::c_int) as
                                                      isize) as UInt32 >>
                                     ((*s).tPos << 2 as std::os::raw::c_int &
                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)
                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                                    16 as std::os::raw::c_int;
                        if (*s).rNToGo == 0 as std::os::raw::c_int {
                            (*s).rNToGo= BZ2_rNums[(*s).rTPos as usize];
                            (*s).rTPos+= 1;
                            if (*s).rTPos == 512 as std::os::raw::c_int {
                                (*s).rTPos= 0 as std::os::raw::c_int
                            }
                        }
                        (*s).rNToGo-= 1;
                        (*s).k0;
                        (*s).nblock_used+= 1
                    }
                }
            }
        }
    } else {
        while 1 as std::os::raw::c_int as Bool != 0 {
            /* try to finish existing run */
            while 1 as std::os::raw::c_int as Bool != 0 {
                if (*(*s).strm).avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint
                   {
                    return 0 as std::os::raw::c_int as Bool
                }
                if (*s).state_out_len == 0 as std::os::raw::c_int { break ; }
                *((*(*s).strm).next_out as *mut UChar) = (*s).state_out_ch;
                (*s).calculatedBlockCRC=
                    (*s).calculatedBlockCRC << 8 as std::os::raw::c_int ^
                        BZ2_crc32Table[((*s).calculatedBlockCRC >>
                                            24 as std::os::raw::c_int ^
                                            (*s).state_out_ch as std::os::raw::c_uint)
                                           as usize];
                (*s).state_out_len-= 1;
                (*(*s).strm).next_out= (*(*s).strm).next_out.offset(1);
                (*(*s).strm).avail_out=
                    (*(*s).strm).avail_out.wrapping_sub(1);
                (*(*s).strm).total_out_lo32=
                    (*(*s).strm).total_out_lo32.wrapping_add(1);
                if (*(*s).strm).total_out_lo32 ==
                       0 as std::os::raw::c_int as std::os::raw::c_uint {
                    (*(*s).strm).total_out_hi32=
                        (*(*s).strm).total_out_hi32.wrapping_add(1)
                }
            }
            /* can a new run be started? */
            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                return 0 as std::os::raw::c_int as Bool
            }
            /* Only caused by corrupt data stream? */
            if (*s).nblock_used > (*s).save_nblock + 1 as std::os::raw::c_int {
                return 1 as std::os::raw::c_int as Bool
            }
            (*s).state_out_len= 1 as std::os::raw::c_int;
            (*s).state_out_ch= (*s).k0 as UChar;
            if (*s).tPos >=
                   (100000 as std::os::raw::c_int as
                        UInt32).wrapping_mul((*s).blockSize100k as UInt32) {
                return 1 as std::os::raw::c_int as Bool
            }
            k1=
                BZ2_indexIntoF((*s).tPos as Int32, (*s).cftab.as_mut_ptr()) as
                    UChar;
            (*s).tPos=
                *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                    (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as
                                          isize) as UInt32 >>
                         ((*s).tPos << 2 as std::os::raw::c_int &
                              0x4 as std::os::raw::c_int as std::os::raw::c_uint) &
                         0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                        16 as std::os::raw::c_int;
            (*s).nblock_used+= 1;
            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                continue ;
            }
            if k1 as std::os::raw::c_int != (*s).k0 {
                (*s).k0= k1 as Int32
            } else {
                (*s).state_out_len= 2 as std::os::raw::c_int;
                if (*s).tPos >=
                       (100000 as std::os::raw::c_int as
                            UInt32).wrapping_mul((*s).blockSize100k as UInt32)
                   {
                    return 1 as std::os::raw::c_int as Bool
                }
                k1=
                    BZ2_indexIntoF((*s).tPos as Int32,
                                   (*s).cftab.as_mut_ptr()) as UChar;
                (*s).tPos=
                    *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                        (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int) as
                                              isize) as UInt32 >>
                             ((*s).tPos << 2 as std::os::raw::c_int &
                                  0x4 as std::os::raw::c_int as std::os::raw::c_uint) &
                             0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                            16 as std::os::raw::c_int;
                (*s).nblock_used+= 1;
                if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int {
                    continue ;
                }
                if k1 as std::os::raw::c_int != (*s).k0 {
                    (*s).k0= k1 as Int32
                } else {
                    (*s).state_out_len= 3 as std::os::raw::c_int;
                    if (*s).tPos >=
                           (100000 as std::os::raw::c_int as
                                UInt32).wrapping_mul((*s).blockSize100k as
                                                         UInt32) {
                        return 1 as std::os::raw::c_int as Bool
                    }
                    k1=
                        BZ2_indexIntoF((*s).tPos as Int32,
                                       (*s).cftab.as_mut_ptr()) as UChar;
                    (*s).tPos=
                        *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                            (*(*s).ll4.offset(((*s).tPos >> 1 as std::os::raw::c_int)
                                                  as isize) as UInt32 >>
                                 ((*s).tPos << 2 as std::os::raw::c_int &
                                      0x4 as std::os::raw::c_int as std::os::raw::c_uint) &
                                 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                                16 as std::os::raw::c_int;
                    (*s).nblock_used+= 1;
                    if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int
                       {
                        continue ;
                    }
                    if k1 as std::os::raw::c_int != (*s).k0 {
                        (*s).k0= k1 as Int32
                    } else {
                        if (*s).tPos >=
                               (100000 as std::os::raw::c_int as
                                    UInt32).wrapping_mul((*s).blockSize100k as
                                                             UInt32) {
                            return 1 as std::os::raw::c_int as Bool
                        }
                        k1=
                            BZ2_indexIntoF((*s).tPos as Int32,
                                           (*s).cftab.as_mut_ptr()) as UChar;
                        (*s).tPos=
                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                                (*(*s).ll4.offset(((*s).tPos >>
                                                       1 as std::os::raw::c_int) as
                                                      isize) as UInt32 >>
                                     ((*s).tPos << 2 as std::os::raw::c_int &
                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)
                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                                    16 as std::os::raw::c_int;
                        (*s).nblock_used+= 1;
                        (*s).state_out_len= k1 as Int32 + 4 as std::os::raw::c_int;
                        if (*s).tPos >=
                               (100000 as std::os::raw::c_int as
                                    UInt32).wrapping_mul((*s).blockSize100k as
                                                             UInt32) {
                            return 1 as std::os::raw::c_int as Bool
                        }
                        (*s).k0=
                            BZ2_indexIntoF((*s).tPos as Int32,
                                           (*s).cftab.as_mut_ptr());
                        (*s).tPos=
                            *(*s).ll16.offset((*s).tPos as isize) as UInt32 |
                                (*(*s).ll4.offset(((*s).tPos >>
                                                       1 as std::os::raw::c_int) as
                                                      isize) as UInt32 >>
                                     ((*s).tPos << 2 as std::os::raw::c_int &
                                          0x4 as std::os::raw::c_int as std::os::raw::c_uint)
                                     & 0xf as std::os::raw::c_int as std::os::raw::c_uint) <<
                                    16 as std::os::raw::c_int;
                        (*s).nblock_used+= 1
                    }
                }
            }
        }
    }
    panic!("Reached end of non-void function without returning");
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzDecompress(mut strm: *mut crate::blocksort::bz_stream)
 -> std::os::raw::c_int {
    let mut corrupt: Bool = 0;
    let mut s: *mut DState = 0 as *mut DState;
    if strm.is_null() {(); return -(2 as std::os::raw::c_int) }
    s= (*strm).state as *mut DState;
    if s.is_null() {(); return -(2 as std::os::raw::c_int) }
    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }
    while 1 as std::os::raw::c_int as Bool != 0 {
        if (*s).state == 1 as std::os::raw::c_int { return -(1 as std::os::raw::c_int) }
        if (*s).state == 2 as std::os::raw::c_int {
            if (*s).smallDecompress != 0 {
                corrupt= unRLE_obuf_to_output_SMALL(s)
            } else { corrupt= unRLE_obuf_to_output_FAST(s) }
            if corrupt != 0 { return -(4 as std::os::raw::c_int) }
            if (*s).nblock_used == (*s).save_nblock + 1 as std::os::raw::c_int &&
                   (*s).state_out_len == 0 as std::os::raw::c_int {
                (*s).calculatedBlockCRC= !(*s).calculatedBlockCRC;
                if (*s).verbosity >= 3 as std::os::raw::c_int {
                    fprintf(__stderrp,
                            b" {0x%08x, 0x%08x}\x00" as *const u8 as
                                *const std::os::raw::c_char, (*s).storedBlockCRC,
                            (*s).calculatedBlockCRC);
                }
                if (*s).verbosity >= 2 as std::os::raw::c_int {
                    fprintf(__stderrp,
                            b"]\x00" as *const u8 as *const std::os::raw::c_char);
                }
                if (*s).calculatedBlockCRC != (*s).storedBlockCRC {
                    return -(4 as std::os::raw::c_int)
                }
                (*s).calculatedCombinedCRC=
                    (*s).calculatedCombinedCRC << 1 as std::os::raw::c_int |
                        (*s).calculatedCombinedCRC >> 31 as std::os::raw::c_int;
                (*s).calculatedCombinedCRC^= (*s).calculatedBlockCRC;
                (*s).state= 14 as std::os::raw::c_int
            } else { return 0 as std::os::raw::c_int }
        }
        if (*s).state >= 10 as std::os::raw::c_int {
            let mut r: Int32 = crate::decompress::BZ2_decompress(s);
            if r == 4 as std::os::raw::c_int {
                if (*s).verbosity >= 3 as std::os::raw::c_int {
                    fprintf(__stderrp,
                            b"\n    combined CRCs: stored = 0x%08x, computed = 0x%08x\x00"
                                as *const u8 as *const std::os::raw::c_char,
                            (*s).storedCombinedCRC,
                            (*s).calculatedCombinedCRC);
                }
                if (*s).calculatedCombinedCRC != (*s).storedCombinedCRC {
                    return -(4 as std::os::raw::c_int)
                }
                return r
            }
            if (*s).state != 2 as std::os::raw::c_int { return r }
        }
    }
    if 0 as std::os::raw::c_int == 0 { BZ2_bz__AssertH__fail(6001 as std::os::raw::c_int); }
    return 0 as std::os::raw::c_int;
    /*NOTREACHED*/
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzDecompressEnd(mut strm: *mut crate::blocksort::bz_stream)
 -> std::os::raw::c_int {
    let mut s: *mut DState = 0 as *mut DState;
    if strm.is_null() {(); return -(2 as std::os::raw::c_int) }
    s= (*strm).state as *mut DState;
    if s.is_null() {(); return -(2 as std::os::raw::c_int) }
    if (*s).strm != strm { return -(2 as std::os::raw::c_int) }
    if !(*s).tt.is_null() {
        (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                           (*s).tt as
                                                               *mut std::os::raw::c_void);
    }else { (); }
    if !(*s).ll16.is_null() {
        (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                           (*s).ll16 as
                                                               *mut std::os::raw::c_void);
    }else { (); }
    if !(*s).ll4.is_null() {
        (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                           (*s).ll4 as
                                                               *mut std::os::raw::c_void);
    }else { (); }
    (*strm).bzfree.expect("non-null function pointer")((*strm).opaque,
                                                       (*strm).state);
    (*strm).state= 0 as *mut std::os::raw::c_void;
    return 0 as std::os::raw::c_int;
}
/*---------------------------------------------*/
unsafe extern "C" fn myfeof(mut f: *mut FILE) -> Bool {
    let mut c: Int32 = fgetc(f);
    if c == -(1 as std::os::raw::c_int) { return 1 as std::os::raw::c_int as Bool }
    ungetc(c, f);
    return 0 as std::os::raw::c_int as Bool;
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzWriteOpen(mut bzerror: *mut std::os::raw::c_int,
                                         mut f: *mut FILE,
                                         mut blockSize100k: std::os::raw::c_int,
                                         mut verbosity: std::os::raw::c_int,
                                         mut workFactor: std::os::raw::c_int)
 -> *mut std::os::raw::c_void {
    let mut ret: Int32 = 0;
    let mut bzf: *mut bzFile = 0 as *mut bzFile;
    if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    if f.is_null() ||
           (blockSize100k < 1 as std::os::raw::c_int ||
                blockSize100k > 9 as std::os::raw::c_int) ||
           (workFactor < 0 as std::os::raw::c_int || workFactor > 250 as std::os::raw::c_int)
           || (verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int) {
        if !bzerror.is_null() { *bzerror= -(2 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(2 as std::os::raw::c_int) }else { (); }
        return 0 as *mut std::os::raw::c_void
    }
    if ferror(f) != 0 {
        if !bzerror.is_null() { *bzerror= -(6 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
        return 0 as *mut std::os::raw::c_void
    }
    bzf=
        malloc(::std::mem::size_of::<bzFile>() as std::os::raw::c_ulong) as
            *mut bzFile;
    if bzf.is_null() {();
        if !bzerror.is_null() { *bzerror= -(3 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(3 as std::os::raw::c_int) }else { (); }
        return 0 as *mut std::os::raw::c_void
    }
    if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    (*bzf).initialisedOk= 0 as std::os::raw::c_int as Bool;
    (*bzf).bufN= 0 as std::os::raw::c_int;
    (*bzf).handle= f;
    (*bzf).writing= 1 as std::os::raw::c_int as Bool;
    (*bzf).strm.bzalloc= None;
    (*bzf).strm.bzfree= None;
    (*bzf).strm.opaque= 0 as *mut std::os::raw::c_void;
    if workFactor == 0 as std::os::raw::c_int { workFactor= 30 as std::os::raw::c_int }
    ret=
        BZ2_bzCompressInit(&mut (*bzf).strm, blockSize100k, verbosity,
                           workFactor);
    if ret != 0 as std::os::raw::c_int {
        if !bzerror.is_null() { *bzerror= ret }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= ret }else { (); }
        free(bzf as *mut std::os::raw::c_void);
        return 0 as *mut std::os::raw::c_void
    }
    (*bzf).strm.avail_in= 0 as std::os::raw::c_int as std::os::raw::c_uint;
    (*bzf).initialisedOk= 1 as std::os::raw::c_int as Bool;
    return bzf as *mut std::os::raw::c_void;
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzWrite(mut bzerror: Option<&mut std::os::raw::c_int>,
                                     mut b: *mut std::os::raw::c_void,
                                     mut buf: *const std::os::raw::c_void,
                                     mut len: std::os::raw::c_int) {
    let mut n: Int32 = 0;
    let mut n2: Int32 = 0;
    let mut ret: Int32 = 0;
    let mut bzf: *mut bzFile = b as *mut bzFile;
    if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    if bzf.is_null() || buf.is_null() || len < 0 as std::os::raw::c_int {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(2 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(2 as std::os::raw::c_int) }else { (); }
        return
    }
    if (*bzf).writing == 0 {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(1 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(1 as std::os::raw::c_int) }else { (); }
        return
    }
    if ferror((*bzf).handle) != 0 {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(6 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
        return
    }
    if len == 0 as std::os::raw::c_int {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 0 as std::os::raw::c_int }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
        return
    }
    (*bzf).strm.avail_in= len as std::os::raw::c_uint;
    (*bzf).strm.next_in= buf as *mut std::os::raw::c_char;
    while 1 as std::os::raw::c_int as Bool != 0 {
        (*bzf).strm.avail_out= 5000 as std::os::raw::c_int as std::os::raw::c_uint;
        (*bzf).strm.next_out= (*bzf).buf.as_mut_ptr();
        ret= BZ2_bzCompress(&mut (*bzf).strm, 0 as std::os::raw::c_int);
        if ret != 1 as std::os::raw::c_int {
            if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= ret }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= ret }else { (); }
            return
        }
        if (*bzf).strm.avail_out < 5000 as std::os::raw::c_int as std::os::raw::c_uint {
            n=
                (5000 as std::os::raw::c_int as
                     std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out) as
                    Int32;
            n2=
                fwrite((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,
                       ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,
                       n as std::os::raw::c_ulong, (*bzf).handle) as Int32;
            if n != n2 || ferror((*bzf).handle) != 0 {
                if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(6 as std::os::raw::c_int) }else { (); }
                if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
                return
            }
        }
        if (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 0 as std::os::raw::c_int }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
            return
        }
    };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzWriteClose(mut bzerror: Option<&mut std::os::raw::c_int>,
                                          mut b: Option<&mut std::os::raw::c_void>,
                                          mut abandon: std::os::raw::c_int,
                                          mut nbytes_in: Option<&mut std::os::raw::c_uint>,
                                          mut nbytes_out: Option<&mut std::os::raw::c_uint>) {
    BZ2_bzWriteClose64(core::mem::transmute::<_, *mut i32>(bzerror.as_deref_mut()), core::mem::transmute::<_, *mut crate::std::ffi::c_void>(b.as_deref_mut()), abandon, core::mem::transmute::<_, *mut u32>(nbytes_in.as_deref_mut()), 0 as *mut std::os::raw::c_uint,
                       core::mem::transmute::<_, *mut u32>(nbytes_out.as_deref_mut()), 0 as *mut std::os::raw::c_uint);
}
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzWriteClose64(mut bzerror: *mut std::os::raw::c_int,
                                            mut b: *mut std::os::raw::c_void,
                                            mut abandon: std::os::raw::c_int,
                                            mut nbytes_in_lo32:
                                                *mut std::os::raw::c_uint,
                                            mut nbytes_in_hi32:
                                                *mut std::os::raw::c_uint,
                                            mut nbytes_out_lo32:
                                                *mut std::os::raw::c_uint,
                                            mut nbytes_out_hi32:
                                                *mut std::os::raw::c_uint) {
    let mut n: Int32 = 0;
    let mut n2: Int32 = 0;
    let mut ret: Int32 = 0;
    let mut bzf: *mut bzFile = b as *mut bzFile;
    if bzf.is_null() {();
        if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
        return
    }
    if (*bzf).writing == 0 {
        if !bzerror.is_null() { *bzerror= -(1 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(1 as std::os::raw::c_int) }else { (); }
        return
    }
    if ferror((*bzf).handle) != 0 {
        if !bzerror.is_null() { *bzerror= -(6 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
        return
    }
    if !nbytes_in_lo32.is_null() {
        *nbytes_in_lo32= 0 as std::os::raw::c_int as std::os::raw::c_uint
    }else { (); }
    if !nbytes_in_hi32.is_null() {
        *nbytes_in_hi32= 0 as std::os::raw::c_int as std::os::raw::c_uint
    }else { (); }
    if !nbytes_out_lo32.is_null() {
        *nbytes_out_lo32= 0 as std::os::raw::c_int as std::os::raw::c_uint
    }else { (); }
    if !nbytes_out_hi32.is_null() {
        *nbytes_out_hi32= 0 as std::os::raw::c_int as std::os::raw::c_uint
    }else { (); }
    if abandon == 0 && (*bzf).lastErr == 0 as std::os::raw::c_int {
        while 1 as std::os::raw::c_int as Bool != 0 {
            (*bzf).strm.avail_out= 5000 as std::os::raw::c_int as std::os::raw::c_uint;
            (*bzf).strm.next_out= (*bzf).buf.as_mut_ptr();
            ret= BZ2_bzCompress(&mut (*bzf).strm, 2 as std::os::raw::c_int);
            if ret != 3 as std::os::raw::c_int && ret != 4 as std::os::raw::c_int {
                if !bzerror.is_null() { *bzerror= ret }else { (); }
                if !bzf.is_null() { (*bzf).lastErr= ret }else { (); }
                return
            }
            if (*bzf).strm.avail_out < 5000 as std::os::raw::c_int as std::os::raw::c_uint {
                n=
                    (5000 as std::os::raw::c_int as
                         std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out) as
                        Int32;
                n2=
                    fwrite((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,
                           ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,
                           n as std::os::raw::c_ulong, (*bzf).handle) as Int32;
                if n != n2 || ferror((*bzf).handle) != 0 {
                    if !bzerror.is_null() { *bzerror= -(6 as std::os::raw::c_int) }else { (); }
                    if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
                    return
                }
            }
            if ret == 4 as std::os::raw::c_int { break ; }
        }
    }
    if abandon == 0 && ferror((*bzf).handle) == 0 {
        fflush((*bzf).handle);
        if ferror((*bzf).handle) != 0 {
            if !bzerror.is_null() { *bzerror= -(6 as std::os::raw::c_int) }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
            return
        }
    }
    if !nbytes_in_lo32.is_null() {
        *nbytes_in_lo32= (*bzf).strm.total_in_lo32
    }else { (); }
    if !nbytes_in_hi32.is_null() {
        *nbytes_in_hi32= (*bzf).strm.total_in_hi32
    }else { (); }
    if !nbytes_out_lo32.is_null() {
        *nbytes_out_lo32= (*bzf).strm.total_out_lo32
    }else { (); }
    if !nbytes_out_hi32.is_null() {
        *nbytes_out_hi32= (*bzf).strm.total_out_hi32
    }else { (); }
    if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    BZ2_bzCompressEnd(&mut (*bzf).strm);
    free(bzf as *mut std::os::raw::c_void);
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzReadOpen(mut bzerror: *mut std::os::raw::c_int,
                                        mut f: *mut FILE,
                                        mut verbosity: std::os::raw::c_int,
                                        mut small: std::os::raw::c_int,
                                        mut unused: *const std::os::raw::c_void,
                                        mut nUnused: std::os::raw::c_int)
 -> *mut std::os::raw::c_void {
    let mut bzf: *mut bzFile = 0 as *mut bzFile;
    let mut ret: std::os::raw::c_int = 0;
    if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    if f.is_null() || small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int
           || (verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int)
           || unused.is_null() && nUnused != 0 as std::os::raw::c_int ||
           !unused.is_null() &&
               (nUnused < 0 as std::os::raw::c_int || nUnused > 5000 as std::os::raw::c_int) {
        if !bzerror.is_null() { *bzerror= -(2 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(2 as std::os::raw::c_int) }else { (); }
        return 0 as *mut std::os::raw::c_void
    }
    if ferror(f) != 0 {
        if !bzerror.is_null() { *bzerror= -(6 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
        return 0 as *mut std::os::raw::c_void
    }
    bzf=
        malloc(::std::mem::size_of::<bzFile>() as std::os::raw::c_ulong) as
            *mut bzFile;
    if bzf.is_null() {();
        if !bzerror.is_null() { *bzerror= -(3 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(3 as std::os::raw::c_int) }else { (); }
        return 0 as *mut std::os::raw::c_void
    }
    if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    (*bzf).initialisedOk= 0 as std::os::raw::c_int as Bool;
    (*bzf).handle= f;
    (*bzf).bufN= 0 as std::os::raw::c_int;
    (*bzf).writing= 0 as std::os::raw::c_int as Bool;
    (*bzf).strm.bzalloc= None;
    (*bzf).strm.bzfree= None;
    (*bzf).strm.opaque= 0 as *mut std::os::raw::c_void;
    while nUnused > 0 as std::os::raw::c_int {
        (*bzf).buf[(*bzf).bufN as usize] = *(unused as *mut UChar) as Char;
        (*bzf).bufN+= 1;
        unused=
            (unused as *mut UChar).offset(1 as std::os::raw::c_int as isize) as
                *mut std::os::raw::c_void;
        nUnused-= 1
    }
    ret= BZ2_bzDecompressInit(&mut (*bzf).strm, verbosity, small);
    if ret != 0 as std::os::raw::c_int {
        if !bzerror.is_null() { *bzerror= ret }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= ret }else { (); }
        free(bzf as *mut std::os::raw::c_void);
        return 0 as *mut std::os::raw::c_void
    }
    (*bzf).strm.avail_in= (*bzf).bufN as std::os::raw::c_uint;
    (*bzf).strm.next_in= (*bzf).buf.as_mut_ptr();
    (*bzf).initialisedOk= 1 as std::os::raw::c_int as Bool;
    return bzf as *mut std::os::raw::c_void;
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzReadClose(mut bzerror: *mut std::os::raw::c_int,
                                         mut b: *mut std::os::raw::c_void) {
    let mut bzf: *mut bzFile = b as *mut bzFile;
    if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    if bzf.is_null() {();
        if !bzerror.is_null() { *bzerror= 0 as std::os::raw::c_int }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
        return
    }
    if (*bzf).writing != 0 {
        if !bzerror.is_null() { *bzerror= -(1 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(1 as std::os::raw::c_int) }else { (); }
        return
    }
    if (*bzf).initialisedOk != 0 { BZ2_bzDecompressEnd(&mut (*bzf).strm); }
    free(bzf as *mut std::os::raw::c_void);
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzRead(mut bzerror: Option<&mut std::os::raw::c_int>,
                                    mut b: *mut std::os::raw::c_void,
                                    mut buf: *mut std::os::raw::c_void,
                                    mut len: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut n: Int32 = 0;
    let mut ret: Int32 = 0;
    let mut bzf: *mut bzFile = b as *mut bzFile;
    if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    if bzf.is_null() || buf.is_null() || len < 0 as std::os::raw::c_int {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(2 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(2 as std::os::raw::c_int) }else { (); }
        return 0 as std::os::raw::c_int
    }
    if (*bzf).writing != 0 {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(1 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(1 as std::os::raw::c_int) }else { (); }
        return 0 as std::os::raw::c_int
    }
    if len == 0 as std::os::raw::c_int {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 0 as std::os::raw::c_int }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
        return 0 as std::os::raw::c_int
    }
    (*bzf).strm.avail_out= len as std::os::raw::c_uint;
    (*bzf).strm.next_out= buf as *mut std::os::raw::c_char;
    while 1 as std::os::raw::c_int as Bool != 0 {
        if ferror((*bzf).handle) != 0 {
            if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(6 as std::os::raw::c_int) }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
            return 0 as std::os::raw::c_int
        }
        if (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&
               myfeof((*bzf).handle) == 0 {
            n=
                fread((*bzf).buf.as_mut_ptr() as *mut std::os::raw::c_void,
                      ::std::mem::size_of::<UChar>() as std::os::raw::c_ulong,
                      5000 as std::os::raw::c_int as std::os::raw::c_ulong, (*bzf).handle) as
                    Int32;
            if ferror((*bzf).handle) != 0 {
                if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(6 as std::os::raw::c_int) }else { (); }
                if !bzf.is_null() { (*bzf).lastErr= -(6 as std::os::raw::c_int) }else { (); }
                return 0 as std::os::raw::c_int
            }
            (*bzf).bufN= n;
            (*bzf).strm.avail_in= (*bzf).bufN as std::os::raw::c_uint;
            (*bzf).strm.next_in= (*bzf).buf.as_mut_ptr()
        }
        ret= BZ2_bzDecompress(&mut (*bzf).strm);
        if ret != 0 as std::os::raw::c_int && ret != 4 as std::os::raw::c_int {
            if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= ret }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= ret }else { (); }
            return 0 as std::os::raw::c_int
        }
        if ret == 0 as std::os::raw::c_int &&
               myfeof((*bzf).handle) as std::os::raw::c_int != 0 &&
               (*bzf).strm.avail_in == 0 as std::os::raw::c_int as std::os::raw::c_uint &&
               (*bzf).strm.avail_out > 0 as std::os::raw::c_int as std::os::raw::c_uint {
            if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(7 as std::os::raw::c_int) }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= -(7 as std::os::raw::c_int) }else { (); }
            return 0 as std::os::raw::c_int
        }
        if ret == 4 as std::os::raw::c_int {
            if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 4 as std::os::raw::c_int }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= 4 as std::os::raw::c_int }else { (); }
            return (len as std::os::raw::c_uint).wrapping_sub((*bzf).strm.avail_out)
                       as std::os::raw::c_int
        }
        if (*bzf).strm.avail_out == 0 as std::os::raw::c_int as std::os::raw::c_uint {
            if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 0 as std::os::raw::c_int }else { (); }
            if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
            return len
        }
    }
    return 0 as std::os::raw::c_int;
    /*not reached*/
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzReadGetUnused(mut bzerror: Option<&mut std::os::raw::c_int>,
                                             mut b: *mut std::os::raw::c_void,
                                             mut unused:
                                                 Option<&mut *const std::os::raw::c_void>,
                                             mut nUnused: Option<&mut std::os::raw::c_int>) {
    let mut bzf: *mut bzFile = b as *mut bzFile;
    if bzf.is_null() {();
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(2 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(2 as std::os::raw::c_int) }else { (); }
        return
    }
    if (*bzf).lastErr != 4 as std::os::raw::c_int {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(1 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(1 as std::os::raw::c_int) }else { (); }
        return
    }
    if unused.as_deref().is_none() || nUnused.as_deref().is_none() {
        if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= -(2 as std::os::raw::c_int) }else { (); }
        if !bzf.is_null() { (*bzf).lastErr= -(2 as std::os::raw::c_int) }else { (); }
        return
    }
    if !bzerror.as_deref().is_none() { *bzerror.as_deref_mut().unwrap()= 0 as std::os::raw::c_int }else { (); }
    if !bzf.is_null() { (*bzf).lastErr= 0 as std::os::raw::c_int }else { (); }
    *nUnused.as_deref_mut().unwrap()= (*bzf).strm.avail_in as std::os::raw::c_int;
    *unused.as_deref_mut().unwrap()= (*bzf).strm.next_in as *mut std::os::raw::c_void;
}
/*---------------------------------------------------*/
/*--- Misc convenience stuff                      ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzBuffToBuffCompress(mut dest: *mut std::os::raw::c_char,
                                                  mut destLen:
                                                      Option<&mut std::os::raw::c_uint>,
                                                  mut source:
                                                      *const std::os::raw::c_char,
                                                  mut sourceLen: std::os::raw::c_uint,
                                                  mut blockSize100k:
                                                      std::os::raw::c_int,
                                                  mut verbosity: std::os::raw::c_int,
                                                  mut workFactor: std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut strm: crate::blocksort::bz_stream =
        crate::blocksort::bz_stream{next_in: 0 as *mut std::os::raw::c_char,
                  avail_in: 0,
                  total_in_lo32: 0,
                  total_in_hi32: 0,
                  next_out: 0 as *mut std::os::raw::c_char,
                  avail_out: 0,
                  total_out_lo32: 0,
                  total_out_hi32: 0,
                  state: 0 as *mut std::os::raw::c_void,
                  bzalloc: None,
                  bzfree: None,
                  opaque: 0 as *mut std::os::raw::c_void,};
    let mut ret: std::os::raw::c_int = 0;
    if dest.is_null() || destLen.as_deref().is_none() || source.is_null() ||
           blockSize100k < 1 as std::os::raw::c_int ||
           blockSize100k > 9 as std::os::raw::c_int || verbosity < 0 as std::os::raw::c_int ||
           verbosity > 4 as std::os::raw::c_int || workFactor < 0 as std::os::raw::c_int ||
           workFactor > 250 as std::os::raw::c_int {
        return -(2 as std::os::raw::c_int)
    }
    if workFactor == 0 as std::os::raw::c_int { workFactor= 30 as std::os::raw::c_int }
    strm.bzalloc= None;
    strm.bzfree= None;
    strm.opaque= 0 as *mut std::os::raw::c_void;
    ret= BZ2_bzCompressInit(&mut strm, blockSize100k, verbosity, workFactor);
    if ret != 0 as std::os::raw::c_int { return ret }
    strm.next_in= source;
    strm.next_out= dest;
    strm.avail_in= sourceLen;
    strm.avail_out= (*destLen.as_deref().unwrap());
    ret= BZ2_bzCompress(&mut strm, 2 as std::os::raw::c_int);
    if ret == 3 as std::os::raw::c_int {
        BZ2_bzCompressEnd(&mut strm);
        return -(8 as std::os::raw::c_int)
    } else if ret != 4 as std::os::raw::c_int {
        BZ2_bzCompressEnd(&mut strm);
        return ret
    } else {
        /* normal termination */
        *destLen.as_deref_mut().unwrap()= (*destLen.as_deref().unwrap()).wrapping_sub(strm.avail_out);
        BZ2_bzCompressEnd(&mut strm);
        return 0 as std::os::raw::c_int
    };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzBuffToBuffDecompress(mut dest:
                                                        *mut std::os::raw::c_char,
                                                    mut destLen:
                                                        Option<&mut std::os::raw::c_uint>,
                                                    mut source:
                                                        *const std::os::raw::c_char,
                                                    mut sourceLen:
                                                        std::os::raw::c_uint,
                                                    mut small: std::os::raw::c_int,
                                                    mut verbosity:
                                                        std::os::raw::c_int)
 -> std::os::raw::c_int {
    let mut strm: crate::blocksort::bz_stream =
        crate::blocksort::bz_stream{next_in: 0 as *mut std::os::raw::c_char,
                  avail_in: 0,
                  total_in_lo32: 0,
                  total_in_hi32: 0,
                  next_out: 0 as *mut std::os::raw::c_char,
                  avail_out: 0,
                  total_out_lo32: 0,
                  total_out_hi32: 0,
                  state: 0 as *mut std::os::raw::c_void,
                  bzalloc: None,
                  bzfree: None,
                  opaque: 0 as *mut std::os::raw::c_void,};
    let mut ret: std::os::raw::c_int = 0;
    if dest.is_null() || destLen.as_deref().is_none() || source.is_null() ||
           small != 0 as std::os::raw::c_int && small != 1 as std::os::raw::c_int ||
           verbosity < 0 as std::os::raw::c_int || verbosity > 4 as std::os::raw::c_int {
        return -(2 as std::os::raw::c_int)
    }
    strm.bzalloc= None;
    strm.bzfree= None;
    strm.opaque= 0 as *mut std::os::raw::c_void;
    ret= BZ2_bzDecompressInit(&mut strm, verbosity, small);
    if ret != 0 as std::os::raw::c_int { return ret }
    strm.next_in= source;
    strm.next_out= dest;
    strm.avail_in= sourceLen;
    strm.avail_out= (*destLen.as_deref().unwrap());
    ret= BZ2_bzDecompress(&mut strm);
    if ret == 0 as std::os::raw::c_int {
        if strm.avail_out > 0 as std::os::raw::c_int as std::os::raw::c_uint {
            BZ2_bzDecompressEnd(&mut strm);
            return -(7 as std::os::raw::c_int)
        } else { BZ2_bzDecompressEnd(&mut strm); return -(8 as std::os::raw::c_int) }
    } else if ret != 4 as std::os::raw::c_int {
        BZ2_bzDecompressEnd(&mut strm);
        return ret
    } else {
        /* normal termination */
        *destLen.as_deref_mut().unwrap()= (*destLen.as_deref().unwrap()).wrapping_sub(strm.avail_out);
        BZ2_bzDecompressEnd(&mut strm);
        return 0 as std::os::raw::c_int
    };
}
/*---------------------------------------------------*/
/*--
   Code contributed by Yoshioka Tsuneo (tsuneo@rr.iij4u.or.jp)
   to support better zlib compatibility.
   This code is not _officially_ part of libbzip2 (yet);
   I haven't tested it, documented it, or considered the
   threading-safeness of it.
   If this code breaks, please contact both Yoshioka and me.
--*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
/*--
   return version like "0.9.5d, 4-Sept-1999".
--*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzlibVersion() -> *const std::os::raw::c_char {
    return b"1.0.8, 13-Jul-2019\x00" as *const u8 as *const std::os::raw::c_char;
}
/*---------------------------------------------------*/
unsafe extern "C" fn bzopen_or_bzdopen(mut path: *const std::os::raw::c_char,
                                       mut fd: std::os::raw::c_int,
                                       mut mode: *const std::os::raw::c_char,
                                       mut open_mode: std::os::raw::c_int)
 -> *const std::os::raw::c_void 
 /* bzopen: 0, bzdopen:1 */
 {
    let mut bzerr: std::os::raw::c_int = 0; /* binary mode */
    let mut unused: [std::os::raw::c_char; 5000] = [0; 5000];
    let mut blockSize100k: std::os::raw::c_int = 9 as std::os::raw::c_int;
    let mut writing: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut mode2: [std::os::raw::c_char; 10] = [0; 10];
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut bzfp: *mut std::os::raw::c_void = 0 as *mut std::os::raw::c_void;
    let mut verbosity: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut workFactor: std::os::raw::c_int = 30 as std::os::raw::c_int;
    let mut smallMode: std::os::raw::c_int = 0 as std::os::raw::c_int;
    let mut nUnused: std::os::raw::c_int = 0 as std::os::raw::c_int;
    if mode.is_null() {(); return 0 as *mut std::os::raw::c_void }
    while (*mode) != 0 {
        match  (*mode) as std::os::raw::c_int {
            114 => { writing= 0 as std::os::raw::c_int }
            119 => { writing= 1 as std::os::raw::c_int }
            115 => { smallMode= 1 as std::os::raw::c_int }
            _ => {
                if isdigit((*mode) as std::os::raw::c_int) != 0 {
                    blockSize100k= *mode as std::os::raw::c_int - 0x30 as std::os::raw::c_int
                }
            }
        }
        mode= mode.offset(1)
    }
    strcat(mode2.as_mut_ptr(),
           if writing != 0 {
               b"w\x00" as *const u8 as *const std::os::raw::c_char
           } else { b"r\x00" as *const u8 as *const std::os::raw::c_char });
    strcat(mode2.as_mut_ptr(), b"b\x00" as *const u8 as *const std::os::raw::c_char);
    if open_mode == 0 as std::os::raw::c_int {
        if path.is_null() ||
               strcmp(path, b"\x00" as *const u8 as *const std::os::raw::c_char) ==
                   0 as std::os::raw::c_int {
            fp= if writing != 0 { __stdoutp } else { __stdinp }
        } else { fp= fopen(path, mode2.as_mut_ptr()) }
    } else { fp= fdopen(fd, mode2.as_mut_ptr()) }
    if fp.is_null() {(); return 0 as *mut std::os::raw::c_void }
    if writing != 0 {
        /* Guard against total chaos and anarchy -- JRS */
        if blockSize100k < 1 as std::os::raw::c_int {
            blockSize100k= 1 as std::os::raw::c_int
        }
        if blockSize100k > 9 as std::os::raw::c_int {
            blockSize100k= 9 as std::os::raw::c_int
        }
        bzfp=
            BZ2_bzWriteOpen(&mut bzerr, fp, blockSize100k, verbosity,
                            workFactor)
    } else {
        bzfp=
            BZ2_bzReadOpen(&mut bzerr, fp, verbosity, smallMode,
                           unused.as_mut_ptr() as *mut std::os::raw::c_void, nUnused)
    }
    if bzfp.is_null() {();
        if fp != __stdinp && fp != __stdoutp { fclose(fp); }
        return 0 as *mut std::os::raw::c_void
    }
    return bzfp;
}
/*---------------------------------------------------*/
/*--
   open file for read or write.
      ex) bzopen("file","w9")
      case path="" or NULL => use stdin or stdout.
--*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzopen(mut path: *mut /* owning */ std::os::raw::c_char,
                                    mut mode: *const std::os::raw::c_char)
 -> *const std::os::raw::c_void {
    return bzopen_or_bzdopen(path, -(1 as std::os::raw::c_int), mode,
                             0 as std::os::raw::c_int);
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzdopen(mut fd: std::os::raw::c_int,
                                     mut mode: *const std::os::raw::c_char)
 -> *const std::os::raw::c_void {
    return bzopen_or_bzdopen(0 as *const std::os::raw::c_char, fd, mode,
                             1 as std::os::raw::c_int);
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzread(mut b: *mut std::os::raw::c_void,
                                    mut buf: *mut std::os::raw::c_void,
                                    mut len: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut bzerr: std::os::raw::c_int = 0;
    let mut nread: std::os::raw::c_int = 0;
    if (*(b as *mut bzFile)).lastErr == 4 as std::os::raw::c_int {
        return 0 as std::os::raw::c_int
    }
    nread= BZ2_bzRead(&mut bzerr, b, buf, len);
    if bzerr == 0 as std::os::raw::c_int || bzerr == 4 as std::os::raw::c_int {
        return nread
    } else { return -(1 as std::os::raw::c_int) };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzwrite(mut b: Option<&mut std::os::raw::c_void>,
                                     mut buf: *const std::os::raw::c_void,
                                     mut len: std::os::raw::c_int) -> std::os::raw::c_int {
    let mut bzerr: std::os::raw::c_int = 0;
    BZ2_bzWrite(&mut bzerr, core::mem::transmute::<_, *mut crate::std::ffi::c_void>(b.as_deref_mut()), buf, len);
    if bzerr == 0 as std::os::raw::c_int {
        return len
    } else { return -(1 as std::os::raw::c_int) };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzflush(mut b: *const std::os::raw::c_void)
 -> std::os::raw::c_int {
    /* do nothing now... */
    return 0 as std::os::raw::c_int;
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzclose(mut b: *mut std::os::raw::c_void) {
    let mut bzerr: std::os::raw::c_int = 0;
    let mut fp: *mut FILE = 0 as *mut FILE;
    if b.is_null() {(); return }
    fp= (*(b as *mut bzFile)).handle;
    if (*(b as *mut bzFile)).writing != 0 {
        BZ2_bzWriteClose(&mut bzerr, b.as_mut(), 0 as std::os::raw::c_int,
                         None, None);
        if bzerr != 0 as std::os::raw::c_int {
            BZ2_bzWriteClose(None, b.as_mut(), 1 as std::os::raw::c_int,
                             None, None);
        }
    } else { BZ2_bzReadClose(&mut bzerr, b); }
    if fp != __stdinp && fp != __stdoutp { fclose(fp); };
}
/*---------------------------------------------------*/
/*--
   return last error code 
--*/
static mut bzerrorstrings: [*const std::os::raw::c_char; 16] =
    [b"OK\x00" as *const u8 as *const std::os::raw::c_char,
     b"SEQUENCE_ERROR\x00" as *const u8 as *const std::os::raw::c_char,
     b"PARAM_ERROR\x00" as *const u8 as *const std::os::raw::c_char,
     b"MEM_ERROR\x00" as *const u8 as *const std::os::raw::c_char,
     b"DATA_ERROR\x00" as *const u8 as *const std::os::raw::c_char,
     b"DATA_ERROR_MAGIC\x00" as *const u8 as *const std::os::raw::c_char,
     b"IO_ERROR\x00" as *const u8 as *const std::os::raw::c_char,
     b"UNEXPECTED_EOF\x00" as *const u8 as *const std::os::raw::c_char,
     b"OUTBUFF_FULL\x00" as *const u8 as *const std::os::raw::c_char,
     b"CONFIG_ERROR\x00" as *const u8 as *const std::os::raw::c_char,
     b"???\x00" as *const u8 as *const std::os::raw::c_char,
     b"???\x00" as *const u8 as *const std::os::raw::c_char,
     b"???\x00" as *const u8 as *const std::os::raw::c_char,
     b"???\x00" as *const u8 as *const std::os::raw::c_char,
     b"???\x00" as *const u8 as *const std::os::raw::c_char,
     b"???\x00" as *const u8 as *const std::os::raw::c_char];
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzerror(mut b: *const std::os::raw::c_void,
                                     mut errnum: Option<&mut std::os::raw::c_int>)
 -> *const std::os::raw::c_char {
    let mut err: std::os::raw::c_int = (*(b as *mut bzFile)).lastErr;
    if err > 0 as std::os::raw::c_int { err= 0 as std::os::raw::c_int }
    *errnum.as_deref_mut().unwrap()= err;
    return bzerrorstrings[(err * -(1 as std::os::raw::c_int)) as usize];
}
/*-------------------------------------------------------------*/
/*--- end                                           bzlib.c ---*/
/*-------------------------------------------------------------*/

extern "C" {
    
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    static mut __stderrp: *mut FILE;
    
    
    
    
    
    
    
    
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor12;
impl Default for ErasedByPreprocessor12 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor13;
impl Default for ErasedByPreprocessor13 {fn default() -> Self {Self {
}}}

pub type FILE = crate::blocksort::__sFILE;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor14;
impl Default for ErasedByPreprocessor14 {fn default() -> Self {Self {
}}}

pub type Bool = std::os::raw::c_uchar;
pub type UChar = std::os::raw::c_uchar;
pub type Int32 = std::os::raw::c_int;
pub type UInt32 = std::os::raw::c_uint;
pub type UInt16 = std::os::raw::c_ushort;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor15;
impl Default for ErasedByPreprocessor15 {fn default() -> Self {Self {
}}}

/*-------------------------------------------------------------*/
/*--- Compression machinery (not incl block sorting)        ---*/
/*---                                            compress.c ---*/
/*-------------------------------------------------------------*/
/* ------------------------------------------------------------------
   This file is part of bzip2/libbzip2, a program and library for
   lossless, block-sorting data compression.

   bzip2/libbzip2 version 1.0.8 of 13 July 2019
   Copyright (C) 1996-2019 Julian Seward <jseward@acm.org>

   Please read the WARNING, DISCLAIMER and PATENTS sections in the 
   README file.

   This program is released under the terms of the license contained
   in the file LICENSE.
   ------------------------------------------------------------------ */
/* CHANGES
    0.9.0    -- original version.
    0.9.0a/b -- no changes in this file.
    0.9.0c   -- changed setting of nGroups in sendMTFValues() 
                so as to do a bit better on small files
*/
/*---------------------------------------------------*/
/*--- Bit stream I/O                              ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_bsInitWrite(mut s: Option<&mut crate::blocksort::EState>) {
    (*s.as_deref_mut().unwrap()).bsLive= 0 as std::os::raw::c_int;
    (*s.as_deref_mut().unwrap()).bsBuff= 0 as std::os::raw::c_int as UInt32;
}
/*---------------------------------------------------*/
unsafe extern "C" fn bsFinishWrite(mut s: *mut crate::blocksort::EState) {
    while (*s).bsLive > 0 as std::os::raw::c_int {
        *(*s).zbits.offset((*s).numZ as isize) =
            ((*s).bsBuff >> 24 as std::os::raw::c_int) as UChar;
        (*s).numZ+= 1;
        (*s).bsBuff<<= 8 as std::os::raw::c_int;
        (*s).bsLive-= 8 as std::os::raw::c_int
    };
}
/*---------------------------------------------------*/
/*---------------------------------------------------*/
#[inline]
unsafe extern "C" fn bsW(mut s: *mut crate::blocksort::EState, mut n: Int32, mut v: UInt32) {
    while (*s).bsLive >= 8 as std::os::raw::c_int {
        *(*s).zbits.offset((*s).numZ as isize) =
            ((*s).bsBuff >> 24 as std::os::raw::c_int) as UChar;
        (*s).numZ+= 1;
        (*s).bsBuff<<= 8 as std::os::raw::c_int;
        (*s).bsLive-= 8 as std::os::raw::c_int
    }
    (*s).bsBuff;
    (*s).bsLive+= n;
}
/*---------------------------------------------------*/
unsafe extern "C" fn bsPutUInt32(mut s: Option<&mut crate::blocksort::EState>, mut u: UInt32) {
    bsW(core::mem::transmute::<_, *mut crate::blocksort::EState>(s.as_deref_mut()), 8 as std::os::raw::c_int,
        ((u >> 24 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as
            UInt32);
    bsW(core::mem::transmute::<_, *mut crate::blocksort::EState>(s.as_deref_mut()), 8 as std::os::raw::c_int,
        ((u >> 16 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as
            UInt32);
    bsW(core::mem::transmute::<_, *mut crate::blocksort::EState>(s.as_deref_mut()), 8 as std::os::raw::c_int,
        ((u >> 8 as std::os::raw::c_int) as std::os::raw::c_long & 0xff as std::os::raw::c_long) as
            UInt32);
    bsW(core::mem::transmute::<_, *mut crate::blocksort::EState>(s.as_deref_mut()), 8 as std::os::raw::c_int,
        (u as std::os::raw::c_long & 0xff as std::os::raw::c_long) as UInt32);
}
/*---------------------------------------------------*/
unsafe extern "C" fn bsPutUChar(mut s: Option<&mut crate::blocksort::EState>, mut c: UChar) {
    bsW(core::mem::transmute::<_, *mut crate::blocksort::EState>(s.as_deref_mut()), 8 as std::os::raw::c_int, c as UInt32);
}
/*---------------------------------------------------*/
/*--- The back end proper                         ---*/
/*---------------------------------------------------*/
/*---------------------------------------------------*/
unsafe extern "C" fn makeMaps_e(mut s: Option<&mut crate::blocksort::EState>) {
    let mut i: Int32 = 0;
    (*s.as_deref_mut().unwrap()).nInUse= 0 as std::os::raw::c_int;
    i= 0 as std::os::raw::c_int;
    while i < 256 as std::os::raw::c_int {
        if (*s.as_deref().unwrap()).inUse[i as usize] != 0 {
            (*s.as_deref_mut().unwrap()).unseqToSeq[i as usize] = (*s.as_deref().unwrap()).nInUse as UChar;
            (*s.as_deref_mut().unwrap()).nInUse+= 1
        }
        i+= 1
    };
}
/*---------------------------------------------------*/
unsafe extern "C" fn generateMTFValues(mut s: *mut crate::blocksort::EState) {
    let mut yy: [UChar; 256] = [0; 256];
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut zPend: Int32 = 0;
    let mut wr: Int32 = 0;
    let mut EOB: Int32 = 0;
    /* 
      After sorting (eg, here),
         s->arr1 [ 0 .. s->nblock-1 ] holds sorted order,
         and
         ((UChar*)s->arr2) [ 0 .. s->nblock-1 ] 
         holds the original block data.

      The first thing to do is generate the MTF values,
      and put them in
         ((UInt16*)s->arr1) [ 0 .. s->nblock-1 ].
      Because there are strictly fewer or equal MTF values
      than block values, ptr values in this area are overwritten
      with MTF values only when they are no longer needed.

      The final compressed bitstream is generated into the
      area starting at
         (UChar*) (&((UChar*)s->arr2)[s->nblock])

      These storage aliases are set up in bzCompressInit(),
      except for the last one, which is arranged in 
      compressBlock().
   */
    let mut ptr: *mut UInt32 = (*s).ptr;
    let mut block: *mut UChar = (*s).block;
    let mut mtfv: *mut UInt16 = (*s).mtfv;
    makeMaps_e(s.as_mut());
    EOB= (*s).nInUse + 1 as std::os::raw::c_int;
    i= 0 as std::os::raw::c_int;
    while i <= EOB { (*s).mtfFreq[i as usize] = 0 as std::os::raw::c_int; i+= 1 }
    wr= 0 as std::os::raw::c_int;
    zPend= 0 as std::os::raw::c_int;
    i= 0 as std::os::raw::c_int;
    while i < (*s).nInUse { yy[i as usize] = i as UChar; i+= 1 }
    i= 0 as std::os::raw::c_int;
    while i < (*s).nblock {
        let mut ll_i: UChar = 0;
        j=
            (*ptr.offset(i as
                             isize)).wrapping_sub(1 as std::os::raw::c_int as
                                                      std::os::raw::c_uint) as Int32;
        if j < 0 as std::os::raw::c_int { j+= (*s).nblock }
        ll_i= (*s).unseqToSeq[*block.offset(j as isize) as usize];
        if yy[0 as std::os::raw::c_int as usize] as std::os::raw::c_int == ll_i as std::os::raw::c_int
           {
            zPend+= 1
        } else {
            if zPend > 0 as std::os::raw::c_int {
                zPend-= 1;
                while 1 as std::os::raw::c_int as Bool != 0 {
                    if zPend & 1 as std::os::raw::c_int != 0 {
                        *mtfv.offset(wr as isize) =
                            1 as std::os::raw::c_int as UInt16;
                        wr+= 1;
                        (*s).mtfFreq[1 as std::os::raw::c_int as usize] += 1
                    } else {
                        *mtfv.offset(wr as isize) =
                            0 as std::os::raw::c_int as UInt16;
                        wr+= 1;
                        (*s).mtfFreq[0 as std::os::raw::c_int as usize] += 1
                    }
                    if zPend < 2 as std::os::raw::c_int { break ; }
                    zPend= (zPend - 2 as std::os::raw::c_int) / 2 as std::os::raw::c_int
                }
                zPend= 0 as std::os::raw::c_int
            }
            let mut rtmp: UChar = 0;
            let mut ryy_j: *mut UChar = 0 as *mut UChar;
            let mut rll_i: UChar = 0;
            rtmp= yy[1 as std::os::raw::c_int as usize];
            yy[1 as std::os::raw::c_int as usize] = yy[0 as std::os::raw::c_int as usize];
            ryy_j=
                &mut *yy.as_mut_ptr().offset(1 as std::os::raw::c_int as isize) as
                    *mut UChar;
            rll_i= ll_i;
            while rll_i as std::os::raw::c_int != rtmp as std::os::raw::c_int {
                let mut rtmp2: UChar = 0;
                ryy_j= ryy_j.offset(1);
                rtmp2= rtmp;
                rtmp= (*ryy_j);
                *ryy_j= rtmp2
            }
            yy[0 as std::os::raw::c_int as usize] = rtmp;
            j=
                ryy_j.offset_from(&mut *yy.as_mut_ptr().offset(0 as
                                                                            std::os::raw::c_int
                                                                            as
                                                                            isize)
                                               as *mut UChar) as std::os::raw::c_long
                    as Int32;
            *mtfv.offset(wr as isize) = (j + 1 as std::os::raw::c_int) as UInt16;
            wr+= 1;
            (*s).mtfFreq[(j + 1 as std::os::raw::c_int) as usize] += 1
        }
        i+= 1
    }
    if zPend > 0 as std::os::raw::c_int {
        zPend-= 1;
        while 1 as std::os::raw::c_int as Bool != 0 {
            if zPend & 1 as std::os::raw::c_int != 0 {
                *mtfv.offset(wr as isize) = 1 as std::os::raw::c_int as UInt16;
                wr+= 1;
                (*s).mtfFreq[1 as std::os::raw::c_int as usize] += 1
            } else {
                *mtfv.offset(wr as isize) = 0 as std::os::raw::c_int as UInt16;
                wr+= 1;
                (*s).mtfFreq[0 as std::os::raw::c_int as usize] += 1
            }
            if zPend < 2 as std::os::raw::c_int { break ; }
            zPend= (zPend - 2 as std::os::raw::c_int) / 2 as std::os::raw::c_int
        }
        zPend= 0 as std::os::raw::c_int
    }
    *mtfv.offset(wr as isize) = EOB as UInt16;
    wr+= 1;
    (*s).mtfFreq[EOB as usize] += 1;
    (*s).nMTF= wr;
}
unsafe extern "C" fn sendMTFValues(mut s: *mut crate::blocksort::EState) {
    let mut v: Int32 = 0;
    let mut t: Int32 = 0;
    let mut i: Int32 = 0;
    let mut j: Int32 = 0;
    let mut gs: Int32 = 0;
    let mut ge: Int32 = 0;
    let mut totc: Int32 = 0;
    let mut bt: Int32 = 0;
    let mut bc: Int32 = 0;
    let mut iter: Int32 = 0;
    let mut nSelectors: Int32 = 0;
    let mut alphaSize: Int32 = 0;
    let mut minLen: Int32 = 0;
    let mut maxLen: Int32 = 0;
    let mut selCtr: Int32 = 0;
    let mut nGroups: Int32 = 0;
    let mut nBytes: Int32 = 0;
    /*--
   UChar  len [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
   is a global since the decoder also needs it.

   Int32  code[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
   Int32  rfreq[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
   are also globals only used in this proc.
   Made global to keep stack frame size small.
   --*/
    let mut cost: [UInt16; 6] = [0; 6];
    let mut fave: [Int32; 6] = [0; 6];
    let mut mtfv: *mut UInt16 = (*s).mtfv;
    if (*s).verbosity >= 3 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n\x00"
                    as *const u8 as *const std::os::raw::c_char, (*s).nblock,
                (*s).nMTF, (*s).nInUse);
    }
    alphaSize= (*s).nInUse + 2 as std::os::raw::c_int;
    t= 0 as std::os::raw::c_int;
    while t < 6 as std::os::raw::c_int {
        v= 0 as std::os::raw::c_int;
        while v < alphaSize {
            (*s).len[t as usize][v as usize] = 15 as std::os::raw::c_int as UChar;
            v+= 1
        }
        t+= 1
    }
    /*--- Decide how many coding tables to use ---*/
    if !((*s).nMTF > 0 as std::os::raw::c_int) {
        crate::bzlib::BZ2_bz__AssertH__fail(3001 as std::os::raw::c_int);
    }
    if (*s).nMTF < 200 as std::os::raw::c_int {
        nGroups= 2 as std::os::raw::c_int
    } else if (*s).nMTF < 600 as std::os::raw::c_int {
        nGroups= 3 as std::os::raw::c_int
    } else if (*s).nMTF < 1200 as std::os::raw::c_int {
        nGroups= 4 as std::os::raw::c_int
    } else if (*s).nMTF < 2400 as std::os::raw::c_int {
        nGroups= 5 as std::os::raw::c_int
    } else { nGroups= 6 as std::os::raw::c_int }
    /*--- Generate an initial set of coding tables ---*/
    let mut nPart: Int32 = 0;
    let mut remF: Int32 = 0;
    let mut tFreq: Int32 = 0;
    let mut aFreq: Int32 = 0;
    nPart= nGroups;
    remF= (*s).nMTF;
    gs= 0 as std::os::raw::c_int;
    while nPart > 0 as std::os::raw::c_int {
        tFreq= remF / nPart;
        ge= gs - 1 as std::os::raw::c_int;
        aFreq= 0 as std::os::raw::c_int;
        while aFreq < tFreq && ge < alphaSize - 1 as std::os::raw::c_int {
            ge+= 1;
            aFreq+= (*s).mtfFreq[ge as usize]
        }
        if ge > gs && nPart != nGroups && nPart != 1 as std::os::raw::c_int &&
               (nGroups - nPart) % 2 as std::os::raw::c_int == 1 as std::os::raw::c_int {
            aFreq-= (*s).mtfFreq[ge as usize];
            ge-= 1
        }
        if (*s).verbosity >= 3 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n\x00"
                        as *const u8 as *const std::os::raw::c_char, nPart, gs, ge,
                    aFreq,
                    100.0f64 * aFreq as std::os::raw::c_float as std::os::raw::c_double /
                        (*s).nMTF as std::os::raw::c_float as std::os::raw::c_double);
        }
        v= 0 as std::os::raw::c_int;
        while v < alphaSize {
            if v >= gs && v <= ge {
                (*s).len[(nPart - 1 as std::os::raw::c_int) as usize][v as usize] =
                    0 as std::os::raw::c_int as UChar
            } else {
                (*s).len[(nPart - 1 as std::os::raw::c_int) as usize][v as usize] =
                    15 as std::os::raw::c_int as UChar
            }
            v+= 1
        }
        nPart-= 1;
        gs= ge + 1 as std::os::raw::c_int;
        remF-= aFreq
    }
    /*--- 
      Iterate up to BZ_N_ITERS times to improve the tables.
   ---*/
    iter= 0 as std::os::raw::c_int;
    while iter < 4 as std::os::raw::c_int {
        t= 0 as std::os::raw::c_int;
        while t < nGroups { fave[t as usize] = 0 as std::os::raw::c_int; t+= 1 }
        t= 0 as std::os::raw::c_int;
        while t < nGroups {
            v= 0 as std::os::raw::c_int;
            while v < alphaSize {
                (*s).rfreq[t as usize][v as usize] = 0 as std::os::raw::c_int;
                v+= 1
            }
            t+= 1
        }
        /*---
        Set up an auxiliary length table which is used to fast-track
	the common case (nGroups == 6). 
      ---*/
        if nGroups == 6 as std::os::raw::c_int {
            v= 0 as std::os::raw::c_int;
            while v < alphaSize {
                (*s).len_pack[v as usize][0 as std::os::raw::c_int as usize] =
                    (((*s).len[1 as std::os::raw::c_int as usize][v as usize] as
                          std::os::raw::c_int) << 16 as std::os::raw::c_int |
                         (*s).len[0 as std::os::raw::c_int as usize][v as usize] as
                             std::os::raw::c_int) as UInt32;
                (*s).len_pack[v as usize][1 as std::os::raw::c_int as usize] =
                    (((*s).len[3 as std::os::raw::c_int as usize][v as usize] as
                          std::os::raw::c_int) << 16 as std::os::raw::c_int |
                         (*s).len[2 as std::os::raw::c_int as usize][v as usize] as
                             std::os::raw::c_int) as UInt32;
                (*s).len_pack[v as usize][2 as std::os::raw::c_int as usize] =
                    (((*s).len[5 as std::os::raw::c_int as usize][v as usize] as
                          std::os::raw::c_int) << 16 as std::os::raw::c_int |
                         (*s).len[4 as std::os::raw::c_int as usize][v as usize] as
                             std::os::raw::c_int) as UInt32;
                v+= 1
            }
        }
        nSelectors= 0 as std::os::raw::c_int;
        totc= 0 as std::os::raw::c_int;
        gs= 0 as std::os::raw::c_int;
        while 1 as std::os::raw::c_int as Bool != 0 {
            /*--- Set group start & end marks. --*/
            if gs >= (*s).nMTF { break ; }
            ge= gs + 50 as std::os::raw::c_int - 1 as std::os::raw::c_int;
            if ge >= (*s).nMTF { ge= (*s).nMTF - 1 as std::os::raw::c_int }
            /*-- 
            Calculate the cost of this group as coded
            by each of the coding tables.
         --*/
            t= 0 as std::os::raw::c_int;
            while t < nGroups {
                cost[t as usize] = 0 as std::os::raw::c_int as UInt16;
                t+= 1
            }
            if nGroups == 6 as std::os::raw::c_int &&
                   50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {
                /*--- fast track the common case ---*/
                let mut cost01: UInt32 = 0;
                let mut cost23: UInt32 = 0;
                let mut cost45: UInt32 = 0;
                let mut icv: UInt16 = 0;
                cost45= 0 as std::os::raw::c_int as UInt32;
                cost23= cost45;
                cost01= cost23;
                icv= *mtfv.offset((gs + 0 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 1 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 2 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 3 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 4 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 5 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 6 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 7 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 8 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 9 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 10 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 11 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 12 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 13 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 14 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 15 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 16 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 17 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 18 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 19 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 20 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 21 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 22 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 23 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 24 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 25 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 26 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 27 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 28 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 29 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 30 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 31 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 32 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 33 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 34 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 35 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 36 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 37 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 38 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 39 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 40 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 41 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 42 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 43 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 44 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 45 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 46 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 47 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 48 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                icv= *mtfv.offset((gs + 49 as std::os::raw::c_int) as isize);
                cost01=
                    (cost01 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][0
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost23=
                    (cost23 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][1
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost45=
                    (cost45 as
                         std::os::raw::c_uint).wrapping_add((*s).len_pack[icv as
                                                                      usize][2
                                                                                 as
                                                                                 std::os::raw::c_int
                                                                                 as
                                                                                 usize])
                        as UInt32 as UInt32;
                cost[0 as std::os::raw::c_int as usize] =
                    (cost01 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as
                        UInt16;
                cost[1 as std::os::raw::c_int as usize] =
                    (cost01 >> 16 as std::os::raw::c_int) as UInt16;
                cost[2 as std::os::raw::c_int as usize] =
                    (cost23 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as
                        UInt16;
                cost[3 as std::os::raw::c_int as usize] =
                    (cost23 >> 16 as std::os::raw::c_int) as UInt16;
                cost[4 as std::os::raw::c_int as usize] =
                    (cost45 & 0xffff as std::os::raw::c_int as std::os::raw::c_uint) as
                        UInt16;
                cost[5 as std::os::raw::c_int as usize] =
                    (cost45 >> 16 as std::os::raw::c_int) as UInt16
            } else {
                /*--- slow version which correctly handles all situations ---*/
                i= gs;
                while i <= ge {
                    let mut icv_0: UInt16 = *mtfv.offset(i as isize);
                    t= 0 as std::os::raw::c_int;
                    while t < nGroups {
                        cost[t as usize] =
                            (cost[t as usize] as std::os::raw::c_int +
                                 (*s).len[t as usize][icv_0 as usize] as
                                     std::os::raw::c_int) as UInt16;
                        t+= 1
                    }
                    i+= 1
                }
            }
            /*-- 
            Find the coding table which is best for this group,
            and record its identity in the selector table.
         --*/
            bc= 999999999 as std::os::raw::c_int;
            bt= -(1 as std::os::raw::c_int);
            t= 0 as std::os::raw::c_int;
            while t < nGroups {
                if (cost[t as usize] as std::os::raw::c_int) < bc {
                    bc= cost[t as usize] as Int32;
                    bt= t
                }
                t+= 1
            }
            totc+= bc;
            fave[bt as usize] += 1;
            (*s).selector[nSelectors as usize] = bt as UChar;
            nSelectors+= 1;
            /*-- 
            Increment the symbol frequencies for the selected table.
          --*/
            if nGroups == 6 as std::os::raw::c_int &&
                   50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {
                /*--- fast track the common case ---*/
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 0 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 1 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 2 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 3 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 4 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 5 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 6 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 7 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 8 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 9 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 10 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 11 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 12 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 13 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 14 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 15 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 16 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 17 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 18 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 19 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 20 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 21 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 22 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 23 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 24 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 25 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 26 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 27 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 28 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 29 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 30 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 31 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 32 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 33 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 34 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 35 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 36 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 37 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 38 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 39 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 40 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 41 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 42 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 43 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 44 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 45 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 46 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 47 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 48 as std::os::raw::c_int) as
                                                       isize) as usize] += 1;
                (*s).rfreq[bt as
                               usize][*mtfv.offset((gs + 49 as std::os::raw::c_int) as
                                                       isize) as usize] += 1
            } else {
                /*--- slow version which correctly handles all situations ---*/
                i= gs;
                while i <= ge {
                    (*s).rfreq[bt as usize][*mtfv.offset(i as isize) as usize]
                        += 1;
                    i+= 1
                }
            }
            gs= ge + 1 as std::os::raw::c_int
        }
        if (*s).verbosity >= 3 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"      pass %d: size is %d, grp uses are \x00" as
                        *const u8 as *const std::os::raw::c_char,
                    iter + 1 as std::os::raw::c_int, totc / 8 as std::os::raw::c_int);
            t= 0 as std::os::raw::c_int;
            while t < nGroups {
                fprintf(__stderrp,
                        b"%d \x00" as *const u8 as *const std::os::raw::c_char,
                        fave[t as usize]);
                t+= 1
            }
            fprintf(__stderrp, b"\n\x00" as *const u8 as *const std::os::raw::c_char);
        }
        /*--
        Recompute the tables based on the accumulated frequencies.
      --*/
      /* maxLen was changed from 20 to 17 in bzip2-1.0.3.  See 
         comment in huffman.c for details. */
        t= 0 as std::os::raw::c_int;
        while t < nGroups {
            crate::huffman::BZ2_hbMakeCodeLengths(&mut *(*(*s).len.as_mut_ptr().offset(t as
                                                                           isize)).as_mut_ptr().offset(0
                                                                                                           as
                                                                                                           std::os::raw::c_int
                                                                                                           as
                                                                                                           isize),
                                  &mut *(*(*s).rfreq.as_mut_ptr().offset(t as
                                                                             isize)).as_mut_ptr().offset(0
                                                                                                             as
                                                                                                             std::os::raw::c_int
                                                                                                             as
                                                                                                             isize),
                                  alphaSize, 17 as std::os::raw::c_int);
            t+= 1
        }
        iter+= 1
    }
    if !(nGroups < 8 as std::os::raw::c_int) {
        crate::bzlib::BZ2_bz__AssertH__fail(3002 as std::os::raw::c_int);
    }
    if !(nSelectors < 32768 as std::os::raw::c_int &&
             nSelectors <=
                 2 as std::os::raw::c_int + 900000 as std::os::raw::c_int / 50 as std::os::raw::c_int)
       {
        crate::bzlib::BZ2_bz__AssertH__fail(3003 as std::os::raw::c_int);
    }
    /*--- Compute MTF values for the selectors. ---*/
    let mut pos: [UChar; 6] = [0; 6];
    let mut ll_i: UChar = 0;
    let mut tmp2: UChar = 0;
    let mut tmp: UChar = 0;
    i= 0 as std::os::raw::c_int;
    while i < nGroups { pos[i as usize] = i as UChar; i+= 1 }
    i= 0 as std::os::raw::c_int;
    while i < nSelectors {
        ll_i= (*s).selector[i as usize];
        j= 0 as std::os::raw::c_int;
        tmp= pos[j as usize];
        while ll_i as std::os::raw::c_int != tmp as std::os::raw::c_int {
            j+= 1;
            tmp2= tmp;
            tmp= pos[j as usize];
            pos[j as usize] = tmp2
        }
        pos[0 as std::os::raw::c_int as usize] = tmp;
        (*s).selectorMtf[i as usize] = j as UChar;
        i+= 1
    }
    /*--- Assign actual codes for the tables. --*/
    t= 0 as std::os::raw::c_int;
    while t < nGroups {
        minLen= 32 as std::os::raw::c_int;
        maxLen= 0 as std::os::raw::c_int;
        i= 0 as std::os::raw::c_int;
        while i < alphaSize {
            if (*s).len[t as usize][i as usize] as std::os::raw::c_int > maxLen {
                maxLen= (*s).len[t as usize][i as usize] as Int32
            }
            if ((*s).len[t as usize][i as usize] as std::os::raw::c_int) < minLen {
                minLen= (*s).len[t as usize][i as usize] as Int32
            }
            i+= 1
        }
        if maxLen > 17 as std::os::raw::c_int {
            crate::bzlib::BZ2_bz__AssertH__fail(3004 as std::os::raw::c_int);
        }
        if minLen < 1 as std::os::raw::c_int {
            crate::bzlib::BZ2_bz__AssertH__fail(3005 as std::os::raw::c_int);
        }
        crate::huffman::BZ2_hbAssignCodes(&mut *(*(*s).code.as_mut_ptr().offset(t as
                                                                    isize)).as_mut_ptr().offset(0
                                                                                                    as
                                                                                                    std::os::raw::c_int
                                                                                                    as
                                                                                                    isize),
                          &mut *(*(*s).len.as_mut_ptr().offset(t as
                                                                   isize)).as_mut_ptr().offset(0
                                                                                                   as
                                                                                                   std::os::raw::c_int
                                                                                                   as
                                                                                                   isize),
                          minLen, maxLen, alphaSize);
        t+= 1
    }
    /*--- Transmit the mapping table. ---*/
    let mut inUse16: [Bool; 16] = [0; 16];
    i= 0 as std::os::raw::c_int;
    while i < 16 as std::os::raw::c_int {
        inUse16[i as usize] = 0 as std::os::raw::c_int as Bool;
        j= 0 as std::os::raw::c_int;
        while j < 16 as std::os::raw::c_int {
            if (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] != 0 {
                inUse16[i as usize] = 1 as std::os::raw::c_int as Bool
            }
            j+= 1
        }
        i+= 1
    }
    nBytes= (*s).numZ;
    i= 0 as std::os::raw::c_int;
    while i < 16 as std::os::raw::c_int {
        if inUse16[i as usize] != 0 {
            bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);
        } else { bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32); }
        i+= 1
    }
    i= 0 as std::os::raw::c_int;
    while i < 16 as std::os::raw::c_int {
        if inUse16[i as usize] != 0 {
            j= 0 as std::os::raw::c_int;
            while j < 16 as std::os::raw::c_int {
                if (*s).inUse[(i * 16 as std::os::raw::c_int + j) as usize] != 0 {
                    bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);
                } else {
                    bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);
                }
                j+= 1
            }
        }
        i+= 1
    }
    if (*s).verbosity >= 3 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"      bytes: mapping %d, \x00" as *const u8 as
                    *const std::os::raw::c_char, (*s).numZ - nBytes);
    }
    /*--- Now the selectors. ---*/
    nBytes= (*s).numZ;
    bsW(s, 3 as std::os::raw::c_int, nGroups as UInt32);
    bsW(s, 15 as std::os::raw::c_int, nSelectors as UInt32);
    i= 0 as std::os::raw::c_int;
    while i < nSelectors {
        j= 0 as std::os::raw::c_int;
        while j < (*s).selectorMtf[i as usize] as std::os::raw::c_int {
            bsW(s, 1 as std::os::raw::c_int, 1 as std::os::raw::c_int as UInt32);
            j+= 1
        }
        bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);
        i+= 1
    }
    if (*s).verbosity >= 3 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"selectors %d, \x00" as *const u8 as *const std::os::raw::c_char,
                (*s).numZ - nBytes);
    }
    /*--- Now the coding tables. ---*/
    nBytes= (*s).numZ;
    t= 0 as std::os::raw::c_int;
    while t < nGroups {
        let mut curr: Int32 =
            (*s).len[t as usize][0 as std::os::raw::c_int as usize] as Int32;
        bsW(s, 5 as std::os::raw::c_int, curr as UInt32);
        i= 0 as std::os::raw::c_int;
        while i < alphaSize {
            while curr < (*s).len[t as usize][i as usize] as std::os::raw::c_int {
                bsW(s, 2 as std::os::raw::c_int, 2 as std::os::raw::c_int as UInt32);
                curr+= 1
                /* 10 */
            }
            while curr > (*s).len[t as usize][i as usize] as std::os::raw::c_int {
                bsW(s, 2 as std::os::raw::c_int, 3 as std::os::raw::c_int as UInt32);
                curr-= 1
                /* 11 */
            }
            bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);
            i+= 1
        }
        t+= 1
    }
    if (*s).verbosity >= 3 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"code lengths %d, \x00" as *const u8 as *const std::os::raw::c_char,
                (*s).numZ - nBytes);
    }
    /*--- And finally, the block data proper ---*/
    nBytes= (*s).numZ;
    selCtr= 0 as std::os::raw::c_int;
    gs= 0 as std::os::raw::c_int;
    while 1 as std::os::raw::c_int as Bool != 0 {
        if gs >= (*s).nMTF { break ; }
        ge= gs + 50 as std::os::raw::c_int - 1 as std::os::raw::c_int;
        if ge >= (*s).nMTF { ge= (*s).nMTF - 1 as std::os::raw::c_int }
        if !(((*s).selector[selCtr as usize] as std::os::raw::c_int) < nGroups) {
            crate::bzlib::BZ2_bz__AssertH__fail(3006 as std::os::raw::c_int);
        }
        if nGroups == 6 as std::os::raw::c_int &&
               50 as std::os::raw::c_int == ge - gs + 1 as std::os::raw::c_int {
            /*--- fast track the common case ---*/
            let mut mtfv_i: UInt16 = 0;
            let mut s_len_sel_selCtr: *mut UChar =
                &mut *(*(*s).len.as_mut_ptr().offset(*(*s).selector.as_mut_ptr().offset(selCtr
                                                                                            as
                                                                                            isize)
                                                         as
                                                         isize)).as_mut_ptr().offset(0
                                                                                         as
                                                                                         std::os::raw::c_int
                                                                                         as
                                                                                         isize)
                    as *mut UChar;
            let mut s_code_sel_selCtr: *mut Int32 =
                &mut *(*(*s).code.as_mut_ptr().offset(*(*s).selector.as_mut_ptr().offset(selCtr
                                                                                             as
                                                                                             isize)
                                                          as
                                                          isize)).as_mut_ptr().offset(0
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          isize)
                    as *mut Int32;
            mtfv_i= *mtfv.offset((gs + 0 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 1 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 2 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 3 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 4 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 5 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 6 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 7 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 8 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 9 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 10 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 11 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 12 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 13 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 14 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 15 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 16 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 17 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 18 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 19 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 20 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 21 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 22 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 23 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 24 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 25 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 26 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 27 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 28 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 29 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 30 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 31 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 32 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 33 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 34 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 35 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 36 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 37 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 38 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 39 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 40 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 41 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 42 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 43 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 44 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 45 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 46 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 47 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 48 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
            mtfv_i= *mtfv.offset((gs + 49 as std::os::raw::c_int) as isize);
            bsW(s, *s_len_sel_selCtr.offset(mtfv_i as isize) as Int32,
                *s_code_sel_selCtr.offset(mtfv_i as isize) as UInt32);
        } else {
            /*--- slow version which correctly handles all situations ---*/
            i= gs;
            while i <= ge {
                bsW(s,
                    (*s).len[(*s).selector[selCtr as usize] as
                                 usize][*mtfv.offset(i as isize) as usize] as
                        Int32,
                    (*s).code[(*s).selector[selCtr as usize] as
                                  usize][*mtfv.offset(i as isize) as usize] as
                        UInt32);
                i+= 1
            }
        }
        gs= ge + 1 as std::os::raw::c_int;
        selCtr+= 1
    }
    if !(selCtr == nSelectors) { crate::bzlib::BZ2_bz__AssertH__fail(3007 as std::os::raw::c_int); }
    if (*s).verbosity >= 3 as std::os::raw::c_int {
        fprintf(__stderrp,
                b"codes %d\n\x00" as *const u8 as *const std::os::raw::c_char,
                (*s).numZ - nBytes);
    };
}
/*---------------------------------------------------*/
#[no_mangle]
pub unsafe extern "C" fn BZ2_compressBlock(mut s: *mut crate::blocksort::EState,
                                           mut is_last_block: Bool) {
    if (*s).nblock > 0 as std::os::raw::c_int {
        (*s).blockCRC= !(*s).blockCRC;
        (*s).combinedCRC=
            (*s).combinedCRC << 1 as std::os::raw::c_int |
                (*s).combinedCRC >> 31 as std::os::raw::c_int;
        (*s).combinedCRC^= (*s).blockCRC;
        if (*s).blockNo > 1 as std::os::raw::c_int { (*s).numZ= 0 as std::os::raw::c_int }
        if (*s).verbosity >= 2 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d\n\x00"
                        as *const u8 as *const std::os::raw::c_char, (*s).blockNo,
                    (*s).blockCRC, (*s).combinedCRC, (*s).nblock);
        }
        crate::blocksort::BZ2_blockSort(s);
    }
    (*s).zbits=
        &mut *((*s).arr2 as *mut UChar).offset((*s).nblock as isize) as
            *mut UChar;
    /*-- If this is the first block, create the stream header. --*/
    if (*s).blockNo == 1 as std::os::raw::c_int {
        BZ2_bsInitWrite(s.as_mut());
        bsPutUChar(s.as_mut(), 0x42 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x5a as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x68 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), (0x30 as std::os::raw::c_int + (*s).blockSize100k) as UChar);
    }
    if (*s).nblock > 0 as std::os::raw::c_int {
        bsPutUChar(s.as_mut(), 0x31 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x41 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x59 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x26 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x53 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x59 as std::os::raw::c_int as UChar);
        /*-- Now the block's CRC, so it is in a known place. --*/
        bsPutUInt32(s.as_mut(), (*s).blockCRC);
        /*-- 
         Now a single bit indicating (non-)randomisation. 
         As of version 0.9.5, we use a better sorting algorithm
         which makes randomisation unnecessary.  So always set
         the randomised bit to 'no'.  Of course, the decoder
         still needs to be able to handle randomised blocks
         so as to maintain backwards compatibility with
         older versions of bzip2.
      --*/
        bsW(s, 1 as std::os::raw::c_int, 0 as std::os::raw::c_int as UInt32);
        bsW(s, 24 as std::os::raw::c_int, (*s).origPtr as UInt32);
        generateMTFValues(s);
        sendMTFValues(s);
    }
    /*-- If this is the last block, add the stream trailer. --*/
    if is_last_block != 0 {
        bsPutUChar(s.as_mut(), 0x17 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x72 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x45 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x38 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x50 as std::os::raw::c_int as UChar);
        bsPutUChar(s.as_mut(), 0x90 as std::os::raw::c_int as UChar);
        bsPutUInt32(s.as_mut(), (*s).combinedCRC);
        if (*s).verbosity >= 2 as std::os::raw::c_int {
            fprintf(__stderrp,
                    b"    final combined CRC = 0x%08x\n   \x00" as *const u8
                        as *const std::os::raw::c_char, (*s).combinedCRC);
        }
        bsFinishWrite(s);
    };
}
/*-------------------------------------------------------------*/
/*--- end                                        compress.c ---*/
/*-------------------------------------------------------------*/
