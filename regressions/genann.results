Solving genann::genann_free with precision 1... ✅
Solving example4::load_data with precision 1... ✅
Solving genann::genann_init with precision 1... ✅
Solving genann::genann_copy with precision 1... ✅
Solving example1::main_0 with precision 1... ❌
Solving example2::main_0 with precision 1... ❌
Solving example3::main_0 with precision 1... ❌
Solving example4::main_0 with precision 1... ❌
Solving genann::genann_act_sigmoid with precision 1... ✅
Solving genann::genann_act_sigmoid_cached with precision 1... ✅
Solving genann::genann_act_threshold with precision 1... ✅
Solving genann::genann_act_linear with precision 1... ✅
Solving genann::genann_read with precision 1... ✅
Solving genann::genann_randomize with precision 1... ✅
Solving genann::genann_run with precision 1... ✅
Solving genann::genann_train with precision 1... ❌
Solving genann::genann_write with precision 1... ✅
Solving test::basic with precision 1... ❌
Solving test::xor with precision 1... ❌
Solving test::backprop with precision 1... ❌
Solving test::train_and with precision 1... ❌
Solving test::train_or with precision 1... ❌
Solving test::train_xor with precision 1... ❌
Solving test::persist with precision 1... ✅
Solving test::copy with precision 1... ✅
Solving test::sigmoid with precision 1... ✅
Solving test::main_0 with precision 1... ✅
genann::genann_free: (&move) -> _
example4::load_data: () -> _
genann::genann_init: (_, _, _, _) -> &move
genann::genann_copy: (&) -> &move
example1::main_0: (_, &any) -> _
example2::main_0: (_, &any) -> _
example3::main_0: (_, &any) -> _
example4::main_0: (_, &any) -> _
genann::genann_act_sigmoid: (_) -> _
genann::genann_act_sigmoid_cached: (_) -> _
genann::genann_act_threshold: (_) -> _
genann::genann_act_linear: (_) -> _
genann::genann_read: (&) -> &move
genann::genann_randomize: (&uniq  ↓ &uniq ) -> _
genann::genann_run: (&uniq  ↓ &uniq , &) -> &
genann::genann_train: (&any, &any, &any, _) -> _
genann::genann_write: (&, &) -> _
test::basic: () -> _
test::xor: () -> _
test::backprop: () -> _
test::train_and: () -> _
test::train_or: () -> _
test::train_xor: () -> _
test::persist: () -> _
test::copy: () -> _
test::sigmoid: () -> _
test::main_0: (_, &) -> _
Solving genann::genann_free with precision 2... ✅
Solving example4::load_data with precision 2... ❌
Solving genann::genann_init with precision 2... ✅
Solving genann::genann_copy with precision 2... ❌
Solving example1::main_0 with precision 2... ❌
Solving example2::main_0 with precision 2... ❌
Solving example3::main_0 with precision 2... ❌
Solving example4::main_0 with precision 2... ❌
Solving genann::genann_act_sigmoid with precision 2... ✅
Solving genann::genann_act_sigmoid_cached with precision 2... ✅
Solving genann::genann_act_threshold with precision 2... ✅
Solving genann::genann_act_linear with precision 2... ✅
Solving genann::genann_read with precision 2... ✅
Solving genann::genann_randomize with precision 2... ❌
Solving genann::genann_run with precision 2... ✅
Solving genann::genann_train with precision 2... ❌
Solving genann::genann_write with precision 2... ✅
Solving test::basic with precision 2... ❌
Solving test::xor with precision 2... ❌
Solving test::backprop with precision 2... ❌
Solving test::train_and with precision 2... ❌
Solving test::train_or with precision 2... ❌
Solving test::train_xor with precision 2... ❌
Solving test::persist with precision 2... ✅
Solving test::copy with precision 2... ✅
Solving test::sigmoid with precision 2... ✅
Solving test::main_0 with precision 2... ✅
genann::genann_free: (&move &move &move &move) -> _
example4::load_data: () -> _
genann::genann_init: (_, _, _, _) -> &move &move &move &move
genann::genann_copy: (& & & &) -> &move &move &move &move
example1::main_0: (_, &any &any) -> _
example2::main_0: (_, &any &any) -> _
example3::main_0: (_, &any &any) -> _
example4::main_0: (_, &any &any) -> _
genann::genann_act_sigmoid: (_) -> _
genann::genann_act_sigmoid_cached: (_) -> _
genann::genann_act_threshold: (_) -> _
genann::genann_act_linear: (_) -> _
genann::genann_read: (& & & & & & &) -> &move &move &move &move
genann::genann_randomize: (&uniq & & & ↓ &uniq &move &move &move) -> _
genann::genann_run: (&uniq & & & ↓ &uniq & & &, &) -> &
genann::genann_train: (&any &any &any &any, &any, &any, _) -> _
genann::genann_write: (& & & &, & & & & & & &) -> _
test::basic: () -> _
test::xor: () -> _
test::backprop: () -> _
test::train_and: () -> _
test::train_or: () -> _
test::train_xor: () -> _
test::persist: () -> _
test::copy: () -> _
test::sigmoid: () -> _
test::main_0: (_, & &) -> _
Solving genann::genann_free with precision 3... ✅
Solving example4::load_data with precision 2... ❌
Solving genann::genann_init with precision 3... ✅
Solving genann::genann_copy with precision 2... ❌
Solving example1::main_0 with precision 1... ❌
Solving example2::main_0 with precision 1... ❌
Solving example3::main_0 with precision 1... ❌
Solving example4::main_0 with precision 1... ❌
Solving genann::genann_act_sigmoid with precision 3... ✅
Solving genann::genann_act_sigmoid_cached with precision 3... ✅
Solving genann::genann_act_threshold with precision 3... ✅
Solving genann::genann_act_linear with precision 3... ✅
Solving genann::genann_read with precision 3... ✅
Solving genann::genann_randomize with precision 2... ❌
Solving genann::genann_run with precision 3... ✅
Solving genann::genann_train with precision 1... ❌
Solving genann::genann_write with precision 3... ✅
Solving test::basic with precision 1... ❌
Solving test::xor with precision 1... ❌
Solving test::backprop with precision 1... ❌
Solving test::train_and with precision 1... ❌
Solving test::train_or with precision 1... ❌
Solving test::train_xor with precision 1... ❌
Solving test::persist with precision 3... ✅
Solving test::copy with precision 3... ✅
Solving test::sigmoid with precision 3... ✅
Solving test::main_0 with precision 3... ✅
genann::genann_free: (&move &move &move &move) -> _
example4::load_data: () -> _
genann::genann_init: (_, _, _, _) -> &move &move &move &move
genann::genann_copy: (& & & &) -> &move &move &move &move
example1::main_0: (_, &any) -> _
example2::main_0: (_, &any) -> _
example3::main_0: (_, &any) -> _
example4::main_0: (_, &any) -> _
genann::genann_act_sigmoid: (_) -> _
genann::genann_act_sigmoid_cached: (_) -> _
genann::genann_act_threshold: (_) -> _
genann::genann_act_linear: (_) -> _
genann::genann_read: (& & & & & & &) -> &move &move &move &move
genann::genann_randomize: (&uniq & & & ↓ &uniq &move &move &move) -> _
genann::genann_run: (&uniq & & & ↓ &uniq & & &, &) -> &
genann::genann_train: (&any, &any, &any, _) -> _
genann::genann_write: (& & & &, & & & & & & &) -> _
test::basic: () -> _
test::xor: () -> _
test::backprop: () -> _
test::train_and: () -> _
test::train_or: () -> _
test::train_xor: () -> _
test::persist: () -> _
test::copy: () -> _
test::sigmoid: () -> _
test::main_0: (_, & &) -> _
Solving genann::genann_free with precision 3... ✅
Solving example4::load_data with precision 1... ✅
Solving genann::genann_init with precision 3... ✅
Solving genann::genann_copy with precision 1... ✅
Solving genann::genann_act_sigmoid with precision 3... ✅
Solving genann::genann_act_sigmoid_cached with precision 3... ✅
Solving genann::genann_act_threshold with precision 3... ✅
Solving genann::genann_act_linear with precision 3... ✅
Solving genann::genann_read with precision 3... ✅
Solving genann::genann_randomize with precision 1... ✅
Solving genann::genann_run with precision 3... ✅
Solving genann::genann_write with precision 3... ✅
Solving test::persist with precision 3... ✅
Solving test::copy with precision 3... ✅
Solving test::sigmoid with precision 3... ✅
Solving test::main_0 with precision 3... ✅
genann::genann_free: (&move &move &move &move) -> _
example4::load_data: () -> _
genann::genann_init: (_, _, _, _) -> &move &move &move &move
genann::genann_copy: (&) -> &move
example1::main_0: (_, _) -> _
example2::main_0: (_, _) -> _
example3::main_0: (_, _) -> _
example4::main_0: (_, _) -> _
genann::genann_act_sigmoid: (_) -> _
genann::genann_act_sigmoid_cached: (_) -> _
genann::genann_act_threshold: (_) -> _
genann::genann_act_linear: (_) -> _
genann::genann_read: (& & & & & & &) -> &move &move &move &move
genann::genann_randomize: (&uniq  ↓ &uniq ) -> _
genann::genann_run: (&uniq & & & ↓ &uniq & & &, &) -> &
genann::genann_train: (_, _, _, _) -> _
genann::genann_write: (& & & &, & & & & & & &) -> _
test::basic: () -> _
test::xor: () -> _
test::backprop: () -> _
test::train_and: () -> _
test::train_or: () -> _
test::train_xor: () -> _
test::persist: () -> _
test::copy: () -> _
test::sigmoid: () -> _
test::main_0: (_, & &) -> _
Solving genann::genann_free with precision 3... ✅
Solving example4::load_data with precision 1... ✅
Solving genann::genann_init with precision 3... ✅
Solving genann::genann_copy with precision 1... ✅
Solving genann::genann_act_sigmoid with precision 3... ✅
Solving genann::genann_act_sigmoid_cached with precision 3... ✅
Solving genann::genann_act_threshold with precision 3... ✅
Solving genann::genann_act_linear with precision 3... ✅
Solving genann::genann_read with precision 3... ✅
Solving genann::genann_randomize with precision 1... ✅
Solving genann::genann_run with precision 3... ✅
Solving genann::genann_write with precision 3... ✅
Solving test::persist with precision 3... ✅
Solving test::copy with precision 3... ✅
Solving test::sigmoid with precision 3... ✅
Solving test::main_0 with precision 3... ✅
genann::genann_free: (&move &move &move &move) -> _
example4::load_data: () -> _
genann::genann_init: (_, _, _, _) -> &move &move &move &move
genann::genann_copy: (&) -> &move
example1::main_0: (_, _) -> _
example2::main_0: (_, _) -> _
example3::main_0: (_, _) -> _
example4::main_0: (_, _) -> _
genann::genann_act_sigmoid: (_) -> _
genann::genann_act_sigmoid_cached: (_) -> _
genann::genann_act_threshold: (_) -> _
genann::genann_act_linear: (_) -> _
genann::genann_read: (& & & & & & &) -> &move &move &move &move
genann::genann_randomize: (&uniq  ↓ &uniq ) -> _
genann::genann_run: (&uniq & & & ↓ &uniq & & &, &) -> &
genann::genann_train: (_, _, _, _) -> _
genann::genann_write: (& & & &, & & & & & & &) -> _
test::basic: () -> _
test::xor: () -> _
test::backprop: () -> _
test::train_and: () -> _
test::train_or: () -> _
test::train_xor: () -> _
test::persist: () -> _
test::copy: () -> _
test::sigmoid: () -> _
test::main_0: (_, & &) -> _
Solving genann::genann_free with precision 3... ✅
Solving example4::load_data with precision 1... ✅
Solving genann::genann_init with precision 3... ✅
Solving genann::genann_copy with precision 1... ✅
Solving genann::genann_act_sigmoid with precision 3... ✅
Solving genann::genann_act_sigmoid_cached with precision 3... ✅
Solving genann::genann_act_threshold with precision 3... ✅
Solving genann::genann_act_linear with precision 3... ✅
Solving genann::genann_read with precision 3... ✅
Solving genann::genann_randomize with precision 1... ✅
Solving genann::genann_run with precision 3... ✅
Solving genann::genann_write with precision 3... ✅
Solving test::persist with precision 3... ✅
Solving test::copy with precision 3... ✅
Solving test::sigmoid with precision 3... ✅
Solving test::main_0 with precision 3... ✅
genann::genann_free: (&move &move &move &move) -> _
example4::load_data: () -> _
genann::genann_init: (_, _, _, _) -> &move &move &move &move
genann::genann_copy: (&) -> &move
example1::main_0: (_, _) -> _
example2::main_0: (_, _) -> _
example3::main_0: (_, _) -> _
example4::main_0: (_, _) -> _
genann::genann_act_sigmoid: (_) -> _
genann::genann_act_sigmoid_cached: (_) -> _
genann::genann_act_threshold: (_) -> _
genann::genann_act_linear: (_) -> _
genann::genann_read: (& & & & & & &) -> &move &move &move &move
genann::genann_randomize: (&uniq  ↓ &uniq ) -> _
genann::genann_run: (&uniq & & & ↓ &uniq & & &, &) -> &
genann::genann_train: (_, _, _, _) -> _
genann::genann_write: (& & & &, & & & & & & &) -> _
test::basic: () -> _
test::xor: () -> _
test::backprop: () -> _
test::train_and: () -> _
test::train_or: () -> _
test::train_xor: () -> _
test::persist: () -> _
test::copy: () -> _
test::sigmoid: () -> _
test::main_0: (_, & &) -> _
@DefId(0:7 ~ c2rust_lib[1043]::example1::main_0)
bb0:
  _7 = const b"GENANN example 1.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[0])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[1])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[2])
  _3 = example1::printf(move _4) -> bb1
  using: _4@Mir(bb0[3])
bb1:
  _12 = const b"Train a small ANN to the XOR function using backpropagation.\n\x00"
  using: 
  _11 = &raw const (*_12)
  using: _12@Mir(bb1[0])
  _10 = move _11 as *const u8 (Pointer(ArrayToPointer))
  using: _11@Mir(bb1[1])
  _9 = move _10 as *const i8 (PtrToPtr)
  using: _10@Mir(bb1[2])
  _8 = example1::printf(move _9) -> bb2
  using: _9@Mir(bb1[3])
bb2:
  _15 = const 0f64
  using: 
  _16 = const 0f64
  using: 
  _14 = [move _15, move _16]
  using: _15@Mir(bb2[0]), _16@Mir(bb2[1])
  _18 = const 0f64
  using: 
  _19 = const 1f64
  using: 
  _17 = [move _18, move _19]
  using: _18@Mir(bb2[3]), _19@Mir(bb2[4])
  _21 = const 1f64
  using: 
  _22 = const 0f64
  using: 
  _20 = [move _21, move _22]
  using: _21@Mir(bb2[6]), _22@Mir(bb2[7])
  _24 = const 1f64
  using: 
  _25 = const 1f64
  using: 
  _23 = [move _24, move _25]
  using: _24@Mir(bb2[9]), _25@Mir(bb2[10])
  _13 = [move _14, move _17, move _20, move _23]
  using: _14@Mir(bb2[2]), _17@Mir(bb2[5]), _20@Mir(bb2[8]), _23@Mir(bb2[11])
  _27 = const 0f64
  using: 
  _28 = const 1f64
  using: 
  _29 = const 1f64
  using: 
  _30 = const 0f64
  using: 
  _26 = [move _27, move _28, move _29, move _30]
  using: _27@Mir(bb2[13]), _28@Mir(bb2[14]), _29@Mir(bb2[15]), _30@Mir(bb2[16])
  _31 = const 0_i32
  using: 
  _33 = const 2_i32
  using: 
  _34 = const 1_i32
  using: 
  _35 = const 2_i32
  using: 
  _36 = const 1_i32
  using: 
  _32 = genann::genann_init(move _33, move _34, move _35, move _36) -> bb3
  using: _33@Mir(bb2[19]), _34@Mir(bb2[20]), _35@Mir(bb2[21]), _36@Mir(bb2[22])
bb3:
  _31 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _38 = _31
  using: _31@Phi(bb4)
  _39 = const 300_i32
  using: 
  _37 = Lt(move _38, move _39)
  using: _38@Mir(bb4[0]), _39@Mir(bb4[1])
  switchInt(move _37) -> [0: bb23, otherwise: bb5]
  using: _37@Mir(bb4[2])
bb5:
  _42 = _32
  using: _32@Phi(bb4)
  _41 = move _42 as *const example1::genann (Pointer(MutToConstPointer))
  using: _42@Mir(bb5[0])
  _46 = const 0_usize
  using: 
  _45 = &_13[_46]
  using: _13@Phi(bb4), _46@Mir(bb5[2])
  _44 = move _45 as &[f64] (Pointer(Unsize))
  using: _45@Mir(bb5[3])
  _43 = core::slice::<impl [f64]>::as_ptr(move _44) -> bb6
  using: _44@Mir(bb5[4])
bb6:
  _50 = &_26
  using: _26@Phi(bb4)
  _49 = move _50 as &[f64] (Pointer(Unsize))
  using: _50@Mir(bb6[0])
  _48 = core::slice::<impl [f64]>::as_ptr(move _49) -> bb7
  using: _49@Mir(bb6[1])
bb7:
  _51 = const 0_isize
  using: 
  _47 = std::ptr::const_ptr::<impl *const f64>::offset(move _48, move _51) -> bb8
  using: _48@Mir(bb6[2]), _51@Mir(bb7[0])
bb8:
  _52 = const 3f64
  using: 
  _40 = genann::genann_train(move _41, move _43, move _47, move _52) -> bb9
  using: _41@Mir(bb5[1]), _43@Mir(bb5[5]), _47@Mir(bb7[1]), _52@Mir(bb8[0])
bb9:
  _55 = _32
  using: _32@Phi(bb4)
  _54 = move _55 as *const example1::genann (Pointer(MutToConstPointer))
  using: _55@Mir(bb9[0])
  _59 = const 1_usize
  using: 
  _58 = &_13[_59]
  using: _13@Phi(bb4), _59@Mir(bb9[2])
  _57 = move _58 as &[f64] (Pointer(Unsize))
  using: _58@Mir(bb9[3])
  _56 = core::slice::<impl [f64]>::as_ptr(move _57) -> bb10
  using: _57@Mir(bb9[4])
bb10:
  _63 = &_26
  using: _26@Phi(bb4)
  _62 = move _63 as &[f64] (Pointer(Unsize))
  using: _63@Mir(bb10[0])
  _61 = core::slice::<impl [f64]>::as_ptr(move _62) -> bb11
  using: _62@Mir(bb10[1])
bb11:
  _64 = const 1_isize
  using: 
  _60 = std::ptr::const_ptr::<impl *const f64>::offset(move _61, move _64) -> bb12
  using: _61@Mir(bb10[2]), _64@Mir(bb11[0])
bb12:
  _65 = const 3f64
  using: 
  _53 = genann::genann_train(move _54, move _56, move _60, move _65) -> bb13
  using: _54@Mir(bb9[1]), _56@Mir(bb9[5]), _60@Mir(bb11[1]), _65@Mir(bb12[0])
bb13:
  _68 = _32
  using: _32@Phi(bb4)
  _67 = move _68 as *const example1::genann (Pointer(MutToConstPointer))
  using: _68@Mir(bb13[0])
  _72 = const 2_usize
  using: 
  _71 = &_13[_72]
  using: _13@Phi(bb4), _72@Mir(bb13[2])
  _70 = move _71 as &[f64] (Pointer(Unsize))
  using: _71@Mir(bb13[3])
  _69 = core::slice::<impl [f64]>::as_ptr(move _70) -> bb14
  using: _70@Mir(bb13[4])
bb14:
  _76 = &_26
  using: _26@Phi(bb4)
  _75 = move _76 as &[f64] (Pointer(Unsize))
  using: _76@Mir(bb14[0])
  _74 = core::slice::<impl [f64]>::as_ptr(move _75) -> bb15
  using: _75@Mir(bb14[1])
bb15:
  _77 = const 2_isize
  using: 
  _73 = std::ptr::const_ptr::<impl *const f64>::offset(move _74, move _77) -> bb16
  using: _74@Mir(bb14[2]), _77@Mir(bb15[0])
bb16:
  _78 = const 3f64
  using: 
  _66 = genann::genann_train(move _67, move _69, move _73, move _78) -> bb17
  using: _67@Mir(bb13[1]), _69@Mir(bb13[5]), _73@Mir(bb15[1]), _78@Mir(bb16[0])
bb17:
  _81 = _32
  using: _32@Phi(bb4)
  _80 = move _81 as *const example1::genann (Pointer(MutToConstPointer))
  using: _81@Mir(bb17[0])
  _85 = const 3_usize
  using: 
  _84 = &_13[_85]
  using: _13@Phi(bb4), _85@Mir(bb17[2])
  _83 = move _84 as &[f64] (Pointer(Unsize))
  using: _84@Mir(bb17[3])
  _82 = core::slice::<impl [f64]>::as_ptr(move _83) -> bb18
  using: _83@Mir(bb17[4])
bb18:
  _89 = &_26
  using: _26@Phi(bb4)
  _88 = move _89 as &[f64] (Pointer(Unsize))
  using: _89@Mir(bb18[0])
  _87 = core::slice::<impl [f64]>::as_ptr(move _88) -> bb19
  using: _88@Mir(bb18[1])
bb19:
  _90 = const 3_isize
  using: 
  _86 = std::ptr::const_ptr::<impl *const f64>::offset(move _87, move _90) -> bb20
  using: _87@Mir(bb18[2]), _90@Mir(bb19[0])
bb20:
  _91 = const 3f64
  using: 
  _79 = genann::genann_train(move _80, move _82, move _86, move _91) -> bb21
  using: _80@Mir(bb17[1]), _82@Mir(bb17[5]), _86@Mir(bb19[1]), _91@Mir(bb20[0])
bb21:
  _92 = CheckedAdd(_31, const 1_i32)
  using: _31@Phi(bb4)
  assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _31, const 1_i32) -> bb22
  using: _92@Entry, _31@Entry
bb22:
  _31 = move (_92.0: i32)
  using: _92@Mir(bb21[0])
  goto -> bb4
  using: 
bb23:
  _97 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _96 = &raw const (*_97)
  using: _97@Mir(bb23[0])
  _95 = move _96 as *const u8 (Pointer(ArrayToPointer))
  using: _96@Mir(bb23[1])
  _94 = move _95 as *const i8 (PtrToPtr)
  using: _95@Mir(bb23[2])
  _99 = const 0_usize
  using: 
  _100 = const 0_usize
  using: 
  _98 = _13[_99][_100]
  using: _13@Phi(bb4), _100@Mir(bb23[5]), _99@Mir(bb23[4])
  _102 = const 0_usize
  using: 
  _103 = const 1_usize
  using: 
  _101 = _13[_102][_103]
  using: _13@Phi(bb4), _103@Mir(bb23[8]), _102@Mir(bb23[7])
  _107 = _32
  using: _32@Phi(bb4)
  _106 = move _107 as *const example1::genann (Pointer(MutToConstPointer))
  using: _107@Mir(bb23[10])
  _111 = const 0_usize
  using: 
  _110 = &_13[_111]
  using: _13@Phi(bb4), _111@Mir(bb23[12])
  _109 = move _110 as &[f64] (Pointer(Unsize))
  using: _110@Mir(bb23[13])
  _108 = core::slice::<impl [f64]>::as_ptr(move _109) -> bb24
  using: _109@Mir(bb23[14])
bb24:
  _105 = genann::genann_run(move _106, move _108) -> bb25
  using: _106@Mir(bb23[11]), _108@Mir(bb23[15])
bb25:
  _104 = (*_105)
  using: _105@Mir(bb24[0])
  _93 = example1::printf(move _94, move _98, move _101, move _104) -> bb26
  using: _94@Mir(bb23[3]), _98@Mir(bb23[6]), _101@Mir(bb23[9]), _104@Mir(bb25[0])
bb26:
  _116 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _115 = &raw const (*_116)
  using: _116@Mir(bb26[0])
  _114 = move _115 as *const u8 (Pointer(ArrayToPointer))
  using: _115@Mir(bb26[1])
  _113 = move _114 as *const i8 (PtrToPtr)
  using: _114@Mir(bb26[2])
  _118 = const 1_usize
  using: 
  _119 = const 0_usize
  using: 
  _117 = _13[_118][_119]
  using: _13@Phi(bb4), _119@Mir(bb26[5]), _118@Mir(bb26[4])
  _121 = const 1_usize
  using: 
  _122 = const 1_usize
  using: 
  _120 = _13[_121][_122]
  using: _13@Phi(bb4), _122@Mir(bb26[8]), _121@Mir(bb26[7])
  _126 = _32
  using: _32@Phi(bb4)
  _125 = move _126 as *const example1::genann (Pointer(MutToConstPointer))
  using: _126@Mir(bb26[10])
  _130 = const 1_usize
  using: 
  _129 = &_13[_130]
  using: _13@Phi(bb4), _130@Mir(bb26[12])
  _128 = move _129 as &[f64] (Pointer(Unsize))
  using: _129@Mir(bb26[13])
  _127 = core::slice::<impl [f64]>::as_ptr(move _128) -> bb27
  using: _128@Mir(bb26[14])
bb27:
  _124 = genann::genann_run(move _125, move _127) -> bb28
  using: _125@Mir(bb26[11]), _127@Mir(bb26[15])
bb28:
  _123 = (*_124)
  using: _124@Mir(bb27[0])
  _112 = example1::printf(move _113, move _117, move _120, move _123) -> bb29
  using: _113@Mir(bb26[3]), _117@Mir(bb26[6]), _120@Mir(bb26[9]), _123@Mir(bb28[0])
bb29:
  _135 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _134 = &raw const (*_135)
  using: _135@Mir(bb29[0])
  _133 = move _134 as *const u8 (Pointer(ArrayToPointer))
  using: _134@Mir(bb29[1])
  _132 = move _133 as *const i8 (PtrToPtr)
  using: _133@Mir(bb29[2])
  _137 = const 2_usize
  using: 
  _138 = const 0_usize
  using: 
  _136 = _13[_137][_138]
  using: _13@Phi(bb4), _138@Mir(bb29[5]), _137@Mir(bb29[4])
  _140 = const 2_usize
  using: 
  _141 = const 1_usize
  using: 
  _139 = _13[_140][_141]
  using: _13@Phi(bb4), _141@Mir(bb29[8]), _140@Mir(bb29[7])
  _145 = _32
  using: _32@Phi(bb4)
  _144 = move _145 as *const example1::genann (Pointer(MutToConstPointer))
  using: _145@Mir(bb29[10])
  _149 = const 2_usize
  using: 
  _148 = &_13[_149]
  using: _13@Phi(bb4), _149@Mir(bb29[12])
  _147 = move _148 as &[f64] (Pointer(Unsize))
  using: _148@Mir(bb29[13])
  _146 = core::slice::<impl [f64]>::as_ptr(move _147) -> bb30
  using: _147@Mir(bb29[14])
bb30:
  _143 = genann::genann_run(move _144, move _146) -> bb31
  using: _144@Mir(bb29[11]), _146@Mir(bb29[15])
bb31:
  _142 = (*_143)
  using: _143@Mir(bb30[0])
  _131 = example1::printf(move _132, move _136, move _139, move _142) -> bb32
  using: _132@Mir(bb29[3]), _136@Mir(bb29[6]), _139@Mir(bb29[9]), _142@Mir(bb31[0])
bb32:
  _154 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _153 = &raw const (*_154)
  using: _154@Mir(bb32[0])
  _152 = move _153 as *const u8 (Pointer(ArrayToPointer))
  using: _153@Mir(bb32[1])
  _151 = move _152 as *const i8 (PtrToPtr)
  using: _152@Mir(bb32[2])
  _156 = const 3_usize
  using: 
  _157 = const 0_usize
  using: 
  _155 = _13[_156][_157]
  using: _13@Phi(bb4), _157@Mir(bb32[5]), _156@Mir(bb32[4])
  _159 = const 3_usize
  using: 
  _160 = const 1_usize
  using: 
  _158 = _13[_159][_160]
  using: _13@Phi(bb4), _160@Mir(bb32[8]), _159@Mir(bb32[7])
  _164 = _32
  using: _32@Phi(bb4)
  _163 = move _164 as *const example1::genann (Pointer(MutToConstPointer))
  using: _164@Mir(bb32[10])
  _168 = const 3_usize
  using: 
  _167 = &_13[_168]
  using: _13@Phi(bb4), _168@Mir(bb32[12])
  _166 = move _167 as &[f64] (Pointer(Unsize))
  using: _167@Mir(bb32[13])
  _165 = core::slice::<impl [f64]>::as_ptr(move _166) -> bb33
  using: _166@Mir(bb32[14])
bb33:
  _162 = genann::genann_run(move _163, move _165) -> bb34
  using: _163@Mir(bb32[11]), _165@Mir(bb32[15])
bb34:
  _161 = (*_162)
  using: _162@Mir(bb33[0])
  _150 = example1::printf(move _151, move _155, move _158, move _161) -> bb35
  using: _151@Mir(bb32[3]), _155@Mir(bb32[6]), _158@Mir(bb32[9]), _161@Mir(bb34[0])
bb35:
  _170 = _32
  using: _32@Phi(bb4)
  _169 = genann::genann_free(move _170) -> bb36
  using: _170@Mir(bb35[0])
bb36:
  _0 = const 0_i32
  using: 
  return
  using: _0@Mir(bb36[0])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _14, move _17, move _20, move _23] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _27, move _28, move _29, move _30] is not supported
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:63:83: 63:91 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:64:29: 64:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example1.rs:64:38: 64:79 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:66:83: 66:91 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:67:29: 67:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example1.rs:67:38: 67:79 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:69:83: 69:91 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:70:29: 70:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example1.rs:70:38: 70:79 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:72:83: 72:91 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:73:29: 73:37 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example1.rs:73:38: 73:79 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:82:85: 82:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:87:85: 87:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:92:85: 92:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example1.rs:97:85: 97:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
@DefId(0:17 ~ c2rust_lib[1043]::example2::main_0)
bb0:
  _7 = const b"GENANN example 2.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[0])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[1])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[2])
  _3 = example2::printf(move _4) -> bb1
  using: _4@Mir(bb0[3])
bb1:
  _12 = const b"Train a small ANN to the XOR function using random search.\n\x00"
  using: 
  _11 = &raw const (*_12)
  using: _12@Mir(bb1[0])
  _10 = move _11 as *const u8 (Pointer(ArrayToPointer))
  using: _11@Mir(bb1[1])
  _9 = move _10 as *const i8 (PtrToPtr)
  using: _10@Mir(bb1[2])
  _8 = example2::printf(move _9) -> bb2
  using: _9@Mir(bb1[3])
bb2:
  _15 = const 0f64
  using: 
  _16 = const 0f64
  using: 
  _14 = [move _15, move _16]
  using: _15@Mir(bb2[0]), _16@Mir(bb2[1])
  _18 = const 0f64
  using: 
  _19 = const 1f64
  using: 
  _17 = [move _18, move _19]
  using: _18@Mir(bb2[3]), _19@Mir(bb2[4])
  _21 = const 1f64
  using: 
  _22 = const 0f64
  using: 
  _20 = [move _21, move _22]
  using: _21@Mir(bb2[6]), _22@Mir(bb2[7])
  _24 = const 1f64
  using: 
  _25 = const 1f64
  using: 
  _23 = [move _24, move _25]
  using: _24@Mir(bb2[9]), _25@Mir(bb2[10])
  _13 = [move _14, move _17, move _20, move _23]
  using: _14@Mir(bb2[2]), _17@Mir(bb2[5]), _20@Mir(bb2[8]), _23@Mir(bb2[11])
  _27 = const 0f64
  using: 
  _28 = const 1f64
  using: 
  _29 = const 1f64
  using: 
  _30 = const 0f64
  using: 
  _26 = [move _27, move _28, move _29, move _30]
  using: _27@Mir(bb2[13]), _28@Mir(bb2[14]), _29@Mir(bb2[15]), _30@Mir(bb2[16])
  _31 = const 0_i32
  using: 
  _33 = const 2_i32
  using: 
  _34 = const 1_i32
  using: 
  _35 = const 2_i32
  using: 
  _36 = const 1_i32
  using: 
  _32 = genann::genann_init(move _33, move _34, move _35, move _36) -> bb3
  using: _33@Mir(bb2[19]), _34@Mir(bb2[20]), _35@Mir(bb2[21]), _36@Mir(bb2[22])
bb3:
  _37 = const 0f64
  using: 
  _38 = const 1000f64
  using: 
  _39 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _40 = CheckedAdd(_39, const 1_i32)
  using: _39@Phi(bb4)
  assert(!move (_40.1: bool), "attempt to compute `{} + {}`, which would overflow", _39, const 1_i32) -> bb5
  using: _40@Entry, _39@Entry
bb5:
  _39 = move (_40.0: i32)
  using: _40@Mir(bb4[0])
  _43 = _39
  using: _39@Mir(bb5[0])
  _44 = const 1000_i32
  using: 
  _45 = const false
  using: 
  _46 = Eq(_43, const i32::MIN)
  using: _43@Mir(bb5[1])
  _47 = BitAnd(move _45, move _46)
  using: _45@Mir(bb5[3]), _46@Mir(bb5[4])
  assert(!move _47, "attempt to compute the remainder of `{} % {}`, which would overflow", _43, _44) -> bb6
  using: _47@Entry, _43@Entry, _44@Entry
bb6:
  _42 = Rem(move _43, move _44)
  using: _43@Mir(bb5[1]), _44@Mir(bb5[2])
  _48 = const 0_i32
  using: 
  _41 = Eq(move _42, move _48)
  using: _42@Mir(bb6[0]), _48@Mir(bb6[1])
  switchInt(move _41) -> [0: bb8, otherwise: bb7]
  using: _41@Mir(bb6[2])
bb7:
  _50 = _32
  using: _32@Phi(bb4)
  _49 = genann::genann_randomize(move _50) -> bb8
  using: _50@Mir(bb7[0])
bb8:
  _53 = _32
  using: _32@Phi(bb8)
  _52 = move _53 as *const example1::genann (Pointer(MutToConstPointer))
  using: _53@Mir(bb8[0])
  _51 = genann::genann_copy(move _52) -> bb9
  using: _52@Mir(bb8[1])
bb9:
  _31 = const 0_i32
  using: 
  goto -> bb10
  using: 
bb10:
  _55 = _31
  using: _31@Phi(bb10)
  _56 = ((*_32).6: i32)
  using: _32@Phi(bb10)
  _54 = Lt(move _55, move _56)
  using: _55@Mir(bb10[0]), _56@Mir(bb10[1])
  switchInt(move _54) -> [0: bb15, otherwise: bb11]
  using: _54@Mir(bb10[2])
bb11:
  _60 = example2::rand() -> bb12
  using: 
bb12:
  _59 = move _60 as f64 (IntToFloat)
  using: _60@Mir(bb11[0])
  _61 = const 2147483647f64
  using: 
  _58 = Div(move _59, move _61)
  using: _59@Mir(bb12[0]), _61@Mir(bb12[1])
  _57 = Sub(move _58, const 0.5f64)
  using: _58@Mir(bb12[2])
  _63 = ((*_32).8: *mut f64)
  using: _32@Phi(bb10)
  _65 = _31
  using: _31@Phi(bb10)
  _64 = move _65 as isize (IntToInt)
  using: _65@Mir(bb12[5])
  _62 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _63, move _64) -> bb13
  using: _63@Mir(bb12[4]), _64@Mir(bb12[6])
bb13:
  (*_62) = Add((*_62), move _57)
  using: _62@Mir(bb12[7]), _62@Mir(bb12[7]), _57@Mir(bb12[3])
  _66 = CheckedAdd(_31, const 1_i32)
  using: _31@Phi(bb10)
  assert(!move (_66.1: bool), "attempt to compute `{} + {}`, which would overflow", _31, const 1_i32) -> bb14
  using: _66@Entry, _31@Entry
bb14:
  _31 = move (_66.0: i32)
  using: _66@Mir(bb13[1])
  goto -> bb10
  using: 
bb15:
  _37 = const 0f64
  using: 
  _72 = _32
  using: _32@Phi(bb10)
  _71 = move _72 as *const example1::genann (Pointer(MutToConstPointer))
  using: _72@Mir(bb15[1])
  _76 = const 0_usize
  using: 
  _75 = &_13[_76]
  using: _13@Phi(bb4), _76@Mir(bb15[3])
  _74 = move _75 as &[f64] (Pointer(Unsize))
  using: _75@Mir(bb15[4])
  _73 = core::slice::<impl [f64]>::as_ptr(move _74) -> bb16
  using: _74@Mir(bb15[5])
bb16:
  _70 = genann::genann_run(move _71, move _73) -> bb17
  using: _71@Mir(bb15[2]), _73@Mir(bb15[6])
bb17:
  _69 = (*_70)
  using: _70@Mir(bb16[0])
  _78 = const 0_usize
  using: 
  _77 = _26[_78]
  using: _26@Phi(bb4), _78@Mir(bb17[1])
  _68 = Sub(move _69, move _77)
  using: _69@Mir(bb17[0]), _77@Mir(bb17[2])
  _67 = example2::pow(move _68, const 2f64) -> bb18
  using: _68@Mir(bb17[3])
bb18:
  _37 = Add(_37, move _67)
  using: _67@Mir(bb17[4])
  _84 = _32
  using: _32@Phi(bb10)
  _83 = move _84 as *const example1::genann (Pointer(MutToConstPointer))
  using: _84@Mir(bb18[1])
  _88 = const 1_usize
  using: 
  _87 = &_13[_88]
  using: _13@Phi(bb4), _88@Mir(bb18[3])
  _86 = move _87 as &[f64] (Pointer(Unsize))
  using: _87@Mir(bb18[4])
  _85 = core::slice::<impl [f64]>::as_ptr(move _86) -> bb19
  using: _86@Mir(bb18[5])
bb19:
  _82 = genann::genann_run(move _83, move _85) -> bb20
  using: _83@Mir(bb18[2]), _85@Mir(bb18[6])
bb20:
  _81 = (*_82)
  using: _82@Mir(bb19[0])
  _90 = const 1_usize
  using: 
  _89 = _26[_90]
  using: _26@Phi(bb4), _90@Mir(bb20[1])
  _80 = Sub(move _81, move _89)
  using: _81@Mir(bb20[0]), _89@Mir(bb20[2])
  _79 = example2::pow(move _80, const 2f64) -> bb21
  using: _80@Mir(bb20[3])
bb21:
  _37 = Add(_37, move _79)
  using: _79@Mir(bb20[4])
  _96 = _32
  using: _32@Phi(bb10)
  _95 = move _96 as *const example1::genann (Pointer(MutToConstPointer))
  using: _96@Mir(bb21[1])
  _100 = const 2_usize
  using: 
  _99 = &_13[_100]
  using: _13@Phi(bb4), _100@Mir(bb21[3])
  _98 = move _99 as &[f64] (Pointer(Unsize))
  using: _99@Mir(bb21[4])
  _97 = core::slice::<impl [f64]>::as_ptr(move _98) -> bb22
  using: _98@Mir(bb21[5])
bb22:
  _94 = genann::genann_run(move _95, move _97) -> bb23
  using: _95@Mir(bb21[2]), _97@Mir(bb21[6])
bb23:
  _93 = (*_94)
  using: _94@Mir(bb22[0])
  _102 = const 2_usize
  using: 
  _101 = _26[_102]
  using: _26@Phi(bb4), _102@Mir(bb23[1])
  _92 = Sub(move _93, move _101)
  using: _93@Mir(bb23[0]), _101@Mir(bb23[2])
  _91 = example2::pow(move _92, const 2f64) -> bb24
  using: _92@Mir(bb23[3])
bb24:
  _37 = Add(_37, move _91)
  using: _91@Mir(bb23[4])
  _108 = _32
  using: _32@Phi(bb10)
  _107 = move _108 as *const example1::genann (Pointer(MutToConstPointer))
  using: _108@Mir(bb24[1])
  _112 = const 3_usize
  using: 
  _111 = &_13[_112]
  using: _13@Phi(bb4), _112@Mir(bb24[3])
  _110 = move _111 as &[f64] (Pointer(Unsize))
  using: _111@Mir(bb24[4])
  _109 = core::slice::<impl [f64]>::as_ptr(move _110) -> bb25
  using: _110@Mir(bb24[5])
bb25:
  _106 = genann::genann_run(move _107, move _109) -> bb26
  using: _107@Mir(bb24[2]), _109@Mir(bb24[6])
bb26:
  _105 = (*_106)
  using: _106@Mir(bb25[0])
  _114 = const 3_usize
  using: 
  _113 = _26[_114]
  using: _26@Phi(bb4), _114@Mir(bb26[1])
  _104 = Sub(move _105, move _113)
  using: _105@Mir(bb26[0]), _113@Mir(bb26[2])
  _103 = example2::pow(move _104, const 2f64) -> bb27
  using: _104@Mir(bb26[3])
bb27:
  _37 = Add(_37, move _103)
  using: _103@Mir(bb26[4])
  _116 = _37
  using: _37@Mir(bb27[0])
  _117 = _38
  using: _38@Phi(bb4)
  _115 = Lt(move _116, move _117)
  using: _116@Mir(bb27[1]), _117@Mir(bb27[2])
  switchInt(move _115) -> [0: bb30, otherwise: bb28]
  using: _115@Mir(bb27[3])
bb28:
  _119 = _51
  using: _51@Mir(bb8[2])
  _118 = genann::genann_free(move _119) -> bb29
  using: _119@Mir(bb28[0])
bb29:
  _120 = _37
  using: _37@Mir(bb27[0])
  _38 = move _120
  using: _120@Mir(bb29[0])
  goto -> bb32
  using: 
bb30:
  _122 = _32
  using: _32@Phi(bb10)
  _121 = genann::genann_free(move _122) -> bb31
  using: _122@Mir(bb30[0])
bb31:
  _123 = _51
  using: _51@Mir(bb8[2])
  _32 = move _123
  using: _123@Mir(bb31[0])
  goto -> bb32
  using: 
bb32:
  _126 = _37
  using: _37@Phi(bb32)
  _125 = Gt(move _126, const 0.01f64)
  using: _126@Mir(bb32[0])
  _124 = Not(move _125)
  using: _125@Mir(bb32[1])
  switchInt(move _124) -> [0: bb4, otherwise: bb33]
  using: _124@Mir(bb32[2])
bb33:
  _131 = const b"Finished in %d loops.\n\x00"
  using: 
  _130 = &raw const (*_131)
  using: _131@Mir(bb33[0])
  _129 = move _130 as *const u8 (Pointer(ArrayToPointer))
  using: _130@Mir(bb33[1])
  _128 = move _129 as *const i8 (PtrToPtr)
  using: _129@Mir(bb33[2])
  _132 = _39
  using: _39@Mir(bb5[0])
  _127 = example2::printf(move _128, move _132) -> bb34
  using: _128@Mir(bb33[3]), _132@Mir(bb33[4])
bb34:
  _137 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _136 = &raw const (*_137)
  using: _137@Mir(bb34[0])
  _135 = move _136 as *const u8 (Pointer(ArrayToPointer))
  using: _136@Mir(bb34[1])
  _134 = move _135 as *const i8 (PtrToPtr)
  using: _135@Mir(bb34[2])
  _139 = const 0_usize
  using: 
  _140 = const 0_usize
  using: 
  _138 = _13[_139][_140]
  using: _13@Phi(bb4), _140@Mir(bb34[5]), _139@Mir(bb34[4])
  _142 = const 0_usize
  using: 
  _143 = const 1_usize
  using: 
  _141 = _13[_142][_143]
  using: _13@Phi(bb4), _143@Mir(bb34[8]), _142@Mir(bb34[7])
  _147 = _32
  using: _32@Phi(bb32)
  _146 = move _147 as *const example1::genann (Pointer(MutToConstPointer))
  using: _147@Mir(bb34[10])
  _151 = const 0_usize
  using: 
  _150 = &_13[_151]
  using: _13@Phi(bb4), _151@Mir(bb34[12])
  _149 = move _150 as &[f64] (Pointer(Unsize))
  using: _150@Mir(bb34[13])
  _148 = core::slice::<impl [f64]>::as_ptr(move _149) -> bb35
  using: _149@Mir(bb34[14])
bb35:
  _145 = genann::genann_run(move _146, move _148) -> bb36
  using: _146@Mir(bb34[11]), _148@Mir(bb34[15])
bb36:
  _144 = (*_145)
  using: _145@Mir(bb35[0])
  _133 = example2::printf(move _134, move _138, move _141, move _144) -> bb37
  using: _134@Mir(bb34[3]), _138@Mir(bb34[6]), _141@Mir(bb34[9]), _144@Mir(bb36[0])
bb37:
  _156 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _155 = &raw const (*_156)
  using: _156@Mir(bb37[0])
  _154 = move _155 as *const u8 (Pointer(ArrayToPointer))
  using: _155@Mir(bb37[1])
  _153 = move _154 as *const i8 (PtrToPtr)
  using: _154@Mir(bb37[2])
  _158 = const 1_usize
  using: 
  _159 = const 0_usize
  using: 
  _157 = _13[_158][_159]
  using: _13@Phi(bb4), _159@Mir(bb37[5]), _158@Mir(bb37[4])
  _161 = const 1_usize
  using: 
  _162 = const 1_usize
  using: 
  _160 = _13[_161][_162]
  using: _13@Phi(bb4), _162@Mir(bb37[8]), _161@Mir(bb37[7])
  _166 = _32
  using: _32@Phi(bb32)
  _165 = move _166 as *const example1::genann (Pointer(MutToConstPointer))
  using: _166@Mir(bb37[10])
  _170 = const 1_usize
  using: 
  _169 = &_13[_170]
  using: _13@Phi(bb4), _170@Mir(bb37[12])
  _168 = move _169 as &[f64] (Pointer(Unsize))
  using: _169@Mir(bb37[13])
  _167 = core::slice::<impl [f64]>::as_ptr(move _168) -> bb38
  using: _168@Mir(bb37[14])
bb38:
  _164 = genann::genann_run(move _165, move _167) -> bb39
  using: _165@Mir(bb37[11]), _167@Mir(bb37[15])
bb39:
  _163 = (*_164)
  using: _164@Mir(bb38[0])
  _152 = example2::printf(move _153, move _157, move _160, move _163) -> bb40
  using: _153@Mir(bb37[3]), _157@Mir(bb37[6]), _160@Mir(bb37[9]), _163@Mir(bb39[0])
bb40:
  _175 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _174 = &raw const (*_175)
  using: _175@Mir(bb40[0])
  _173 = move _174 as *const u8 (Pointer(ArrayToPointer))
  using: _174@Mir(bb40[1])
  _172 = move _173 as *const i8 (PtrToPtr)
  using: _173@Mir(bb40[2])
  _177 = const 2_usize
  using: 
  _178 = const 0_usize
  using: 
  _176 = _13[_177][_178]
  using: _13@Phi(bb4), _178@Mir(bb40[5]), _177@Mir(bb40[4])
  _180 = const 2_usize
  using: 
  _181 = const 1_usize
  using: 
  _179 = _13[_180][_181]
  using: _13@Phi(bb4), _181@Mir(bb40[8]), _180@Mir(bb40[7])
  _185 = _32
  using: _32@Phi(bb32)
  _184 = move _185 as *const example1::genann (Pointer(MutToConstPointer))
  using: _185@Mir(bb40[10])
  _189 = const 2_usize
  using: 
  _188 = &_13[_189]
  using: _13@Phi(bb4), _189@Mir(bb40[12])
  _187 = move _188 as &[f64] (Pointer(Unsize))
  using: _188@Mir(bb40[13])
  _186 = core::slice::<impl [f64]>::as_ptr(move _187) -> bb41
  using: _187@Mir(bb40[14])
bb41:
  _183 = genann::genann_run(move _184, move _186) -> bb42
  using: _184@Mir(bb40[11]), _186@Mir(bb40[15])
bb42:
  _182 = (*_183)
  using: _183@Mir(bb41[0])
  _171 = example2::printf(move _172, move _176, move _179, move _182) -> bb43
  using: _172@Mir(bb40[3]), _176@Mir(bb40[6]), _179@Mir(bb40[9]), _182@Mir(bb42[0])
bb43:
  _194 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _193 = &raw const (*_194)
  using: _194@Mir(bb43[0])
  _192 = move _193 as *const u8 (Pointer(ArrayToPointer))
  using: _193@Mir(bb43[1])
  _191 = move _192 as *const i8 (PtrToPtr)
  using: _192@Mir(bb43[2])
  _196 = const 3_usize
  using: 
  _197 = const 0_usize
  using: 
  _195 = _13[_196][_197]
  using: _13@Phi(bb4), _197@Mir(bb43[5]), _196@Mir(bb43[4])
  _199 = const 3_usize
  using: 
  _200 = const 1_usize
  using: 
  _198 = _13[_199][_200]
  using: _13@Phi(bb4), _200@Mir(bb43[8]), _199@Mir(bb43[7])
  _204 = _32
  using: _32@Phi(bb32)
  _203 = move _204 as *const example1::genann (Pointer(MutToConstPointer))
  using: _204@Mir(bb43[10])
  _208 = const 3_usize
  using: 
  _207 = &_13[_208]
  using: _13@Phi(bb4), _208@Mir(bb43[12])
  _206 = move _207 as &[f64] (Pointer(Unsize))
  using: _207@Mir(bb43[13])
  _205 = core::slice::<impl [f64]>::as_ptr(move _206) -> bb44
  using: _206@Mir(bb43[14])
bb44:
  _202 = genann::genann_run(move _203, move _205) -> bb45
  using: _203@Mir(bb43[11]), _205@Mir(bb43[15])
bb45:
  _201 = (*_202)
  using: _202@Mir(bb44[0])
  _190 = example2::printf(move _191, move _195, move _198, move _201) -> bb46
  using: _191@Mir(bb43[3]), _195@Mir(bb43[6]), _198@Mir(bb43[9]), _201@Mir(bb45[0])
bb46:
  _210 = _32
  using: _32@Phi(bb32)
  _209 = genann::genann_free(move _210) -> bb47
  using: _210@Mir(bb46[0])
bb47:
  _0 = const 0_i32
  using: 
  return
  using: _0@Mir(bb47[0])
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _14, move _17, move _20, move _23] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _27, move _28, move _29, move _30] is not supported
rewrite call example2::rand @ workspace/genann/example2.rs:67:17: 67:23 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example2.rs:66:28: 66:46 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:74:90: 74:98 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call example2::pow @ workspace/genann/example2.rs:74:13: 75:71 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:77:90: 77:98 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call example2::pow @ workspace/genann/example2.rs:77:13: 78:71 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:80:90: 80:98 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call example2::pow @ workspace/genann/example2.rs:80:13: 81:71 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:83:90: 83:98 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call example2::pow @ workspace/genann/example2.rs:83:13: 84:71 (#0) by default
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:99:85: 99:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:104:85: 104:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:109:85: 109:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example2.rs:114:85: 114:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
@DefId(0:34 ~ c2rust_lib[1043]::example3::main_0)
bb0:
  _7 = const b"GENANN example 3.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[0])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[1])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[2])
  _3 = example3::printf(move _4) -> bb1
  using: _4@Mir(bb0[3])
bb1:
  _12 = const b"Load a saved ANN to solve the XOR function.\n\x00"
  using: 
  _11 = &raw const (*_12)
  using: _12@Mir(bb1[0])
  _10 = move _11 as *const u8 (Pointer(ArrayToPointer))
  using: _11@Mir(bb1[1])
  _9 = move _10 as *const i8 (PtrToPtr)
  using: _10@Mir(bb1[2])
  _8 = example3::printf(move _9) -> bb2
  using: _9@Mir(bb1[3])
bb2:
  _15 = const {alloc56: *mut *const i8}
  using: 
  _14 = (*_15)
  using: _15@Mir(bb2[0])
  _19 = const b"r\x00"
  using: 
  _18 = &raw const (*_19)
  using: _19@Mir(bb2[2])
  _17 = move _18 as *const u8 (Pointer(ArrayToPointer))
  using: _18@Mir(bb2[3])
  _16 = move _17 as *const i8 (PtrToPtr)
  using: _17@Mir(bb2[4])
  _13 = example3::fopen(move _14, move _16) -> bb3
  using: _14@Mir(bb2[1]), _16@Mir(bb2[5])
bb3:
  _21 = _13
  using: _13@Mir(bb2[6])
  _20 = std::ptr::mut_ptr::<impl *mut example3::__sFILE>::is_null(move _21) -> bb4
  using: _21@Mir(bb3[0])
bb4:
  switchInt(move _20) -> [0: bb7, otherwise: bb5]
  using: _20@Mir(bb3[1])
bb5:
  _24 = _13
  using: _13@Mir(bb2[6])
  _23 = move _24 as usize (PointerExposeAddress)
  using: _24@Mir(bb5[0])
  _22 = Eq(move _23, const 0_usize)
  using: _23@Mir(bb5[1])
  assume(move _22)
  using: _22@Mir(bb5[2])
  _29 = const b"Couldn\'t open file: %s\n\x00"
  using: 
  _28 = &raw const (*_29)
  using: _29@Mir(bb5[4])
  _27 = move _28 as *const u8 (Pointer(ArrayToPointer))
  using: _28@Mir(bb5[5])
  _26 = move _27 as *const i8 (PtrToPtr)
  using: _27@Mir(bb5[6])
  _31 = const {alloc56: *mut *const i8}
  using: 
  _30 = (*_31)
  using: _31@Mir(bb5[8])
  _25 = example3::printf(move _26, move _30) -> bb6
  using: _26@Mir(bb5[7]), _30@Mir(bb5[9])
bb6:
  _33 = const 1_i32
  using: 
  _32 = example3::exit(move _33)
  using: _33@Mir(bb6[0])
bb7:
  _35 = _13
  using: _13@Mir(bb2[6])
  _34 = genann::genann_read(move _35) -> bb8
  using: _35@Mir(bb7[0])
bb8:
  _37 = _13
  using: _13@Mir(bb2[6])
  _36 = example3::fclose(move _37) -> bb9
  using: _37@Mir(bb8[0])
bb9:
  _39 = _34
  using: _34@Mir(bb7[1])
  _38 = std::ptr::mut_ptr::<impl *mut example1::genann>::is_null(move _39) -> bb10
  using: _39@Mir(bb9[0])
bb10:
  switchInt(move _38) -> [0: bb13, otherwise: bb11]
  using: _38@Mir(bb9[1])
bb11:
  _42 = _34
  using: _34@Mir(bb7[1])
  _41 = move _42 as usize (PointerExposeAddress)
  using: _42@Mir(bb11[0])
  _40 = Eq(move _41, const 0_usize)
  using: _41@Mir(bb11[1])
  assume(move _40)
  using: _40@Mir(bb11[2])
  _47 = const b"Error loading ANN from file: %s.\x00"
  using: 
  _46 = &raw const (*_47)
  using: _47@Mir(bb11[4])
  _45 = move _46 as *const u8 (Pointer(ArrayToPointer))
  using: _46@Mir(bb11[5])
  _44 = move _45 as *const i8 (PtrToPtr)
  using: _45@Mir(bb11[6])
  _49 = const {alloc56: *mut *const i8}
  using: 
  _48 = (*_49)
  using: _49@Mir(bb11[8])
  _43 = example3::printf(move _44, move _48) -> bb12
  using: _44@Mir(bb11[7]), _48@Mir(bb11[9])
bb12:
  _51 = const 1_i32
  using: 
  _50 = example3::exit(move _51)
  using: _51@Mir(bb12[0])
bb13:
  _54 = const 0f64
  using: 
  _55 = const 0f64
  using: 
  _53 = [move _54, move _55]
  using: _54@Mir(bb13[0]), _55@Mir(bb13[1])
  _57 = const 0f64
  using: 
  _58 = const 1f64
  using: 
  _56 = [move _57, move _58]
  using: _57@Mir(bb13[3]), _58@Mir(bb13[4])
  _60 = const 1f64
  using: 
  _61 = const 0f64
  using: 
  _59 = [move _60, move _61]
  using: _60@Mir(bb13[6]), _61@Mir(bb13[7])
  _63 = const 1f64
  using: 
  _64 = const 1f64
  using: 
  _62 = [move _63, move _64]
  using: _63@Mir(bb13[9]), _64@Mir(bb13[10])
  _52 = [move _53, move _56, move _59, move _62]
  using: _53@Mir(bb13[2]), _56@Mir(bb13[5]), _59@Mir(bb13[8]), _62@Mir(bb13[11])
  _69 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _68 = &raw const (*_69)
  using: _69@Mir(bb13[13])
  _67 = move _68 as *const u8 (Pointer(ArrayToPointer))
  using: _68@Mir(bb13[14])
  _66 = move _67 as *const i8 (PtrToPtr)
  using: _67@Mir(bb13[15])
  _71 = const 0_usize
  using: 
  _72 = const 0_usize
  using: 
  _70 = _52[_71][_72]
  using: _52@Mir(bb13[12]), _72@Mir(bb13[18]), _71@Mir(bb13[17])
  _74 = const 0_usize
  using: 
  _75 = const 1_usize
  using: 
  _73 = _52[_74][_75]
  using: _52@Mir(bb13[12]), _75@Mir(bb13[21]), _74@Mir(bb13[20])
  _79 = _34
  using: _34@Mir(bb7[1])
  _78 = move _79 as *const example1::genann (Pointer(MutToConstPointer))
  using: _79@Mir(bb13[23])
  _83 = const 0_usize
  using: 
  _82 = &_52[_83]
  using: _52@Mir(bb13[12]), _83@Mir(bb13[25])
  _81 = move _82 as &[f64] (Pointer(Unsize))
  using: _82@Mir(bb13[26])
  _80 = core::slice::<impl [f64]>::as_ptr(move _81) -> bb14
  using: _81@Mir(bb13[27])
bb14:
  _77 = genann::genann_run(move _78, move _80) -> bb15
  using: _78@Mir(bb13[24]), _80@Mir(bb13[28])
bb15:
  _76 = (*_77)
  using: _77@Mir(bb14[0])
  _65 = example3::printf(move _66, move _70, move _73, move _76) -> bb16
  using: _66@Mir(bb13[16]), _70@Mir(bb13[19]), _73@Mir(bb13[22]), _76@Mir(bb15[0])
bb16:
  _88 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _87 = &raw const (*_88)
  using: _88@Mir(bb16[0])
  _86 = move _87 as *const u8 (Pointer(ArrayToPointer))
  using: _87@Mir(bb16[1])
  _85 = move _86 as *const i8 (PtrToPtr)
  using: _86@Mir(bb16[2])
  _90 = const 1_usize
  using: 
  _91 = const 0_usize
  using: 
  _89 = _52[_90][_91]
  using: _52@Mir(bb13[12]), _91@Mir(bb16[5]), _90@Mir(bb16[4])
  _93 = const 1_usize
  using: 
  _94 = const 1_usize
  using: 
  _92 = _52[_93][_94]
  using: _52@Mir(bb13[12]), _94@Mir(bb16[8]), _93@Mir(bb16[7])
  _98 = _34
  using: _34@Mir(bb7[1])
  _97 = move _98 as *const example1::genann (Pointer(MutToConstPointer))
  using: _98@Mir(bb16[10])
  _102 = const 1_usize
  using: 
  _101 = &_52[_102]
  using: _52@Mir(bb13[12]), _102@Mir(bb16[12])
  _100 = move _101 as &[f64] (Pointer(Unsize))
  using: _101@Mir(bb16[13])
  _99 = core::slice::<impl [f64]>::as_ptr(move _100) -> bb17
  using: _100@Mir(bb16[14])
bb17:
  _96 = genann::genann_run(move _97, move _99) -> bb18
  using: _97@Mir(bb16[11]), _99@Mir(bb16[15])
bb18:
  _95 = (*_96)
  using: _96@Mir(bb17[0])
  _84 = example3::printf(move _85, move _89, move _92, move _95) -> bb19
  using: _85@Mir(bb16[3]), _89@Mir(bb16[6]), _92@Mir(bb16[9]), _95@Mir(bb18[0])
bb19:
  _107 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _106 = &raw const (*_107)
  using: _107@Mir(bb19[0])
  _105 = move _106 as *const u8 (Pointer(ArrayToPointer))
  using: _106@Mir(bb19[1])
  _104 = move _105 as *const i8 (PtrToPtr)
  using: _105@Mir(bb19[2])
  _109 = const 2_usize
  using: 
  _110 = const 0_usize
  using: 
  _108 = _52[_109][_110]
  using: _52@Mir(bb13[12]), _110@Mir(bb19[5]), _109@Mir(bb19[4])
  _112 = const 2_usize
  using: 
  _113 = const 1_usize
  using: 
  _111 = _52[_112][_113]
  using: _52@Mir(bb13[12]), _113@Mir(bb19[8]), _112@Mir(bb19[7])
  _117 = _34
  using: _34@Mir(bb7[1])
  _116 = move _117 as *const example1::genann (Pointer(MutToConstPointer))
  using: _117@Mir(bb19[10])
  _121 = const 2_usize
  using: 
  _120 = &_52[_121]
  using: _52@Mir(bb13[12]), _121@Mir(bb19[12])
  _119 = move _120 as &[f64] (Pointer(Unsize))
  using: _120@Mir(bb19[13])
  _118 = core::slice::<impl [f64]>::as_ptr(move _119) -> bb20
  using: _119@Mir(bb19[14])
bb20:
  _115 = genann::genann_run(move _116, move _118) -> bb21
  using: _116@Mir(bb19[11]), _118@Mir(bb19[15])
bb21:
  _114 = (*_115)
  using: _115@Mir(bb20[0])
  _103 = example3::printf(move _104, move _108, move _111, move _114) -> bb22
  using: _104@Mir(bb19[3]), _108@Mir(bb19[6]), _111@Mir(bb19[9]), _114@Mir(bb21[0])
bb22:
  _126 = const b"Output for [%1.f, %1.f] is %1.f.\n\x00"
  using: 
  _125 = &raw const (*_126)
  using: _126@Mir(bb22[0])
  _124 = move _125 as *const u8 (Pointer(ArrayToPointer))
  using: _125@Mir(bb22[1])
  _123 = move _124 as *const i8 (PtrToPtr)
  using: _124@Mir(bb22[2])
  _128 = const 3_usize
  using: 
  _129 = const 0_usize
  using: 
  _127 = _52[_128][_129]
  using: _52@Mir(bb13[12]), _129@Mir(bb22[5]), _128@Mir(bb22[4])
  _131 = const 3_usize
  using: 
  _132 = const 1_usize
  using: 
  _130 = _52[_131][_132]
  using: _52@Mir(bb13[12]), _132@Mir(bb22[8]), _131@Mir(bb22[7])
  _136 = _34
  using: _34@Mir(bb7[1])
  _135 = move _136 as *const example1::genann (Pointer(MutToConstPointer))
  using: _136@Mir(bb22[10])
  _140 = const 3_usize
  using: 
  _139 = &_52[_140]
  using: _52@Mir(bb13[12]), _140@Mir(bb22[12])
  _138 = move _139 as &[f64] (Pointer(Unsize))
  using: _139@Mir(bb22[13])
  _137 = core::slice::<impl [f64]>::as_ptr(move _138) -> bb23
  using: _138@Mir(bb22[14])
bb23:
  _134 = genann::genann_run(move _135, move _137) -> bb24
  using: _135@Mir(bb22[11]), _137@Mir(bb22[15])
bb24:
  _133 = (*_134)
  using: _134@Mir(bb23[0])
  _122 = example3::printf(move _123, move _127, move _130, move _133) -> bb25
  using: _123@Mir(bb22[3]), _127@Mir(bb22[6]), _130@Mir(bb22[9]), _133@Mir(bb24[0])
bb25:
  _142 = _34
  using: _34@Mir(bb7[1])
  _141 = genann::genann_free(move _142) -> bb26
  using: _142@Mir(bb25[0])
bb26:
  _0 = const 0_i32
  using: 
  return
  using: _0@Mir(bb26[0])
rewrite call example3::fopen @ workspace/genann/example3.rs:74:9: 74:79 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call example3::exit @ workspace/genann/example3.rs:78:9: 78:39 (#0) by default
rewrite call example3::fclose @ workspace/genann/example3.rs:81:5: 81:18 (#0) by default
rewrite call example3::exit @ workspace/genann/example3.rs:85:9: 85:39 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _53, move _56, move _59, move _62] is not supported
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example3.rs:102:85: 102:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example3.rs:107:85: 107:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example3.rs:112:85: 112:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call core::slice::<impl [T]>::as_ptr @ workspace/genann/example3.rs:117:85: 117:93 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
@DefId(0:63 ~ c2rust_lib[1043]::example4::load_data)
bb0:
  _5 = const b"example/iris.data\x00"
  using: 
  _4 = &raw const (*_5)
  using: _5@Mir(bb0[0])
  _3 = move _4 as *const u8 (Pointer(ArrayToPointer))
  using: _4@Mir(bb0[1])
  _2 = move _3 as *const i8 (PtrToPtr)
  using: _3@Mir(bb0[2])
  _9 = const b"r\x00"
  using: 
  _8 = &raw const (*_9)
  using: _9@Mir(bb0[4])
  _7 = move _8 as *const u8 (Pointer(ArrayToPointer))
  using: _8@Mir(bb0[5])
  _6 = move _7 as *const i8 (PtrToPtr)
  using: _7@Mir(bb0[6])
  _1 = example4::fopen(move _2, move _6) -> bb1
  using: _2@Mir(bb0[3]), _6@Mir(bb0[7])
bb1:
  _11 = _1
  using: _1@Mir(bb0[8])
  _10 = std::ptr::mut_ptr::<impl *mut example3::__sFILE>::is_null(move _11) -> bb2
  using: _11@Mir(bb1[0])
bb2:
  switchInt(move _10) -> [0: bb5, otherwise: bb3]
  using: _10@Mir(bb1[1])
bb3:
  _14 = _1
  using: _1@Mir(bb0[8])
  _13 = move _14 as usize (PointerExposeAddress)
  using: _14@Mir(bb3[0])
  _12 = Eq(move _13, const 0_usize)
  using: _13@Mir(bb3[1])
  assume(move _12)
  using: _12@Mir(bb3[2])
  _19 = const b"Could not open file: %s\n\x00"
  using: 
  _18 = &raw const (*_19)
  using: _19@Mir(bb3[4])
  _17 = move _18 as *const u8 (Pointer(ArrayToPointer))
  using: _18@Mir(bb3[5])
  _16 = move _17 as *const i8 (PtrToPtr)
  using: _17@Mir(bb3[6])
  _21 = const {alloc88: *mut *const i8}
  using: 
  _20 = (*_21)
  using: _21@Mir(bb3[8])
  _15 = example4::printf(move _16, move _20) -> bb4
  using: _16@Mir(bb3[7]), _20@Mir(bb3[9])
bb4:
  _23 = const 1_i32
  using: 
  _22 = example4::exit(move _23)
  using: _23@Mir(bb4[0])
bb5:
  _24 = [const 0_i8; 1024]
  using: 
  goto -> bb6
  using: 
bb6:
  _27 = _1
  using: _1@Phi(bb6)
  _26 = example4::feof(move _27) -> bb10
  using: _27@Mir(bb6[0])
bb7:
  _25 = const false
  using: 
  goto -> bb9
  using: 
bb8:
  _33 = &mut _24
  using: _24@Phi(bb6)
  _32 = move _33 as &mut [i8] (Pointer(Unsize))
  using: _33@Mir(bb8[0])
  _31 = core::slice::<impl [i8]>::as_mut_ptr(move _32) -> bb11
  using: _32@Mir(bb8[1])
bb9:
  switchInt(move _25) -> [0: bb16, otherwise: bb14]
  using: _25@Phi(bb9)
bb10:
  switchInt(move _26) -> [0: bb8, otherwise: bb7]
  using: _26@Mir(bb6[1])
bb11:
  _34 = const 1024_i32
  using: 
  _35 = _1
  using: _1@Phi(bb6)
  _30 = example4::fgets(move _31, move _34, move _35) -> bb12
  using: _31@Mir(bb8[2]), _34@Mir(bb11[0]), _35@Mir(bb11[1])
bb12:
  _29 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _30) -> bb13
  using: _30@Mir(bb11[2])
bb13:
  _28 = Not(move _29)
  using: _29@Mir(bb12[0])
  _25 = move _28
  using: _28@Mir(bb13[0])
  goto -> bb9
  using: 
bb14:
  _36 = const {alloc89: *mut i32}
  using: 
  _37 = CheckedAdd((*_36), const 1_i32)
  using: _36@Mir(bb14[0])
  assert(!move (_37.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_36), const 1_i32) -> bb15
  using: _37@Entry, _36@Entry
bb15:
  (*_36) = move (_37.0: i32)
  using: _36@Mir(bb14[0]), _37@Mir(bb14[1])
  goto -> bb6
  using: 
bb16:
  _39 = _1
  using: _1@Phi(bb9)
  _40 = const 0_i64
  using: 
  _41 = const 0_i32
  using: 
  _38 = example4::fseek(move _39, move _40, move _41) -> bb17
  using: _39@Mir(bb16[0]), _40@Mir(bb16[1]), _41@Mir(bb16[2])
bb17:
  _46 = const b"Loading %d data points from %s\n\x00"
  using: 
  _45 = &raw const (*_46)
  using: _46@Mir(bb17[0])
  _44 = move _45 as *const u8 (Pointer(ArrayToPointer))
  using: _45@Mir(bb17[1])
  _43 = move _44 as *const i8 (PtrToPtr)
  using: _44@Mir(bb17[2])
  _48 = const {alloc89: *mut i32}
  using: 
  _47 = (*_48)
  using: _48@Mir(bb17[4])
  _50 = const {alloc88: *mut *const i8}
  using: 
  _49 = (*_50)
  using: _50@Mir(bb17[6])
  _42 = example4::printf(move _43, move _47, move _49) -> bb18
  using: _43@Mir(bb17[3]), _47@Mir(bb17[5]), _49@Mir(bb17[7])
bb18:
  _55 = std::mem::size_of::<f64>() -> bb19
  using: 
bb19:
  _54 = move _55 as u64 (IntToInt)
  using: _55@Mir(bb18[0])
  _58 = const {alloc89: *mut i32}
  using: 
  _57 = (*_58)
  using: _58@Mir(bb19[1])
  _56 = move _57 as u64 (IntToInt)
  using: _57@Mir(bb19[2])
  _53 = core::num::<impl u64>::wrapping_mul(move _54, move _56) -> bb20
  using: _54@Mir(bb19[0]), _56@Mir(bb19[3])
bb20:
  _59 = const 4_u64
  using: 
  _52 = core::num::<impl u64>::wrapping_mul(move _53, move _59) -> bb21
  using: _53@Mir(bb19[4]), _59@Mir(bb20[0])
bb21:
  _51 = example4::malloc(move _52) -> bb22
  using: _52@Mir(bb20[1])
bb22:
  _60 = const {alloc90: *mut *mut f64}
  using: 
  (*_60) = move _51 as *mut f64 (PtrToPtr)
  using: _60@Mir(bb22[0]), _51@Mir(bb21[0])
  _65 = std::mem::size_of::<f64>() -> bb23
  using: 
bb23:
  _64 = move _65 as u64 (IntToInt)
  using: _65@Mir(bb22[2])
  _68 = const {alloc89: *mut i32}
  using: 
  _67 = (*_68)
  using: _68@Mir(bb23[1])
  _66 = move _67 as u64 (IntToInt)
  using: _67@Mir(bb23[2])
  _63 = core::num::<impl u64>::wrapping_mul(move _64, move _66) -> bb24
  using: _64@Mir(bb23[0]), _66@Mir(bb23[3])
bb24:
  _69 = const 3_u64
  using: 
  _62 = core::num::<impl u64>::wrapping_mul(move _63, move _69) -> bb25
  using: _63@Mir(bb23[4]), _69@Mir(bb24[0])
bb25:
  _61 = example4::malloc(move _62) -> bb26
  using: _62@Mir(bb24[1])
bb26:
  _70 = const {alloc91: *mut *mut f64}
  using: 
  (*_70) = move _61 as *mut f64 (PtrToPtr)
  using: _70@Mir(bb26[0]), _61@Mir(bb25[0])
  _71 = const 0_i32
  using: 
  _72 = const 0_i32
  using: 
  _71 = const 0_i32
  using: 
  goto -> bb27
  using: 
bb27:
  _74 = _71
  using: _71@Phi(bb27)
  _76 = const {alloc89: *mut i32}
  using: 
  _75 = (*_76)
  using: _76@Mir(bb27[1])
  _73 = Lt(move _74, move _75)
  using: _74@Mir(bb27[0]), _75@Mir(bb27[2])
  switchInt(move _73) -> [0: bb73, otherwise: bb28]
  using: _73@Mir(bb27[3])
bb28:
  _79 = const {alloc90: *mut *mut f64}
  using: 
  _78 = (*_79)
  using: _79@Mir(bb28[0])
  _82 = _71
  using: _71@Phi(bb27)
  _83 = const 4_i32
  using: 
  _84 = CheckedMul(_82, _83)
  using: _82@Mir(bb28[2]), _83@Mir(bb28[3])
  assert(!move (_84.1: bool), "attempt to compute `{} * {}`, which would overflow", move _82, move _83) -> bb29
  using: _84@Entry, _82@Entry, _83@Entry
bb29:
  _81 = move (_84.0: i32)
  using: _84@Mir(bb28[4])
  _80 = move _81 as isize (IntToInt)
  using: _81@Mir(bb29[0])
  _77 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _78, move _80) -> bb30
  using: _78@Mir(bb28[1]), _80@Mir(bb29[1])
bb30:
  _87 = const {alloc91: *mut *mut f64}
  using: 
  _86 = (*_87)
  using: _87@Mir(bb30[0])
  _90 = _71
  using: _71@Phi(bb27)
  _91 = const 3_i32
  using: 
  _92 = CheckedMul(_90, _91)
  using: _90@Mir(bb30[2]), _91@Mir(bb30[3])
  assert(!move (_92.1: bool), "attempt to compute `{} * {}`, which would overflow", move _90, move _91) -> bb31
  using: _92@Entry, _90@Entry, _91@Entry
bb31:
  _89 = move (_92.0: i32)
  using: _92@Mir(bb30[4])
  _88 = move _89 as isize (IntToInt)
  using: _89@Mir(bb31[0])
  _85 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _86, move _88) -> bb32
  using: _86@Mir(bb30[1]), _88@Mir(bb31[1])
bb32:
  _94 = _85
  using: _85@Mir(bb31[2])
  _95 = const 2_isize
  using: 
  _93 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _94, move _95) -> bb33
  using: _94@Mir(bb32[0]), _95@Mir(bb32[1])
bb33:
  (*_93) = const 0f64
  using: _93@Mir(bb32[2])
  _98 = _85
  using: _85@Mir(bb31[2])
  _99 = const 2_isize
  using: 
  _97 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _98, move _99) -> bb34
  using: _98@Mir(bb33[1]), _99@Mir(bb33[2])
bb34:
  _96 = (*_97)
  using: _97@Mir(bb33[3])
  _101 = _85
  using: _85@Mir(bb31[2])
  _102 = const 1_isize
  using: 
  _100 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _101, move _102) -> bb35
  using: _101@Mir(bb34[1]), _102@Mir(bb34[2])
bb35:
  (*_100) = move _96
  using: _100@Mir(bb34[3]), _96@Mir(bb34[0])
  _105 = _85
  using: _85@Mir(bb31[2])
  _106 = const 1_isize
  using: 
  _104 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _105, move _106) -> bb36
  using: _105@Mir(bb35[1]), _106@Mir(bb35[2])
bb36:
  _103 = (*_104)
  using: _104@Mir(bb35[3])
  _108 = _85
  using: _85@Mir(bb31[2])
  _109 = const 0_isize
  using: 
  _107 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _108, move _109) -> bb37
  using: _108@Mir(bb36[1]), _109@Mir(bb36[2])
bb37:
  (*_107) = move _103
  using: _107@Mir(bb36[3]), _103@Mir(bb36[0])
  _114 = &mut _24
  using: _24@Phi(bb27)
  _113 = move _114 as &mut [i8] (Pointer(Unsize))
  using: _114@Mir(bb37[1])
  _112 = core::slice::<impl [i8]>::as_mut_ptr(move _113) -> bb38
  using: _113@Mir(bb37[2])
bb38:
  _115 = const 1024_i32
  using: 
  _116 = _1
  using: _1@Phi(bb27)
  _111 = example4::fgets(move _112, move _115, move _116) -> bb39
  using: _112@Mir(bb37[3]), _115@Mir(bb38[0]), _116@Mir(bb38[1])
bb39:
  _110 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _111) -> bb40
  using: _111@Mir(bb38[2])
bb40:
  switchInt(move _110) -> [0: bb45, otherwise: bb41]
  using: _110@Mir(bb39[0])
bb41:
  _122 = &mut _24
  using: _24@Phi(bb27)
  _121 = move _122 as &mut [i8] (Pointer(Unsize))
  using: _122@Mir(bb41[0])
  _120 = core::slice::<impl [i8]>::as_mut_ptr(move _121) -> bb42
  using: _121@Mir(bb41[1])
bb42:
  _123 = const 1024_i32
  using: 
  _124 = _1
  using: _1@Phi(bb27)
  _119 = example4::fgets(move _120, move _123, move _124) -> bb43
  using: _120@Mir(bb41[2]), _123@Mir(bb42[0]), _124@Mir(bb42[1])
bb43:
  _118 = move _119 as usize (PointerExposeAddress)
  using: _119@Mir(bb42[2])
  _117 = Eq(move _118, const 0_usize)
  using: _118@Mir(bb43[0])
  assume(move _117)
  using: _117@Mir(bb43[1])
  _129 = const b"fgets\x00"
  using: 
  _128 = &raw const (*_129)
  using: _129@Mir(bb43[3])
  _127 = move _128 as *const u8 (Pointer(ArrayToPointer))
  using: _128@Mir(bb43[4])
  _126 = move _127 as *const i8 (PtrToPtr)
  using: _127@Mir(bb43[5])
  _125 = example4::perror(move _126) -> bb44
  using: _126@Mir(bb43[6])
bb44:
  _131 = const 1_i32
  using: 
  _130 = example4::exit(move _131)
  using: _131@Mir(bb44[0])
bb45:
  _135 = &mut _24
  using: _24@Phi(bb27)
  _134 = move _135 as &mut [i8] (Pointer(Unsize))
  using: _135@Mir(bb45[0])
  _133 = core::slice::<impl [i8]>::as_mut_ptr(move _134) -> bb46
  using: _134@Mir(bb45[1])
bb46:
  _139 = const b",\x00"
  using: 
  _138 = &raw const (*_139)
  using: _139@Mir(bb46[0])
  _137 = move _138 as *const u8 (Pointer(ArrayToPointer))
  using: _138@Mir(bb46[1])
  _136 = move _137 as *const i8 (PtrToPtr)
  using: _137@Mir(bb46[2])
  _132 = example4::strtok(move _133, move _136) -> bb47
  using: _133@Mir(bb45[2]), _136@Mir(bb46[3])
bb47:
  _72 = const 0_i32
  using: 
  goto -> bb48
  using: 
bb48:
  _141 = _72
  using: _72@Phi(bb48)
  _142 = const 4_i32
  using: 
  _140 = Lt(move _141, move _142)
  using: _141@Mir(bb48[0]), _142@Mir(bb48[1])
  switchInt(move _140) -> [0: bb54, otherwise: bb49]
  using: _140@Mir(bb48[2])
bb49:
  _145 = _132
  using: _132@Phi(bb48)
  _144 = move _145 as *const i8 (Pointer(MutToConstPointer))
  using: _145@Mir(bb49[0])
  _143 = example4::atof(move _144) -> bb50
  using: _144@Mir(bb49[1])
bb50:
  _147 = _77
  using: _77@Phi(bb48)
  _149 = _72
  using: _72@Phi(bb48)
  _148 = move _149 as isize (IntToInt)
  using: _149@Mir(bb50[1])
  _146 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _147, move _148) -> bb51
  using: _147@Mir(bb50[0]), _148@Mir(bb50[2])
bb51:
  (*_146) = move _143
  using: _146@Mir(bb50[3]), _143@Mir(bb49[2])
  _151 = const {0x0 as *mut i8}
  using: 
  _155 = const b",\x00"
  using: 
  _154 = &raw const (*_155)
  using: _155@Mir(bb51[2])
  _153 = move _154 as *const u8 (Pointer(ArrayToPointer))
  using: _154@Mir(bb51[3])
  _152 = move _153 as *const i8 (PtrToPtr)
  using: _153@Mir(bb51[4])
  _150 = example4::strtok(move _151, move _152) -> bb52
  using: _151@Mir(bb51[1]), _152@Mir(bb51[5])
bb52:
  _132 = move _150
  using: _150@Mir(bb51[6])
  _156 = CheckedAdd(_72, const 1_i32)
  using: _72@Phi(bb48)
  assert(!move (_156.1: bool), "attempt to compute `{} + {}`, which would overflow", _72, const 1_i32) -> bb53
  using: _156@Entry, _72@Entry
bb53:
  _72 = move (_156.0: i32)
  using: _156@Mir(bb52[1])
  goto -> bb48
  using: 
bb54:
  _157 = const 0_i32
  using: 
  _159 = _132
  using: _132@Phi(bb48)
  _164 = _132
  using: _132@Phi(bb48)
  _163 = move _164 as *const i8 (Pointer(MutToConstPointer))
  using: _164@Mir(bb54[2])
  _162 = example4::strlen(move _163) -> bb55
  using: _163@Mir(bb54[3])
bb55:
  _165 = const 1_u64
  using: 
  _161 = core::num::<impl u64>::wrapping_sub(move _162, move _165) -> bb56
  using: _162@Mir(bb54[4]), _165@Mir(bb55[0])
bb56:
  _160 = move _161 as isize (IntToInt)
  using: _161@Mir(bb55[1])
  _158 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _159, move _160) -> bb57
  using: _159@Mir(bb54[1]), _160@Mir(bb56[0])
bb57:
  (*_158) = move _157 as i8 (IntToInt)
  using: _158@Mir(bb56[1]), _157@Mir(bb54[0])
  _169 = _132
  using: _132@Phi(bb48)
  _168 = move _169 as *const i8 (Pointer(MutToConstPointer))
  using: _169@Mir(bb57[1])
  _171 = const {alloc92: *mut [*const i8; 3]}
  using: 
  _172 = const 0_usize
  using: 
  _170 = (*_171)[_172]
  using: _171@Mir(bb57[3]), _172@Mir(bb57[4])
  _167 = example4::strcmp(move _168, move _170) -> bb58
  using: _168@Mir(bb57[2]), _170@Mir(bb57[5])
bb58:
  _173 = const 0_i32
  using: 
  _166 = Eq(move _167, move _173)
  using: _167@Mir(bb57[6]), _173@Mir(bb58[0])
  switchInt(move _166) -> [0: bb61, otherwise: bb59]
  using: _166@Mir(bb58[1])
bb59:
  _175 = _85
  using: _85@Mir(bb31[2])
  _176 = const 0_isize
  using: 
  _174 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _175, move _176) -> bb60
  using: _175@Mir(bb59[0]), _176@Mir(bb59[1])
bb60:
  (*_174) = const 1f64
  using: _174@Mir(bb59[2])
  goto -> bb71
  using: 
bb61:
  _180 = _132
  using: _132@Phi(bb48)
  _179 = move _180 as *const i8 (Pointer(MutToConstPointer))
  using: _180@Mir(bb61[0])
  _182 = const {alloc92: *mut [*const i8; 3]}
  using: 
  _183 = const 1_usize
  using: 
  _181 = (*_182)[_183]
  using: _182@Mir(bb61[2]), _183@Mir(bb61[3])
  _178 = example4::strcmp(move _179, move _181) -> bb62
  using: _179@Mir(bb61[1]), _181@Mir(bb61[4])
bb62:
  _184 = const 0_i32
  using: 
  _177 = Eq(move _178, move _184)
  using: _178@Mir(bb61[5]), _184@Mir(bb62[0])
  switchInt(move _177) -> [0: bb65, otherwise: bb63]
  using: _177@Mir(bb62[1])
bb63:
  _186 = _85
  using: _85@Mir(bb31[2])
  _187 = const 1_isize
  using: 
  _185 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _186, move _187) -> bb64
  using: _186@Mir(bb63[0]), _187@Mir(bb63[1])
bb64:
  (*_185) = const 1f64
  using: _185@Mir(bb63[2])
  goto -> bb71
  using: 
bb65:
  _191 = _132
  using: _132@Phi(bb48)
  _190 = move _191 as *const i8 (Pointer(MutToConstPointer))
  using: _191@Mir(bb65[0])
  _193 = const {alloc92: *mut [*const i8; 3]}
  using: 
  _194 = const 2_usize
  using: 
  _192 = (*_193)[_194]
  using: _193@Mir(bb65[2]), _194@Mir(bb65[3])
  _189 = example4::strcmp(move _190, move _192) -> bb66
  using: _190@Mir(bb65[1]), _192@Mir(bb65[4])
bb66:
  _195 = const 0_i32
  using: 
  _188 = Eq(move _189, move _195)
  using: _189@Mir(bb65[5]), _195@Mir(bb66[0])
  switchInt(move _188) -> [0: bb69, otherwise: bb67]
  using: _188@Mir(bb66[1])
bb67:
  _197 = _85
  using: _85@Mir(bb31[2])
  _198 = const 2_isize
  using: 
  _196 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _197, move _198) -> bb68
  using: _197@Mir(bb67[0]), _198@Mir(bb67[1])
bb68:
  (*_196) = const 1f64
  using: _196@Mir(bb67[2])
  goto -> bb71
  using: 
bb69:
  _203 = const b"Unknown class %s.\n\x00"
  using: 
  _202 = &raw const (*_203)
  using: _203@Mir(bb69[0])
  _201 = move _202 as *const u8 (Pointer(ArrayToPointer))
  using: _202@Mir(bb69[1])
  _200 = move _201 as *const i8 (PtrToPtr)
  using: _201@Mir(bb69[2])
  _204 = _132
  using: _132@Phi(bb48)
  _199 = example4::printf(move _200, move _204) -> bb70
  using: _200@Mir(bb69[3]), _204@Mir(bb69[4])
bb70:
  _206 = const 1_i32
  using: 
  _205 = example4::exit(move _206)
  using: _206@Mir(bb70[0])
bb71:
  _207 = CheckedAdd(_71, const 1_i32)
  using: _71@Phi(bb27)
  assert(!move (_207.1: bool), "attempt to compute `{} + {}`, which would overflow", _71, const 1_i32) -> bb72
  using: _207@Entry, _71@Entry
bb72:
  _71 = move (_207.0: i32)
  using: _207@Mir(bb71[0])
  goto -> bb27
  using: 
bb73:
  _209 = _1
  using: _1@Phi(bb27)
  _208 = example4::fclose(move _209) -> bb74
  using: _209@Mir(bb73[0])
bb74:
  return
  using: _0@Entry
rewrite call example4::fopen @ workspace/genann/example4.rs:80:9: 81:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call example4::exit @ workspace/genann/example4.rs:85:9: 85:39 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [const 0_i8; 1024] is not supported
rewrite call example4::feof @ workspace/genann/example4.rs:89:11: 89:21 (#0) by default
rewrite call example4::fgets @ workspace/genann/example4.rs:90:16: 90:75 (#0) by default
rewrite call example4::fseek @ workspace/genann/example4.rs:93:5: 93:92 (#0) by default
rewrite call std::mem::size_of @ workspace/genann/example4.rs:98:17: 98:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/example4.rs:99:44: 100:75 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/example4.rs:100:76: 104:107 (#0) by default
rewrite call std::mem::size_of @ workspace/genann/example4.rs:107:17: 107:64 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/example4.rs:108:44: 109:75 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/example4.rs:109:76: 113:107 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:121:19: 121:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:123:19: 123:66 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:124:12: 124:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:124:114: 124:155 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:124:67: 124:108 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:125:59: 125:100 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:125:12: 125:53 (#0) by default
rewrite call example4::fgets @ workspace/genann/example4.rs:126:12: 126:71 (#0) by default
rewrite call example4::fgets @ workspace/genann/example4.rs:126:107: 126:166 (#0) by default
rewrite call example4::perror @ workspace/genann/example4.rs:127:13: 127:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call example4::exit @ workspace/genann/example4.rs:128:13: 128:43 (#0) by default
rewrite call example4::strtok @ workspace/genann/example4.rs:131:13: 132:73 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call example4::atof @ workspace/genann/example4.rs:135:37: 135:48 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:135:16: 135:34 (#0) by default
rewrite call example4::strtok @ workspace/genann/example4.rs:137:17: 138:77 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call example4::strlen @ workspace/genann/example4.rs:141:23: 141:36 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/example4.rs:141:37: 142:76 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:141:16: 142:86 (#0) by default
rewrite call example4::strcmp @ workspace/genann/example4.rs:144:12: 144:73 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:146:16: 146:57 (#0) by default
rewrite call example4::strcmp @ workspace/genann/example4.rs:147:19: 147:80 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:149:16: 149:57 (#0) by default
rewrite call example4::strcmp @ workspace/genann/example4.rs:150:19: 150:80 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:152:16: 152:57 (#0) by default
rewrite call example4::exit @ workspace/genann/example4.rs:156:13: 156:43 (#0) by default
rewrite call example4::fclose @ workspace/genann/example4.rs:161:5: 161:17 (#0) by default
@DefId(0:66 ~ c2rust_lib[1043]::example4::main_0)
bb0:
  _7 = const b"GENANN example 4.\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[0])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[1])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[2])
  _3 = example4::printf(move _4) -> bb1
  using: _4@Mir(bb0[3])
bb1:
  _12 = const b"Train an ANN on the IRIS dataset using backpropagation.\n\x00"
  using: 
  _11 = &raw const (*_12)
  using: _12@Mir(bb1[0])
  _10 = move _11 as *const u8 (Pointer(ArrayToPointer))
  using: _11@Mir(bb1[1])
  _9 = move _10 as *const i8 (PtrToPtr)
  using: _10@Mir(bb1[2])
  _8 = example4::printf(move _9) -> bb2
  using: _9@Mir(bb1[3])
bb2:
  _13 = example4::load_data() -> bb3
  using: 
bb3:
  _15 = const 4_i32
  using: 
  _16 = const 1_i32
  using: 
  _17 = const 4_i32
  using: 
  _18 = const 3_i32
  using: 
  _14 = genann::genann_init(move _15, move _16, move _17, move _18) -> bb4
  using: _15@Mir(bb3[0]), _16@Mir(bb3[1]), _17@Mir(bb3[2]), _18@Mir(bb3[3])
bb4:
  _19 = const 0_i32
  using: 
  _20 = const 0_i32
  using: 
  _21 = const 5000_i32
  using: 
  _26 = const b"Training for %d loops over data.\n\x00"
  using: 
  _25 = &raw const (*_26)
  using: _26@Mir(bb4[3])
  _24 = move _25 as *const u8 (Pointer(ArrayToPointer))
  using: _25@Mir(bb4[4])
  _23 = move _24 as *const i8 (PtrToPtr)
  using: _24@Mir(bb4[5])
  _27 = const 5000_i32
  using: 
  _22 = example4::printf(move _23, move _27) -> bb5
  using: _23@Mir(bb4[6]), _27@Mir(bb4[7])
bb5:
  _19 = const 0_i32
  using: 
  goto -> bb6
  using: 
bb6:
  _29 = _19
  using: _19@Phi(bb6)
  _30 = _21
  using: _21@Mir(bb4[2])
  _28 = Lt(move _29, move _30)
  using: _29@Mir(bb6[0]), _30@Mir(bb6[1])
  switchInt(move _28) -> [0: bb18, otherwise: bb7]
  using: _28@Mir(bb6[2])
bb7:
  _20 = const 0_i32
  using: 
  goto -> bb8
  using: 
bb8:
  _32 = _20
  using: _20@Phi(bb8)
  _34 = const {alloc89: *mut i32}
  using: 
  _33 = (*_34)
  using: _34@Mir(bb8[1])
  _31 = Lt(move _32, move _33)
  using: _32@Mir(bb8[0]), _33@Mir(bb8[2])
  switchInt(move _31) -> [0: bb16, otherwise: bb9]
  using: _31@Mir(bb8[3])
bb9:
  _37 = _14
  using: _14@Phi(bb8)
  _36 = move _37 as *const example1::genann (Pointer(MutToConstPointer))
  using: _37@Mir(bb9[0])
  _41 = const {alloc90: *mut *mut f64}
  using: 
  _40 = (*_41)
  using: _41@Mir(bb9[2])
  _44 = _20
  using: _20@Phi(bb8)
  _45 = const 4_i32
  using: 
  _46 = CheckedMul(_44, _45)
  using: _44@Mir(bb9[4]), _45@Mir(bb9[5])
  assert(!move (_46.1: bool), "attempt to compute `{} * {}`, which would overflow", move _44, move _45) -> bb10
  using: _46@Entry, _44@Entry, _45@Entry
bb10:
  _43 = move (_46.0: i32)
  using: _46@Mir(bb9[6])
  _42 = move _43 as isize (IntToInt)
  using: _43@Mir(bb10[0])
  _39 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _40, move _42) -> bb11
  using: _40@Mir(bb9[3]), _42@Mir(bb10[1])
bb11:
  _38 = move _39 as *const f64 (Pointer(MutToConstPointer))
  using: _39@Mir(bb10[2])
  _50 = const {alloc91: *mut *mut f64}
  using: 
  _49 = (*_50)
  using: _50@Mir(bb11[1])
  _53 = _20
  using: _20@Phi(bb8)
  _54 = const 3_i32
  using: 
  _55 = CheckedMul(_53, _54)
  using: _53@Mir(bb11[3]), _54@Mir(bb11[4])
  assert(!move (_55.1: bool), "attempt to compute `{} * {}`, which would overflow", move _53, move _54) -> bb12
  using: _55@Entry, _53@Entry, _54@Entry
bb12:
  _52 = move (_55.0: i32)
  using: _55@Mir(bb11[5])
  _51 = move _52 as isize (IntToInt)
  using: _52@Mir(bb12[0])
  _48 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _49, move _51) -> bb13
  using: _49@Mir(bb11[2]), _51@Mir(bb12[1])
bb13:
  _47 = move _48 as *const f64 (Pointer(MutToConstPointer))
  using: _48@Mir(bb12[2])
  _35 = genann::genann_train(move _36, move _38, move _47, const 0.01f64) -> bb14
  using: _36@Mir(bb9[1]), _38@Mir(bb11[0]), _47@Mir(bb13[0])
bb14:
  _56 = CheckedAdd(_20, const 1_i32)
  using: _20@Phi(bb8)
  assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, const 1_i32) -> bb15
  using: _56@Entry, _20@Entry
bb15:
  _20 = move (_56.0: i32)
  using: _56@Mir(bb14[0])
  goto -> bb8
  using: 
bb16:
  _57 = CheckedAdd(_19, const 1_i32)
  using: _19@Phi(bb6)
  assert(!move (_57.1: bool), "attempt to compute `{} + {}`, which would overflow", _19, const 1_i32) -> bb17
  using: _57@Entry, _19@Entry
bb17:
  _19 = move (_57.0: i32)
  using: _57@Mir(bb16[0])
  goto -> bb6
  using: 
bb18:
  _58 = const 0_i32
  using: 
  _20 = const 0_i32
  using: 
  goto -> bb19
  using: 
bb19:
  _60 = _20
  using: _20@Phi(bb19)
  _62 = const {alloc89: *mut i32}
  using: 
  _61 = (*_62)
  using: _62@Mir(bb19[1])
  _59 = Lt(move _60, move _61)
  using: _60@Mir(bb19[0]), _61@Mir(bb19[2])
  switchInt(move _59) -> [0: bb69, otherwise: bb20]
  using: _59@Mir(bb19[3])
bb20:
  _65 = _14
  using: _14@Phi(bb19)
  _64 = move _65 as *const example1::genann (Pointer(MutToConstPointer))
  using: _65@Mir(bb20[0])
  _69 = const {alloc90: *mut *mut f64}
  using: 
  _68 = (*_69)
  using: _69@Mir(bb20[2])
  _72 = _20
  using: _20@Phi(bb19)
  _73 = const 4_i32
  using: 
  _74 = CheckedMul(_72, _73)
  using: _72@Mir(bb20[4]), _73@Mir(bb20[5])
  assert(!move (_74.1: bool), "attempt to compute `{} * {}`, which would overflow", move _72, move _73) -> bb21
  using: _74@Entry, _72@Entry, _73@Entry
bb21:
  _71 = move (_74.0: i32)
  using: _74@Mir(bb20[6])
  _70 = move _71 as isize (IntToInt)
  using: _71@Mir(bb21[0])
  _67 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _68, move _70) -> bb22
  using: _68@Mir(bb20[3]), _70@Mir(bb21[1])
bb22:
  _66 = move _67 as *const f64 (Pointer(MutToConstPointer))
  using: _67@Mir(bb21[2])
  _63 = genann::genann_run(move _64, move _66) -> bb23
  using: _64@Mir(bb20[1]), _66@Mir(bb22[0])
bb23:
  _79 = const {alloc91: *mut *mut f64}
  using: 
  _78 = (*_79)
  using: _79@Mir(bb23[0])
  _83 = _20
  using: _20@Phi(bb19)
  _84 = const 3_i32
  using: 
  _85 = CheckedMul(_83, _84)
  using: _83@Mir(bb23[2]), _84@Mir(bb23[3])
  assert(!move (_85.1: bool), "attempt to compute `{} * {}`, which would overflow", move _83, move _84) -> bb24
  using: _85@Entry, _83@Entry, _84@Entry
bb24:
  _82 = move (_85.0: i32)
  using: _85@Mir(bb23[4])
  _86 = const 0_i32
  using: 
  _87 = CheckedAdd(_82, _86)
  using: _82@Mir(bb24[0]), _86@Mir(bb24[1])
  assert(!move (_87.1: bool), "attempt to compute `{} + {}`, which would overflow", move _82, move _86) -> bb25
  using: _87@Entry, _82@Entry, _86@Entry
bb25:
  _81 = move (_87.0: i32)
  using: _87@Mir(bb24[2])
  _80 = move _81 as isize (IntToInt)
  using: _81@Mir(bb25[0])
  _77 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _78, move _80) -> bb26
  using: _78@Mir(bb23[1]), _80@Mir(bb25[1])
bb26:
  _76 = (*_77)
  using: _77@Mir(bb25[2])
  _75 = Eq(move _76, const 1f64)
  using: _76@Mir(bb26[0])
  switchInt(move _75) -> [0: bb37, otherwise: bb27]
  using: _75@Mir(bb26[1])
bb27:
  _92 = _63
  using: _63@Mir(bb22[1])
  _93 = const 0_isize
  using: 
  _91 = std::ptr::const_ptr::<impl *const f64>::offset(move _92, move _93) -> bb31
  using: _92@Mir(bb27[0]), _93@Mir(bb27[1])
bb28:
  _88 = const false
  using: 
  goto -> bb30
  using: 
bb29:
  _101 = _63
  using: _63@Mir(bb22[1])
  _102 = const 0_isize
  using: 
  _100 = std::ptr::const_ptr::<impl *const f64>::offset(move _101, move _102) -> bb33
  using: _101@Mir(bb29[0]), _102@Mir(bb29[1])
bb30:
  switchInt(move _88) -> [0: bb67, otherwise: bb35]
  using: _88@Phi(bb30)
bb31:
  _90 = (*_91)
  using: _91@Mir(bb27[2])
  _96 = _63
  using: _63@Mir(bb22[1])
  _97 = const 1_isize
  using: 
  _95 = std::ptr::const_ptr::<impl *const f64>::offset(move _96, move _97) -> bb32
  using: _96@Mir(bb31[1]), _97@Mir(bb31[2])
bb32:
  _94 = (*_95)
  using: _95@Mir(bb31[3])
  _89 = Gt(move _90, move _94)
  using: _90@Mir(bb31[0]), _94@Mir(bb32[0])
  switchInt(move _89) -> [0: bb28, otherwise: bb29]
  using: _89@Mir(bb32[1])
bb33:
  _99 = (*_100)
  using: _100@Mir(bb29[2])
  _105 = _63
  using: _63@Mir(bb22[1])
  _106 = const 2_isize
  using: 
  _104 = std::ptr::const_ptr::<impl *const f64>::offset(move _105, move _106) -> bb34
  using: _105@Mir(bb33[1]), _106@Mir(bb33[2])
bb34:
  _103 = (*_104)
  using: _104@Mir(bb33[3])
  _98 = Gt(move _99, move _103)
  using: _99@Mir(bb33[0]), _103@Mir(bb34[0])
  _88 = move _98
  using: _98@Mir(bb34[1])
  goto -> bb30
  using: 
bb35:
  _107 = CheckedAdd(_58, const 1_i32)
  using: _58@Phi(bb19)
  assert(!move (_107.1: bool), "attempt to compute `{} + {}`, which would overflow", _58, const 1_i32) -> bb36
  using: _107@Entry, _58@Entry
bb36:
  _58 = move (_107.0: i32)
  using: _107@Mir(bb35[0])
  goto -> bb67
  using: 
bb37:
  _112 = const {alloc91: *mut *mut f64}
  using: 
  _111 = (*_112)
  using: _112@Mir(bb37[0])
  _116 = _20
  using: _20@Phi(bb19)
  _117 = const 3_i32
  using: 
  _118 = CheckedMul(_116, _117)
  using: _116@Mir(bb37[2]), _117@Mir(bb37[3])
  assert(!move (_118.1: bool), "attempt to compute `{} * {}`, which would overflow", move _116, move _117) -> bb38
  using: _118@Entry, _116@Entry, _117@Entry
bb38:
  _115 = move (_118.0: i32)
  using: _118@Mir(bb37[4])
  _119 = const 1_i32
  using: 
  _120 = CheckedAdd(_115, _119)
  using: _115@Mir(bb38[0]), _119@Mir(bb38[1])
  assert(!move (_120.1: bool), "attempt to compute `{} + {}`, which would overflow", move _115, move _119) -> bb39
  using: _120@Entry, _115@Entry, _119@Entry
bb39:
  _114 = move (_120.0: i32)
  using: _120@Mir(bb38[2])
  _113 = move _114 as isize (IntToInt)
  using: _114@Mir(bb39[0])
  _110 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _111, move _113) -> bb40
  using: _111@Mir(bb37[1]), _113@Mir(bb39[1])
bb40:
  _109 = (*_110)
  using: _110@Mir(bb39[2])
  _108 = Eq(move _109, const 1f64)
  using: _109@Mir(bb40[0])
  switchInt(move _108) -> [0: bb51, otherwise: bb41]
  using: _108@Mir(bb40[1])
bb41:
  _125 = _63
  using: _63@Phi(bb30)
  _126 = const 1_isize
  using: 
  _124 = std::ptr::const_ptr::<impl *const f64>::offset(move _125, move _126) -> bb45
  using: _125@Mir(bb41[0]), _126@Mir(bb41[1])
bb42:
  _121 = const false
  using: 
  goto -> bb44
  using: 
bb43:
  _134 = _63
  using: _63@Phi(bb30)
  _135 = const 1_isize
  using: 
  _133 = std::ptr::const_ptr::<impl *const f64>::offset(move _134, move _135) -> bb47
  using: _134@Mir(bb43[0]), _135@Mir(bb43[1])
bb44:
  switchInt(move _121) -> [0: bb67, otherwise: bb49]
  using: _121@Phi(bb44)
bb45:
  _123 = (*_124)
  using: _124@Mir(bb41[2])
  _129 = _63
  using: _63@Phi(bb30)
  _130 = const 0_isize
  using: 
  _128 = std::ptr::const_ptr::<impl *const f64>::offset(move _129, move _130) -> bb46
  using: _129@Mir(bb45[1]), _130@Mir(bb45[2])
bb46:
  _127 = (*_128)
  using: _128@Mir(bb45[3])
  _122 = Gt(move _123, move _127)
  using: _123@Mir(bb45[0]), _127@Mir(bb46[0])
  switchInt(move _122) -> [0: bb42, otherwise: bb43]
  using: _122@Mir(bb46[1])
bb47:
  _132 = (*_133)
  using: _133@Mir(bb43[2])
  _138 = _63
  using: _63@Phi(bb30)
  _139 = const 2_isize
  using: 
  _137 = std::ptr::const_ptr::<impl *const f64>::offset(move _138, move _139) -> bb48
  using: _138@Mir(bb47[1]), _139@Mir(bb47[2])
bb48:
  _136 = (*_137)
  using: _137@Mir(bb47[3])
  _131 = Gt(move _132, move _136)
  using: _132@Mir(bb47[0]), _136@Mir(bb48[0])
  _121 = move _131
  using: _131@Mir(bb48[1])
  goto -> bb44
  using: 
bb49:
  _140 = CheckedAdd(_58, const 1_i32)
  using: _58@Phi(bb19)
  assert(!move (_140.1: bool), "attempt to compute `{} + {}`, which would overflow", _58, const 1_i32) -> bb50
  using: _140@Entry, _58@Entry
bb50:
  _58 = move (_140.0: i32)
  using: _140@Mir(bb49[0])
  goto -> bb67
  using: 
bb51:
  _145 = const {alloc91: *mut *mut f64}
  using: 
  _144 = (*_145)
  using: _145@Mir(bb51[0])
  _149 = _20
  using: _20@Phi(bb19)
  _150 = const 3_i32
  using: 
  _151 = CheckedMul(_149, _150)
  using: _149@Mir(bb51[2]), _150@Mir(bb51[3])
  assert(!move (_151.1: bool), "attempt to compute `{} * {}`, which would overflow", move _149, move _150) -> bb52
  using: _151@Entry, _149@Entry, _150@Entry
bb52:
  _148 = move (_151.0: i32)
  using: _151@Mir(bb51[4])
  _152 = const 2_i32
  using: 
  _153 = CheckedAdd(_148, _152)
  using: _148@Mir(bb52[0]), _152@Mir(bb52[1])
  assert(!move (_153.1: bool), "attempt to compute `{} + {}`, which would overflow", move _148, move _152) -> bb53
  using: _153@Entry, _148@Entry, _152@Entry
bb53:
  _147 = move (_153.0: i32)
  using: _153@Mir(bb52[2])
  _146 = move _147 as isize (IntToInt)
  using: _147@Mir(bb53[0])
  _143 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _144, move _146) -> bb54
  using: _144@Mir(bb51[1]), _146@Mir(bb53[1])
bb54:
  _142 = (*_143)
  using: _143@Mir(bb53[2])
  _141 = Eq(move _142, const 1f64)
  using: _142@Mir(bb54[0])
  switchInt(move _141) -> [0: bb65, otherwise: bb55]
  using: _141@Mir(bb54[1])
bb55:
  _158 = _63
  using: _63@Phi(bb44)
  _159 = const 2_isize
  using: 
  _157 = std::ptr::const_ptr::<impl *const f64>::offset(move _158, move _159) -> bb59
  using: _158@Mir(bb55[0]), _159@Mir(bb55[1])
bb56:
  _154 = const false
  using: 
  goto -> bb58
  using: 
bb57:
  _167 = _63
  using: _63@Phi(bb44)
  _168 = const 2_isize
  using: 
  _166 = std::ptr::const_ptr::<impl *const f64>::offset(move _167, move _168) -> bb61
  using: _167@Mir(bb57[0]), _168@Mir(bb57[1])
bb58:
  switchInt(move _154) -> [0: bb67, otherwise: bb63]
  using: _154@Phi(bb58)
bb59:
  _156 = (*_157)
  using: _157@Mir(bb55[2])
  _162 = _63
  using: _63@Phi(bb44)
  _163 = const 0_isize
  using: 
  _161 = std::ptr::const_ptr::<impl *const f64>::offset(move _162, move _163) -> bb60
  using: _162@Mir(bb59[1]), _163@Mir(bb59[2])
bb60:
  _160 = (*_161)
  using: _161@Mir(bb59[3])
  _155 = Gt(move _156, move _160)
  using: _156@Mir(bb59[0]), _160@Mir(bb60[0])
  switchInt(move _155) -> [0: bb56, otherwise: bb57]
  using: _155@Mir(bb60[1])
bb61:
  _165 = (*_166)
  using: _166@Mir(bb57[2])
  _171 = _63
  using: _63@Phi(bb44)
  _172 = const 1_isize
  using: 
  _170 = std::ptr::const_ptr::<impl *const f64>::offset(move _171, move _172) -> bb62
  using: _171@Mir(bb61[1]), _172@Mir(bb61[2])
bb62:
  _169 = (*_170)
  using: _170@Mir(bb61[3])
  _164 = Gt(move _165, move _169)
  using: _165@Mir(bb61[0]), _169@Mir(bb62[0])
  _154 = move _164
  using: _164@Mir(bb62[1])
  goto -> bb58
  using: 
bb63:
  _173 = CheckedAdd(_58, const 1_i32)
  using: _58@Phi(bb19)
  assert(!move (_173.1: bool), "attempt to compute `{} + {}`, which would overflow", _58, const 1_i32) -> bb64
  using: _173@Entry, _58@Entry
bb64:
  _58 = move (_173.0: i32)
  using: _173@Mir(bb63[0])
  goto -> bb67
  using: 
bb65:
  _178 = const b"Logic error.\n\x00"
  using: 
  _177 = &raw const (*_178)
  using: _178@Mir(bb65[0])
  _176 = move _177 as *const u8 (Pointer(ArrayToPointer))
  using: _177@Mir(bb65[1])
  _175 = move _176 as *const i8 (PtrToPtr)
  using: _176@Mir(bb65[2])
  _174 = example4::printf(move _175) -> bb66
  using: _175@Mir(bb65[3])
bb66:
  _180 = const 1_i32
  using: 
  _179 = example4::exit(move _180)
  using: _180@Mir(bb66[0])
bb67:
  _181 = CheckedAdd(_20, const 1_i32)
  using: _20@Phi(bb67)
  assert(!move (_181.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, const 1_i32) -> bb68
  using: _181@Entry, _20@Entry
bb68:
  _20 = move (_181.0: i32)
  using: _181@Mir(bb67[0])
  goto -> bb19
  using: 
bb69:
  _186 = const b"%d/%d correct (%0.1f%%).\n\x00"
  using: 
  _185 = &raw const (*_186)
  using: _186@Mir(bb69[0])
  _184 = move _185 as *const u8 (Pointer(ArrayToPointer))
  using: _185@Mir(bb69[1])
  _183 = move _184 as *const i8 (PtrToPtr)
  using: _184@Mir(bb69[2])
  _187 = _58
  using: _58@Phi(bb67)
  _189 = const {alloc89: *mut i32}
  using: 
  _188 = (*_189)
  using: _189@Mir(bb69[5])
  _193 = _58
  using: _58@Phi(bb67)
  _192 = move _193 as f64 (IntToFloat)
  using: _193@Mir(bb69[7])
  _196 = const {alloc89: *mut i32}
  using: 
  _195 = (*_196)
  using: _196@Mir(bb69[9])
  _194 = move _195 as f64 (IntToFloat)
  using: _195@Mir(bb69[10])
  _191 = Div(move _192, move _194)
  using: _192@Mir(bb69[8]), _194@Mir(bb69[11])
  _190 = Mul(move _191, const 100f64)
  using: _191@Mir(bb69[12])
  _182 = example4::printf(move _183, move _187, move _188, move _190) -> bb70
  using: _183@Mir(bb69[3]), _187@Mir(bb69[4]), _188@Mir(bb69[6]), _190@Mir(bb69[13])
bb70:
  _198 = _14
  using: _14@Phi(bb19)
  _197 = genann::genann_free(move _198) -> bb71
  using: _198@Mir(bb70[0])
bb71:
  _0 = const 0_i32
  using: 
  return
  using: _0@Mir(bb71[0])
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:187:52: 187:99 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:188:32: 188:79 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:199:50: 199:97 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:200:19: 200:93 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:202:23: 202:64 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:204:27: 204:68 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:203:27: 203:68 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:205:31: 205:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:208:26: 209:43 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:210:23: 210:64 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:212:27: 212:68 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:211:27: 211:68 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:213:31: 213:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/example4.rs:216:26: 217:43 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:218:23: 218:64 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:220:27: 220:68 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:219:27: 219:68 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/example4.rs:221:31: 221:72 (#0) by default
rewrite call example4::exit @ workspace/genann/example4.rs:226:13: 226:43 (#0) by default
@DefId(0:84 ~ c2rust_lib[1043]::genann::genann_act_sigmoid)
bb0:
  _3 = _1
  using: _1@Entry
  _2 = Lt(move _3, const -45f64)
  using: _3@Mir(bb0[0])
  switchInt(move _2) -> [0: bb2, otherwise: bb1]
  using: _2@Mir(bb0[1])
bb1:
  _0 = const 0f64
  using: 
  goto -> bb6
  using: 
bb2:
  _5 = _1
  using: _1@Entry
  _4 = Gt(move _5, const 45f64)
  using: _5@Mir(bb2[0])
  switchInt(move _4) -> [0: bb4, otherwise: bb3]
  using: _4@Mir(bb2[1])
bb3:
  _0 = const 1f64
  using: 
  goto -> bb6
  using: 
bb4:
  _7 = const 1f64
  using: 
  _10 = _1
  using: _1@Entry
  _9 = Neg(move _10)
  using: _10@Mir(bb4[1])
  _8 = genann::exp(move _9) -> bb5
  using: _9@Mir(bb4[2])
bb5:
  _6 = Add(move _7, move _8)
  using: _7@Mir(bb4[0]), _8@Mir(bb4[3])
  _0 = Div(const 1f64, move _6)
  using: _6@Mir(bb5[0])
  goto -> bb6
  using: 
bb6:
  return
  using: _0@Phi(bb6)
rewrite call genann::exp @ workspace/genann/genann.rs:48:75: 48:82 (#0) by default
@DefId(0:85 ~ c2rust_lib[1043]::genann::genann_act_sigmoid_cached)
bb0:
  _2 = const -15f64
  using: 
  _3 = const 15f64
  using: 
  _5 = const {alloc122: *mut i32}
  using: 
  _4 = (*_5)
  using: _5@Mir(bb0[2])
  switchInt(move _4) -> [0: bb1, otherwise: bb8]
  using: _4@Mir(bb0[3])
bb1:
  _7 = _3
  using: _3@Mir(bb0[1])
  _8 = _2
  using: _2@Mir(bb0[0])
  _6 = Sub(move _7, move _8)
  using: _7@Mir(bb1[0]), _8@Mir(bb1[1])
  _9 = const 4096f64
  using: 
  _10 = const {alloc123: *mut f64}
  using: 
  (*_10) = Div(move _6, move _9)
  using: _10@Mir(bb1[4]), _6@Mir(bb1[2]), _9@Mir(bb1[3])
  _11 = const 0_i32
  using: 
  _11 = const 0_i32
  using: 
  goto -> bb2
  using: 
bb2:
  _13 = _11
  using: _11@Phi(bb2)
  _14 = const 4096_i32
  using: 
  _12 = Lt(move _13, move _14)
  using: _13@Mir(bb2[0]), _14@Mir(bb2[1])
  switchInt(move _12) -> [0: bb7, otherwise: bb3]
  using: _12@Mir(bb2[2])
bb3:
  _17 = _2
  using: _2@Phi(bb2)
  _20 = const {alloc123: *mut f64}
  using: 
  _19 = (*_20)
  using: _20@Mir(bb3[1])
  _22 = _11
  using: _11@Phi(bb2)
  _21 = move _22 as f64 (IntToFloat)
  using: _22@Mir(bb3[3])
  _18 = Mul(move _19, move _21)
  using: _19@Mir(bb3[2]), _21@Mir(bb3[4])
  _16 = Add(move _17, move _18)
  using: _17@Mir(bb3[0]), _18@Mir(bb3[5])
  _15 = genann::genann_act_sigmoid(move _16) -> bb4
  using: _16@Mir(bb3[6])
bb4:
  _23 = const {alloc124: *mut [f64; 4096]}
  using: 
  _25 = _11
  using: _11@Phi(bb2)
  _24 = move _25 as usize (IntToInt)
  using: _25@Mir(bb4[1])
  _26 = const 4096_usize
  using: 
  _27 = Lt(_24, _26)
  using: _24@Mir(bb4[2]), _26@Mir(bb4[3])
  assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _24) -> bb5
  using: _27@Entry, _26@Entry, _24@Entry
bb5:
  (*_23)[_24] = move _15
  using: _23@Mir(bb4[0]), _24@Mir(bb4[2]), _15@Mir(bb3[7])
  _28 = CheckedAdd(_11, const 1_i32)
  using: _11@Phi(bb2)
  assert(!move (_28.1: bool), "attempt to compute `{} + {}`, which would overflow", _11, const 1_i32) -> bb6
  using: _28@Entry, _11@Entry
bb6:
  _11 = move (_28.0: i32)
  using: _28@Mir(bb5[1])
  goto -> bb2
  using: 
bb7:
  _29 = const 1_i32
  using: 
  _30 = const {alloc122: *mut i32}
  using: 
  (*_30) = move _29
  using: _30@Mir(bb7[1]), _29@Mir(bb7[0])
  goto -> bb8
  using: 
bb8:
  _31 = const 0_i32
  using: 
  _35 = _1
  using: _1@Entry
  _36 = _2
  using: _2@Phi(bb8)
  _34 = Sub(move _35, move _36)
  using: _35@Mir(bb8[1]), _36@Mir(bb8[2])
  _38 = const {alloc123: *mut f64}
  using: 
  _37 = (*_38)
  using: _38@Mir(bb8[4])
  _33 = Div(move _34, move _37)
  using: _34@Mir(bb8[3]), _37@Mir(bb8[5])
  _32 = Add(move _33, const 0.5f64)
  using: _33@Mir(bb8[6])
  _31 = move _32 as i32 (FloatToInt)
  using: _32@Mir(bb8[7])
  _40 = _31
  using: _31@Mir(bb8[8])
  _41 = const 0_i32
  using: 
  _39 = Le(move _40, move _41)
  using: _40@Mir(bb8[9]), _41@Mir(bb8[10])
  switchInt(move _39) -> [0: bb10, otherwise: bb9]
  using: _39@Mir(bb8[11])
bb9:
  _42 = const {alloc124: *mut [f64; 4096]}
  using: 
  _43 = const 0_usize
  using: 
  _0 = (*_42)[_43]
  using: _42@Mir(bb9[0]), _43@Mir(bb9[1])
  goto -> bb14
  using: 
bb10:
  _45 = _31
  using: _31@Mir(bb8[8])
  _46 = const 4096_i32
  using: 
  _44 = Ge(move _45, move _46)
  using: _45@Mir(bb10[0]), _46@Mir(bb10[1])
  switchInt(move _44) -> [0: bb12, otherwise: bb11]
  using: _44@Mir(bb10[2])
bb11:
  _47 = const {alloc124: *mut [f64; 4096]}
  using: 
  _48 = const 4095_usize
  using: 
  _0 = (*_47)[_48]
  using: _47@Mir(bb11[0]), _48@Mir(bb11[1])
  goto -> bb14
  using: 
bb12:
  _49 = const {alloc124: *mut [f64; 4096]}
  using: 
  _51 = _31
  using: _31@Mir(bb8[8])
  _50 = move _51 as usize (IntToInt)
  using: _51@Mir(bb12[1])
  _52 = const 4096_usize
  using: 
  _53 = Lt(_50, _52)
  using: _50@Mir(bb12[2]), _52@Mir(bb12[3])
  assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _50) -> bb13
  using: _53@Entry, _52@Entry, _50@Entry
bb13:
  _0 = (*_49)[_50]
  using: _49@Mir(bb12[0]), _50@Mir(bb12[2])
  goto -> bb14
  using: 
bb14:
  return
  using: _0@Phi(bb14)
@DefId(0:91 ~ c2rust_lib[1043]::genann::genann_act_threshold)
bb0:
  _4 = _1
  using: _1@Entry
  _5 = const 0f64
  using: 
  _3 = Gt(move _4, move _5)
  using: _4@Mir(bb0[0]), _5@Mir(bb0[1])
  _2 = move _3 as i32 (IntToInt)
  using: _3@Mir(bb0[2])
  _0 = move _2 as f64 (IntToFloat)
  using: _2@Mir(bb0[3])
  return
  using: _0@Mir(bb0[4])
@DefId(0:92 ~ c2rust_lib[1043]::genann::genann_act_linear)
bb0:
  _0 = _1
  using: _1@Entry
  return
  using: _0@Mir(bb0[0])
@DefId(0:93 ~ c2rust_lib[1043]::genann::genann_init)
bb0:
  _6 = _2
  using: _2@Entry
  _7 = const 0_i32
  using: 
  _5 = Lt(move _6, move _7)
  using: _6@Mir(bb0[0]), _7@Mir(bb0[1])
  switchInt(move _5) -> [0: bb2, otherwise: bb1]
  using: _5@Mir(bb0[2])
bb1:
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb48
  using: 
bb2:
  _9 = _1
  using: _1@Entry
  _10 = const 1_i32
  using: 
  _8 = Lt(move _9, move _10)
  using: _9@Mir(bb2[0]), _10@Mir(bb2[1])
  switchInt(move _8) -> [0: bb4, otherwise: bb3]
  using: _8@Mir(bb2[2])
bb3:
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb48
  using: 
bb4:
  _12 = _4
  using: _4@Entry
  _13 = const 1_i32
  using: 
  _11 = Lt(move _12, move _13)
  using: _12@Mir(bb4[0]), _13@Mir(bb4[1])
  switchInt(move _11) -> [0: bb6, otherwise: bb5]
  using: _11@Mir(bb4[2])
bb5:
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb48
  using: 
bb6:
  _16 = _2
  using: _2@Entry
  _17 = const 0_i32
  using: 
  _15 = Gt(move _16, move _17)
  using: _16@Mir(bb6[0]), _17@Mir(bb6[1])
  switchInt(move _15) -> [0: bb7, otherwise: bb8]
  using: _15@Mir(bb6[2])
bb7:
  _14 = const false
  using: 
  goto -> bb9
  using: 
bb8:
  _19 = _3
  using: _3@Entry
  _20 = const 1_i32
  using: 
  _18 = Lt(move _19, move _20)
  using: _19@Mir(bb8[0]), _20@Mir(bb8[1])
  _14 = move _18
  using: _18@Mir(bb8[2])
  goto -> bb9
  using: 
bb9:
  switchInt(move _14) -> [0: bb11, otherwise: bb10]
  using: _14@Phi(bb9)
bb10:
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb48
  using: 
bb11:
  _22 = _2
  using: _2@Entry
  switchInt(move _22) -> [0: bb13, otherwise: bb12]
  using: _22@Mir(bb11[0])
bb12:
  _25 = _1
  using: _1@Entry
  _26 = const 1_i32
  using: 
  _27 = CheckedAdd(_25, _26)
  using: _25@Mir(bb12[0]), _26@Mir(bb12[1])
  assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", move _25, move _26) -> bb14
  using: _27@Entry, _25@Entry, _26@Entry
bb13:
  _21 = const 0_i32
  using: 
  goto -> bb21
  using: 
bb14:
  _24 = move (_27.0: i32)
  using: _27@Mir(bb12[2])
  _28 = _3
  using: _3@Phi(bb9)
  _29 = CheckedMul(_24, _28)
  using: _24@Mir(bb14[0]), _28@Mir(bb14[1])
  assert(!move (_29.1: bool), "attempt to compute `{} * {}`, which would overflow", move _24, move _28) -> bb15
  using: _29@Entry, _24@Entry, _28@Entry
bb15:
  _23 = move (_29.0: i32)
  using: _29@Mir(bb14[2])
  _33 = _2
  using: _2@Entry
  _34 = const 1_i32
  using: 
  _35 = CheckedSub(_33, _34)
  using: _33@Mir(bb15[1]), _34@Mir(bb15[2])
  assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", move _33, move _34) -> bb16
  using: _35@Entry, _33@Entry, _34@Entry
bb16:
  _32 = move (_35.0: i32)
  using: _35@Mir(bb15[3])
  _37 = _3
  using: _3@Phi(bb9)
  _38 = const 1_i32
  using: 
  _39 = CheckedAdd(_37, _38)
  using: _37@Mir(bb16[1]), _38@Mir(bb16[2])
  assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", move _37, move _38) -> bb17
  using: _39@Entry, _37@Entry, _38@Entry
bb17:
  _36 = move (_39.0: i32)
  using: _39@Mir(bb16[3])
  _40 = CheckedMul(_32, _36)
  using: _32@Mir(bb16[0]), _36@Mir(bb17[0])
  assert(!move (_40.1: bool), "attempt to compute `{} * {}`, which would overflow", move _32, move _36) -> bb18
  using: _40@Entry, _32@Entry, _36@Entry
bb18:
  _31 = move (_40.0: i32)
  using: _40@Mir(bb17[1])
  _41 = _3
  using: _3@Phi(bb9)
  _42 = CheckedMul(_31, _41)
  using: _31@Mir(bb18[0]), _41@Mir(bb18[1])
  assert(!move (_42.1: bool), "attempt to compute `{} * {}`, which would overflow", move _31, move _41) -> bb19
  using: _42@Entry, _31@Entry, _41@Entry
bb19:
  _30 = move (_42.0: i32)
  using: _42@Mir(bb18[2])
  _43 = CheckedAdd(_23, _30)
  using: _23@Mir(bb15[0]), _30@Mir(bb19[0])
  assert(!move (_43.1: bool), "attempt to compute `{} + {}`, which would overflow", move _23, move _30) -> bb20
  using: _43@Entry, _23@Entry, _30@Entry
bb20:
  _21 = move (_43.0: i32)
  using: _43@Mir(bb19[1])
  goto -> bb21
  using: 
bb21:
  _46 = _2
  using: _2@Phi(bb21)
  switchInt(move _46) -> [0: bb24, otherwise: bb22]
  using: _46@Mir(bb21[0])
bb22:
  _47 = _3
  using: _3@Phi(bb21)
  _48 = const 1_i32
  using: 
  _49 = CheckedAdd(_47, _48)
  using: _47@Mir(bb22[0]), _48@Mir(bb22[1])
  assert(!move (_49.1: bool), "attempt to compute `{} + {}`, which would overflow", move _47, move _48) -> bb23
  using: _49@Entry, _47@Entry, _48@Entry
bb23:
  _45 = move (_49.0: i32)
  using: _49@Mir(bb22[2])
  goto -> bb26
  using: 
bb24:
  _50 = _1
  using: _1@Phi(bb21)
  _51 = const 1_i32
  using: 
  _52 = CheckedAdd(_50, _51)
  using: _50@Mir(bb24[0]), _51@Mir(bb24[1])
  assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", move _50, move _51) -> bb25
  using: _52@Entry, _50@Entry, _51@Entry
bb25:
  _45 = move (_52.0: i32)
  using: _52@Mir(bb24[2])
  goto -> bb26
  using: 
bb26:
  _53 = _4
  using: _4@Entry
  _54 = CheckedMul(_45, _53)
  using: _45@Phi(bb26), _53@Mir(bb26[0])
  assert(!move (_54.1: bool), "attempt to compute `{} * {}`, which would overflow", move _45, move _53) -> bb27
  using: _54@Entry, _45@Entry, _53@Entry
bb27:
  _44 = move (_54.0: i32)
  using: _54@Mir(bb26[1])
  _56 = _21
  using: _21@Phi(bb21)
  _57 = _44
  using: _44@Mir(bb27[0])
  _58 = CheckedAdd(_56, _57)
  using: _56@Mir(bb27[1]), _57@Mir(bb27[2])
  assert(!move (_58.1: bool), "attempt to compute `{} + {}`, which would overflow", move _56, move _57) -> bb28
  using: _58@Entry, _56@Entry, _57@Entry
bb28:
  _55 = move (_58.0: i32)
  using: _58@Mir(bb27[3])
  _61 = _1
  using: _1@Phi(bb26)
  _63 = _3
  using: _3@Phi(bb26)
  _64 = _2
  using: _2@Phi(bb21)
  _65 = CheckedMul(_63, _64)
  using: _63@Mir(bb28[2]), _64@Mir(bb28[3])
  assert(!move (_65.1: bool), "attempt to compute `{} * {}`, which would overflow", move _63, move _64) -> bb29
  using: _65@Entry, _63@Entry, _64@Entry
bb29:
  _62 = move (_65.0: i32)
  using: _65@Mir(bb28[4])
  _66 = CheckedAdd(_61, _62)
  using: _61@Mir(bb28[1]), _62@Mir(bb29[0])
  assert(!move (_66.1: bool), "attempt to compute `{} + {}`, which would overflow", move _61, move _62) -> bb30
  using: _66@Entry, _61@Entry, _62@Entry
bb30:
  _60 = move (_66.0: i32)
  using: _66@Mir(bb29[1])
  _67 = _4
  using: _4@Entry
  _68 = CheckedAdd(_60, _67)
  using: _60@Mir(bb30[0]), _67@Mir(bb30[1])
  assert(!move (_68.1: bool), "attempt to compute `{} + {}`, which would overflow", move _60, move _67) -> bb31
  using: _68@Entry, _60@Entry, _67@Entry
bb31:
  _59 = move (_68.0: i32)
  using: _68@Mir(bb30[2])
  _72 = std::mem::size_of::<example1::genann>() -> bb32
  using: 
bb32:
  _71 = move _72 as u64 (IntToInt)
  using: _72@Mir(bb31[1])
  _75 = std::mem::size_of::<f64>() -> bb33
  using: 
bb33:
  _74 = move _75 as u64 (IntToInt)
  using: _75@Mir(bb32[1])
  _79 = _55
  using: _55@Mir(bb28[0])
  _80 = _59
  using: _59@Mir(bb31[0])
  _81 = CheckedAdd(_79, _80)
  using: _79@Mir(bb33[1]), _80@Mir(bb33[2])
  assert(!move (_81.1: bool), "attempt to compute `{} + {}`, which would overflow", move _79, move _80) -> bb34
  using: _81@Entry, _79@Entry, _80@Entry
bb34:
  _78 = move (_81.0: i32)
  using: _81@Mir(bb33[3])
  _83 = _59
  using: _59@Mir(bb31[0])
  _84 = _1
  using: _1@Phi(bb26)
  _85 = CheckedSub(_83, _84)
  using: _83@Mir(bb34[1]), _84@Mir(bb34[2])
  assert(!move (_85.1: bool), "attempt to compute `{} - {}`, which would overflow", move _83, move _84) -> bb35
  using: _85@Entry, _83@Entry, _84@Entry
bb35:
  _82 = move (_85.0: i32)
  using: _85@Mir(bb34[3])
  _86 = CheckedAdd(_78, _82)
  using: _78@Mir(bb34[0]), _82@Mir(bb35[0])
  assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", move _78, move _82) -> bb36
  using: _86@Entry, _78@Entry, _82@Entry
bb36:
  _77 = move (_86.0: i32)
  using: _86@Mir(bb35[1])
  _76 = move _77 as u64 (IntToInt)
  using: _77@Mir(bb36[0])
  _73 = core::num::<impl u64>::wrapping_mul(move _74, move _76) -> bb37
  using: _74@Mir(bb33[0]), _76@Mir(bb36[1])
bb37:
  _70 = core::num::<impl u64>::wrapping_add(move _71, move _73) -> bb38
  using: _71@Mir(bb32[0]), _73@Mir(bb36[2])
bb38:
  _69 = move _70 as i32 (IntToInt)
  using: _70@Mir(bb37[0])
  _90 = _69
  using: _69@Mir(bb38[0])
  _89 = move _90 as u64 (IntToInt)
  using: _90@Mir(bb38[1])
  _88 = genann::malloc(move _89) -> bb39
  using: _89@Mir(bb38[2])
bb39:
  _87 = move _88 as *mut example1::genann (PtrToPtr)
  using: _88@Mir(bb38[3])
  _92 = _87
  using: _87@Mir(bb39[0])
  _91 = std::ptr::mut_ptr::<impl *mut example1::genann>::is_null(move _92) -> bb40
  using: _92@Mir(bb39[1])
bb40:
  switchInt(move _91) -> [0: bb42, otherwise: bb41]
  using: _91@Mir(bb39[2])
bb41:
  _95 = _87
  using: _87@Mir(bb39[0])
  _94 = move _95 as usize (PointerExposeAddress)
  using: _95@Mir(bb41[0])
  _93 = Eq(move _94, const 0_usize)
  using: _94@Mir(bb41[1])
  assume(move _93)
  using: _93@Mir(bb41[2])
  _98 = _87
  using: _87@Mir(bb39[0])
  _97 = move _98 as usize (PointerExposeAddress)
  using: _98@Mir(bb41[4])
  _96 = Eq(move _97, const 0_usize)
  using: _97@Mir(bb41[5])
  assume(move _96)
  using: _96@Mir(bb41[6])
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb48
  using: 
bb42:
  _99 = _1
  using: _1@Phi(bb26)
  ((*_87).0: i32) = move _99
  using: _87@Mir(bb39[0]), _99@Mir(bb42[0])
  _100 = _2
  using: _2@Phi(bb21)
  ((*_87).1: i32) = move _100
  using: _87@Mir(bb39[0]), _100@Mir(bb42[2])
  _101 = _3
  using: _3@Phi(bb26)
  ((*_87).2: i32) = move _101
  using: _87@Mir(bb39[0]), _101@Mir(bb42[4])
  _102 = _4
  using: _4@Entry
  ((*_87).3: i32) = move _102
  using: _87@Mir(bb39[0]), _102@Mir(bb42[6])
  _103 = _55
  using: _55@Mir(bb28[0])
  ((*_87).6: i32) = move _103
  using: _87@Mir(bb39[0]), _103@Mir(bb42[8])
  _104 = _59
  using: _59@Mir(bb31[0])
  ((*_87).7: i32) = move _104
  using: _87@Mir(bb39[0]), _104@Mir(bb42[10])
  _107 = _87
  using: _87@Mir(bb39[0])
  _106 = move _107 as *mut i8 (PtrToPtr)
  using: _107@Mir(bb42[12])
  _110 = std::mem::size_of::<example1::genann>() -> bb43
  using: 
bb43:
  _109 = move _110 as u64 (IntToInt)
  using: _110@Mir(bb42[14])
  _108 = move _109 as isize (IntToInt)
  using: _109@Mir(bb43[0])
  _105 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _106, move _108) -> bb44
  using: _106@Mir(bb42[13]), _108@Mir(bb43[1])
bb44:
  ((*_87).8: *mut f64) = move _105 as *mut f64 (PtrToPtr)
  using: _87@Mir(bb39[0]), _105@Mir(bb43[2])
  _112 = ((*_87).8: *mut f64)
  using: _87@Mir(bb39[0])
  _114 = ((*_87).6: i32)
  using: _87@Mir(bb39[0])
  _113 = move _114 as isize (IntToInt)
  using: _114@Mir(bb44[2])
  _111 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _112, move _113) -> bb45
  using: _112@Mir(bb44[1]), _113@Mir(bb44[3])
bb45:
  ((*_87).9: *mut f64) = move _111
  using: _87@Mir(bb39[0]), _111@Mir(bb44[4])
  _116 = ((*_87).9: *mut f64)
  using: _87@Mir(bb39[0])
  _118 = ((*_87).7: i32)
  using: _87@Mir(bb39[0])
  _117 = move _118 as isize (IntToInt)
  using: _118@Mir(bb45[2])
  _115 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _116, move _117) -> bb46
  using: _116@Mir(bb45[1]), _117@Mir(bb45[3])
bb46:
  ((*_87).10: *mut f64) = move _115
  using: _87@Mir(bb39[0]), _115@Mir(bb45[4])
  _120 = _87
  using: _87@Mir(bb39[0])
  _119 = genann::genann_randomize(move _120) -> bb47
  using: _120@Mir(bb46[1])
bb47:
  _122 = genann::genann_act_sigmoid_cached as unsafe extern "C" fn(f64) -> f64 (Pointer(ReifyFnPointer))
  using: 
  Deinit(_121)
  using: 
  ((_121 as Some).0: unsafe extern "C" fn(f64) -> f64) = move _122
  using: _122@Mir(bb47[0])
  discriminant(_121) = 1
  using: 
  ((*_87).4: std::option::Option<unsafe extern "C" fn(f64) -> f64>) = move _121
  using: _87@Mir(bb39[0]), _121@Mir(bb47[1])
  _124 = genann::genann_act_sigmoid_cached as unsafe extern "C" fn(f64) -> f64 (Pointer(ReifyFnPointer))
  using: 
  Deinit(_123)
  using: 
  ((_123 as Some).0: unsafe extern "C" fn(f64) -> f64) = move _124
  using: _124@Mir(bb47[5])
  discriminant(_123) = 1
  using: 
  ((*_87).5: std::option::Option<unsafe extern "C" fn(f64) -> f64>) = move _123
  using: _87@Mir(bb39[0]), _123@Mir(bb47[6])
  _0 = _87
  using: _87@Mir(bb39[0])
  goto -> bb48
  using: 
bb48:
  return
  using: _0@Phi(bb48)
rewrite call std::mem::size_of @ workspace/genann/genann.rs:121:10: 121:58 (#0) by default
rewrite call std::mem::size_of @ workspace/genann/genann.rs:122:51: 122:98 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/genann.rs:124:70: 132:101 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/genann/genann.rs:122:37: 132:102 (#0) by default
rewrite call genann::malloc @ workspace/genann/genann.rs:134:49: 134:86 (#0) by default
rewrite call std::mem::size_of @ workspace/genann/genann.rs:145:48: 145:96 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:145:41: 146:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:148:35: 148:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:149:34: 149:71 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_121) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_121) = 1 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_123) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_123) = 1 is ignored
@DefId(0:94 ~ c2rust_lib[1043]::genann::genann_read)
bb0:
  _2 = const 0_i32
  using: 
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 0_i32
  using: 
  _6 = const 0_i32
  using: 
  _7 = const 0_i32
  using: 
  _8 = genann::__error() -> bb1
  using: 
bb1:
  (*_8) = move _7
  using: _8@Mir(bb0[6]), _7@Mir(bb0[5])
  _10 = _1
  using: _1@Entry
  _14 = const b"%d %d %d %d\x00"
  using: 
  _13 = &raw const (*_14)
  using: _14@Mir(bb1[2])
  _12 = move _13 as *const u8 (Pointer(ArrayToPointer))
  using: _13@Mir(bb1[3])
  _11 = move _12 as *const i8 (PtrToPtr)
  using: _12@Mir(bb1[4])
  _16 = &mut _2
  using: _2@Mir(bb0[0])
  _15 = &raw mut (*_16)
  using: _16@Mir(bb1[6])
  _18 = &mut _3
  using: _3@Mir(bb0[1])
  _17 = &raw mut (*_18)
  using: _18@Mir(bb1[8])
  _20 = &mut _4
  using: _4@Mir(bb0[2])
  _19 = &raw mut (*_20)
  using: _20@Mir(bb1[10])
  _22 = &mut _5
  using: _5@Mir(bb0[3])
  _21 = &raw mut (*_22)
  using: _22@Mir(bb1[12])
  _9 = genann::fscanf(move _10, move _11, move _15, move _17, move _19, move _21) -> bb2
  using: _10@Mir(bb1[1]), _11@Mir(bb1[5]), _15@Mir(bb1[7]), _17@Mir(bb1[9]), _19@Mir(bb1[11]), _21@Mir(bb1[13])
bb2:
  _6 = move _9
  using: _9@Mir(bb1[14])
  _25 = _6
  using: _6@Mir(bb2[0])
  _26 = const 4_i32
  using: 
  _24 = Lt(move _25, move _26)
  using: _25@Mir(bb2[1]), _26@Mir(bb2[2])
  switchInt(move _24) -> [0: bb4, otherwise: bb3]
  using: _24@Mir(bb2[3])
bb3:
  _23 = const true
  using: 
  goto -> bb5
  using: 
bb4:
  _29 = genann::__error() -> bb6
  using: 
bb5:
  switchInt(move _23) -> [0: bb9, otherwise: bb7]
  using: _23@Phi(bb5)
bb6:
  _28 = (*_29)
  using: _29@Mir(bb4[0])
  _30 = const 0_i32
  using: 
  _27 = Ne(move _28, move _30)
  using: _28@Mir(bb6[0]), _30@Mir(bb6[1])
  _23 = move _27
  using: _27@Mir(bb6[2])
  goto -> bb5
  using: 
bb7:
  _35 = const b"fscanf\x00"
  using: 
  _34 = &raw const (*_35)
  using: _35@Mir(bb7[0])
  _33 = move _34 as *const u8 (Pointer(ArrayToPointer))
  using: _34@Mir(bb7[1])
  _32 = move _33 as *const i8 (PtrToPtr)
  using: _33@Mir(bb7[2])
  _31 = genann::perror(move _32) -> bb8
  using: _32@Mir(bb7[3])
bb8:
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb26
  using: 
bb9:
  _37 = _2
  using: _2@Mir(bb0[0])
  _38 = _3
  using: _3@Mir(bb0[1])
  _39 = _4
  using: _4@Mir(bb0[2])
  _40 = _5
  using: _5@Mir(bb0[3])
  _36 = genann::genann_init(move _37, move _38, move _39, move _40) -> bb10
  using: _37@Mir(bb9[0]), _38@Mir(bb9[1]), _39@Mir(bb9[2]), _40@Mir(bb9[3])
bb10:
  _41 = const 0_i32
  using: 
  _41 = const 0_i32
  using: 
  goto -> bb11
  using: 
bb11:
  _43 = _41
  using: _41@Phi(bb11)
  _44 = ((*_36).6: i32)
  using: _36@Phi(bb11)
  _42 = Lt(move _43, move _44)
  using: _43@Mir(bb11[0]), _44@Mir(bb11[1])
  switchInt(move _42) -> [0: bb25, otherwise: bb12]
  using: _42@Mir(bb11[2])
bb12:
  _45 = const 0_i32
  using: 
  _46 = genann::__error() -> bb13
  using: 
bb13:
  (*_46) = move _45
  using: _46@Mir(bb12[1]), _45@Mir(bb12[0])
  _48 = _1
  using: _1@Phi(bb11)
  _52 = const b" %le\x00"
  using: 
  _51 = &raw const (*_52)
  using: _52@Mir(bb13[2])
  _50 = move _51 as *const u8 (Pointer(ArrayToPointer))
  using: _51@Mir(bb13[3])
  _49 = move _50 as *const i8 (PtrToPtr)
  using: _50@Mir(bb13[4])
  _54 = ((*_36).8: *mut f64)
  using: _36@Phi(bb11)
  _56 = _41
  using: _41@Phi(bb11)
  _55 = move _56 as isize (IntToInt)
  using: _56@Mir(bb13[7])
  _53 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _54, move _55) -> bb14
  using: _54@Mir(bb13[6]), _55@Mir(bb13[8])
bb14:
  _47 = genann::fscanf(move _48, move _49, move _53) -> bb15
  using: _48@Mir(bb13[1]), _49@Mir(bb13[5]), _53@Mir(bb13[9])
bb15:
  _6 = move _47
  using: _47@Mir(bb14[0])
  _59 = _6
  using: _6@Mir(bb15[0])
  _60 = const 1_i32
  using: 
  _58 = Lt(move _59, move _60)
  using: _59@Mir(bb15[1]), _60@Mir(bb15[2])
  switchInt(move _58) -> [0: bb17, otherwise: bb16]
  using: _58@Mir(bb15[3])
bb16:
  _57 = const true
  using: 
  goto -> bb18
  using: 
bb17:
  _63 = genann::__error() -> bb19
  using: 
bb18:
  switchInt(move _57) -> [0: bb23, otherwise: bb20]
  using: _57@Phi(bb18)
bb19:
  _62 = (*_63)
  using: _63@Mir(bb17[0])
  _64 = const 0_i32
  using: 
  _61 = Ne(move _62, move _64)
  using: _62@Mir(bb19[0]), _64@Mir(bb19[1])
  _57 = move _61
  using: _61@Mir(bb19[2])
  goto -> bb18
  using: 
bb20:
  _69 = const b"fscanf\x00"
  using: 
  _68 = &raw const (*_69)
  using: _69@Mir(bb20[0])
  _67 = move _68 as *const u8 (Pointer(ArrayToPointer))
  using: _68@Mir(bb20[1])
  _66 = move _67 as *const i8 (PtrToPtr)
  using: _67@Mir(bb20[2])
  _65 = genann::perror(move _66) -> bb21
  using: _66@Mir(bb20[3])
bb21:
  _71 = _36
  using: _36@Phi(bb11)
  _70 = genann::genann_free(move _71) -> bb22
  using: _71@Mir(bb21[0])
bb22:
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb26
  using: 
bb23:
  _72 = CheckedAdd(_41, const 1_i32)
  using: _41@Phi(bb11)
  assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _41, const 1_i32) -> bb24
  using: _72@Entry, _41@Entry
bb24:
  _41 = move (_72.0: i32)
  using: _72@Mir(bb23[0])
  goto -> bb11
  using: 
bb25:
  _0 = _36
  using: _36@Phi(bb11)
  goto -> bb26
  using: 
bb26:
  return
  using: _0@Phi(bb26)
rewrite call genann::__error @ workspace/genann/genann.rs:166:6: 166:15 (#0) by default
rewrite call genann::fscanf @ workspace/genann/genann.rs:168:9: 172:57 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call genann::__error @ workspace/genann/genann.rs:173:42: 173:51 (#0) by default
rewrite call genann::perror @ workspace/genann/genann.rs:174:9: 174:74 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call genann::__error @ workspace/genann/genann.rs:182:10: 182:19 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:185:34: 185:52 (#0) by default
rewrite call genann::fscanf @ workspace/genann/genann.rs:184:13: 185:53 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call genann::__error @ workspace/genann/genann.rs:186:46: 186:55 (#0) by default
rewrite call genann::perror @ workspace/genann/genann.rs:187:13: 187:78 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:95 ~ c2rust_lib[1043]::genann::genann_copy)
bb0:
  _5 = std::mem::size_of::<example1::genann>() -> bb1
  using: 
bb1:
  _4 = move _5 as u64 (IntToInt)
  using: _5@Mir(bb0[0])
  _8 = std::mem::size_of::<f64>() -> bb2
  using: 
bb2:
  _7 = move _8 as u64 (IntToInt)
  using: _8@Mir(bb1[1])
  _12 = ((*_1).6: i32)
  using: _1@Entry
  _13 = ((*_1).7: i32)
  using: _1@Entry
  _14 = CheckedAdd(_12, _13)
  using: _12@Mir(bb2[1]), _13@Mir(bb2[2])
  assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", move _12, move _13) -> bb3
  using: _14@Entry, _12@Entry, _13@Entry
bb3:
  _11 = move (_14.0: i32)
  using: _14@Mir(bb2[3])
  _16 = ((*_1).7: i32)
  using: _1@Entry
  _17 = ((*_1).0: i32)
  using: _1@Entry
  _18 = CheckedSub(_16, _17)
  using: _16@Mir(bb3[1]), _17@Mir(bb3[2])
  assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", move _16, move _17) -> bb4
  using: _18@Entry, _16@Entry, _17@Entry
bb4:
  _15 = move (_18.0: i32)
  using: _18@Mir(bb3[3])
  _19 = CheckedAdd(_11, _15)
  using: _11@Mir(bb3[0]), _15@Mir(bb4[0])
  assert(!move (_19.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, move _15) -> bb5
  using: _19@Entry, _11@Entry, _15@Entry
bb5:
  _10 = move (_19.0: i32)
  using: _19@Mir(bb4[1])
  _9 = move _10 as u64 (IntToInt)
  using: _10@Mir(bb5[0])
  _6 = core::num::<impl u64>::wrapping_mul(move _7, move _9) -> bb6
  using: _7@Mir(bb2[0]), _9@Mir(bb5[1])
bb6:
  _3 = core::num::<impl u64>::wrapping_add(move _4, move _6) -> bb7
  using: _4@Mir(bb1[0]), _6@Mir(bb5[2])
bb7:
  _2 = move _3 as i32 (IntToInt)
  using: _3@Mir(bb6[0])
  _23 = _2
  using: _2@Mir(bb7[0])
  _22 = move _23 as u64 (IntToInt)
  using: _23@Mir(bb7[1])
  _21 = genann::malloc(move _22) -> bb8
  using: _22@Mir(bb7[2])
bb8:
  _20 = move _21 as *mut example1::genann (PtrToPtr)
  using: _21@Mir(bb7[3])
  _25 = _20
  using: _20@Mir(bb8[0])
  _24 = std::ptr::mut_ptr::<impl *mut example1::genann>::is_null(move _25) -> bb9
  using: _25@Mir(bb8[1])
bb9:
  switchInt(move _24) -> [0: bb11, otherwise: bb10]
  using: _24@Mir(bb8[2])
bb10:
  _28 = _20
  using: _20@Mir(bb8[0])
  _27 = move _28 as usize (PointerExposeAddress)
  using: _28@Mir(bb10[0])
  _26 = Eq(move _27, const 0_usize)
  using: _27@Mir(bb10[1])
  assume(move _26)
  using: _26@Mir(bb10[2])
  _31 = _20
  using: _20@Mir(bb8[0])
  _30 = move _31 as usize (PointerExposeAddress)
  using: _31@Mir(bb10[4])
  _29 = Eq(move _30, const 0_usize)
  using: _30@Mir(bb10[5])
  assume(move _29)
  using: _29@Mir(bb10[6])
  _0 = const {0x0 as *mut example1::genann}
  using: 
  goto -> bb17
  using: 
bb11:
  _34 = _20
  using: _20@Mir(bb8[0])
  _33 = move _34 as *mut std::ffi::c_void (PtrToPtr)
  using: _34@Mir(bb11[0])
  _36 = _1
  using: _1@Entry
  _35 = move _36 as *const std::ffi::c_void (PtrToPtr)
  using: _36@Mir(bb11[2])
  _38 = _2
  using: _2@Mir(bb7[0])
  _37 = move _38 as u64 (IntToInt)
  using: _38@Mir(bb11[4])
  _32 = genann::memcpy(move _33, move _35, move _37) -> bb12
  using: _33@Mir(bb11[1]), _35@Mir(bb11[3]), _37@Mir(bb11[5])
bb12:
  _41 = _20
  using: _20@Mir(bb8[0])
  _40 = move _41 as *mut i8 (PtrToPtr)
  using: _41@Mir(bb12[0])
  _44 = std::mem::size_of::<example1::genann>() -> bb13
  using: 
bb13:
  _43 = move _44 as u64 (IntToInt)
  using: _44@Mir(bb12[2])
  _42 = move _43 as isize (IntToInt)
  using: _43@Mir(bb13[0])
  _39 = std::ptr::mut_ptr::<impl *mut i8>::offset(move _40, move _42) -> bb14
  using: _40@Mir(bb12[1]), _42@Mir(bb13[1])
bb14:
  ((*_20).8: *mut f64) = move _39 as *mut f64 (PtrToPtr)
  using: _20@Mir(bb8[0]), _39@Mir(bb13[2])
  _46 = ((*_20).8: *mut f64)
  using: _20@Mir(bb8[0])
  _48 = ((*_20).6: i32)
  using: _20@Mir(bb8[0])
  _47 = move _48 as isize (IntToInt)
  using: _48@Mir(bb14[2])
  _45 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _46, move _47) -> bb15
  using: _46@Mir(bb14[1]), _47@Mir(bb14[3])
bb15:
  ((*_20).9: *mut f64) = move _45
  using: _20@Mir(bb8[0]), _45@Mir(bb14[4])
  _50 = ((*_20).9: *mut f64)
  using: _20@Mir(bb8[0])
  _52 = ((*_20).7: i32)
  using: _20@Mir(bb8[0])
  _51 = move _52 as isize (IntToInt)
  using: _52@Mir(bb15[2])
  _49 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _50, move _51) -> bb16
  using: _50@Mir(bb15[1]), _51@Mir(bb15[3])
bb16:
  ((*_20).10: *mut f64) = move _49
  using: _20@Mir(bb8[0]), _49@Mir(bb15[4])
  _0 = _20
  using: _20@Mir(bb8[0])
  goto -> bb17
  using: 
bb17:
  return
  using: _0@Phi(bb17)
rewrite call std::mem::size_of @ workspace/genann/genann.rs:198:10: 198:58 (#0) by default
rewrite call std::mem::size_of @ workspace/genann/genann.rs:199:51: 199:98 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/genann.rs:201:70: 209:101 (#0) by default
rewrite call core::num::<impl u64>::wrapping_add @ workspace/genann/genann.rs:199:37: 209:102 (#0) by default
rewrite call genann::malloc @ workspace/genann/genann.rs:211:49: 211:86 (#0) by default
rewrite call genann::memcpy @ workspace/genann/genann.rs:213:5: 214:42 (#0) by default
rewrite call std::mem::size_of @ workspace/genann/genann.rs:218:48: 218:96 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:218:41: 219:75 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:221:35: 221:72 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:222:34: 222:71 (#0) by default
@DefId(0:96 ~ c2rust_lib[1043]::genann::genann_randomize)
bb0:
  _2 = const 0_i32
  using: 
  _2 = const 0_i32
  using: 
  goto -> bb1
  using: 
bb1:
  _4 = _2
  using: _2@Phi(bb1)
  _5 = ((*_1).6: i32)
  using: _1@Phi(bb1)
  _3 = Lt(move _4, move _5)
  using: _4@Mir(bb1[0]), _5@Mir(bb1[1])
  switchInt(move _3) -> [0: bb6, otherwise: bb2]
  using: _3@Mir(bb1[2])
bb2:
  _8 = genann::rand() -> bb3
  using: 
bb3:
  _7 = move _8 as f64 (IntToFloat)
  using: _8@Mir(bb2[0])
  _9 = const 2147483647f64
  using: 
  _6 = Div(move _7, move _9)
  using: _7@Mir(bb3[0]), _9@Mir(bb3[1])
  _10 = _6
  using: _6@Mir(bb3[2])
  _12 = ((*_1).8: *mut f64)
  using: _1@Phi(bb1)
  _14 = _2
  using: _2@Phi(bb1)
  _13 = move _14 as isize (IntToInt)
  using: _14@Mir(bb3[5])
  _11 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _12, move _13) -> bb4
  using: _12@Mir(bb3[4]), _13@Mir(bb3[6])
bb4:
  (*_11) = Sub(move _10, const 0.5f64)
  using: _11@Mir(bb3[7]), _10@Mir(bb3[3])
  _15 = CheckedAdd(_2, const 1_i32)
  using: _2@Phi(bb1)
  assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb5
  using: _15@Entry, _2@Entry
bb5:
  _2 = move (_15.0: i32)
  using: _15@Mir(bb4[1])
  goto -> bb1
  using: 
bb6:
  return
  using: _0@Entry
rewrite call genann::rand @ workspace/genann/genann.rs:231:13: 231:19 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:234:24: 234:42 (#0) by default
@DefId(0:97 ~ c2rust_lib[1043]::genann::genann_free)
bb0:
  _4 = _1
  using: _1@Entry
  _3 = move _4 as *mut std::ffi::c_void (PtrToPtr)
  using: _4@Mir(bb0[0])
  _2 = genann::free(move _3) -> bb1
  using: _3@Mir(bb0[1])
bb1:
  return
  using: _0@Entry
@DefId(0:98 ~ c2rust_lib[1043]::genann::genann_run)
bb0:
  _4 = ((*_1).8: *mut f64)
  using: _1@Entry
  _3 = move _4 as *const f64 (Pointer(MutToConstPointer))
  using: _4@Mir(bb0[0])
  _6 = ((*_1).9: *mut f64)
  using: _1@Entry
  _8 = ((*_1).0: i32)
  using: _1@Entry
  _7 = move _8 as isize (IntToInt)
  using: _8@Mir(bb0[3])
  _5 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _6, move _7) -> bb1
  using: _6@Mir(bb0[2]), _7@Mir(bb0[4])
bb1:
  _10 = ((*_1).9: *mut f64)
  using: _1@Entry
  _9 = move _10 as *const f64 (Pointer(MutToConstPointer))
  using: _10@Mir(bb1[0])
  _13 = ((*_1).9: *mut f64)
  using: _1@Entry
  _12 = move _13 as *mut std::ffi::c_void (PtrToPtr)
  using: _13@Mir(bb1[2])
  _15 = _2
  using: _2@Entry
  _14 = move _15 as *const std::ffi::c_void (PtrToPtr)
  using: _15@Mir(bb1[4])
  _18 = std::mem::size_of::<f64>() -> bb2
  using: 
bb2:
  _17 = move _18 as u64 (IntToInt)
  using: _18@Mir(bb1[6])
  _20 = ((*_1).0: i32)
  using: _1@Entry
  _19 = move _20 as u64 (IntToInt)
  using: _20@Mir(bb2[1])
  _16 = core::num::<impl u64>::wrapping_mul(move _17, move _19) -> bb3
  using: _17@Mir(bb2[0]), _19@Mir(bb2[2])
bb3:
  _11 = genann::memcpy(move _12, move _14, move _16) -> bb4
  using: _12@Mir(bb1[3]), _14@Mir(bb1[5]), _16@Mir(bb2[3])
bb4:
  _21 = const 0_i32
  using: 
  _22 = const 0_i32
  using: 
  _23 = const 0_i32
  using: 
  _24 = ((*_1).4: std::option::Option<unsafe extern "C" fn(f64) -> f64>)
  using: _1@Entry
  _25 = ((*_1).5: std::option::Option<unsafe extern "C" fn(f64) -> f64>)
  using: _1@Entry
  _21 = const 0_i32
  using: 
  goto -> bb5
  using: 
bb5:
  _27 = _21
  using: _21@Phi(bb5)
  _28 = ((*_1).1: i32)
  using: _1@Phi(bb5)
  _26 = Lt(move _27, move _28)
  using: _27@Mir(bb5[0]), _28@Mir(bb5[1])
  switchInt(move _26) -> [0: bb29, otherwise: bb6]
  using: _26@Mir(bb5[2])
bb6:
  _22 = const 0_i32
  using: 
  goto -> bb7
  using: 
bb7:
  _30 = _22
  using: _22@Phi(bb7)
  _31 = ((*_1).2: i32)
  using: _1@Phi(bb7)
  _29 = Lt(move _30, move _31)
  using: _30@Mir(bb7[0]), _31@Mir(bb7[1])
  switchInt(move _29) -> [0: bb23, otherwise: bb8]
  using: _29@Mir(bb7[2])
bb8:
  _32 = _3
  using: _3@Phi(bb7)
  _34 = _3
  using: _3@Phi(bb7)
  _33 = std::ptr::const_ptr::<impl *const f64>::offset(move _34, const 1_isize) -> bb9
  using: _34@Mir(bb8[1])
bb9:
  _3 = move _33
  using: _33@Mir(bb8[2])
  _36 = (*_32)
  using: _32@Mir(bb8[0])
  _35 = Mul(move _36, const -1f64)
  using: _36@Mir(bb9[1])
  _23 = const 0_i32
  using: 
  goto -> bb10
  using: 
bb10:
  _38 = _23
  using: _23@Phi(bb10)
  _41 = _21
  using: _21@Phi(bb7)
  _42 = const 0_i32
  using: 
  _40 = Eq(move _41, move _42)
  using: _41@Mir(bb10[1]), _42@Mir(bb10[2])
  switchInt(move _40) -> [0: bb12, otherwise: bb11]
  using: _40@Mir(bb10[3])
bb11:
  _39 = ((*_1).0: i32)
  using: _1@Phi(bb10)
  goto -> bb13
  using: 
bb12:
  _39 = ((*_1).2: i32)
  using: _1@Phi(bb10)
  goto -> bb13
  using: 
bb13:
  _37 = Lt(move _38, move _39)
  using: _38@Mir(bb10[0]), _39@Phi(bb13)
  switchInt(move _37) -> [0: bb18, otherwise: bb14]
  using: _37@Mir(bb13[0])
bb14:
  _43 = _3
  using: _3@Phi(bb10)
  _45 = _3
  using: _3@Phi(bb10)
  _44 = std::ptr::const_ptr::<impl *const f64>::offset(move _45, const 1_isize) -> bb15
  using: _45@Mir(bb14[1])
bb15:
  _3 = move _44
  using: _44@Mir(bb14[2])
  _47 = (*_43)
  using: _43@Mir(bb14[0])
  _50 = _9
  using: _9@Phi(bb10)
  _52 = _23
  using: _23@Phi(bb10)
  _51 = move _52 as isize (IntToInt)
  using: _52@Mir(bb15[3])
  _49 = std::ptr::const_ptr::<impl *const f64>::offset(move _50, move _51) -> bb16
  using: _50@Mir(bb15[2]), _51@Mir(bb15[4])
bb16:
  _48 = (*_49)
  using: _49@Mir(bb15[5])
  _46 = Mul(move _47, move _48)
  using: _47@Mir(bb15[1]), _48@Mir(bb16[0])
  _35 = Add(_35, move _46)
  using: _46@Mir(bb16[1])
  _53 = CheckedAdd(_23, const 1_i32)
  using: _23@Phi(bb10)
  assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", _23, const 1_i32) -> bb17
  using: _53@Entry, _23@Entry
bb17:
  _23 = move (_53.0: i32)
  using: _53@Mir(bb16[3])
  goto -> bb10
  using: 
bb18:
  _54 = _5
  using: _5@Phi(bb7)
  _56 = _5
  using: _5@Phi(bb7)
  _55 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _56, const 1_isize) -> bb19
  using: _56@Mir(bb18[1])
bb19:
  _5 = move _55
  using: _55@Mir(bb18[2])
  _59 = _24
  using: _24@Phi(bb7)
  _61 = const "non-null function pointer"
  using: 
  _60 = _61
  using: _61@Mir(bb19[2])
  _58 = std::option::Option::<unsafe extern "C" fn(f64) -> f64>::expect(move _59, move _60) -> bb20
  using: _59@Mir(bb19[1]), _60@Mir(bb19[3])
bb20:
  _62 = _35
  using: _35@Mir(bb16[2])
  _57 = move _58(move _62) -> bb21
  using: _58@Entry, _62@Mir(bb20[0])
bb21:
  (*_54) = move _57
  using: _54@Mir(bb18[0]), _57@Mir(bb20[1])
  _63 = CheckedAdd(_22, const 1_i32)
  using: _22@Phi(bb7)
  assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", _22, const 1_i32) -> bb22
  using: _63@Entry, _22@Entry
bb22:
  _22 = move (_63.0: i32)
  using: _63@Mir(bb21[1])
  goto -> bb7
  using: 
bb23:
  _65 = _9
  using: _9@Phi(bb10)
  _69 = _21
  using: _21@Phi(bb7)
  _70 = const 0_i32
  using: 
  _68 = Eq(move _69, move _70)
  using: _69@Mir(bb23[1]), _70@Mir(bb23[2])
  switchInt(move _68) -> [0: bb25, otherwise: bb24]
  using: _68@Mir(bb23[3])
bb24:
  _67 = ((*_1).0: i32)
  using: _1@Phi(bb13)
  goto -> bb26
  using: 
bb25:
  _67 = ((*_1).2: i32)
  using: _1@Phi(bb13)
  goto -> bb26
  using: 
bb26:
  _66 = move _67 as isize (IntToInt)
  using: _67@Phi(bb26)
  _64 = std::ptr::const_ptr::<impl *const f64>::offset(move _65, move _66) -> bb27
  using: _65@Mir(bb23[0]), _66@Mir(bb26[0])
bb27:
  _9 = move _64
  using: _64@Mir(bb26[1])
  _71 = CheckedAdd(_21, const 1_i32)
  using: _21@Phi(bb7)
  assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _21, const 1_i32) -> bb28
  using: _71@Entry, _21@Entry
bb28:
  _21 = move (_71.0: i32)
  using: _71@Mir(bb27[1])
  goto -> bb5
  using: 
bb29:
  _72 = _5
  using: _5@Phi(bb7)
  _0 = move _72 as *const f64 (Pointer(MutToConstPointer))
  using: _72@Mir(bb29[0])
  _22 = const 0_i32
  using: 
  goto -> bb30
  using: 
bb30:
  _74 = _22
  using: _22@Phi(bb30)
  _75 = ((*_1).3: i32)
  using: _1@Phi(bb30)
  _73 = Lt(move _74, move _75)
  using: _74@Mir(bb30[0]), _75@Mir(bb30[1])
  switchInt(move _73) -> [0: bb46, otherwise: bb31]
  using: _73@Mir(bb30[2])
bb31:
  _76 = _3
  using: _3@Phi(bb30)
  _78 = _3
  using: _3@Phi(bb30)
  _77 = std::ptr::const_ptr::<impl *const f64>::offset(move _78, const 1_isize) -> bb32
  using: _78@Mir(bb31[1])
bb32:
  _3 = move _77
  using: _77@Mir(bb31[2])
  _80 = (*_76)
  using: _76@Mir(bb31[0])
  _79 = Mul(move _80, const -1f64)
  using: _80@Mir(bb32[1])
  _23 = const 0_i32
  using: 
  goto -> bb33
  using: 
bb33:
  _82 = _23
  using: _23@Phi(bb33)
  _84 = ((*_1).1: i32)
  using: _1@Phi(bb33)
  switchInt(move _84) -> [0: bb35, otherwise: bb34]
  using: _84@Mir(bb33[1])
bb34:
  _83 = ((*_1).2: i32)
  using: _1@Phi(bb33)
  goto -> bb36
  using: 
bb35:
  _83 = ((*_1).0: i32)
  using: _1@Phi(bb33)
  goto -> bb36
  using: 
bb36:
  _81 = Lt(move _82, move _83)
  using: _82@Mir(bb33[0]), _83@Phi(bb36)
  switchInt(move _81) -> [0: bb41, otherwise: bb37]
  using: _81@Mir(bb36[0])
bb37:
  _85 = _3
  using: _3@Phi(bb33)
  _87 = _3
  using: _3@Phi(bb33)
  _86 = std::ptr::const_ptr::<impl *const f64>::offset(move _87, const 1_isize) -> bb38
  using: _87@Mir(bb37[1])
bb38:
  _3 = move _86
  using: _86@Mir(bb37[2])
  _89 = (*_85)
  using: _85@Mir(bb37[0])
  _92 = _9
  using: _9@Phi(bb33)
  _94 = _23
  using: _23@Phi(bb33)
  _93 = move _94 as isize (IntToInt)
  using: _94@Mir(bb38[3])
  _91 = std::ptr::const_ptr::<impl *const f64>::offset(move _92, move _93) -> bb39
  using: _92@Mir(bb38[2]), _93@Mir(bb38[4])
bb39:
  _90 = (*_91)
  using: _91@Mir(bb38[5])
  _88 = Mul(move _89, move _90)
  using: _89@Mir(bb38[1]), _90@Mir(bb39[0])
  _79 = Add(_79, move _88)
  using: _88@Mir(bb39[1])
  _95 = CheckedAdd(_23, const 1_i32)
  using: _23@Phi(bb33)
  assert(!move (_95.1: bool), "attempt to compute `{} + {}`, which would overflow", _23, const 1_i32) -> bb40
  using: _95@Entry, _23@Entry
bb40:
  _23 = move (_95.0: i32)
  using: _95@Mir(bb39[3])
  goto -> bb33
  using: 
bb41:
  _96 = _5
  using: _5@Phi(bb30)
  _98 = _5
  using: _5@Phi(bb30)
  _97 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _98, const 1_isize) -> bb42
  using: _98@Mir(bb41[1])
bb42:
  _5 = move _97
  using: _97@Mir(bb41[2])
  _101 = _25
  using: _25@Phi(bb30)
  _103 = const "non-null function pointer"
  using: 
  _102 = _103
  using: _103@Mir(bb42[2])
  _100 = std::option::Option::<unsafe extern "C" fn(f64) -> f64>::expect(move _101, move _102) -> bb43
  using: _101@Mir(bb42[1]), _102@Mir(bb42[3])
bb43:
  _104 = _79
  using: _79@Mir(bb39[2])
  _99 = move _100(move _104) -> bb44
  using: _100@Entry, _104@Mir(bb43[0])
bb44:
  (*_96) = move _99
  using: _96@Mir(bb41[0]), _99@Mir(bb43[1])
  _105 = CheckedAdd(_22, const 1_i32)
  using: _22@Phi(bb30)
  assert(!move (_105.1: bool), "attempt to compute `{} + {}`, which would overflow", _22, const 1_i32) -> bb45
  using: _105@Entry, _22@Entry
bb45:
  _22 = move (_105.0: i32)
  using: _105@Mir(bb44[1])
  goto -> bb30
  using: 
bb46:
  _112 = _3
  using: _3@Mir(bb32[0])
  _114 = ((*_1).8: *mut f64)
  using: _1@Phi(bb36)
  _113 = move _114 as *const f64 (Pointer(MutToConstPointer))
  using: _114@Mir(bb46[1])
  _111 = std::ptr::const_ptr::<impl *const f64>::offset_from(move _112, move _113) -> bb47
  using: _112@Mir(bb46[0]), _113@Mir(bb46[2])
bb47:
  _110 = move _111 as i64 (IntToInt)
  using: _111@Mir(bb46[3])
  _116 = ((*_1).6: i32)
  using: _1@Phi(bb36)
  _115 = move _116 as i64 (IntToInt)
  using: _116@Mir(bb47[1])
  _109 = Eq(move _110, move _115)
  using: _110@Mir(bb47[0]), _115@Mir(bb47[2])
  _108 = Not(move _109)
  using: _109@Mir(bb47[3])
  _107 = move _108 as i32 (IntToInt)
  using: _108@Mir(bb47[4])
  _106 = move _107 as i64 (IntToInt)
  using: _107@Mir(bb47[5])
  switchInt(move _106) -> [0: bb49, otherwise: bb48]
  using: _106@Mir(bb47[6])
bb48:
  _121 = const b"genann_run\x00"
  using: 
  _120 = &raw const (*_121)
  using: _121@Mir(bb48[0])
  _119 = move _120 as *const u8 (Pointer(ArrayToPointer))
  using: _120@Mir(bb48[1])
  _118 = move _119 as *const i8 (PtrToPtr)
  using: _119@Mir(bb48[2])
  _125 = const b"genann.c\x00"
  using: 
  _124 = &raw const (*_125)
  using: _125@Mir(bb48[4])
  _123 = move _124 as *const u8 (Pointer(ArrayToPointer))
  using: _124@Mir(bb48[5])
  _122 = move _123 as *const i8 (PtrToPtr)
  using: _123@Mir(bb48[6])
  _126 = const 225_i32
  using: 
  _130 = const b"w - ann->weight == ann->total_weights\x00"
  using: 
  _129 = &raw const (*_130)
  using: _130@Mir(bb48[9])
  _128 = move _129 as *const u8 (Pointer(ArrayToPointer))
  using: _129@Mir(bb48[10])
  _127 = move _128 as *const i8 (PtrToPtr)
  using: _128@Mir(bb48[11])
  _117 = genann::__assert_rtn(move _118, move _122, move _126, move _127)
  using: _118@Mir(bb48[3]), _122@Mir(bb48[7]), _126@Mir(bb48[8]), _127@Mir(bb48[12])
bb49:
  _137 = _5
  using: _5@Phi(bb30)
  _139 = ((*_1).9: *mut f64)
  using: _1@Phi(bb36)
  _138 = move _139 as *const f64 (Pointer(MutToConstPointer))
  using: _139@Mir(bb49[1])
  _136 = std::ptr::mut_ptr::<impl *mut f64>::offset_from(move _137, move _138) -> bb50
  using: _137@Mir(bb49[0]), _138@Mir(bb49[2])
bb50:
  _135 = move _136 as i64 (IntToInt)
  using: _136@Mir(bb49[3])
  _141 = ((*_1).7: i32)
  using: _1@Phi(bb36)
  _140 = move _141 as i64 (IntToInt)
  using: _141@Mir(bb50[1])
  _134 = Eq(move _135, move _140)
  using: _135@Mir(bb50[0]), _140@Mir(bb50[2])
  _133 = Not(move _134)
  using: _134@Mir(bb50[3])
  _132 = move _133 as i32 (IntToInt)
  using: _133@Mir(bb50[4])
  _131 = move _132 as i64 (IntToInt)
  using: _132@Mir(bb50[5])
  switchInt(move _131) -> [0: bb52, otherwise: bb51]
  using: _131@Mir(bb50[6])
bb51:
  _146 = const b"genann_run\x00"
  using: 
  _145 = &raw const (*_146)
  using: _146@Mir(bb51[0])
  _144 = move _145 as *const u8 (Pointer(ArrayToPointer))
  using: _145@Mir(bb51[1])
  _143 = move _144 as *const i8 (PtrToPtr)
  using: _144@Mir(bb51[2])
  _150 = const b"genann.c\x00"
  using: 
  _149 = &raw const (*_150)
  using: _150@Mir(bb51[4])
  _148 = move _149 as *const u8 (Pointer(ArrayToPointer))
  using: _149@Mir(bb51[5])
  _147 = move _148 as *const i8 (PtrToPtr)
  using: _148@Mir(bb51[6])
  _151 = const 226_i32
  using: 
  _155 = const b"o - ann->output == ann->total_neurons\x00"
  using: 
  _154 = &raw const (*_155)
  using: _155@Mir(bb51[9])
  _153 = move _154 as *const u8 (Pointer(ArrayToPointer))
  using: _154@Mir(bb51[10])
  _152 = move _153 as *const i8 (PtrToPtr)
  using: _153@Mir(bb51[11])
  _142 = genann::__assert_rtn(move _143, move _147, move _151, move _152)
  using: _143@Mir(bb51[3]), _147@Mir(bb51[7]), _151@Mir(bb51[8]), _152@Mir(bb51[12])
bb52:
  return
  using: _0@Mir(bb29[1])
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:249:23: 249:53 (#0) by default
rewrite call std::mem::size_of @ workspace/genann/genann.rs:254:13: 254:60 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/genann.rs:255:40: 255:92 (#0) by default
rewrite call genann::memcpy @ workspace/genann/genann.rs:253:5: 255:93 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:267:19: 267:28 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:275:23: 275:32 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:276:37: 276:55 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:280:19: 280:28 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/genann/genann.rs:281:27: 281:62 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:285:15: 287:56 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:295:15: 295:24 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:303:19: 303:28 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:304:35: 304:53 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:308:15: 308:24 (#0) by default
rewrite call std::option::Option::<T>::expect @ workspace/genann/genann.rs:309:24: 309:59 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset_from @ workspace/genann/genann.rs:313:12: 313:38 (#0) by default
rewrite call genann::__assert_rtn @ workspace/genann/genann.rs:316:9: 320:57 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset_from @ workspace/genann/genann.rs:322:12: 322:38 (#0) by default
rewrite call genann::__assert_rtn @ workspace/genann/genann.rs:325:9: 329:57 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:99 ~ c2rust_lib[1043]::genann::genann_train)
bb0:
  _6 = _1
  using: _1@Entry
  _7 = _2
  using: _2@Entry
  _5 = genann::genann_run(move _6, move _7) -> bb1
  using: _6@Mir(bb0[0]), _7@Mir(bb0[1])
bb1:
  _8 = const 0_i32
  using: 
  _9 = const 0_i32
  using: 
  _10 = const 0_i32
  using: 
  _14 = ((*_1).9: *mut f64)
  using: _1@Entry
  _16 = ((*_1).0: i32)
  using: _1@Entry
  _15 = move _16 as isize (IntToInt)
  using: _16@Mir(bb1[4])
  _13 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _14, move _15) -> bb2
  using: _14@Mir(bb1[3]), _15@Mir(bb1[5])
bb2:
  _19 = ((*_1).2: i32)
  using: _1@Entry
  _20 = ((*_1).1: i32)
  using: _1@Entry
  _21 = CheckedMul(_19, _20)
  using: _19@Mir(bb2[0]), _20@Mir(bb2[1])
  assert(!move (_21.1: bool), "attempt to compute `{} * {}`, which would overflow", move _19, move _20) -> bb3
  using: _21@Entry, _19@Entry, _20@Entry
bb3:
  _18 = move (_21.0: i32)
  using: _21@Mir(bb2[2])
  _17 = move _18 as isize (IntToInt)
  using: _18@Mir(bb3[0])
  _12 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _13, move _17) -> bb4
  using: _13@Mir(bb1[6]), _17@Mir(bb3[1])
bb4:
  _11 = move _12 as *const f64 (Pointer(MutToConstPointer))
  using: _12@Mir(bb3[2])
  _23 = ((*_1).10: *mut f64)
  using: _1@Entry
  _26 = ((*_1).2: i32)
  using: _1@Entry
  _27 = ((*_1).1: i32)
  using: _1@Entry
  _28 = CheckedMul(_26, _27)
  using: _26@Mir(bb4[2]), _27@Mir(bb4[3])
  assert(!move (_28.1: bool), "attempt to compute `{} * {}`, which would overflow", move _26, move _27) -> bb5
  using: _28@Entry, _26@Entry, _27@Entry
bb5:
  _25 = move (_28.0: i32)
  using: _28@Mir(bb4[4])
  _24 = move _25 as isize (IntToInt)
  using: _25@Mir(bb5[0])
  _22 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _23, move _24) -> bb6
  using: _23@Mir(bb4[1]), _24@Mir(bb5[1])
bb6:
  _29 = _3
  using: _3@Entry
  _31 = &((*_1).5: std::option::Option<unsafe extern "C" fn(f64) -> f64>)
  using: _1@Entry
  _385 = const _
  using: 
  _32 = _385
  using: _385@Mir(bb6[2])
  _30 = <std::option::Option<unsafe extern "C" fn(f64) -> f64> as std::cmp::PartialEq>::eq(move _31, move _32) -> bb7
  using: _31@Mir(bb6[1]), _32@Mir(bb6[3])
bb7:
  switchInt(move _30) -> [0: bb15, otherwise: bb8]
  using: _30@Mir(bb6[4])
bb8:
  _9 = const 0_i32
  using: 
  goto -> bb9
  using: 
bb9:
  _34 = _9
  using: _9@Phi(bb9)
  _35 = ((*_1).3: i32)
  using: _1@Entry
  _33 = Lt(move _34, move _35)
  using: _34@Mir(bb9[0]), _35@Mir(bb9[1])
  switchInt(move _33) -> [0: bb22, otherwise: bb10]
  using: _33@Mir(bb9[2])
bb10:
  _36 = _29
  using: _29@Phi(bb9)
  _38 = _29
  using: _29@Phi(bb9)
  _37 = std::ptr::const_ptr::<impl *const f64>::offset(move _38, const 1_isize) -> bb11
  using: _38@Mir(bb10[1])
bb11:
  _29 = move _37
  using: _37@Mir(bb10[2])
  _39 = _11
  using: _11@Phi(bb9)
  _41 = _11
  using: _11@Phi(bb9)
  _40 = std::ptr::const_ptr::<impl *const f64>::offset(move _41, const 1_isize) -> bb12
  using: _41@Mir(bb11[2])
bb12:
  _11 = move _40
  using: _40@Mir(bb11[3])
  _42 = _22
  using: _22@Phi(bb9)
  _44 = _22
  using: _22@Phi(bb9)
  _43 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _44, const 1_isize) -> bb13
  using: _44@Mir(bb12[2])
bb13:
  _22 = move _43
  using: _43@Mir(bb12[3])
  _45 = (*_36)
  using: _36@Mir(bb10[0])
  _46 = (*_39)
  using: _39@Mir(bb11[1])
  (*_42) = Sub(move _45, move _46)
  using: _42@Mir(bb12[1]), _45@Mir(bb13[1]), _46@Mir(bb13[2])
  _47 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb9)
  assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb14
  using: _47@Entry, _9@Entry
bb14:
  _9 = move (_47.0: i32)
  using: _47@Mir(bb13[4])
  goto -> bb9
  using: 
bb15:
  _9 = const 0_i32
  using: 
  goto -> bb16
  using: 
bb16:
  _49 = _9
  using: _9@Phi(bb16)
  _50 = ((*_1).3: i32)
  using: _1@Entry
  _48 = Lt(move _49, move _50)
  using: _49@Mir(bb16[0]), _50@Mir(bb16[1])
  switchInt(move _48) -> [0: bb22, otherwise: bb17]
  using: _48@Mir(bb16[2])
bb17:
  _51 = _22
  using: _22@Phi(bb16)
  _53 = _22
  using: _22@Phi(bb16)
  _52 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _53, const 1_isize) -> bb18
  using: _53@Mir(bb17[1])
bb18:
  _22 = move _52
  using: _52@Mir(bb17[2])
  _56 = (*_29)
  using: _29@Phi(bb16)
  _57 = (*_11)
  using: _11@Phi(bb16)
  _55 = Sub(move _56, move _57)
  using: _56@Mir(bb18[1]), _57@Mir(bb18[2])
  _58 = (*_11)
  using: _11@Phi(bb16)
  _54 = Mul(move _55, move _58)
  using: _55@Mir(bb18[3]), _58@Mir(bb18[4])
  _60 = (*_11)
  using: _11@Phi(bb16)
  _59 = Sub(const 1f64, move _60)
  using: _60@Mir(bb18[6])
  (*_51) = Mul(move _54, move _59)
  using: _51@Mir(bb17[0]), _54@Mir(bb18[5]), _59@Mir(bb18[7])
  _62 = _11
  using: _11@Phi(bb16)
  _61 = std::ptr::const_ptr::<impl *const f64>::offset(move _62, const 1_isize) -> bb19
  using: _62@Mir(bb18[9])
bb19:
  _11 = move _61
  using: _61@Mir(bb18[10])
  _64 = _29
  using: _29@Phi(bb16)
  _63 = std::ptr::const_ptr::<impl *const f64>::offset(move _64, const 1_isize) -> bb20
  using: _64@Mir(bb19[1])
bb20:
  _29 = move _63
  using: _63@Mir(bb19[2])
  _65 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb16)
  assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb21
  using: _65@Entry, _9@Entry
bb21:
  _9 = move (_65.0: i32)
  using: _65@Mir(bb20[1])
  goto -> bb16
  using: 
bb22:
  _66 = ((*_1).1: i32)
  using: _1@Phi(bb22)
  _67 = const 1_i32
  using: 
  _68 = CheckedSub(_66, _67)
  using: _66@Mir(bb22[0]), _67@Mir(bb22[1])
  assert(!move (_68.1: bool), "attempt to compute `{} - {}`, which would overflow", move _66, move _67) -> bb23
  using: _68@Entry, _66@Entry, _67@Entry
bb23:
  _8 = move (_68.0: i32)
  using: _68@Mir(bb22[2])
  goto -> bb24
  using: 
bb24:
  _70 = _8
  using: _8@Phi(bb24)
  _71 = const 0_i32
  using: 
  _69 = Ge(move _70, move _71)
  using: _70@Mir(bb24[0]), _71@Mir(bb24[1])
  switchInt(move _69) -> [0: bb62, otherwise: bb25]
  using: _69@Mir(bb24[2])
bb25:
  _75 = ((*_1).9: *mut f64)
  using: _1@Phi(bb24)
  _77 = ((*_1).0: i32)
  using: _1@Phi(bb24)
  _76 = move _77 as isize (IntToInt)
  using: _77@Mir(bb25[1])
  _74 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _75, move _76) -> bb26
  using: _75@Mir(bb25[0]), _76@Mir(bb25[2])
bb26:
  _80 = _8
  using: _8@Phi(bb24)
  _81 = ((*_1).2: i32)
  using: _1@Phi(bb24)
  _82 = CheckedMul(_80, _81)
  using: _80@Mir(bb26[0]), _81@Mir(bb26[1])
  assert(!move (_82.1: bool), "attempt to compute `{} * {}`, which would overflow", move _80, move _81) -> bb27
  using: _82@Entry, _80@Entry, _81@Entry
bb27:
  _79 = move (_82.0: i32)
  using: _82@Mir(bb26[2])
  _78 = move _79 as isize (IntToInt)
  using: _79@Mir(bb27[0])
  _73 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _74, move _78) -> bb28
  using: _74@Mir(bb25[3]), _78@Mir(bb27[1])
bb28:
  _72 = move _73 as *const f64 (Pointer(MutToConstPointer))
  using: _73@Mir(bb27[2])
  _84 = ((*_1).10: *mut f64)
  using: _1@Phi(bb24)
  _87 = _8
  using: _8@Phi(bb24)
  _88 = ((*_1).2: i32)
  using: _1@Phi(bb24)
  _89 = CheckedMul(_87, _88)
  using: _87@Mir(bb28[2]), _88@Mir(bb28[3])
  assert(!move (_89.1: bool), "attempt to compute `{} * {}`, which would overflow", move _87, move _88) -> bb29
  using: _89@Entry, _87@Entry, _88@Entry
bb29:
  _86 = move (_89.0: i32)
  using: _89@Mir(bb28[4])
  _85 = move _86 as isize (IntToInt)
  using: _86@Mir(bb29[0])
  _83 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _84, move _85) -> bb30
  using: _84@Mir(bb28[1]), _85@Mir(bb29[1])
bb30:
  _92 = ((*_1).10: *mut f64)
  using: _1@Phi(bb24)
  _96 = _8
  using: _8@Phi(bb24)
  _97 = const 1_i32
  using: 
  _98 = CheckedAdd(_96, _97)
  using: _96@Mir(bb30[1]), _97@Mir(bb30[2])
  assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", move _96, move _97) -> bb31
  using: _98@Entry, _96@Entry, _97@Entry
bb31:
  _95 = move (_98.0: i32)
  using: _98@Mir(bb30[3])
  _99 = ((*_1).2: i32)
  using: _1@Phi(bb24)
  _100 = CheckedMul(_95, _99)
  using: _95@Mir(bb31[0]), _99@Mir(bb31[1])
  assert(!move (_100.1: bool), "attempt to compute `{} * {}`, which would overflow", move _95, move _99) -> bb32
  using: _100@Entry, _95@Entry, _99@Entry
bb32:
  _94 = move (_100.0: i32)
  using: _100@Mir(bb31[2])
  _93 = move _94 as isize (IntToInt)
  using: _94@Mir(bb32[0])
  _91 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _92, move _93) -> bb33
  using: _92@Mir(bb30[0]), _93@Mir(bb32[1])
bb33:
  _90 = move _91 as *const f64 (Pointer(MutToConstPointer))
  using: _91@Mir(bb32[2])
  _104 = ((*_1).8: *mut f64)
  using: _1@Phi(bb24)
  _108 = ((*_1).0: i32)
  using: _1@Phi(bb24)
  _109 = const 1_i32
  using: 
  _110 = CheckedAdd(_108, _109)
  using: _108@Mir(bb33[2]), _109@Mir(bb33[3])
  assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", move _108, move _109) -> bb34
  using: _110@Entry, _108@Entry, _109@Entry
bb34:
  _107 = move (_110.0: i32)
  using: _110@Mir(bb33[4])
  _111 = ((*_1).2: i32)
  using: _1@Phi(bb24)
  _112 = CheckedMul(_107, _111)
  using: _107@Mir(bb34[0]), _111@Mir(bb34[1])
  assert(!move (_112.1: bool), "attempt to compute `{} * {}`, which would overflow", move _107, move _111) -> bb35
  using: _112@Entry, _107@Entry, _111@Entry
bb35:
  _106 = move (_112.0: i32)
  using: _112@Mir(bb34[2])
  _105 = move _106 as isize (IntToInt)
  using: _106@Mir(bb35[0])
  _103 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _104, move _105) -> bb36
  using: _104@Mir(bb33[1]), _105@Mir(bb35[1])
bb36:
  _117 = ((*_1).2: i32)
  using: _1@Phi(bb24)
  _118 = const 1_i32
  using: 
  _119 = CheckedAdd(_117, _118)
  using: _117@Mir(bb36[0]), _118@Mir(bb36[1])
  assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", move _117, move _118) -> bb37
  using: _119@Entry, _117@Entry, _118@Entry
bb37:
  _116 = move (_119.0: i32)
  using: _119@Mir(bb36[2])
  _120 = ((*_1).2: i32)
  using: _1@Phi(bb24)
  _121 = CheckedMul(_116, _120)
  using: _116@Mir(bb37[0]), _120@Mir(bb37[1])
  assert(!move (_121.1: bool), "attempt to compute `{} * {}`, which would overflow", move _116, move _120) -> bb38
  using: _121@Entry, _116@Entry, _120@Entry
bb38:
  _115 = move (_121.0: i32)
  using: _121@Mir(bb37[2])
  _122 = _8
  using: _8@Phi(bb24)
  _123 = CheckedMul(_115, _122)
  using: _115@Mir(bb38[0]), _122@Mir(bb38[1])
  assert(!move (_123.1: bool), "attempt to compute `{} * {}`, which would overflow", move _115, move _122) -> bb39
  using: _123@Entry, _115@Entry, _122@Entry
bb39:
  _114 = move (_123.0: i32)
  using: _123@Mir(bb38[2])
  _113 = move _114 as isize (IntToInt)
  using: _114@Mir(bb39[0])
  _102 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _103, move _113) -> bb40
  using: _103@Mir(bb35[2]), _113@Mir(bb39[1])
bb40:
  _101 = move _102 as *const f64 (Pointer(MutToConstPointer))
  using: _102@Mir(bb39[2])
  _9 = const 0_i32
  using: 
  goto -> bb41
  using: 
bb41:
  _125 = _9
  using: _9@Phi(bb41)
  _126 = ((*_1).2: i32)
  using: _1@Phi(bb41)
  _124 = Lt(move _125, move _126)
  using: _125@Mir(bb41[0]), _126@Mir(bb41[1])
  switchInt(move _124) -> [0: bb60, otherwise: bb42]
  using: _124@Mir(bb41[2])
bb42:
  _127 = const 0f64
  using: 
  _10 = const 0_i32
  using: 
  goto -> bb43
  using: 
bb43:
  _129 = _10
  using: _10@Phi(bb43)
  _132 = _8
  using: _8@Phi(bb41)
  _134 = ((*_1).1: i32)
  using: _1@Phi(bb43)
  _135 = const 1_i32
  using: 
  _136 = CheckedSub(_134, _135)
  using: _134@Mir(bb43[2]), _135@Mir(bb43[3])
  assert(!move (_136.1: bool), "attempt to compute `{} - {}`, which would overflow", move _134, move _135) -> bb44
  using: _136@Entry, _134@Entry, _135@Entry
bb44:
  _133 = move (_136.0: i32)
  using: _136@Mir(bb43[4])
  _131 = Eq(move _132, move _133)
  using: _132@Mir(bb43[1]), _133@Mir(bb44[0])
  switchInt(move _131) -> [0: bb46, otherwise: bb45]
  using: _131@Mir(bb44[1])
bb45:
  _130 = ((*_1).3: i32)
  using: _1@Phi(bb43)
  goto -> bb47
  using: 
bb46:
  _130 = ((*_1).2: i32)
  using: _1@Phi(bb43)
  goto -> bb47
  using: 
bb47:
  _128 = Lt(move _129, move _130)
  using: _129@Mir(bb43[0]), _130@Phi(bb47)
  switchInt(move _128) -> [0: bb56, otherwise: bb48]
  using: _128@Mir(bb47[0])
bb48:
  _139 = _90
  using: _90@Phi(bb43)
  _141 = _10
  using: _10@Phi(bb43)
  _140 = move _141 as isize (IntToInt)
  using: _141@Mir(bb48[1])
  _138 = std::ptr::const_ptr::<impl *const f64>::offset(move _139, move _140) -> bb49
  using: _139@Mir(bb48[0]), _140@Mir(bb48[2])
bb49:
  _137 = (*_138)
  using: _138@Mir(bb48[3])
  _144 = _10
  using: _10@Phi(bb43)
  _146 = ((*_1).2: i32)
  using: _1@Phi(bb47)
  _147 = const 1_i32
  using: 
  _148 = CheckedAdd(_146, _147)
  using: _146@Mir(bb49[2]), _147@Mir(bb49[3])
  assert(!move (_148.1: bool), "attempt to compute `{} + {}`, which would overflow", move _146, move _147) -> bb50
  using: _148@Entry, _146@Entry, _147@Entry
bb50:
  _145 = move (_148.0: i32)
  using: _148@Mir(bb49[4])
  _149 = CheckedMul(_144, _145)
  using: _144@Mir(bb49[1]), _145@Mir(bb50[0])
  assert(!move (_149.1: bool), "attempt to compute `{} * {}`, which would overflow", move _144, move _145) -> bb51
  using: _149@Entry, _144@Entry, _145@Entry
bb51:
  _143 = move (_149.0: i32)
  using: _149@Mir(bb50[1])
  _151 = _9
  using: _9@Phi(bb43)
  _152 = const 1_i32
  using: 
  _153 = CheckedAdd(_151, _152)
  using: _151@Mir(bb51[1]), _152@Mir(bb51[2])
  assert(!move (_153.1: bool), "attempt to compute `{} + {}`, which would overflow", move _151, move _152) -> bb52
  using: _153@Entry, _151@Entry, _152@Entry
bb52:
  _150 = move (_153.0: i32)
  using: _153@Mir(bb51[3])
  _154 = CheckedAdd(_143, _150)
  using: _143@Mir(bb51[0]), _150@Mir(bb52[0])
  assert(!move (_154.1: bool), "attempt to compute `{} + {}`, which would overflow", move _143, move _150) -> bb53
  using: _154@Entry, _143@Entry, _150@Entry
bb53:
  _142 = move (_154.0: i32)
  using: _154@Mir(bb52[1])
  _157 = _101
  using: _101@Phi(bb43)
  _159 = _142
  using: _142@Mir(bb53[0])
  _158 = move _159 as isize (IntToInt)
  using: _159@Mir(bb53[2])
  _156 = std::ptr::const_ptr::<impl *const f64>::offset(move _157, move _158) -> bb54
  using: _157@Mir(bb53[1]), _158@Mir(bb53[3])
bb54:
  _155 = (*_156)
  using: _156@Mir(bb53[4])
  _161 = _137
  using: _137@Mir(bb49[0])
  _162 = _155
  using: _155@Mir(bb54[0])
  _160 = Mul(move _161, move _162)
  using: _161@Mir(bb54[1]), _162@Mir(bb54[2])
  _127 = Add(_127, move _160)
  using: _160@Mir(bb54[3])
  _163 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb43)
  assert(!move (_163.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb55
  using: _163@Entry, _10@Entry
bb55:
  _10 = move (_163.0: i32)
  using: _163@Mir(bb54[5])
  goto -> bb43
  using: 
bb56:
  _165 = (*_72)
  using: _72@Phi(bb41)
  _167 = (*_72)
  using: _72@Phi(bb41)
  _166 = Sub(const 1f64, move _167)
  using: _167@Mir(bb56[1])
  _164 = Mul(move _165, move _166)
  using: _165@Mir(bb56[0]), _166@Mir(bb56[2])
  _168 = _127
  using: _127@Mir(bb54[4])
  (*_83) = Mul(move _164, move _168)
  using: _83@Phi(bb41), _164@Mir(bb56[3]), _168@Mir(bb56[4])
  _170 = _83
  using: _83@Phi(bb41)
  _169 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _170, const 1_isize) -> bb57
  using: _170@Mir(bb56[6])
bb57:
  _83 = move _169
  using: _169@Mir(bb56[7])
  _172 = _72
  using: _72@Phi(bb41)
  _171 = std::ptr::const_ptr::<impl *const f64>::offset(move _172, const 1_isize) -> bb58
  using: _172@Mir(bb57[1])
bb58:
  _72 = move _171
  using: _171@Mir(bb57[2])
  _173 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb43)
  assert(!move (_173.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb59
  using: _173@Entry, _9@Entry
bb59:
  _9 = move (_173.0: i32)
  using: _173@Mir(bb58[1])
  goto -> bb41
  using: 
bb60:
  _174 = CheckedSub(_8, const 1_i32)
  using: _8@Phi(bb41)
  assert(!move (_174.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_i32) -> bb61
  using: _174@Entry, _8@Entry
bb61:
  _8 = move (_174.0: i32)
  using: _174@Mir(bb60[0])
  goto -> bb24
  using: 
bb62:
  _177 = ((*_1).10: *mut f64)
  using: _1@Phi(bb47)
  _180 = ((*_1).2: i32)
  using: _1@Phi(bb47)
  _181 = ((*_1).1: i32)
  using: _1@Phi(bb47)
  _182 = CheckedMul(_180, _181)
  using: _180@Mir(bb62[1]), _181@Mir(bb62[2])
  assert(!move (_182.1: bool), "attempt to compute `{} * {}`, which would overflow", move _180, move _181) -> bb63
  using: _182@Entry, _180@Entry, _181@Entry
bb63:
  _179 = move (_182.0: i32)
  using: _182@Mir(bb62[3])
  _178 = move _179 as isize (IntToInt)
  using: _179@Mir(bb63[0])
  _176 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _177, move _178) -> bb64
  using: _177@Mir(bb62[0]), _178@Mir(bb63[1])
bb64:
  _175 = move _176 as *const f64 (Pointer(MutToConstPointer))
  using: _176@Mir(bb63[2])
  _184 = ((*_1).8: *mut f64)
  using: _1@Phi(bb47)
  _187 = ((*_1).1: i32)
  using: _1@Phi(bb47)
  switchInt(move _187) -> [0: bb73, otherwise: bb65]
  using: _187@Mir(bb64[2])
bb65:
  _190 = ((*_1).0: i32)
  using: _1@Phi(bb47)
  _191 = const 1_i32
  using: 
  _192 = CheckedAdd(_190, _191)
  using: _190@Mir(bb65[0]), _191@Mir(bb65[1])
  assert(!move (_192.1: bool), "attempt to compute `{} + {}`, which would overflow", move _190, move _191) -> bb66
  using: _192@Entry, _190@Entry, _191@Entry
bb66:
  _189 = move (_192.0: i32)
  using: _192@Mir(bb65[2])
  _193 = ((*_1).2: i32)
  using: _1@Phi(bb47)
  _194 = CheckedMul(_189, _193)
  using: _189@Mir(bb66[0]), _193@Mir(bb66[1])
  assert(!move (_194.1: bool), "attempt to compute `{} * {}`, which would overflow", move _189, move _193) -> bb67
  using: _194@Entry, _189@Entry, _193@Entry
bb67:
  _188 = move (_194.0: i32)
  using: _194@Mir(bb66[2])
  _198 = ((*_1).2: i32)
  using: _1@Phi(bb47)
  _199 = const 1_i32
  using: 
  _200 = CheckedAdd(_198, _199)
  using: _198@Mir(bb67[1]), _199@Mir(bb67[2])
  assert(!move (_200.1: bool), "attempt to compute `{} + {}`, which would overflow", move _198, move _199) -> bb68
  using: _200@Entry, _198@Entry, _199@Entry
bb68:
  _197 = move (_200.0: i32)
  using: _200@Mir(bb67[3])
  _201 = ((*_1).2: i32)
  using: _1@Phi(bb47)
  _202 = CheckedMul(_197, _201)
  using: _197@Mir(bb68[0]), _201@Mir(bb68[1])
  assert(!move (_202.1: bool), "attempt to compute `{} * {}`, which would overflow", move _197, move _201) -> bb69
  using: _202@Entry, _197@Entry, _201@Entry
bb69:
  _196 = move (_202.0: i32)
  using: _202@Mir(bb68[2])
  _204 = ((*_1).1: i32)
  using: _1@Phi(bb47)
  _205 = const 1_i32
  using: 
  _206 = CheckedSub(_204, _205)
  using: _204@Mir(bb69[1]), _205@Mir(bb69[2])
  assert(!move (_206.1: bool), "attempt to compute `{} - {}`, which would overflow", move _204, move _205) -> bb70
  using: _206@Entry, _204@Entry, _205@Entry
bb70:
  _203 = move (_206.0: i32)
  using: _206@Mir(bb69[3])
  _207 = CheckedMul(_196, _203)
  using: _196@Mir(bb69[0]), _203@Mir(bb70[0])
  assert(!move (_207.1: bool), "attempt to compute `{} * {}`, which would overflow", move _196, move _203) -> bb71
  using: _207@Entry, _196@Entry, _203@Entry
bb71:
  _195 = move (_207.0: i32)
  using: _207@Mir(bb70[1])
  _208 = CheckedAdd(_188, _195)
  using: _188@Mir(bb67[0]), _195@Mir(bb71[0])
  assert(!move (_208.1: bool), "attempt to compute `{} + {}`, which would overflow", move _188, move _195) -> bb72
  using: _208@Entry, _188@Entry, _195@Entry
bb72:
  _186 = move (_208.0: i32)
  using: _208@Mir(bb71[1])
  goto -> bb74
  using: 
bb73:
  _186 = const 0_i32
  using: 
  goto -> bb74
  using: 
bb74:
  _185 = move _186 as isize (IntToInt)
  using: _186@Phi(bb74)
  _183 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _184, move _185) -> bb75
  using: _184@Mir(bb64[1]), _185@Mir(bb74[0])
bb75:
  _211 = ((*_1).9: *mut f64)
  using: _1@Phi(bb74)
  _214 = ((*_1).1: i32)
  using: _1@Phi(bb74)
  switchInt(move _214) -> [0: bb80, otherwise: bb76]
  using: _214@Mir(bb75[1])
bb76:
  _215 = ((*_1).0: i32)
  using: _1@Phi(bb74)
  _217 = ((*_1).2: i32)
  using: _1@Phi(bb74)
  _219 = ((*_1).1: i32)
  using: _1@Phi(bb74)
  _220 = const 1_i32
  using: 
  _221 = CheckedSub(_219, _220)
  using: _219@Mir(bb76[2]), _220@Mir(bb76[3])
  assert(!move (_221.1: bool), "attempt to compute `{} - {}`, which would overflow", move _219, move _220) -> bb77
  using: _221@Entry, _219@Entry, _220@Entry
bb77:
  _218 = move (_221.0: i32)
  using: _221@Mir(bb76[4])
  _222 = CheckedMul(_217, _218)
  using: _217@Mir(bb76[1]), _218@Mir(bb77[0])
  assert(!move (_222.1: bool), "attempt to compute `{} * {}`, which would overflow", move _217, move _218) -> bb78
  using: _222@Entry, _217@Entry, _218@Entry
bb78:
  _216 = move (_222.0: i32)
  using: _222@Mir(bb77[1])
  _223 = CheckedAdd(_215, _216)
  using: _215@Mir(bb76[0]), _216@Mir(bb78[0])
  assert(!move (_223.1: bool), "attempt to compute `{} + {}`, which would overflow", move _215, move _216) -> bb79
  using: _223@Entry, _215@Entry, _216@Entry
bb79:
  _213 = move (_223.0: i32)
  using: _223@Mir(bb78[1])
  goto -> bb81
  using: 
bb80:
  _213 = const 0_i32
  using: 
  goto -> bb81
  using: 
bb81:
  _212 = move _213 as isize (IntToInt)
  using: _213@Phi(bb81)
  _210 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _211, move _212) -> bb82
  using: _211@Mir(bb75[0]), _212@Mir(bb81[0])
bb82:
  _209 = move _210 as *const f64 (Pointer(MutToConstPointer))
  using: _210@Mir(bb81[1])
  _9 = const 0_i32
  using: 
  goto -> bb83
  using: 
bb83:
  _225 = _9
  using: _9@Phi(bb83)
  _226 = ((*_1).3: i32)
  using: _1@Phi(bb83)
  _224 = Lt(move _225, move _226)
  using: _225@Mir(bb83[0]), _226@Mir(bb83[1])
  switchInt(move _224) -> [0: bb102, otherwise: bb84]
  using: _224@Mir(bb83[2])
bb84:
  _10 = const 0_i32
  using: 
  goto -> bb85
  using: 
bb85:
  _228 = _10
  using: _10@Phi(bb85)
  _231 = ((*_1).1: i32)
  using: _1@Phi(bb85)
  switchInt(move _231) -> [0: bb87, otherwise: bb86]
  using: _231@Mir(bb85[1])
bb86:
  _230 = ((*_1).2: i32)
  using: _1@Phi(bb85)
  goto -> bb88
  using: 
bb87:
  _230 = ((*_1).0: i32)
  using: _1@Phi(bb85)
  goto -> bb88
  using: 
bb88:
  _232 = const 1_i32
  using: 
  _233 = CheckedAdd(_230, _232)
  using: _230@Phi(bb88), _232@Mir(bb88[0])
  assert(!move (_233.1: bool), "attempt to compute `{} + {}`, which would overflow", move _230, move _232) -> bb89
  using: _233@Entry, _230@Entry, _232@Entry
bb89:
  _229 = move (_233.0: i32)
  using: _233@Mir(bb88[1])
  _227 = Lt(move _228, move _229)
  using: _228@Mir(bb85[0]), _229@Mir(bb89[0])
  switchInt(move _227) -> [0: bb99, otherwise: bb90]
  using: _227@Mir(bb89[1])
bb90:
  _235 = _10
  using: _10@Phi(bb85)
  _236 = const 0_i32
  using: 
  _234 = Eq(move _235, move _236)
  using: _235@Mir(bb90[0]), _236@Mir(bb90[1])
  switchInt(move _234) -> [0: bb93, otherwise: bb91]
  using: _234@Mir(bb90[2])
bb91:
  _237 = _183
  using: _183@Phi(bb85)
  _239 = _183
  using: _183@Phi(bb85)
  _238 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _239, const 1_isize) -> bb92
  using: _239@Mir(bb91[1])
bb92:
  _183 = move _238
  using: _238@Mir(bb91[2])
  _242 = (*_175)
  using: _175@Phi(bb85)
  _243 = _4
  using: _4@Phi(bb85)
  _241 = Mul(move _242, move _243)
  using: _242@Mir(bb92[1]), _243@Mir(bb92[2])
  _240 = Mul(move _241, const -1f64)
  using: _241@Mir(bb92[3])
  (*_237) = Add((*_237), move _240)
  using: _237@Mir(bb91[0]), _237@Mir(bb91[0]), _240@Mir(bb92[4])
  goto -> bb97
  using: 
bb93:
  _244 = _183
  using: _183@Phi(bb85)
  _246 = _183
  using: _183@Phi(bb85)
  _245 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _246, const 1_isize) -> bb94
  using: _246@Mir(bb93[1])
bb94:
  _183 = move _245
  using: _245@Mir(bb93[2])
  _249 = (*_175)
  using: _175@Phi(bb85)
  _250 = _4
  using: _4@Phi(bb85)
  _248 = Mul(move _249, move _250)
  using: _249@Mir(bb94[1]), _250@Mir(bb94[2])
  _253 = _209
  using: _209@Phi(bb85)
  _256 = _10
  using: _10@Phi(bb85)
  _257 = const 1_i32
  using: 
  _258 = CheckedSub(_256, _257)
  using: _256@Mir(bb94[5]), _257@Mir(bb94[6])
  assert(!move (_258.1: bool), "attempt to compute `{} - {}`, which would overflow", move _256, move _257) -> bb95
  using: _258@Entry, _256@Entry, _257@Entry
bb95:
  _255 = move (_258.0: i32)
  using: _258@Mir(bb94[7])
  _254 = move _255 as isize (IntToInt)
  using: _255@Mir(bb95[0])
  _252 = std::ptr::const_ptr::<impl *const f64>::offset(move _253, move _254) -> bb96
  using: _253@Mir(bb94[4]), _254@Mir(bb95[1])
bb96:
  _251 = (*_252)
  using: _252@Mir(bb95[2])
  _247 = Mul(move _248, move _251)
  using: _248@Mir(bb94[3]), _251@Mir(bb96[0])
  (*_244) = Add((*_244), move _247)
  using: _244@Mir(bb93[0]), _244@Mir(bb93[0]), _247@Mir(bb96[1])
  goto -> bb97
  using: 
bb97:
  _259 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb97)
  assert(!move (_259.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb98
  using: _259@Entry, _10@Entry
bb98:
  _10 = move (_259.0: i32)
  using: _259@Mir(bb97[0])
  goto -> bb85
  using: 
bb99:
  _261 = _175
  using: _175@Phi(bb97)
  _260 = std::ptr::const_ptr::<impl *const f64>::offset(move _261, const 1_isize) -> bb100
  using: _261@Mir(bb99[0])
bb100:
  _175 = move _260
  using: _260@Mir(bb99[1])
  _262 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb83)
  assert(!move (_262.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb101
  using: _262@Entry, _9@Entry
bb101:
  _9 = move (_262.0: i32)
  using: _262@Mir(bb100[1])
  goto -> bb83
  using: 
bb102:
  _269 = _183
  using: _183@Phi(bb97)
  _271 = ((*_1).8: *mut f64)
  using: _1@Phi(bb88)
  _270 = move _271 as *const f64 (Pointer(MutToConstPointer))
  using: _271@Mir(bb102[1])
  _268 = std::ptr::mut_ptr::<impl *mut f64>::offset_from(move _269, move _270) -> bb103
  using: _269@Mir(bb102[0]), _270@Mir(bb102[2])
bb103:
  _267 = move _268 as i64 (IntToInt)
  using: _268@Mir(bb102[3])
  _273 = ((*_1).6: i32)
  using: _1@Phi(bb88)
  _272 = move _273 as i64 (IntToInt)
  using: _273@Mir(bb103[1])
  _266 = Eq(move _267, move _272)
  using: _267@Mir(bb103[0]), _272@Mir(bb103[2])
  _265 = Not(move _266)
  using: _266@Mir(bb103[3])
  _264 = move _265 as i32 (IntToInt)
  using: _265@Mir(bb103[4])
  _263 = move _264 as i64 (IntToInt)
  using: _264@Mir(bb103[5])
  switchInt(move _263) -> [0: bb105, otherwise: bb104]
  using: _263@Mir(bb103[6])
bb104:
  _278 = const b"genann_train\x00"
  using: 
  _277 = &raw const (*_278)
  using: _278@Mir(bb104[0])
  _276 = move _277 as *const u8 (Pointer(ArrayToPointer))
  using: _277@Mir(bb104[1])
  _275 = move _276 as *const i8 (PtrToPtr)
  using: _276@Mir(bb104[2])
  _282 = const b"genann.c\x00"
  using: 
  _281 = &raw const (*_282)
  using: _282@Mir(bb104[4])
  _280 = move _281 as *const u8 (Pointer(ArrayToPointer))
  using: _281@Mir(bb104[5])
  _279 = move _280 as *const i8 (PtrToPtr)
  using: _280@Mir(bb104[6])
  _283 = const 318_i32
  using: 
  _287 = const b"w - ann->weight == ann->total_weights\x00"
  using: 
  _286 = &raw const (*_287)
  using: _287@Mir(bb104[9])
  _285 = move _286 as *const u8 (Pointer(ArrayToPointer))
  using: _286@Mir(bb104[10])
  _284 = move _285 as *const i8 (PtrToPtr)
  using: _285@Mir(bb104[11])
  _274 = genann::__assert_rtn(move _275, move _279, move _283, move _284)
  using: _275@Mir(bb104[3]), _279@Mir(bb104[7]), _283@Mir(bb104[8]), _284@Mir(bb104[12])
bb105:
  _288 = ((*_1).1: i32)
  using: _1@Phi(bb88)
  _289 = const 1_i32
  using: 
  _290 = CheckedSub(_288, _289)
  using: _288@Mir(bb105[0]), _289@Mir(bb105[1])
  assert(!move (_290.1: bool), "attempt to compute `{} - {}`, which would overflow", move _288, move _289) -> bb106
  using: _290@Entry, _288@Entry, _289@Entry
bb106:
  _8 = move (_290.0: i32)
  using: _290@Mir(bb105[2])
  goto -> bb107
  using: 
bb107:
  _292 = _8
  using: _8@Phi(bb107)
  _293 = const 0_i32
  using: 
  _291 = Ge(move _292, move _293)
  using: _292@Mir(bb107[0]), _293@Mir(bb107[1])
  switchInt(move _291) -> [0: bb150, otherwise: bb108]
  using: _291@Mir(bb107[2])
bb108:
  _296 = ((*_1).10: *mut f64)
  using: _1@Phi(bb107)
  _299 = _8
  using: _8@Phi(bb107)
  _300 = ((*_1).2: i32)
  using: _1@Phi(bb107)
  _301 = CheckedMul(_299, _300)
  using: _299@Mir(bb108[1]), _300@Mir(bb108[2])
  assert(!move (_301.1: bool), "attempt to compute `{} * {}`, which would overflow", move _299, move _300) -> bb109
  using: _301@Entry, _299@Entry, _300@Entry
bb109:
  _298 = move (_301.0: i32)
  using: _301@Mir(bb108[3])
  _297 = move _298 as isize (IntToInt)
  using: _298@Mir(bb109[0])
  _295 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _296, move _297) -> bb110
  using: _296@Mir(bb108[0]), _297@Mir(bb109[1])
bb110:
  _294 = move _295 as *const f64 (Pointer(MutToConstPointer))
  using: _295@Mir(bb109[2])
  _304 = ((*_1).9: *mut f64)
  using: _1@Phi(bb107)
  _307 = _8
  using: _8@Phi(bb107)
  switchInt(move _307) -> [0: bb115, otherwise: bb111]
  using: _307@Mir(bb110[2])
bb111:
  _308 = ((*_1).0: i32)
  using: _1@Phi(bb107)
  _310 = ((*_1).2: i32)
  using: _1@Phi(bb107)
  _312 = _8
  using: _8@Phi(bb107)
  _313 = const 1_i32
  using: 
  _314 = CheckedSub(_312, _313)
  using: _312@Mir(bb111[2]), _313@Mir(bb111[3])
  assert(!move (_314.1: bool), "attempt to compute `{} - {}`, which would overflow", move _312, move _313) -> bb112
  using: _314@Entry, _312@Entry, _313@Entry
bb112:
  _311 = move (_314.0: i32)
  using: _314@Mir(bb111[4])
  _315 = CheckedMul(_310, _311)
  using: _310@Mir(bb111[1]), _311@Mir(bb112[0])
  assert(!move (_315.1: bool), "attempt to compute `{} * {}`, which would overflow", move _310, move _311) -> bb113
  using: _315@Entry, _310@Entry, _311@Entry
bb113:
  _309 = move (_315.0: i32)
  using: _315@Mir(bb112[1])
  _316 = CheckedAdd(_308, _309)
  using: _308@Mir(bb111[0]), _309@Mir(bb113[0])
  assert(!move (_316.1: bool), "attempt to compute `{} + {}`, which would overflow", move _308, move _309) -> bb114
  using: _316@Entry, _308@Entry, _309@Entry
bb114:
  _306 = move (_316.0: i32)
  using: _316@Mir(bb113[1])
  goto -> bb116
  using: 
bb115:
  _306 = const 0_i32
  using: 
  goto -> bb116
  using: 
bb116:
  _305 = move _306 as isize (IntToInt)
  using: _306@Phi(bb116)
  _303 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _304, move _305) -> bb117
  using: _304@Mir(bb110[1]), _305@Mir(bb116[0])
bb117:
  _302 = move _303 as *const f64 (Pointer(MutToConstPointer))
  using: _303@Mir(bb116[1])
  _318 = ((*_1).8: *mut f64)
  using: _1@Phi(bb116)
  _321 = _8
  using: _8@Phi(bb116)
  switchInt(move _321) -> [0: bb126, otherwise: bb118]
  using: _321@Mir(bb117[2])
bb118:
  _324 = ((*_1).0: i32)
  using: _1@Phi(bb116)
  _325 = const 1_i32
  using: 
  _326 = CheckedAdd(_324, _325)
  using: _324@Mir(bb118[0]), _325@Mir(bb118[1])
  assert(!move (_326.1: bool), "attempt to compute `{} + {}`, which would overflow", move _324, move _325) -> bb119
  using: _326@Entry, _324@Entry, _325@Entry
bb119:
  _323 = move (_326.0: i32)
  using: _326@Mir(bb118[2])
  _327 = ((*_1).2: i32)
  using: _1@Phi(bb116)
  _328 = CheckedMul(_323, _327)
  using: _323@Mir(bb119[0]), _327@Mir(bb119[1])
  assert(!move (_328.1: bool), "attempt to compute `{} * {}`, which would overflow", move _323, move _327) -> bb120
  using: _328@Entry, _323@Entry, _327@Entry
bb120:
  _322 = move (_328.0: i32)
  using: _328@Mir(bb119[2])
  _332 = ((*_1).2: i32)
  using: _1@Phi(bb116)
  _333 = const 1_i32
  using: 
  _334 = CheckedAdd(_332, _333)
  using: _332@Mir(bb120[1]), _333@Mir(bb120[2])
  assert(!move (_334.1: bool), "attempt to compute `{} + {}`, which would overflow", move _332, move _333) -> bb121
  using: _334@Entry, _332@Entry, _333@Entry
bb121:
  _331 = move (_334.0: i32)
  using: _334@Mir(bb120[3])
  _335 = ((*_1).2: i32)
  using: _1@Phi(bb116)
  _336 = CheckedMul(_331, _335)
  using: _331@Mir(bb121[0]), _335@Mir(bb121[1])
  assert(!move (_336.1: bool), "attempt to compute `{} * {}`, which would overflow", move _331, move _335) -> bb122
  using: _336@Entry, _331@Entry, _335@Entry
bb122:
  _330 = move (_336.0: i32)
  using: _336@Mir(bb121[2])
  _338 = _8
  using: _8@Phi(bb116)
  _339 = const 1_i32
  using: 
  _340 = CheckedSub(_338, _339)
  using: _338@Mir(bb122[1]), _339@Mir(bb122[2])
  assert(!move (_340.1: bool), "attempt to compute `{} - {}`, which would overflow", move _338, move _339) -> bb123
  using: _340@Entry, _338@Entry, _339@Entry
bb123:
  _337 = move (_340.0: i32)
  using: _340@Mir(bb122[3])
  _341 = CheckedMul(_330, _337)
  using: _330@Mir(bb122[0]), _337@Mir(bb123[0])
  assert(!move (_341.1: bool), "attempt to compute `{} * {}`, which would overflow", move _330, move _337) -> bb124
  using: _341@Entry, _330@Entry, _337@Entry
bb124:
  _329 = move (_341.0: i32)
  using: _341@Mir(bb123[1])
  _342 = CheckedAdd(_322, _329)
  using: _322@Mir(bb120[0]), _329@Mir(bb124[0])
  assert(!move (_342.1: bool), "attempt to compute `{} + {}`, which would overflow", move _322, move _329) -> bb125
  using: _342@Entry, _322@Entry, _329@Entry
bb125:
  _320 = move (_342.0: i32)
  using: _342@Mir(bb124[1])
  goto -> bb127
  using: 
bb126:
  _320 = const 0_i32
  using: 
  goto -> bb127
  using: 
bb127:
  _319 = move _320 as isize (IntToInt)
  using: _320@Phi(bb127)
  _317 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _318, move _319) -> bb128
  using: _318@Mir(bb117[1]), _319@Mir(bb127[0])
bb128:
  _9 = const 0_i32
  using: 
  goto -> bb129
  using: 
bb129:
  _344 = _9
  using: _9@Phi(bb129)
  _345 = ((*_1).2: i32)
  using: _1@Phi(bb129)
  _343 = Lt(move _344, move _345)
  using: _344@Mir(bb129[0]), _345@Mir(bb129[1])
  switchInt(move _343) -> [0: bb148, otherwise: bb130]
  using: _343@Mir(bb129[2])
bb130:
  _10 = const 0_i32
  using: 
  goto -> bb131
  using: 
bb131:
  _347 = _10
  using: _10@Phi(bb131)
  _351 = _8
  using: _8@Phi(bb129)
  _352 = const 0_i32
  using: 
  _350 = Eq(move _351, move _352)
  using: _351@Mir(bb131[1]), _352@Mir(bb131[2])
  switchInt(move _350) -> [0: bb133, otherwise: bb132]
  using: _350@Mir(bb131[3])
bb132:
  _349 = ((*_1).0: i32)
  using: _1@Phi(bb131)
  goto -> bb134
  using: 
bb133:
  _349 = ((*_1).2: i32)
  using: _1@Phi(bb131)
  goto -> bb134
  using: 
bb134:
  _353 = const 1_i32
  using: 
  _354 = CheckedAdd(_349, _353)
  using: _349@Phi(bb134), _353@Mir(bb134[0])
  assert(!move (_354.1: bool), "attempt to compute `{} + {}`, which would overflow", move _349, move _353) -> bb135
  using: _354@Entry, _349@Entry, _353@Entry
bb135:
  _348 = move (_354.0: i32)
  using: _354@Mir(bb134[1])
  _346 = Lt(move _347, move _348)
  using: _347@Mir(bb131[0]), _348@Mir(bb135[0])
  switchInt(move _346) -> [0: bb145, otherwise: bb136]
  using: _346@Mir(bb135[1])
bb136:
  _356 = _10
  using: _10@Phi(bb131)
  _357 = const 0_i32
  using: 
  _355 = Eq(move _356, move _357)
  using: _356@Mir(bb136[0]), _357@Mir(bb136[1])
  switchInt(move _355) -> [0: bb139, otherwise: bb137]
  using: _355@Mir(bb136[2])
bb137:
  _358 = _317
  using: _317@Phi(bb131)
  _360 = _317
  using: _317@Phi(bb131)
  _359 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _360, const 1_isize) -> bb138
  using: _360@Mir(bb137[1])
bb138:
  _317 = move _359
  using: _359@Mir(bb137[2])
  _363 = (*_294)
  using: _294@Phi(bb131)
  _364 = _4
  using: _4@Phi(bb131)
  _362 = Mul(move _363, move _364)
  using: _363@Mir(bb138[1]), _364@Mir(bb138[2])
  _361 = Mul(move _362, const -1f64)
  using: _362@Mir(bb138[3])
  (*_358) = Add((*_358), move _361)
  using: _358@Mir(bb137[0]), _358@Mir(bb137[0]), _361@Mir(bb138[4])
  goto -> bb143
  using: 
bb139:
  _365 = _317
  using: _317@Phi(bb131)
  _367 = _317
  using: _317@Phi(bb131)
  _366 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _367, const 1_isize) -> bb140
  using: _367@Mir(bb139[1])
bb140:
  _317 = move _366
  using: _366@Mir(bb139[2])
  _370 = (*_294)
  using: _294@Phi(bb131)
  _371 = _4
  using: _4@Phi(bb131)
  _369 = Mul(move _370, move _371)
  using: _370@Mir(bb140[1]), _371@Mir(bb140[2])
  _374 = _302
  using: _302@Phi(bb131)
  _377 = _10
  using: _10@Phi(bb131)
  _378 = const 1_i32
  using: 
  _379 = CheckedSub(_377, _378)
  using: _377@Mir(bb140[5]), _378@Mir(bb140[6])
  assert(!move (_379.1: bool), "attempt to compute `{} - {}`, which would overflow", move _377, move _378) -> bb141
  using: _379@Entry, _377@Entry, _378@Entry
bb141:
  _376 = move (_379.0: i32)
  using: _379@Mir(bb140[7])
  _375 = move _376 as isize (IntToInt)
  using: _376@Mir(bb141[0])
  _373 = std::ptr::const_ptr::<impl *const f64>::offset(move _374, move _375) -> bb142
  using: _374@Mir(bb140[4]), _375@Mir(bb141[1])
bb142:
  _372 = (*_373)
  using: _373@Mir(bb141[2])
  _368 = Mul(move _369, move _372)
  using: _369@Mir(bb140[3]), _372@Mir(bb142[0])
  (*_365) = Add((*_365), move _368)
  using: _365@Mir(bb139[0]), _365@Mir(bb139[0]), _368@Mir(bb142[1])
  goto -> bb143
  using: 
bb143:
  _380 = CheckedAdd(_10, const 1_i32)
  using: _10@Phi(bb143)
  assert(!move (_380.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, const 1_i32) -> bb144
  using: _380@Entry, _10@Entry
bb144:
  _10 = move (_380.0: i32)
  using: _380@Mir(bb143[0])
  goto -> bb131
  using: 
bb145:
  _382 = _294
  using: _294@Phi(bb143)
  _381 = std::ptr::const_ptr::<impl *const f64>::offset(move _382, const 1_isize) -> bb146
  using: _382@Mir(bb145[0])
bb146:
  _294 = move _381
  using: _381@Mir(bb145[1])
  _383 = CheckedAdd(_9, const 1_i32)
  using: _9@Phi(bb129)
  assert(!move (_383.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> bb147
  using: _383@Entry, _9@Entry
bb147:
  _9 = move (_383.0: i32)
  using: _383@Mir(bb146[1])
  goto -> bb129
  using: 
bb148:
  _384 = CheckedSub(_8, const 1_i32)
  using: _8@Phi(bb129)
  assert(!move (_384.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_i32) -> bb149
  using: _384@Entry, _8@Entry
bb149:
  _8 = move (_384.0: i32)
  using: _384@Mir(bb148[0])
  goto -> bb107
  using: 
bb150:
  return
  using: _0@Entry
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:346:23: 347:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:347:41: 349:58 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:351:22: 352:39 (#0) by default
rewrite call std::cmp::PartialEq::eq @ workspace/genann/genann.rs:355:8: 357:95 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const reference is ignored
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:362:19: 362:28 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:364:19: 364:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:366:19: 366:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:374:19: 374:28 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:376:19: 376:28 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:377:19: 377:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:388:27: 389:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:389:45: 390:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:392:26: 392:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:395:26: 396:43 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:399:27: 401:44 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:401:45: 404:62 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:414:65: 414:83 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:419:25: 419:48 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:424:23: 424:32 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:425:23: 425:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:433:22: 434:39 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:436:23: 443:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:445:23: 450:77 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:460:23: 460:32 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:464:23: 464:32 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:467:28: 467:75 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:471:19: 471:28 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset_from @ workspace/genann/genann.rs:474:12: 474:38 (#0) by default
rewrite call genann::__assert_rtn @ workspace/genann/genann.rs:477:9: 481:57 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:491:26: 491:62 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:494:27: 498:81 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:501:27: 507:81 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:517:31: 517:40 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:521:31: 521:40 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:524:34: 524:81 (#0) by default
rewrite call std::ptr::const_ptr::<impl *const T>::offset @ workspace/genann/genann.rs:528:23: 528:32 (#0) by default
@DefId(0:100 ~ c2rust_lib[1043]::genann::genann_write)
bb0:
  _4 = _2
  using: _2@Entry
  _8 = const b"%d %d %d %d\x00"
  using: 
  _7 = &raw const (*_8)
  using: _8@Mir(bb0[1])
  _6 = move _7 as *const u8 (Pointer(ArrayToPointer))
  using: _7@Mir(bb0[2])
  _5 = move _6 as *const i8 (PtrToPtr)
  using: _6@Mir(bb0[3])
  _9 = ((*_1).0: i32)
  using: _1@Entry
  _10 = ((*_1).1: i32)
  using: _1@Entry
  _11 = ((*_1).2: i32)
  using: _1@Entry
  _12 = ((*_1).3: i32)
  using: _1@Entry
  _3 = genann::fprintf(move _4, move _5, move _9, move _10, move _11, move _12) -> bb1
  using: _4@Mir(bb0[0]), _5@Mir(bb0[4]), _9@Mir(bb0[5]), _10@Mir(bb0[6]), _11@Mir(bb0[7]), _12@Mir(bb0[8])
bb1:
  _13 = const 0_i32
  using: 
  _13 = const 0_i32
  using: 
  goto -> bb2
  using: 
bb2:
  _15 = _13
  using: _13@Phi(bb2)
  _16 = ((*_1).6: i32)
  using: _1@Phi(bb2)
  _14 = Lt(move _15, move _16)
  using: _15@Mir(bb2[0]), _16@Mir(bb2[1])
  switchInt(move _14) -> [0: bb7, otherwise: bb3]
  using: _14@Mir(bb2[2])
bb3:
  _18 = _2
  using: _2@Phi(bb2)
  _22 = const b" %.20e\x00"
  using: 
  _21 = &raw const (*_22)
  using: _22@Mir(bb3[1])
  _20 = move _21 as *const u8 (Pointer(ArrayToPointer))
  using: _21@Mir(bb3[2])
  _19 = move _20 as *const i8 (PtrToPtr)
  using: _20@Mir(bb3[3])
  _25 = ((*_1).8: *mut f64)
  using: _1@Phi(bb2)
  _27 = _13
  using: _13@Phi(bb2)
  _26 = move _27 as isize (IntToInt)
  using: _27@Mir(bb3[6])
  _24 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _25, move _26) -> bb4
  using: _25@Mir(bb3[5]), _26@Mir(bb3[7])
bb4:
  _23 = (*_24)
  using: _24@Mir(bb3[8])
  _17 = genann::fprintf(move _18, move _19, move _23) -> bb5
  using: _18@Mir(bb3[0]), _19@Mir(bb3[4]), _23@Mir(bb4[0])
bb5:
  _28 = CheckedAdd(_13, const 1_i32)
  using: _13@Phi(bb2)
  assert(!move (_28.1: bool), "attempt to compute `{} + {}`, which would overflow", _13, const 1_i32) -> bb6
  using: _28@Entry, _13@Entry
bb6:
  _13 = move (_28.0: i32)
  using: _28@Mir(bb5[0])
  goto -> bb2
  using: 
bb7:
  return
  using: _0@Entry
rewrite call genann::fprintf @ workspace/genann/genann.rs:537:5: 539:28 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/genann.rs:544:32: 544:50 (#0) by default
rewrite call genann::fprintf @ workspace/genann/genann.rs:543:9: 544:51 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:118 ~ c2rust_lib[1043]::test::basic)
bb0:
  _2 = const 1_i32
  using: 
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 1_i32
  using: 
  _1 = genann::genann_init(move _2, move _3, move _4, move _5) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1]), _4@Mir(bb0[2]), _5@Mir(bb0[3])
bb1:
  _6 = const {alloc184: *mut i32}
  using: 
  _7 = CheckedAdd((*_6), const 1_i32)
  using: _6@Mir(bb1[0])
  assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_6), const 1_i32) -> bb2
  using: _7@Entry, _6@Entry
bb2:
  (*_6) = move (_7.0: i32)
  using: _6@Mir(bb1[0]), _7@Mir(bb1[1])
  _9 = ((*_1).6: i32)
  using: _1@Mir(bb0[4])
  _10 = const 2_i32
  using: 
  _8 = Ne(move _9, move _10)
  using: _9@Mir(bb2[1]), _10@Mir(bb2[2])
  switchInt(move _8) -> [0: bb5, otherwise: bb3]
  using: _8@Mir(bb2[3])
bb3:
  _11 = const {alloc185: *mut i32}
  using: 
  _12 = CheckedAdd((*_11), const 1_i32)
  using: _11@Mir(bb3[0])
  assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_11), const 1_i32) -> bb4
  using: _12@Entry, _11@Entry
bb4:
  (*_11) = move (_12.0: i32)
  using: _11@Mir(bb3[0]), _12@Mir(bb3[1])
  _17 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _16 = &raw const (*_17)
  using: _17@Mir(bb4[1])
  _15 = move _16 as *const u8 (Pointer(ArrayToPointer))
  using: _16@Mir(bb4[2])
  _14 = move _15 as *const i8 (PtrToPtr)
  using: _15@Mir(bb4[3])
  _21 = const b"test.c\x00"
  using: 
  _20 = &raw const (*_21)
  using: _21@Mir(bb4[5])
  _19 = move _20 as *const u8 (Pointer(ArrayToPointer))
  using: _20@Mir(bb4[6])
  _18 = move _19 as *const i8 (PtrToPtr)
  using: _19@Mir(bb4[7])
  _22 = const 37_i32
  using: 
  _23 = ((*_1).6: i32)
  using: _1@Mir(bb0[4])
  _24 = const 2_i32
  using: 
  _13 = test::printf(move _14, move _18, move _22, move _23, move _24) -> bb5
  using: _14@Mir(bb4[4]), _18@Mir(bb4[8]), _22@Mir(bb4[9]), _23@Mir(bb4[10]), _24@Mir(bb4[11])
bb5:
  _25 = const 0f64
  using: 
  _26 = const 0_i32
  using: 
  _25 = move _26 as f64 (IntToFloat)
  using: _26@Mir(bb5[1])
  _27 = const 0_i32
  using: 
  _29 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _30 = const 0_isize
  using: 
  _28 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _29, move _30) -> bb6
  using: _29@Mir(bb5[4]), _30@Mir(bb5[5])
bb6:
  (*_28) = move _27 as f64 (IntToFloat)
  using: _28@Mir(bb5[6]), _27@Mir(bb5[3])
  _31 = const 0_i32
  using: 
  _33 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _34 = const 1_isize
  using: 
  _32 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _33, move _34) -> bb7
  using: _33@Mir(bb6[2]), _34@Mir(bb6[3])
bb7:
  (*_32) = move _31 as f64 (IntToFloat)
  using: _32@Mir(bb6[4]), _31@Mir(bb6[1])
  _35 = const {alloc184: *mut i32}
  using: 
  _36 = CheckedAdd((*_35), const 1_i32)
  using: _35@Mir(bb7[1])
  assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_35), const 1_i32) -> bb8
  using: _36@Entry, _35@Entry
bb8:
  (*_35) = move (_36.0: i32)
  using: _35@Mir(bb7[1]), _36@Mir(bb7[2])
  _43 = _1
  using: _1@Phi(bb5)
  _42 = move _43 as *const example1::genann (Pointer(MutToConstPointer))
  using: _43@Mir(bb8[1])
  _45 = &mut _25
  using: _25@Mir(bb5[2])
  _44 = &raw const (*_45)
  using: _45@Mir(bb8[3])
  _41 = genann::genann_run(move _42, move _44) -> bb9
  using: _42@Mir(bb8[2]), _44@Mir(bb8[4])
bb9:
  _40 = (*_41)
  using: _41@Mir(bb8[5])
  _39 = Sub(const 0.5f64, move _40)
  using: _40@Mir(bb9[0])
  _38 = test::fabs(move _39) -> bb10
  using: _39@Mir(bb9[1])
bb10:
  _37 = Gt(move _38, const 0.001f64)
  using: _38@Mir(bb9[2])
  switchInt(move _37) -> [0: bb14, otherwise: bb11]
  using: _37@Mir(bb10[0])
bb11:
  _46 = const {alloc185: *mut i32}
  using: 
  _47 = CheckedAdd((*_46), const 1_i32)
  using: _46@Mir(bb11[0])
  assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_46), const 1_i32) -> bb12
  using: _47@Entry, _46@Entry
bb12:
  (*_46) = move (_47.0: i32)
  using: _46@Mir(bb11[0]), _47@Mir(bb11[1])
  _52 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _51 = &raw const (*_52)
  using: _52@Mir(bb12[1])
  _50 = move _51 as *const u8 (Pointer(ArrayToPointer))
  using: _51@Mir(bb12[2])
  _49 = move _50 as *const i8 (PtrToPtr)
  using: _50@Mir(bb12[3])
  _56 = const b"test.c\x00"
  using: 
  _55 = &raw const (*_56)
  using: _56@Mir(bb12[5])
  _54 = move _55 as *const u8 (Pointer(ArrayToPointer))
  using: _55@Mir(bb12[6])
  _53 = move _54 as *const i8 (PtrToPtr)
  using: _54@Mir(bb12[7])
  _57 = const 44_i32
  using: 
  _61 = _1
  using: _1@Phi(bb5)
  _60 = move _61 as *const example1::genann (Pointer(MutToConstPointer))
  using: _61@Mir(bb12[10])
  _63 = &mut _25
  using: _25@Mir(bb5[2])
  _62 = &raw const (*_63)
  using: _63@Mir(bb12[12])
  _59 = genann::genann_run(move _60, move _62) -> bb13
  using: _60@Mir(bb12[11]), _62@Mir(bb12[13])
bb13:
  _58 = (*_59)
  using: _59@Mir(bb12[14])
  _48 = test::printf(move _49, move _53, move _57, const 0.5f64, move _58) -> bb14
  using: _49@Mir(bb12[4]), _53@Mir(bb12[8]), _57@Mir(bb12[9]), _58@Mir(bb13[0])
bb14:
  _64 = const 1_i32
  using: 
  _25 = move _64 as f64 (IntToFloat)
  using: _64@Mir(bb14[0])
  _65 = const {alloc184: *mut i32}
  using: 
  _66 = CheckedAdd((*_65), const 1_i32)
  using: _65@Mir(bb14[2])
  assert(!move (_66.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_65), const 1_i32) -> bb15
  using: _66@Entry, _65@Entry
bb15:
  (*_65) = move (_66.0: i32)
  using: _65@Mir(bb14[2]), _66@Mir(bb14[3])
  _73 = _1
  using: _1@Phi(bb14)
  _72 = move _73 as *const example1::genann (Pointer(MutToConstPointer))
  using: _73@Mir(bb15[1])
  _75 = &mut _25
  using: _25@Mir(bb14[1])
  _74 = &raw const (*_75)
  using: _75@Mir(bb15[3])
  _71 = genann::genann_run(move _72, move _74) -> bb16
  using: _72@Mir(bb15[2]), _74@Mir(bb15[4])
bb16:
  _70 = (*_71)
  using: _71@Mir(bb15[5])
  _69 = Sub(const 0.5f64, move _70)
  using: _70@Mir(bb16[0])
  _68 = test::fabs(move _69) -> bb17
  using: _69@Mir(bb16[1])
bb17:
  _67 = Gt(move _68, const 0.001f64)
  using: _68@Mir(bb16[2])
  switchInt(move _67) -> [0: bb21, otherwise: bb18]
  using: _67@Mir(bb17[0])
bb18:
  _76 = const {alloc185: *mut i32}
  using: 
  _77 = CheckedAdd((*_76), const 1_i32)
  using: _76@Mir(bb18[0])
  assert(!move (_77.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_76), const 1_i32) -> bb19
  using: _77@Entry, _76@Entry
bb19:
  (*_76) = move (_77.0: i32)
  using: _76@Mir(bb18[0]), _77@Mir(bb18[1])
  _82 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _81 = &raw const (*_82)
  using: _82@Mir(bb19[1])
  _80 = move _81 as *const u8 (Pointer(ArrayToPointer))
  using: _81@Mir(bb19[2])
  _79 = move _80 as *const i8 (PtrToPtr)
  using: _80@Mir(bb19[3])
  _86 = const b"test.c\x00"
  using: 
  _85 = &raw const (*_86)
  using: _86@Mir(bb19[5])
  _84 = move _85 as *const u8 (Pointer(ArrayToPointer))
  using: _85@Mir(bb19[6])
  _83 = move _84 as *const i8 (PtrToPtr)
  using: _84@Mir(bb19[7])
  _87 = const 47_i32
  using: 
  _91 = _1
  using: _1@Phi(bb14)
  _90 = move _91 as *const example1::genann (Pointer(MutToConstPointer))
  using: _91@Mir(bb19[10])
  _93 = &mut _25
  using: _25@Mir(bb14[1])
  _92 = &raw const (*_93)
  using: _93@Mir(bb19[12])
  _89 = genann::genann_run(move _90, move _92) -> bb20
  using: _90@Mir(bb19[11]), _92@Mir(bb19[13])
bb20:
  _88 = (*_89)
  using: _89@Mir(bb19[14])
  _78 = test::printf(move _79, move _83, move _87, const 0.5f64, move _88) -> bb21
  using: _79@Mir(bb19[4]), _83@Mir(bb19[8]), _87@Mir(bb19[9]), _88@Mir(bb20[0])
bb21:
  _94 = const 11_i32
  using: 
  _25 = move _94 as f64 (IntToFloat)
  using: _94@Mir(bb21[0])
  _95 = const {alloc184: *mut i32}
  using: 
  _96 = CheckedAdd((*_95), const 1_i32)
  using: _95@Mir(bb21[2])
  assert(!move (_96.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_95), const 1_i32) -> bb22
  using: _96@Entry, _95@Entry
bb22:
  (*_95) = move (_96.0: i32)
  using: _95@Mir(bb21[2]), _96@Mir(bb21[3])
  _103 = _1
  using: _1@Phi(bb21)
  _102 = move _103 as *const example1::genann (Pointer(MutToConstPointer))
  using: _103@Mir(bb22[1])
  _105 = &mut _25
  using: _25@Mir(bb21[1])
  _104 = &raw const (*_105)
  using: _105@Mir(bb22[3])
  _101 = genann::genann_run(move _102, move _104) -> bb23
  using: _102@Mir(bb22[2]), _104@Mir(bb22[4])
bb23:
  _100 = (*_101)
  using: _101@Mir(bb22[5])
  _99 = Sub(const 0.5f64, move _100)
  using: _100@Mir(bb23[0])
  _98 = test::fabs(move _99) -> bb24
  using: _99@Mir(bb23[1])
bb24:
  _97 = Gt(move _98, const 0.001f64)
  using: _98@Mir(bb23[2])
  switchInt(move _97) -> [0: bb28, otherwise: bb25]
  using: _97@Mir(bb24[0])
bb25:
  _106 = const {alloc185: *mut i32}
  using: 
  _107 = CheckedAdd((*_106), const 1_i32)
  using: _106@Mir(bb25[0])
  assert(!move (_107.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_106), const 1_i32) -> bb26
  using: _107@Entry, _106@Entry
bb26:
  (*_106) = move (_107.0: i32)
  using: _106@Mir(bb25[0]), _107@Mir(bb25[1])
  _112 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _111 = &raw const (*_112)
  using: _112@Mir(bb26[1])
  _110 = move _111 as *const u8 (Pointer(ArrayToPointer))
  using: _111@Mir(bb26[2])
  _109 = move _110 as *const i8 (PtrToPtr)
  using: _110@Mir(bb26[3])
  _116 = const b"test.c\x00"
  using: 
  _115 = &raw const (*_116)
  using: _116@Mir(bb26[5])
  _114 = move _115 as *const u8 (Pointer(ArrayToPointer))
  using: _115@Mir(bb26[6])
  _113 = move _114 as *const i8 (PtrToPtr)
  using: _114@Mir(bb26[7])
  _117 = const 50_i32
  using: 
  _121 = _1
  using: _1@Phi(bb21)
  _120 = move _121 as *const example1::genann (Pointer(MutToConstPointer))
  using: _121@Mir(bb26[10])
  _123 = &mut _25
  using: _25@Mir(bb21[1])
  _122 = &raw const (*_123)
  using: _123@Mir(bb26[12])
  _119 = genann::genann_run(move _120, move _122) -> bb27
  using: _120@Mir(bb26[11]), _122@Mir(bb26[13])
bb27:
  _118 = (*_119)
  using: _119@Mir(bb26[14])
  _108 = test::printf(move _109, move _113, move _117, const 0.5f64, move _118) -> bb28
  using: _109@Mir(bb26[4]), _113@Mir(bb26[8]), _117@Mir(bb26[9]), _118@Mir(bb27[0])
bb28:
  _124 = const 1_i32
  using: 
  _25 = move _124 as f64 (IntToFloat)
  using: _124@Mir(bb28[0])
  _125 = const 1_i32
  using: 
  _127 = ((*_1).8: *mut f64)
  using: _1@Phi(bb28)
  _128 = const 0_isize
  using: 
  _126 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _127, move _128) -> bb29
  using: _127@Mir(bb28[3]), _128@Mir(bb28[4])
bb29:
  (*_126) = move _125 as f64 (IntToFloat)
  using: _126@Mir(bb28[5]), _125@Mir(bb28[2])
  _129 = const 1_i32
  using: 
  _131 = ((*_1).8: *mut f64)
  using: _1@Phi(bb28)
  _132 = const 1_isize
  using: 
  _130 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _131, move _132) -> bb30
  using: _131@Mir(bb29[2]), _132@Mir(bb29[3])
bb30:
  (*_130) = move _129 as f64 (IntToFloat)
  using: _130@Mir(bb29[4]), _129@Mir(bb29[1])
  _133 = const {alloc184: *mut i32}
  using: 
  _134 = CheckedAdd((*_133), const 1_i32)
  using: _133@Mir(bb30[1])
  assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_133), const 1_i32) -> bb31
  using: _134@Entry, _133@Entry
bb31:
  (*_133) = move (_134.0: i32)
  using: _133@Mir(bb30[1]), _134@Mir(bb30[2])
  _141 = _1
  using: _1@Phi(bb28)
  _140 = move _141 as *const example1::genann (Pointer(MutToConstPointer))
  using: _141@Mir(bb31[1])
  _143 = &mut _25
  using: _25@Mir(bb28[1])
  _142 = &raw const (*_143)
  using: _143@Mir(bb31[3])
  _139 = genann::genann_run(move _140, move _142) -> bb32
  using: _140@Mir(bb31[2]), _142@Mir(bb31[4])
bb32:
  _138 = (*_139)
  using: _139@Mir(bb31[5])
  _137 = Sub(const 0.5f64, move _138)
  using: _138@Mir(bb32[0])
  _136 = test::fabs(move _137) -> bb33
  using: _137@Mir(bb32[1])
bb33:
  _135 = Gt(move _136, const 0.001f64)
  using: _136@Mir(bb32[2])
  switchInt(move _135) -> [0: bb37, otherwise: bb34]
  using: _135@Mir(bb33[0])
bb34:
  _144 = const {alloc185: *mut i32}
  using: 
  _145 = CheckedAdd((*_144), const 1_i32)
  using: _144@Mir(bb34[0])
  assert(!move (_145.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_144), const 1_i32) -> bb35
  using: _145@Entry, _144@Entry
bb35:
  (*_144) = move (_145.0: i32)
  using: _144@Mir(bb34[0]), _145@Mir(bb34[1])
  _150 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _149 = &raw const (*_150)
  using: _150@Mir(bb35[1])
  _148 = move _149 as *const u8 (Pointer(ArrayToPointer))
  using: _149@Mir(bb35[2])
  _147 = move _148 as *const i8 (PtrToPtr)
  using: _148@Mir(bb35[3])
  _154 = const b"test.c\x00"
  using: 
  _153 = &raw const (*_154)
  using: _154@Mir(bb35[5])
  _152 = move _153 as *const u8 (Pointer(ArrayToPointer))
  using: _153@Mir(bb35[6])
  _151 = move _152 as *const i8 (PtrToPtr)
  using: _152@Mir(bb35[7])
  _155 = const 55_i32
  using: 
  _159 = _1
  using: _1@Phi(bb28)
  _158 = move _159 as *const example1::genann (Pointer(MutToConstPointer))
  using: _159@Mir(bb35[10])
  _161 = &mut _25
  using: _25@Mir(bb28[1])
  _160 = &raw const (*_161)
  using: _161@Mir(bb35[12])
  _157 = genann::genann_run(move _158, move _160) -> bb36
  using: _158@Mir(bb35[11]), _160@Mir(bb35[13])
bb36:
  _156 = (*_157)
  using: _157@Mir(bb35[14])
  _146 = test::printf(move _147, move _151, move _155, const 0.5f64, move _156) -> bb37
  using: _147@Mir(bb35[4]), _151@Mir(bb35[8]), _155@Mir(bb35[9]), _156@Mir(bb36[0])
bb37:
  _162 = const 10_i32
  using: 
  _25 = move _162 as f64 (IntToFloat)
  using: _162@Mir(bb37[0])
  _163 = const 1_i32
  using: 
  _165 = ((*_1).8: *mut f64)
  using: _1@Phi(bb37)
  _166 = const 0_isize
  using: 
  _164 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _165, move _166) -> bb38
  using: _165@Mir(bb37[3]), _166@Mir(bb37[4])
bb38:
  (*_164) = move _163 as f64 (IntToFloat)
  using: _164@Mir(bb37[5]), _163@Mir(bb37[2])
  _167 = const 1_i32
  using: 
  _169 = ((*_1).8: *mut f64)
  using: _1@Phi(bb37)
  _170 = const 1_isize
  using: 
  _168 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _169, move _170) -> bb39
  using: _169@Mir(bb38[2]), _170@Mir(bb38[3])
bb39:
  (*_168) = move _167 as f64 (IntToFloat)
  using: _168@Mir(bb38[4]), _167@Mir(bb38[1])
  _171 = const {alloc184: *mut i32}
  using: 
  _172 = CheckedAdd((*_171), const 1_i32)
  using: _171@Mir(bb39[1])
  assert(!move (_172.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_171), const 1_i32) -> bb40
  using: _172@Entry, _171@Entry
bb40:
  (*_171) = move (_172.0: i32)
  using: _171@Mir(bb39[1]), _172@Mir(bb39[2])
  _179 = _1
  using: _1@Phi(bb37)
  _178 = move _179 as *const example1::genann (Pointer(MutToConstPointer))
  using: _179@Mir(bb40[1])
  _181 = &mut _25
  using: _25@Mir(bb37[1])
  _180 = &raw const (*_181)
  using: _181@Mir(bb40[3])
  _177 = genann::genann_run(move _178, move _180) -> bb41
  using: _178@Mir(bb40[2]), _180@Mir(bb40[4])
bb41:
  _176 = (*_177)
  using: _177@Mir(bb40[5])
  _175 = Sub(const 1f64, move _176)
  using: _176@Mir(bb41[0])
  _174 = test::fabs(move _175) -> bb42
  using: _175@Mir(bb41[1])
bb42:
  _173 = Gt(move _174, const 0.001f64)
  using: _174@Mir(bb41[2])
  switchInt(move _173) -> [0: bb46, otherwise: bb43]
  using: _173@Mir(bb42[0])
bb43:
  _182 = const {alloc185: *mut i32}
  using: 
  _183 = CheckedAdd((*_182), const 1_i32)
  using: _182@Mir(bb43[0])
  assert(!move (_183.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_182), const 1_i32) -> bb44
  using: _183@Entry, _182@Entry
bb44:
  (*_182) = move (_183.0: i32)
  using: _182@Mir(bb43[0]), _183@Mir(bb43[1])
  _188 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _187 = &raw const (*_188)
  using: _188@Mir(bb44[1])
  _186 = move _187 as *const u8 (Pointer(ArrayToPointer))
  using: _187@Mir(bb44[2])
  _185 = move _186 as *const i8 (PtrToPtr)
  using: _186@Mir(bb44[3])
  _192 = const b"test.c\x00"
  using: 
  _191 = &raw const (*_192)
  using: _192@Mir(bb44[5])
  _190 = move _191 as *const u8 (Pointer(ArrayToPointer))
  using: _191@Mir(bb44[6])
  _189 = move _190 as *const i8 (PtrToPtr)
  using: _190@Mir(bb44[7])
  _193 = const 60_i32
  using: 
  _197 = _1
  using: _1@Phi(bb37)
  _196 = move _197 as *const example1::genann (Pointer(MutToConstPointer))
  using: _197@Mir(bb44[10])
  _199 = &mut _25
  using: _25@Mir(bb37[1])
  _198 = &raw const (*_199)
  using: _199@Mir(bb44[12])
  _195 = genann::genann_run(move _196, move _198) -> bb45
  using: _196@Mir(bb44[11]), _198@Mir(bb44[13])
bb45:
  _194 = (*_195)
  using: _195@Mir(bb44[14])
  _184 = test::printf(move _185, move _189, move _193, const 1f64, move _194) -> bb46
  using: _185@Mir(bb44[4]), _189@Mir(bb44[8]), _193@Mir(bb44[9]), _194@Mir(bb45[0])
bb46:
  _200 = const -10_i32
  using: 
  _25 = move _200 as f64 (IntToFloat)
  using: _200@Mir(bb46[0])
  _201 = const {alloc184: *mut i32}
  using: 
  _202 = CheckedAdd((*_201), const 1_i32)
  using: _201@Mir(bb46[2])
  assert(!move (_202.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_201), const 1_i32) -> bb47
  using: _202@Entry, _201@Entry
bb47:
  (*_201) = move (_202.0: i32)
  using: _201@Mir(bb46[2]), _202@Mir(bb46[3])
  _209 = _1
  using: _1@Phi(bb46)
  _208 = move _209 as *const example1::genann (Pointer(MutToConstPointer))
  using: _209@Mir(bb47[1])
  _211 = &mut _25
  using: _25@Mir(bb46[1])
  _210 = &raw const (*_211)
  using: _211@Mir(bb47[3])
  _207 = genann::genann_run(move _208, move _210) -> bb48
  using: _208@Mir(bb47[2]), _210@Mir(bb47[4])
bb48:
  _206 = (*_207)
  using: _207@Mir(bb47[5])
  _205 = Sub(const 0f64, move _206)
  using: _206@Mir(bb48[0])
  _204 = test::fabs(move _205) -> bb49
  using: _205@Mir(bb48[1])
bb49:
  _203 = Gt(move _204, const 0.001f64)
  using: _204@Mir(bb48[2])
  switchInt(move _203) -> [0: bb53, otherwise: bb50]
  using: _203@Mir(bb49[0])
bb50:
  _212 = const {alloc185: *mut i32}
  using: 
  _213 = CheckedAdd((*_212), const 1_i32)
  using: _212@Mir(bb50[0])
  assert(!move (_213.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_212), const 1_i32) -> bb51
  using: _213@Entry, _212@Entry
bb51:
  (*_212) = move (_213.0: i32)
  using: _212@Mir(bb50[0]), _213@Mir(bb50[1])
  _218 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _217 = &raw const (*_218)
  using: _218@Mir(bb51[1])
  _216 = move _217 as *const u8 (Pointer(ArrayToPointer))
  using: _217@Mir(bb51[2])
  _215 = move _216 as *const i8 (PtrToPtr)
  using: _216@Mir(bb51[3])
  _222 = const b"test.c\x00"
  using: 
  _221 = &raw const (*_222)
  using: _222@Mir(bb51[5])
  _220 = move _221 as *const u8 (Pointer(ArrayToPointer))
  using: _221@Mir(bb51[6])
  _219 = move _220 as *const i8 (PtrToPtr)
  using: _220@Mir(bb51[7])
  _223 = const 63_i32
  using: 
  _227 = _1
  using: _1@Phi(bb46)
  _226 = move _227 as *const example1::genann (Pointer(MutToConstPointer))
  using: _227@Mir(bb51[10])
  _229 = &mut _25
  using: _25@Mir(bb46[1])
  _228 = &raw const (*_229)
  using: _229@Mir(bb51[12])
  _225 = genann::genann_run(move _226, move _228) -> bb52
  using: _226@Mir(bb51[11]), _228@Mir(bb51[13])
bb52:
  _224 = (*_225)
  using: _225@Mir(bb51[14])
  _214 = test::printf(move _215, move _219, move _223, const 0f64, move _224) -> bb53
  using: _215@Mir(bb51[4]), _219@Mir(bb51[8]), _223@Mir(bb51[9]), _224@Mir(bb52[0])
bb53:
  _231 = _1
  using: _1@Phi(bb53)
  _230 = genann::genann_free(move _231) -> bb54
  using: _231@Mir(bb53[0])
bb54:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:97:20: 97:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:99:20: 99:61 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:102:8: 102:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:110:8: 110:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:118:8: 118:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:125:20: 125:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:127:20: 127:61 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:130:8: 130:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:137:20: 137:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:139:20: 139:61 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:142:8: 142:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:150:8: 150:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:119 ~ c2rust_lib[1043]::test::xor)
bb0:
  _2 = const 2_i32
  using: 
  _3 = const 1_i32
  using: 
  _4 = const 2_i32
  using: 
  _5 = const 1_i32
  using: 
  _1 = genann::genann_init(move _2, move _3, move _4, move _5) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1]), _4@Mir(bb0[2]), _5@Mir(bb0[3])
bb1:
  _7 = genann::genann_act_threshold as unsafe extern "C" fn(f64) -> f64 (Pointer(ReifyFnPointer))
  using: 
  Deinit(_6)
  using: 
  ((_6 as Some).0: unsafe extern "C" fn(f64) -> f64) = move _7
  using: _7@Mir(bb1[0])
  discriminant(_6) = 1
  using: 
  ((*_1).4: std::option::Option<unsafe extern "C" fn(f64) -> f64>) = move _6
  using: _1@Mir(bb0[4]), _6@Mir(bb1[1])
  _9 = genann::genann_act_threshold as unsafe extern "C" fn(f64) -> f64 (Pointer(ReifyFnPointer))
  using: 
  Deinit(_8)
  using: 
  ((_8 as Some).0: unsafe extern "C" fn(f64) -> f64) = move _9
  using: _9@Mir(bb1[5])
  discriminant(_8) = 1
  using: 
  ((*_1).5: std::option::Option<unsafe extern "C" fn(f64) -> f64>) = move _8
  using: _1@Mir(bb0[4]), _8@Mir(bb1[6])
  _10 = const {alloc184: *mut i32}
  using: 
  _11 = CheckedAdd((*_10), const 1_i32)
  using: _10@Mir(bb1[10])
  assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_10), const 1_i32) -> bb2
  using: _11@Entry, _10@Entry
bb2:
  (*_10) = move (_11.0: i32)
  using: _10@Mir(bb1[10]), _11@Mir(bb1[11])
  _13 = ((*_1).6: i32)
  using: _1@Mir(bb0[4])
  _14 = const 9_i32
  using: 
  _12 = Ne(move _13, move _14)
  using: _13@Mir(bb2[1]), _14@Mir(bb2[2])
  switchInt(move _12) -> [0: bb5, otherwise: bb3]
  using: _12@Mir(bb2[3])
bb3:
  _15 = const {alloc185: *mut i32}
  using: 
  _16 = CheckedAdd((*_15), const 1_i32)
  using: _15@Mir(bb3[0])
  assert(!move (_16.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_15), const 1_i32) -> bb4
  using: _16@Entry, _15@Entry
bb4:
  (*_15) = move (_16.0: i32)
  using: _15@Mir(bb3[0]), _16@Mir(bb3[1])
  _21 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _20 = &raw const (*_21)
  using: _21@Mir(bb4[1])
  _19 = move _20 as *const u8 (Pointer(ArrayToPointer))
  using: _20@Mir(bb4[2])
  _18 = move _19 as *const i8 (PtrToPtr)
  using: _19@Mir(bb4[3])
  _25 = const b"test.c\x00"
  using: 
  _24 = &raw const (*_25)
  using: _25@Mir(bb4[5])
  _23 = move _24 as *const u8 (Pointer(ArrayToPointer))
  using: _24@Mir(bb4[6])
  _22 = move _23 as *const i8 (PtrToPtr)
  using: _23@Mir(bb4[7])
  _26 = const 74_i32
  using: 
  _27 = ((*_1).6: i32)
  using: _1@Mir(bb0[4])
  _28 = const 9_i32
  using: 
  _17 = test::printf(move _18, move _22, move _26, move _27, move _28) -> bb5
  using: _18@Mir(bb4[4]), _22@Mir(bb4[8]), _26@Mir(bb4[9]), _27@Mir(bb4[10]), _28@Mir(bb4[11])
bb5:
  _30 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _31 = const 0_isize
  using: 
  _29 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _30, move _31) -> bb6
  using: _30@Mir(bb5[0]), _31@Mir(bb5[1])
bb6:
  (*_29) = const 0.5f64
  using: _29@Mir(bb5[2])
  _32 = const 1_i32
  using: 
  _34 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _35 = const 1_isize
  using: 
  _33 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _34, move _35) -> bb7
  using: _34@Mir(bb6[2]), _35@Mir(bb6[3])
bb7:
  (*_33) = move _32 as f64 (IntToFloat)
  using: _33@Mir(bb6[4]), _32@Mir(bb6[1])
  _36 = const 1_i32
  using: 
  _38 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _39 = const 2_isize
  using: 
  _37 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _38, move _39) -> bb8
  using: _38@Mir(bb7[2]), _39@Mir(bb7[3])
bb8:
  (*_37) = move _36 as f64 (IntToFloat)
  using: _37@Mir(bb7[4]), _36@Mir(bb7[1])
  _40 = const 1_i32
  using: 
  _42 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _43 = const 3_isize
  using: 
  _41 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _42, move _43) -> bb9
  using: _42@Mir(bb8[2]), _43@Mir(bb8[3])
bb9:
  (*_41) = move _40 as f64 (IntToFloat)
  using: _41@Mir(bb8[4]), _40@Mir(bb8[1])
  _44 = const 1_i32
  using: 
  _46 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _47 = const 4_isize
  using: 
  _45 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _46, move _47) -> bb10
  using: _46@Mir(bb9[2]), _47@Mir(bb9[3])
bb10:
  (*_45) = move _44 as f64 (IntToFloat)
  using: _45@Mir(bb9[4]), _44@Mir(bb9[1])
  _48 = const 1_i32
  using: 
  _50 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _51 = const 5_isize
  using: 
  _49 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _50, move _51) -> bb11
  using: _50@Mir(bb10[2]), _51@Mir(bb10[3])
bb11:
  (*_49) = move _48 as f64 (IntToFloat)
  using: _49@Mir(bb10[4]), _48@Mir(bb10[1])
  _53 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _54 = const 6_isize
  using: 
  _52 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _53, move _54) -> bb12
  using: _53@Mir(bb11[1]), _54@Mir(bb11[2])
bb12:
  (*_52) = const 0.5f64
  using: _52@Mir(bb11[3])
  _55 = const 1_i32
  using: 
  _57 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _58 = const 7_isize
  using: 
  _56 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _57, move _58) -> bb13
  using: _57@Mir(bb12[2]), _58@Mir(bb12[3])
bb13:
  (*_56) = move _55 as f64 (IntToFloat)
  using: _56@Mir(bb12[4]), _55@Mir(bb12[1])
  _59 = const -1_i32
  using: 
  _61 = ((*_1).8: *mut f64)
  using: _1@Phi(bb5)
  _62 = const 8_isize
  using: 
  _60 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _61, move _62) -> bb14
  using: _61@Mir(bb13[2]), _62@Mir(bb13[3])
bb14:
  (*_60) = move _59 as f64 (IntToFloat)
  using: _60@Mir(bb13[4]), _59@Mir(bb13[1])
  _65 = const 0f64
  using: 
  _66 = const 0f64
  using: 
  _64 = [move _65, move _66]
  using: _65@Mir(bb14[1]), _66@Mir(bb14[2])
  _68 = const 0f64
  using: 
  _69 = const 1f64
  using: 
  _67 = [move _68, move _69]
  using: _68@Mir(bb14[4]), _69@Mir(bb14[5])
  _71 = const 1f64
  using: 
  _72 = const 0f64
  using: 
  _70 = [move _71, move _72]
  using: _71@Mir(bb14[7]), _72@Mir(bb14[8])
  _74 = const 1f64
  using: 
  _75 = const 1f64
  using: 
  _73 = [move _74, move _75]
  using: _74@Mir(bb14[10]), _75@Mir(bb14[11])
  _63 = [move _64, move _67, move _70, move _73]
  using: _64@Mir(bb14[3]), _67@Mir(bb14[6]), _70@Mir(bb14[9]), _73@Mir(bb14[12])
  _77 = const 0f64
  using: 
  _78 = const 1f64
  using: 
  _79 = const 1f64
  using: 
  _80 = const 0f64
  using: 
  _76 = [move _77, move _78, move _79, move _80]
  using: _77@Mir(bb14[14]), _78@Mir(bb14[15]), _79@Mir(bb14[16]), _80@Mir(bb14[17])
  _81 = const {alloc184: *mut i32}
  using: 
  _82 = CheckedAdd((*_81), const 1_i32)
  using: _81@Mir(bb14[19])
  assert(!move (_82.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_81), const 1_i32) -> bb15
  using: _82@Entry, _81@Entry
bb15:
  (*_81) = move (_82.0: i32)
  using: _81@Mir(bb14[19]), _82@Mir(bb14[20])
  _87 = const 0_usize
  using: 
  _86 = _76[_87]
  using: _76@Mir(bb14[18]), _87@Mir(bb15[1])
  _91 = _1
  using: _1@Phi(bb5)
  _90 = move _91 as *const example1::genann (Pointer(MutToConstPointer))
  using: _91@Mir(bb15[3])
  _96 = const 0_usize
  using: 
  _95 = &mut _63[_96]
  using: _63@Mir(bb14[13]), _96@Mir(bb15[5])
  _94 = move _95 as &mut [f64] (Pointer(Unsize))
  using: _95@Mir(bb15[6])
  _93 = core::slice::<impl [f64]>::as_mut_ptr(move _94) -> bb16
  using: _94@Mir(bb15[7])
bb16:
  _92 = move _93 as *const f64 (Pointer(MutToConstPointer))
  using: _93@Mir(bb15[8])
  _89 = genann::genann_run(move _90, move _92) -> bb17
  using: _90@Mir(bb15[4]), _92@Mir(bb16[0])
bb17:
  _88 = (*_89)
  using: _89@Mir(bb16[1])
  _85 = Sub(move _86, move _88)
  using: _86@Mir(bb15[2]), _88@Mir(bb17[0])
  _84 = test::fabs(move _85) -> bb18
  using: _85@Mir(bb17[1])
bb18:
  _83 = Gt(move _84, const 0.001f64)
  using: _84@Mir(bb17[2])
  switchInt(move _83) -> [0: bb23, otherwise: bb19]
  using: _83@Mir(bb18[0])
bb19:
  _97 = const {alloc185: *mut i32}
  using: 
  _98 = CheckedAdd((*_97), const 1_i32)
  using: _97@Mir(bb19[0])
  assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_97), const 1_i32) -> bb20
  using: _98@Entry, _97@Entry
bb20:
  (*_97) = move (_98.0: i32)
  using: _97@Mir(bb19[0]), _98@Mir(bb19[1])
  _103 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _102 = &raw const (*_103)
  using: _103@Mir(bb20[1])
  _101 = move _102 as *const u8 (Pointer(ArrayToPointer))
  using: _102@Mir(bb20[2])
  _100 = move _101 as *const i8 (PtrToPtr)
  using: _101@Mir(bb20[3])
  _107 = const b"test.c\x00"
  using: 
  _106 = &raw const (*_107)
  using: _107@Mir(bb20[5])
  _105 = move _106 as *const u8 (Pointer(ArrayToPointer))
  using: _106@Mir(bb20[6])
  _104 = move _105 as *const i8 (PtrToPtr)
  using: _105@Mir(bb20[7])
  _108 = const 95_i32
  using: 
  _110 = const 0_usize
  using: 
  _109 = _76[_110]
  using: _76@Mir(bb14[18]), _110@Mir(bb20[10])
  _114 = _1
  using: _1@Phi(bb5)
  _113 = move _114 as *const example1::genann (Pointer(MutToConstPointer))
  using: _114@Mir(bb20[12])
  _119 = const 0_usize
  using: 
  _118 = &mut _63[_119]
  using: _63@Mir(bb14[13]), _119@Mir(bb20[14])
  _117 = move _118 as &mut [f64] (Pointer(Unsize))
  using: _118@Mir(bb20[15])
  _116 = core::slice::<impl [f64]>::as_mut_ptr(move _117) -> bb21
  using: _117@Mir(bb20[16])
bb21:
  _115 = move _116 as *const f64 (Pointer(MutToConstPointer))
  using: _116@Mir(bb20[17])
  _112 = genann::genann_run(move _113, move _115) -> bb22
  using: _113@Mir(bb20[13]), _115@Mir(bb21[0])
bb22:
  _111 = (*_112)
  using: _112@Mir(bb21[1])
  _99 = test::printf(move _100, move _104, move _108, move _109, move _111) -> bb23
  using: _100@Mir(bb20[4]), _104@Mir(bb20[8]), _108@Mir(bb20[9]), _109@Mir(bb20[11]), _111@Mir(bb22[0])
bb23:
  _120 = const {alloc184: *mut i32}
  using: 
  _121 = CheckedAdd((*_120), const 1_i32)
  using: _120@Mir(bb23[0])
  assert(!move (_121.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_120), const 1_i32) -> bb24
  using: _121@Entry, _120@Entry
bb24:
  (*_120) = move (_121.0: i32)
  using: _120@Mir(bb23[0]), _121@Mir(bb23[1])
  _126 = const 1_usize
  using: 
  _125 = _76[_126]
  using: _76@Phi(bb23), _126@Mir(bb24[1])
  _130 = _1
  using: _1@Phi(bb23)
  _129 = move _130 as *const example1::genann (Pointer(MutToConstPointer))
  using: _130@Mir(bb24[3])
  _135 = const 1_usize
  using: 
  _134 = &mut _63[_135]
  using: _63@Phi(bb23), _135@Mir(bb24[5])
  _133 = move _134 as &mut [f64] (Pointer(Unsize))
  using: _134@Mir(bb24[6])
  _132 = core::slice::<impl [f64]>::as_mut_ptr(move _133) -> bb25
  using: _133@Mir(bb24[7])
bb25:
  _131 = move _132 as *const f64 (Pointer(MutToConstPointer))
  using: _132@Mir(bb24[8])
  _128 = genann::genann_run(move _129, move _131) -> bb26
  using: _129@Mir(bb24[4]), _131@Mir(bb25[0])
bb26:
  _127 = (*_128)
  using: _128@Mir(bb25[1])
  _124 = Sub(move _125, move _127)
  using: _125@Mir(bb24[2]), _127@Mir(bb26[0])
  _123 = test::fabs(move _124) -> bb27
  using: _124@Mir(bb26[1])
bb27:
  _122 = Gt(move _123, const 0.001f64)
  using: _123@Mir(bb26[2])
  switchInt(move _122) -> [0: bb32, otherwise: bb28]
  using: _122@Mir(bb27[0])
bb28:
  _136 = const {alloc185: *mut i32}
  using: 
  _137 = CheckedAdd((*_136), const 1_i32)
  using: _136@Mir(bb28[0])
  assert(!move (_137.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_136), const 1_i32) -> bb29
  using: _137@Entry, _136@Entry
bb29:
  (*_136) = move (_137.0: i32)
  using: _136@Mir(bb28[0]), _137@Mir(bb28[1])
  _142 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _141 = &raw const (*_142)
  using: _142@Mir(bb29[1])
  _140 = move _141 as *const u8 (Pointer(ArrayToPointer))
  using: _141@Mir(bb29[2])
  _139 = move _140 as *const i8 (PtrToPtr)
  using: _140@Mir(bb29[3])
  _146 = const b"test.c\x00"
  using: 
  _145 = &raw const (*_146)
  using: _146@Mir(bb29[5])
  _144 = move _145 as *const u8 (Pointer(ArrayToPointer))
  using: _145@Mir(bb29[6])
  _143 = move _144 as *const i8 (PtrToPtr)
  using: _144@Mir(bb29[7])
  _147 = const 96_i32
  using: 
  _149 = const 1_usize
  using: 
  _148 = _76[_149]
  using: _76@Phi(bb23), _149@Mir(bb29[10])
  _153 = _1
  using: _1@Phi(bb23)
  _152 = move _153 as *const example1::genann (Pointer(MutToConstPointer))
  using: _153@Mir(bb29[12])
  _158 = const 1_usize
  using: 
  _157 = &mut _63[_158]
  using: _63@Phi(bb23), _158@Mir(bb29[14])
  _156 = move _157 as &mut [f64] (Pointer(Unsize))
  using: _157@Mir(bb29[15])
  _155 = core::slice::<impl [f64]>::as_mut_ptr(move _156) -> bb30
  using: _156@Mir(bb29[16])
bb30:
  _154 = move _155 as *const f64 (Pointer(MutToConstPointer))
  using: _155@Mir(bb29[17])
  _151 = genann::genann_run(move _152, move _154) -> bb31
  using: _152@Mir(bb29[13]), _154@Mir(bb30[0])
bb31:
  _150 = (*_151)
  using: _151@Mir(bb30[1])
  _138 = test::printf(move _139, move _143, move _147, move _148, move _150) -> bb32
  using: _139@Mir(bb29[4]), _143@Mir(bb29[8]), _147@Mir(bb29[9]), _148@Mir(bb29[11]), _150@Mir(bb31[0])
bb32:
  _159 = const {alloc184: *mut i32}
  using: 
  _160 = CheckedAdd((*_159), const 1_i32)
  using: _159@Mir(bb32[0])
  assert(!move (_160.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_159), const 1_i32) -> bb33
  using: _160@Entry, _159@Entry
bb33:
  (*_159) = move (_160.0: i32)
  using: _159@Mir(bb32[0]), _160@Mir(bb32[1])
  _165 = const 2_usize
  using: 
  _164 = _76[_165]
  using: _76@Phi(bb32), _165@Mir(bb33[1])
  _169 = _1
  using: _1@Phi(bb32)
  _168 = move _169 as *const example1::genann (Pointer(MutToConstPointer))
  using: _169@Mir(bb33[3])
  _174 = const 2_usize
  using: 
  _173 = &mut _63[_174]
  using: _63@Phi(bb32), _174@Mir(bb33[5])
  _172 = move _173 as &mut [f64] (Pointer(Unsize))
  using: _173@Mir(bb33[6])
  _171 = core::slice::<impl [f64]>::as_mut_ptr(move _172) -> bb34
  using: _172@Mir(bb33[7])
bb34:
  _170 = move _171 as *const f64 (Pointer(MutToConstPointer))
  using: _171@Mir(bb33[8])
  _167 = genann::genann_run(move _168, move _170) -> bb35
  using: _168@Mir(bb33[4]), _170@Mir(bb34[0])
bb35:
  _166 = (*_167)
  using: _167@Mir(bb34[1])
  _163 = Sub(move _164, move _166)
  using: _164@Mir(bb33[2]), _166@Mir(bb35[0])
  _162 = test::fabs(move _163) -> bb36
  using: _163@Mir(bb35[1])
bb36:
  _161 = Gt(move _162, const 0.001f64)
  using: _162@Mir(bb35[2])
  switchInt(move _161) -> [0: bb41, otherwise: bb37]
  using: _161@Mir(bb36[0])
bb37:
  _175 = const {alloc185: *mut i32}
  using: 
  _176 = CheckedAdd((*_175), const 1_i32)
  using: _175@Mir(bb37[0])
  assert(!move (_176.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_175), const 1_i32) -> bb38
  using: _176@Entry, _175@Entry
bb38:
  (*_175) = move (_176.0: i32)
  using: _175@Mir(bb37[0]), _176@Mir(bb37[1])
  _181 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _180 = &raw const (*_181)
  using: _181@Mir(bb38[1])
  _179 = move _180 as *const u8 (Pointer(ArrayToPointer))
  using: _180@Mir(bb38[2])
  _178 = move _179 as *const i8 (PtrToPtr)
  using: _179@Mir(bb38[3])
  _185 = const b"test.c\x00"
  using: 
  _184 = &raw const (*_185)
  using: _185@Mir(bb38[5])
  _183 = move _184 as *const u8 (Pointer(ArrayToPointer))
  using: _184@Mir(bb38[6])
  _182 = move _183 as *const i8 (PtrToPtr)
  using: _183@Mir(bb38[7])
  _186 = const 97_i32
  using: 
  _188 = const 2_usize
  using: 
  _187 = _76[_188]
  using: _76@Phi(bb32), _188@Mir(bb38[10])
  _192 = _1
  using: _1@Phi(bb32)
  _191 = move _192 as *const example1::genann (Pointer(MutToConstPointer))
  using: _192@Mir(bb38[12])
  _197 = const 2_usize
  using: 
  _196 = &mut _63[_197]
  using: _63@Phi(bb32), _197@Mir(bb38[14])
  _195 = move _196 as &mut [f64] (Pointer(Unsize))
  using: _196@Mir(bb38[15])
  _194 = core::slice::<impl [f64]>::as_mut_ptr(move _195) -> bb39
  using: _195@Mir(bb38[16])
bb39:
  _193 = move _194 as *const f64 (Pointer(MutToConstPointer))
  using: _194@Mir(bb38[17])
  _190 = genann::genann_run(move _191, move _193) -> bb40
  using: _191@Mir(bb38[13]), _193@Mir(bb39[0])
bb40:
  _189 = (*_190)
  using: _190@Mir(bb39[1])
  _177 = test::printf(move _178, move _182, move _186, move _187, move _189) -> bb41
  using: _178@Mir(bb38[4]), _182@Mir(bb38[8]), _186@Mir(bb38[9]), _187@Mir(bb38[11]), _189@Mir(bb40[0])
bb41:
  _198 = const {alloc184: *mut i32}
  using: 
  _199 = CheckedAdd((*_198), const 1_i32)
  using: _198@Mir(bb41[0])
  assert(!move (_199.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_198), const 1_i32) -> bb42
  using: _199@Entry, _198@Entry
bb42:
  (*_198) = move (_199.0: i32)
  using: _198@Mir(bb41[0]), _199@Mir(bb41[1])
  _204 = const 3_usize
  using: 
  _203 = _76[_204]
  using: _76@Phi(bb41), _204@Mir(bb42[1])
  _208 = _1
  using: _1@Phi(bb41)
  _207 = move _208 as *const example1::genann (Pointer(MutToConstPointer))
  using: _208@Mir(bb42[3])
  _213 = const 3_usize
  using: 
  _212 = &mut _63[_213]
  using: _63@Phi(bb41), _213@Mir(bb42[5])
  _211 = move _212 as &mut [f64] (Pointer(Unsize))
  using: _212@Mir(bb42[6])
  _210 = core::slice::<impl [f64]>::as_mut_ptr(move _211) -> bb43
  using: _211@Mir(bb42[7])
bb43:
  _209 = move _210 as *const f64 (Pointer(MutToConstPointer))
  using: _210@Mir(bb42[8])
  _206 = genann::genann_run(move _207, move _209) -> bb44
  using: _207@Mir(bb42[4]), _209@Mir(bb43[0])
bb44:
  _205 = (*_206)
  using: _206@Mir(bb43[1])
  _202 = Sub(move _203, move _205)
  using: _203@Mir(bb42[2]), _205@Mir(bb44[0])
  _201 = test::fabs(move _202) -> bb45
  using: _202@Mir(bb44[1])
bb45:
  _200 = Gt(move _201, const 0.001f64)
  using: _201@Mir(bb44[2])
  switchInt(move _200) -> [0: bb50, otherwise: bb46]
  using: _200@Mir(bb45[0])
bb46:
  _214 = const {alloc185: *mut i32}
  using: 
  _215 = CheckedAdd((*_214), const 1_i32)
  using: _214@Mir(bb46[0])
  assert(!move (_215.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_214), const 1_i32) -> bb47
  using: _215@Entry, _214@Entry
bb47:
  (*_214) = move (_215.0: i32)
  using: _214@Mir(bb46[0]), _215@Mir(bb46[1])
  _220 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _219 = &raw const (*_220)
  using: _220@Mir(bb47[1])
  _218 = move _219 as *const u8 (Pointer(ArrayToPointer))
  using: _219@Mir(bb47[2])
  _217 = move _218 as *const i8 (PtrToPtr)
  using: _218@Mir(bb47[3])
  _224 = const b"test.c\x00"
  using: 
  _223 = &raw const (*_224)
  using: _224@Mir(bb47[5])
  _222 = move _223 as *const u8 (Pointer(ArrayToPointer))
  using: _223@Mir(bb47[6])
  _221 = move _222 as *const i8 (PtrToPtr)
  using: _222@Mir(bb47[7])
  _225 = const 98_i32
  using: 
  _227 = const 3_usize
  using: 
  _226 = _76[_227]
  using: _76@Phi(bb41), _227@Mir(bb47[10])
  _231 = _1
  using: _1@Phi(bb41)
  _230 = move _231 as *const example1::genann (Pointer(MutToConstPointer))
  using: _231@Mir(bb47[12])
  _236 = const 3_usize
  using: 
  _235 = &mut _63[_236]
  using: _63@Phi(bb41), _236@Mir(bb47[14])
  _234 = move _235 as &mut [f64] (Pointer(Unsize))
  using: _235@Mir(bb47[15])
  _233 = core::slice::<impl [f64]>::as_mut_ptr(move _234) -> bb48
  using: _234@Mir(bb47[16])
bb48:
  _232 = move _233 as *const f64 (Pointer(MutToConstPointer))
  using: _233@Mir(bb47[17])
  _229 = genann::genann_run(move _230, move _232) -> bb49
  using: _230@Mir(bb47[13]), _232@Mir(bb48[0])
bb49:
  _228 = (*_229)
  using: _229@Mir(bb48[1])
  _216 = test::printf(move _217, move _221, move _225, move _226, move _228) -> bb50
  using: _217@Mir(bb47[4]), _221@Mir(bb47[8]), _225@Mir(bb47[9]), _226@Mir(bb47[11]), _228@Mir(bb49[0])
bb50:
  _238 = _1
  using: _1@Phi(bb50)
  _237 = genann::genann_free(move _238) -> bb51
  using: _238@Mir(bb50[0])
bb51:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_6) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_6) = 1 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_8) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_8) = 1 is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:177:20: 177:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:178:20: 178:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:180:20: 180:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:183:20: 183:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:185:20: 185:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:187:20: 187:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:190:20: 190:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:191:20: 191:61 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:193:20: 193:61 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _64, move _67, move _70, move _73] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _77, move _78, move _79, move _80] is not supported
rewrite call test::fabs @ workspace/genann/test.rs:210:8: 212:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:222:8: 224:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:234:8: 236:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:246:8: 248:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:123 ~ c2rust_lib[1043]::test::backprop)
bb0:
  _2 = const 1_i32
  using: 
  _3 = const 0_i32
  using: 
  _4 = const 0_i32
  using: 
  _5 = const 1_i32
  using: 
  _1 = genann::genann_init(move _2, move _3, move _4, move _5) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1]), _4@Mir(bb0[2]), _5@Mir(bb0[3])
bb1:
  _6 = const 0f64
  using: 
  _7 = const 0f64
  using: 
  _6 = const 0.5f64
  using: 
  _8 = const 1_i32
  using: 
  _7 = move _8 as f64 (IntToFloat)
  using: _8@Mir(bb1[3])
  _12 = _1
  using: _1@Mir(bb0[4])
  _11 = move _12 as *const example1::genann (Pointer(MutToConstPointer))
  using: _12@Mir(bb1[5])
  _14 = &mut _6
  using: _6@Mir(bb1[2])
  _13 = &raw const (*_14)
  using: _14@Mir(bb1[7])
  _10 = genann::genann_run(move _11, move _13) -> bb2
  using: _11@Mir(bb1[6]), _13@Mir(bb1[8])
bb2:
  _9 = (*_10)
  using: _10@Mir(bb1[9])
  _17 = _1
  using: _1@Mir(bb0[4])
  _16 = move _17 as *const example1::genann (Pointer(MutToConstPointer))
  using: _17@Mir(bb2[1])
  _19 = &mut _6
  using: _6@Mir(bb1[2])
  _18 = &raw const (*_19)
  using: _19@Mir(bb2[3])
  _21 = &mut _7
  using: _7@Mir(bb1[4])
  _20 = &raw const (*_21)
  using: _21@Mir(bb2[5])
  _15 = genann::genann_train(move _16, move _18, move _20, const 0.5f64) -> bb3
  using: _16@Mir(bb2[2]), _18@Mir(bb2[4]), _20@Mir(bb2[6])
bb3:
  _25 = _1
  using: _1@Mir(bb0[4])
  _24 = move _25 as *const example1::genann (Pointer(MutToConstPointer))
  using: _25@Mir(bb3[0])
  _27 = &mut _6
  using: _6@Mir(bb1[2])
  _26 = &raw const (*_27)
  using: _27@Mir(bb3[2])
  _23 = genann::genann_run(move _24, move _26) -> bb4
  using: _24@Mir(bb3[1]), _26@Mir(bb3[3])
bb4:
  _22 = (*_23)
  using: _23@Mir(bb3[4])
  _28 = const {alloc184: *mut i32}
  using: 
  _29 = CheckedAdd((*_28), const 1_i32)
  using: _28@Mir(bb4[1])
  assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_28), const 1_i32) -> bb5
  using: _29@Entry, _28@Entry
bb5:
  (*_28) = move (_29.0: i32)
  using: _28@Mir(bb4[1]), _29@Mir(bb4[2])
  _34 = _9
  using: _9@Mir(bb2[0])
  _35 = _7
  using: _7@Mir(bb1[4])
  _33 = Sub(move _34, move _35)
  using: _34@Mir(bb5[1]), _35@Mir(bb5[2])
  _32 = test::fabs(move _33) -> bb6
  using: _33@Mir(bb5[3])
bb6:
  _38 = _22
  using: _22@Mir(bb4[0])
  _39 = _7
  using: _7@Mir(bb1[4])
  _37 = Sub(move _38, move _39)
  using: _38@Mir(bb6[0]), _39@Mir(bb6[1])
  _36 = test::fabs(move _37) -> bb7
  using: _37@Mir(bb6[2])
bb7:
  _31 = Gt(move _32, move _36)
  using: _32@Mir(bb5[4]), _36@Mir(bb6[3])
  _30 = Not(move _31)
  using: _31@Mir(bb7[0])
  switchInt(move _30) -> [0: bb10, otherwise: bb8]
  using: _30@Mir(bb7[1])
bb8:
  _40 = const {alloc185: *mut i32}
  using: 
  _41 = CheckedAdd((*_40), const 1_i32)
  using: _40@Mir(bb8[0])
  assert(!move (_41.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_40), const 1_i32) -> bb9
  using: _41@Entry, _40@Entry
bb9:
  (*_40) = move (_41.0: i32)
  using: _40@Mir(bb8[0]), _41@Mir(bb8[1])
  _46 = const b"%s:%d error \n\x00"
  using: 
  _45 = &raw const (*_46)
  using: _46@Mir(bb9[1])
  _44 = move _45 as *const u8 (Pointer(ArrayToPointer))
  using: _45@Mir(bb9[2])
  _43 = move _44 as *const i8 (PtrToPtr)
  using: _44@Mir(bb9[3])
  _50 = const b"test.c\x00"
  using: 
  _49 = &raw const (*_50)
  using: _50@Mir(bb9[5])
  _48 = move _49 as *const u8 (Pointer(ArrayToPointer))
  using: _49@Mir(bb9[6])
  _47 = move _48 as *const i8 (PtrToPtr)
  using: _48@Mir(bb9[7])
  _51 = const 114_i32
  using: 
  _42 = test::printf(move _43, move _47, move _51) -> bb10
  using: _43@Mir(bb9[4]), _47@Mir(bb9[8]), _51@Mir(bb9[9])
bb10:
  _53 = _1
  using: _1@Mir(bb0[4])
  _52 = genann::genann_free(move _53) -> bb11
  using: _53@Mir(bb10[0])
bb11:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:272:10: 272:34 (#0) by default
rewrite call test::fabs @ workspace/genann/test.rs:272:37: 272:62 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:124 ~ c2rust_lib[1043]::test::train_and)
bb0:
  _3 = const 0f64
  using: 
  _4 = const 0f64
  using: 
  _2 = [move _3, move _4]
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1])
  _6 = const 0f64
  using: 
  _7 = const 1f64
  using: 
  _5 = [move _6, move _7]
  using: _6@Mir(bb0[3]), _7@Mir(bb0[4])
  _9 = const 1f64
  using: 
  _10 = const 0f64
  using: 
  _8 = [move _9, move _10]
  using: _9@Mir(bb0[6]), _10@Mir(bb0[7])
  _12 = const 1f64
  using: 
  _13 = const 1f64
  using: 
  _11 = [move _12, move _13]
  using: _12@Mir(bb0[9]), _13@Mir(bb0[10])
  _1 = [move _2, move _5, move _8, move _11]
  using: _2@Mir(bb0[2]), _5@Mir(bb0[5]), _8@Mir(bb0[8]), _11@Mir(bb0[11])
  _15 = const 0f64
  using: 
  _16 = const 0f64
  using: 
  _17 = const 0f64
  using: 
  _18 = const 1f64
  using: 
  _14 = [move _15, move _16, move _17, move _18]
  using: _15@Mir(bb0[13]), _16@Mir(bb0[14]), _17@Mir(bb0[15]), _18@Mir(bb0[16])
  _20 = const 2_i32
  using: 
  _21 = const 0_i32
  using: 
  _22 = const 0_i32
  using: 
  _23 = const 1_i32
  using: 
  _19 = genann::genann_init(move _20, move _21, move _22, move _23) -> bb1
  using: _20@Mir(bb0[18]), _21@Mir(bb0[19]), _22@Mir(bb0[20]), _23@Mir(bb0[21])
bb1:
  _24 = const 0_i32
  using: 
  _25 = const 0_i32
  using: 
  _24 = const 0_i32
  using: 
  goto -> bb2
  using: 
bb2:
  _27 = _24
  using: _24@Phi(bb2)
  _28 = const 50_i32
  using: 
  _26 = Lt(move _27, move _28)
  using: _27@Mir(bb2[0]), _28@Mir(bb2[1])
  switchInt(move _26) -> [0: bb14, otherwise: bb3]
  using: _26@Mir(bb2[2])
bb3:
  _25 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _30 = _25
  using: _25@Phi(bb4)
  _31 = const 4_i32
  using: 
  _29 = Lt(move _30, move _31)
  using: _30@Mir(bb4[0]), _31@Mir(bb4[1])
  switchInt(move _29) -> [0: bb12, otherwise: bb5]
  using: _29@Mir(bb4[2])
bb5:
  _34 = _19
  using: _19@Phi(bb4)
  _33 = move _34 as *const example1::genann (Pointer(MutToConstPointer))
  using: _34@Mir(bb5[0])
  _40 = _25
  using: _25@Phi(bb4)
  _39 = move _40 as usize (IntToInt)
  using: _40@Mir(bb5[2])
  _41 = const 4_usize
  using: 
  _42 = Lt(_39, _41)
  using: _39@Mir(bb5[3]), _41@Mir(bb5[4])
  assert(move _42, "index out of bounds: the length is {} but the index is {}", move _41, _39) -> bb6
  using: _42@Entry, _41@Entry, _39@Entry
bb6:
  _38 = &mut _1[_39]
  using: _1@Phi(bb4), _39@Mir(bb5[3])
  _37 = move _38 as &mut [f64] (Pointer(Unsize))
  using: _38@Mir(bb6[0])
  _36 = core::slice::<impl [f64]>::as_mut_ptr(move _37) -> bb7
  using: _37@Mir(bb6[1])
bb7:
  _35 = move _36 as *const f64 (Pointer(MutToConstPointer))
  using: _36@Mir(bb6[2])
  _47 = &mut _14
  using: _14@Phi(bb4)
  _46 = move _47 as &mut [f64] (Pointer(Unsize))
  using: _47@Mir(bb7[1])
  _45 = core::slice::<impl [f64]>::as_mut_ptr(move _46) -> bb8
  using: _46@Mir(bb7[2])
bb8:
  _49 = _25
  using: _25@Phi(bb4)
  _48 = move _49 as isize (IntToInt)
  using: _49@Mir(bb8[0])
  _44 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _45, move _48) -> bb9
  using: _45@Mir(bb7[3]), _48@Mir(bb8[1])
bb9:
  _43 = move _44 as *const f64 (Pointer(MutToConstPointer))
  using: _44@Mir(bb8[2])
  _32 = genann::genann_train(move _33, move _35, move _43, const 0.80000000000000004f64) -> bb10
  using: _33@Mir(bb5[1]), _35@Mir(bb7[0]), _43@Mir(bb9[0])
bb10:
  _50 = CheckedAdd(_25, const 1_i32)
  using: _25@Phi(bb4)
  assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _25, const 1_i32) -> bb11
  using: _50@Entry, _25@Entry
bb11:
  _25 = move (_50.0: i32)
  using: _50@Mir(bb10[0])
  goto -> bb4
  using: 
bb12:
  _51 = CheckedAdd(_24, const 1_i32)
  using: _24@Phi(bb2)
  assert(!move (_51.1: bool), "attempt to compute `{} + {}`, which would overflow", _24, const 1_i32) -> bb13
  using: _51@Entry, _24@Entry
bb13:
  _24 = move (_51.0: i32)
  using: _51@Mir(bb12[0])
  goto -> bb2
  using: 
bb14:
  _53 = genann::genann_act_threshold as unsafe extern "C" fn(f64) -> f64 (Pointer(ReifyFnPointer))
  using: 
  Deinit(_52)
  using: 
  ((_52 as Some).0: unsafe extern "C" fn(f64) -> f64) = move _53
  using: _53@Mir(bb14[0])
  discriminant(_52) = 1
  using: 
  ((*_19).5: std::option::Option<unsafe extern "C" fn(f64) -> f64>) = move _52
  using: _19@Phi(bb4), _52@Mir(bb14[1])
  _54 = const {alloc184: *mut i32}
  using: 
  _55 = CheckedAdd((*_54), const 1_i32)
  using: _54@Mir(bb14[5])
  assert(!move (_55.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_54), const 1_i32) -> bb15
  using: _55@Entry, _54@Entry
bb15:
  (*_54) = move (_55.0: i32)
  using: _54@Mir(bb14[5]), _55@Mir(bb14[6])
  _60 = const 0_usize
  using: 
  _59 = _14[_60]
  using: _14@Phi(bb4), _60@Mir(bb15[1])
  _64 = _19
  using: _19@Phi(bb4)
  _63 = move _64 as *const example1::genann (Pointer(MutToConstPointer))
  using: _64@Mir(bb15[3])
  _69 = const 0_usize
  using: 
  _68 = &mut _1[_69]
  using: _1@Phi(bb4), _69@Mir(bb15[5])
  _67 = move _68 as &mut [f64] (Pointer(Unsize))
  using: _68@Mir(bb15[6])
  _66 = core::slice::<impl [f64]>::as_mut_ptr(move _67) -> bb16
  using: _67@Mir(bb15[7])
bb16:
  _65 = move _66 as *const f64 (Pointer(MutToConstPointer))
  using: _66@Mir(bb15[8])
  _62 = genann::genann_run(move _63, move _65) -> bb17
  using: _63@Mir(bb15[4]), _65@Mir(bb16[0])
bb17:
  _61 = (*_62)
  using: _62@Mir(bb16[1])
  _58 = Sub(move _59, move _61)
  using: _59@Mir(bb15[2]), _61@Mir(bb17[0])
  _57 = test::fabs(move _58) -> bb18
  using: _58@Mir(bb17[1])
bb18:
  _56 = Gt(move _57, const 0.001f64)
  using: _57@Mir(bb17[2])
  switchInt(move _56) -> [0: bb23, otherwise: bb19]
  using: _56@Mir(bb18[0])
bb19:
  _70 = const {alloc185: *mut i32}
  using: 
  _71 = CheckedAdd((*_70), const 1_i32)
  using: _70@Mir(bb19[0])
  assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_70), const 1_i32) -> bb20
  using: _71@Entry, _70@Entry
bb20:
  (*_70) = move (_71.0: i32)
  using: _70@Mir(bb19[0]), _71@Mir(bb19[1])
  _76 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _75 = &raw const (*_76)
  using: _76@Mir(bb20[1])
  _74 = move _75 as *const u8 (Pointer(ArrayToPointer))
  using: _75@Mir(bb20[2])
  _73 = move _74 as *const i8 (PtrToPtr)
  using: _74@Mir(bb20[3])
  _80 = const b"test.c\x00"
  using: 
  _79 = &raw const (*_80)
  using: _80@Mir(bb20[5])
  _78 = move _79 as *const u8 (Pointer(ArrayToPointer))
  using: _79@Mir(bb20[6])
  _77 = move _78 as *const i8 (PtrToPtr)
  using: _78@Mir(bb20[7])
  _81 = const 135_i32
  using: 
  _83 = const 0_usize
  using: 
  _82 = _14[_83]
  using: _14@Phi(bb4), _83@Mir(bb20[10])
  _87 = _19
  using: _19@Phi(bb4)
  _86 = move _87 as *const example1::genann (Pointer(MutToConstPointer))
  using: _87@Mir(bb20[12])
  _92 = const 0_usize
  using: 
  _91 = &mut _1[_92]
  using: _1@Phi(bb4), _92@Mir(bb20[14])
  _90 = move _91 as &mut [f64] (Pointer(Unsize))
  using: _91@Mir(bb20[15])
  _89 = core::slice::<impl [f64]>::as_mut_ptr(move _90) -> bb21
  using: _90@Mir(bb20[16])
bb21:
  _88 = move _89 as *const f64 (Pointer(MutToConstPointer))
  using: _89@Mir(bb20[17])
  _85 = genann::genann_run(move _86, move _88) -> bb22
  using: _86@Mir(bb20[13]), _88@Mir(bb21[0])
bb22:
  _84 = (*_85)
  using: _85@Mir(bb21[1])
  _72 = test::printf(move _73, move _77, move _81, move _82, move _84) -> bb23
  using: _73@Mir(bb20[4]), _77@Mir(bb20[8]), _81@Mir(bb20[9]), _82@Mir(bb20[11]), _84@Mir(bb22[0])
bb23:
  _93 = const {alloc184: *mut i32}
  using: 
  _94 = CheckedAdd((*_93), const 1_i32)
  using: _93@Mir(bb23[0])
  assert(!move (_94.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_93), const 1_i32) -> bb24
  using: _94@Entry, _93@Entry
bb24:
  (*_93) = move (_94.0: i32)
  using: _93@Mir(bb23[0]), _94@Mir(bb23[1])
  _99 = const 1_usize
  using: 
  _98 = _14[_99]
  using: _14@Phi(bb23), _99@Mir(bb24[1])
  _103 = _19
  using: _19@Phi(bb23)
  _102 = move _103 as *const example1::genann (Pointer(MutToConstPointer))
  using: _103@Mir(bb24[3])
  _108 = const 1_usize
  using: 
  _107 = &mut _1[_108]
  using: _1@Phi(bb23), _108@Mir(bb24[5])
  _106 = move _107 as &mut [f64] (Pointer(Unsize))
  using: _107@Mir(bb24[6])
  _105 = core::slice::<impl [f64]>::as_mut_ptr(move _106) -> bb25
  using: _106@Mir(bb24[7])
bb25:
  _104 = move _105 as *const f64 (Pointer(MutToConstPointer))
  using: _105@Mir(bb24[8])
  _101 = genann::genann_run(move _102, move _104) -> bb26
  using: _102@Mir(bb24[4]), _104@Mir(bb25[0])
bb26:
  _100 = (*_101)
  using: _101@Mir(bb25[1])
  _97 = Sub(move _98, move _100)
  using: _98@Mir(bb24[2]), _100@Mir(bb26[0])
  _96 = test::fabs(move _97) -> bb27
  using: _97@Mir(bb26[1])
bb27:
  _95 = Gt(move _96, const 0.001f64)
  using: _96@Mir(bb26[2])
  switchInt(move _95) -> [0: bb32, otherwise: bb28]
  using: _95@Mir(bb27[0])
bb28:
  _109 = const {alloc185: *mut i32}
  using: 
  _110 = CheckedAdd((*_109), const 1_i32)
  using: _109@Mir(bb28[0])
  assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_109), const 1_i32) -> bb29
  using: _110@Entry, _109@Entry
bb29:
  (*_109) = move (_110.0: i32)
  using: _109@Mir(bb28[0]), _110@Mir(bb28[1])
  _115 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _114 = &raw const (*_115)
  using: _115@Mir(bb29[1])
  _113 = move _114 as *const u8 (Pointer(ArrayToPointer))
  using: _114@Mir(bb29[2])
  _112 = move _113 as *const i8 (PtrToPtr)
  using: _113@Mir(bb29[3])
  _119 = const b"test.c\x00"
  using: 
  _118 = &raw const (*_119)
  using: _119@Mir(bb29[5])
  _117 = move _118 as *const u8 (Pointer(ArrayToPointer))
  using: _118@Mir(bb29[6])
  _116 = move _117 as *const i8 (PtrToPtr)
  using: _117@Mir(bb29[7])
  _120 = const 136_i32
  using: 
  _122 = const 1_usize
  using: 
  _121 = _14[_122]
  using: _14@Phi(bb23), _122@Mir(bb29[10])
  _126 = _19
  using: _19@Phi(bb23)
  _125 = move _126 as *const example1::genann (Pointer(MutToConstPointer))
  using: _126@Mir(bb29[12])
  _131 = const 1_usize
  using: 
  _130 = &mut _1[_131]
  using: _1@Phi(bb23), _131@Mir(bb29[14])
  _129 = move _130 as &mut [f64] (Pointer(Unsize))
  using: _130@Mir(bb29[15])
  _128 = core::slice::<impl [f64]>::as_mut_ptr(move _129) -> bb30
  using: _129@Mir(bb29[16])
bb30:
  _127 = move _128 as *const f64 (Pointer(MutToConstPointer))
  using: _128@Mir(bb29[17])
  _124 = genann::genann_run(move _125, move _127) -> bb31
  using: _125@Mir(bb29[13]), _127@Mir(bb30[0])
bb31:
  _123 = (*_124)
  using: _124@Mir(bb30[1])
  _111 = test::printf(move _112, move _116, move _120, move _121, move _123) -> bb32
  using: _112@Mir(bb29[4]), _116@Mir(bb29[8]), _120@Mir(bb29[9]), _121@Mir(bb29[11]), _123@Mir(bb31[0])
bb32:
  _132 = const {alloc184: *mut i32}
  using: 
  _133 = CheckedAdd((*_132), const 1_i32)
  using: _132@Mir(bb32[0])
  assert(!move (_133.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_132), const 1_i32) -> bb33
  using: _133@Entry, _132@Entry
bb33:
  (*_132) = move (_133.0: i32)
  using: _132@Mir(bb32[0]), _133@Mir(bb32[1])
  _138 = const 2_usize
  using: 
  _137 = _14[_138]
  using: _14@Phi(bb32), _138@Mir(bb33[1])
  _142 = _19
  using: _19@Phi(bb32)
  _141 = move _142 as *const example1::genann (Pointer(MutToConstPointer))
  using: _142@Mir(bb33[3])
  _147 = const 2_usize
  using: 
  _146 = &mut _1[_147]
  using: _1@Phi(bb32), _147@Mir(bb33[5])
  _145 = move _146 as &mut [f64] (Pointer(Unsize))
  using: _146@Mir(bb33[6])
  _144 = core::slice::<impl [f64]>::as_mut_ptr(move _145) -> bb34
  using: _145@Mir(bb33[7])
bb34:
  _143 = move _144 as *const f64 (Pointer(MutToConstPointer))
  using: _144@Mir(bb33[8])
  _140 = genann::genann_run(move _141, move _143) -> bb35
  using: _141@Mir(bb33[4]), _143@Mir(bb34[0])
bb35:
  _139 = (*_140)
  using: _140@Mir(bb34[1])
  _136 = Sub(move _137, move _139)
  using: _137@Mir(bb33[2]), _139@Mir(bb35[0])
  _135 = test::fabs(move _136) -> bb36
  using: _136@Mir(bb35[1])
bb36:
  _134 = Gt(move _135, const 0.001f64)
  using: _135@Mir(bb35[2])
  switchInt(move _134) -> [0: bb41, otherwise: bb37]
  using: _134@Mir(bb36[0])
bb37:
  _148 = const {alloc185: *mut i32}
  using: 
  _149 = CheckedAdd((*_148), const 1_i32)
  using: _148@Mir(bb37[0])
  assert(!move (_149.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_148), const 1_i32) -> bb38
  using: _149@Entry, _148@Entry
bb38:
  (*_148) = move (_149.0: i32)
  using: _148@Mir(bb37[0]), _149@Mir(bb37[1])
  _154 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _153 = &raw const (*_154)
  using: _154@Mir(bb38[1])
  _152 = move _153 as *const u8 (Pointer(ArrayToPointer))
  using: _153@Mir(bb38[2])
  _151 = move _152 as *const i8 (PtrToPtr)
  using: _152@Mir(bb38[3])
  _158 = const b"test.c\x00"
  using: 
  _157 = &raw const (*_158)
  using: _158@Mir(bb38[5])
  _156 = move _157 as *const u8 (Pointer(ArrayToPointer))
  using: _157@Mir(bb38[6])
  _155 = move _156 as *const i8 (PtrToPtr)
  using: _156@Mir(bb38[7])
  _159 = const 137_i32
  using: 
  _161 = const 2_usize
  using: 
  _160 = _14[_161]
  using: _14@Phi(bb32), _161@Mir(bb38[10])
  _165 = _19
  using: _19@Phi(bb32)
  _164 = move _165 as *const example1::genann (Pointer(MutToConstPointer))
  using: _165@Mir(bb38[12])
  _170 = const 2_usize
  using: 
  _169 = &mut _1[_170]
  using: _1@Phi(bb32), _170@Mir(bb38[14])
  _168 = move _169 as &mut [f64] (Pointer(Unsize))
  using: _169@Mir(bb38[15])
  _167 = core::slice::<impl [f64]>::as_mut_ptr(move _168) -> bb39
  using: _168@Mir(bb38[16])
bb39:
  _166 = move _167 as *const f64 (Pointer(MutToConstPointer))
  using: _167@Mir(bb38[17])
  _163 = genann::genann_run(move _164, move _166) -> bb40
  using: _164@Mir(bb38[13]), _166@Mir(bb39[0])
bb40:
  _162 = (*_163)
  using: _163@Mir(bb39[1])
  _150 = test::printf(move _151, move _155, move _159, move _160, move _162) -> bb41
  using: _151@Mir(bb38[4]), _155@Mir(bb38[8]), _159@Mir(bb38[9]), _160@Mir(bb38[11]), _162@Mir(bb40[0])
bb41:
  _171 = const {alloc184: *mut i32}
  using: 
  _172 = CheckedAdd((*_171), const 1_i32)
  using: _171@Mir(bb41[0])
  assert(!move (_172.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_171), const 1_i32) -> bb42
  using: _172@Entry, _171@Entry
bb42:
  (*_171) = move (_172.0: i32)
  using: _171@Mir(bb41[0]), _172@Mir(bb41[1])
  _177 = const 3_usize
  using: 
  _176 = _14[_177]
  using: _14@Phi(bb41), _177@Mir(bb42[1])
  _181 = _19
  using: _19@Phi(bb41)
  _180 = move _181 as *const example1::genann (Pointer(MutToConstPointer))
  using: _181@Mir(bb42[3])
  _186 = const 3_usize
  using: 
  _185 = &mut _1[_186]
  using: _1@Phi(bb41), _186@Mir(bb42[5])
  _184 = move _185 as &mut [f64] (Pointer(Unsize))
  using: _185@Mir(bb42[6])
  _183 = core::slice::<impl [f64]>::as_mut_ptr(move _184) -> bb43
  using: _184@Mir(bb42[7])
bb43:
  _182 = move _183 as *const f64 (Pointer(MutToConstPointer))
  using: _183@Mir(bb42[8])
  _179 = genann::genann_run(move _180, move _182) -> bb44
  using: _180@Mir(bb42[4]), _182@Mir(bb43[0])
bb44:
  _178 = (*_179)
  using: _179@Mir(bb43[1])
  _175 = Sub(move _176, move _178)
  using: _176@Mir(bb42[2]), _178@Mir(bb44[0])
  _174 = test::fabs(move _175) -> bb45
  using: _175@Mir(bb44[1])
bb45:
  _173 = Gt(move _174, const 0.001f64)
  using: _174@Mir(bb44[2])
  switchInt(move _173) -> [0: bb50, otherwise: bb46]
  using: _173@Mir(bb45[0])
bb46:
  _187 = const {alloc185: *mut i32}
  using: 
  _188 = CheckedAdd((*_187), const 1_i32)
  using: _187@Mir(bb46[0])
  assert(!move (_188.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_187), const 1_i32) -> bb47
  using: _188@Entry, _187@Entry
bb47:
  (*_187) = move (_188.0: i32)
  using: _187@Mir(bb46[0]), _188@Mir(bb46[1])
  _193 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _192 = &raw const (*_193)
  using: _193@Mir(bb47[1])
  _191 = move _192 as *const u8 (Pointer(ArrayToPointer))
  using: _192@Mir(bb47[2])
  _190 = move _191 as *const i8 (PtrToPtr)
  using: _191@Mir(bb47[3])
  _197 = const b"test.c\x00"
  using: 
  _196 = &raw const (*_197)
  using: _197@Mir(bb47[5])
  _195 = move _196 as *const u8 (Pointer(ArrayToPointer))
  using: _196@Mir(bb47[6])
  _194 = move _195 as *const i8 (PtrToPtr)
  using: _195@Mir(bb47[7])
  _198 = const 138_i32
  using: 
  _200 = const 3_usize
  using: 
  _199 = _14[_200]
  using: _14@Phi(bb41), _200@Mir(bb47[10])
  _204 = _19
  using: _19@Phi(bb41)
  _203 = move _204 as *const example1::genann (Pointer(MutToConstPointer))
  using: _204@Mir(bb47[12])
  _209 = const 3_usize
  using: 
  _208 = &mut _1[_209]
  using: _1@Phi(bb41), _209@Mir(bb47[14])
  _207 = move _208 as &mut [f64] (Pointer(Unsize))
  using: _208@Mir(bb47[15])
  _206 = core::slice::<impl [f64]>::as_mut_ptr(move _207) -> bb48
  using: _207@Mir(bb47[16])
bb48:
  _205 = move _206 as *const f64 (Pointer(MutToConstPointer))
  using: _206@Mir(bb47[17])
  _202 = genann::genann_run(move _203, move _205) -> bb49
  using: _203@Mir(bb47[13]), _205@Mir(bb48[0])
bb49:
  _201 = (*_202)
  using: _202@Mir(bb48[1])
  _189 = test::printf(move _190, move _194, move _198, move _199, move _201) -> bb50
  using: _190@Mir(bb47[4]), _194@Mir(bb47[8]), _198@Mir(bb47[9]), _199@Mir(bb47[11]), _201@Mir(bb49[0])
bb50:
  _211 = _19
  using: _19@Phi(bb50)
  _210 = genann::genann_free(move _211) -> bb51
  using: _211@Mir(bb50[0])
bb51:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _2, move _5, move _8, move _11] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _15, move _16, move _17, move _18] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:306:46: 306:64 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_52) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_52) = 1 is ignored
rewrite call test::fabs @ workspace/genann/test.rs:315:8: 317:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:327:8: 329:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:339:8: 341:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:351:8: 353:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:128 ~ c2rust_lib[1043]::test::train_or)
bb0:
  _3 = const 0f64
  using: 
  _4 = const 0f64
  using: 
  _2 = [move _3, move _4]
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1])
  _6 = const 0f64
  using: 
  _7 = const 1f64
  using: 
  _5 = [move _6, move _7]
  using: _6@Mir(bb0[3]), _7@Mir(bb0[4])
  _9 = const 1f64
  using: 
  _10 = const 0f64
  using: 
  _8 = [move _9, move _10]
  using: _9@Mir(bb0[6]), _10@Mir(bb0[7])
  _12 = const 1f64
  using: 
  _13 = const 1f64
  using: 
  _11 = [move _12, move _13]
  using: _12@Mir(bb0[9]), _13@Mir(bb0[10])
  _1 = [move _2, move _5, move _8, move _11]
  using: _2@Mir(bb0[2]), _5@Mir(bb0[5]), _8@Mir(bb0[8]), _11@Mir(bb0[11])
  _15 = const 0f64
  using: 
  _16 = const 1f64
  using: 
  _17 = const 1f64
  using: 
  _18 = const 1f64
  using: 
  _14 = [move _15, move _16, move _17, move _18]
  using: _15@Mir(bb0[13]), _16@Mir(bb0[14]), _17@Mir(bb0[15]), _18@Mir(bb0[16])
  _20 = const 2_i32
  using: 
  _21 = const 0_i32
  using: 
  _22 = const 0_i32
  using: 
  _23 = const 1_i32
  using: 
  _19 = genann::genann_init(move _20, move _21, move _22, move _23) -> bb1
  using: _20@Mir(bb0[18]), _21@Mir(bb0[19]), _22@Mir(bb0[20]), _23@Mir(bb0[21])
bb1:
  _25 = _19
  using: _19@Mir(bb0[22])
  _24 = genann::genann_randomize(move _25) -> bb2
  using: _25@Mir(bb1[0])
bb2:
  _26 = const 0_i32
  using: 
  _27 = const 0_i32
  using: 
  _26 = const 0_i32
  using: 
  goto -> bb3
  using: 
bb3:
  _29 = _26
  using: _26@Phi(bb3)
  _30 = const 50_i32
  using: 
  _28 = Lt(move _29, move _30)
  using: _29@Mir(bb3[0]), _30@Mir(bb3[1])
  switchInt(move _28) -> [0: bb15, otherwise: bb4]
  using: _28@Mir(bb3[2])
bb4:
  _27 = const 0_i32
  using: 
  goto -> bb5
  using: 
bb5:
  _32 = _27
  using: _27@Phi(bb5)
  _33 = const 4_i32
  using: 
  _31 = Lt(move _32, move _33)
  using: _32@Mir(bb5[0]), _33@Mir(bb5[1])
  switchInt(move _31) -> [0: bb13, otherwise: bb6]
  using: _31@Mir(bb5[2])
bb6:
  _36 = _19
  using: _19@Phi(bb5)
  _35 = move _36 as *const example1::genann (Pointer(MutToConstPointer))
  using: _36@Mir(bb6[0])
  _42 = _27
  using: _27@Phi(bb5)
  _41 = move _42 as usize (IntToInt)
  using: _42@Mir(bb6[2])
  _43 = const 4_usize
  using: 
  _44 = Lt(_41, _43)
  using: _41@Mir(bb6[3]), _43@Mir(bb6[4])
  assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _41) -> bb7
  using: _44@Entry, _43@Entry, _41@Entry
bb7:
  _40 = &mut _1[_41]
  using: _1@Phi(bb5), _41@Mir(bb6[3])
  _39 = move _40 as &mut [f64] (Pointer(Unsize))
  using: _40@Mir(bb7[0])
  _38 = core::slice::<impl [f64]>::as_mut_ptr(move _39) -> bb8
  using: _39@Mir(bb7[1])
bb8:
  _37 = move _38 as *const f64 (Pointer(MutToConstPointer))
  using: _38@Mir(bb7[2])
  _49 = &mut _14
  using: _14@Phi(bb5)
  _48 = move _49 as &mut [f64] (Pointer(Unsize))
  using: _49@Mir(bb8[1])
  _47 = core::slice::<impl [f64]>::as_mut_ptr(move _48) -> bb9
  using: _48@Mir(bb8[2])
bb9:
  _51 = _27
  using: _27@Phi(bb5)
  _50 = move _51 as isize (IntToInt)
  using: _51@Mir(bb9[0])
  _46 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _47, move _50) -> bb10
  using: _47@Mir(bb8[3]), _50@Mir(bb9[1])
bb10:
  _45 = move _46 as *const f64 (Pointer(MutToConstPointer))
  using: _46@Mir(bb9[2])
  _34 = genann::genann_train(move _35, move _37, move _45, const 0.80000000000000004f64) -> bb11
  using: _35@Mir(bb6[1]), _37@Mir(bb8[0]), _45@Mir(bb10[0])
bb11:
  _52 = CheckedAdd(_27, const 1_i32)
  using: _27@Phi(bb5)
  assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", _27, const 1_i32) -> bb12
  using: _52@Entry, _27@Entry
bb12:
  _27 = move (_52.0: i32)
  using: _52@Mir(bb11[0])
  goto -> bb5
  using: 
bb13:
  _53 = CheckedAdd(_26, const 1_i32)
  using: _26@Phi(bb3)
  assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", _26, const 1_i32) -> bb14
  using: _53@Entry, _26@Entry
bb14:
  _26 = move (_53.0: i32)
  using: _53@Mir(bb13[0])
  goto -> bb3
  using: 
bb15:
  _55 = genann::genann_act_threshold as unsafe extern "C" fn(f64) -> f64 (Pointer(ReifyFnPointer))
  using: 
  Deinit(_54)
  using: 
  ((_54 as Some).0: unsafe extern "C" fn(f64) -> f64) = move _55
  using: _55@Mir(bb15[0])
  discriminant(_54) = 1
  using: 
  ((*_19).5: std::option::Option<unsafe extern "C" fn(f64) -> f64>) = move _54
  using: _19@Phi(bb5), _54@Mir(bb15[1])
  _56 = const {alloc184: *mut i32}
  using: 
  _57 = CheckedAdd((*_56), const 1_i32)
  using: _56@Mir(bb15[5])
  assert(!move (_57.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_56), const 1_i32) -> bb16
  using: _57@Entry, _56@Entry
bb16:
  (*_56) = move (_57.0: i32)
  using: _56@Mir(bb15[5]), _57@Mir(bb15[6])
  _62 = const 0_usize
  using: 
  _61 = _14[_62]
  using: _14@Phi(bb5), _62@Mir(bb16[1])
  _66 = _19
  using: _19@Phi(bb5)
  _65 = move _66 as *const example1::genann (Pointer(MutToConstPointer))
  using: _66@Mir(bb16[3])
  _71 = const 0_usize
  using: 
  _70 = &mut _1[_71]
  using: _1@Phi(bb5), _71@Mir(bb16[5])
  _69 = move _70 as &mut [f64] (Pointer(Unsize))
  using: _70@Mir(bb16[6])
  _68 = core::slice::<impl [f64]>::as_mut_ptr(move _69) -> bb17
  using: _69@Mir(bb16[7])
bb17:
  _67 = move _68 as *const f64 (Pointer(MutToConstPointer))
  using: _68@Mir(bb16[8])
  _64 = genann::genann_run(move _65, move _67) -> bb18
  using: _65@Mir(bb16[4]), _67@Mir(bb17[0])
bb18:
  _63 = (*_64)
  using: _64@Mir(bb17[1])
  _60 = Sub(move _61, move _63)
  using: _61@Mir(bb16[2]), _63@Mir(bb18[0])
  _59 = test::fabs(move _60) -> bb19
  using: _60@Mir(bb18[1])
bb19:
  _58 = Gt(move _59, const 0.001f64)
  using: _59@Mir(bb18[2])
  switchInt(move _58) -> [0: bb24, otherwise: bb20]
  using: _58@Mir(bb19[0])
bb20:
  _72 = const {alloc185: *mut i32}
  using: 
  _73 = CheckedAdd((*_72), const 1_i32)
  using: _72@Mir(bb20[0])
  assert(!move (_73.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_72), const 1_i32) -> bb21
  using: _73@Entry, _72@Entry
bb21:
  (*_72) = move (_73.0: i32)
  using: _72@Mir(bb20[0]), _73@Mir(bb20[1])
  _78 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _77 = &raw const (*_78)
  using: _78@Mir(bb21[1])
  _76 = move _77 as *const u8 (Pointer(ArrayToPointer))
  using: _77@Mir(bb21[2])
  _75 = move _76 as *const i8 (PtrToPtr)
  using: _76@Mir(bb21[3])
  _82 = const b"test.c\x00"
  using: 
  _81 = &raw const (*_82)
  using: _82@Mir(bb21[5])
  _80 = move _81 as *const u8 (Pointer(ArrayToPointer))
  using: _81@Mir(bb21[6])
  _79 = move _80 as *const i8 (PtrToPtr)
  using: _80@Mir(bb21[7])
  _83 = const 160_i32
  using: 
  _85 = const 0_usize
  using: 
  _84 = _14[_85]
  using: _14@Phi(bb5), _85@Mir(bb21[10])
  _89 = _19
  using: _19@Phi(bb5)
  _88 = move _89 as *const example1::genann (Pointer(MutToConstPointer))
  using: _89@Mir(bb21[12])
  _94 = const 0_usize
  using: 
  _93 = &mut _1[_94]
  using: _1@Phi(bb5), _94@Mir(bb21[14])
  _92 = move _93 as &mut [f64] (Pointer(Unsize))
  using: _93@Mir(bb21[15])
  _91 = core::slice::<impl [f64]>::as_mut_ptr(move _92) -> bb22
  using: _92@Mir(bb21[16])
bb22:
  _90 = move _91 as *const f64 (Pointer(MutToConstPointer))
  using: _91@Mir(bb21[17])
  _87 = genann::genann_run(move _88, move _90) -> bb23
  using: _88@Mir(bb21[13]), _90@Mir(bb22[0])
bb23:
  _86 = (*_87)
  using: _87@Mir(bb22[1])
  _74 = test::printf(move _75, move _79, move _83, move _84, move _86) -> bb24
  using: _75@Mir(bb21[4]), _79@Mir(bb21[8]), _83@Mir(bb21[9]), _84@Mir(bb21[11]), _86@Mir(bb23[0])
bb24:
  _95 = const {alloc184: *mut i32}
  using: 
  _96 = CheckedAdd((*_95), const 1_i32)
  using: _95@Mir(bb24[0])
  assert(!move (_96.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_95), const 1_i32) -> bb25
  using: _96@Entry, _95@Entry
bb25:
  (*_95) = move (_96.0: i32)
  using: _95@Mir(bb24[0]), _96@Mir(bb24[1])
  _101 = const 1_usize
  using: 
  _100 = _14[_101]
  using: _14@Phi(bb24), _101@Mir(bb25[1])
  _105 = _19
  using: _19@Phi(bb24)
  _104 = move _105 as *const example1::genann (Pointer(MutToConstPointer))
  using: _105@Mir(bb25[3])
  _110 = const 1_usize
  using: 
  _109 = &mut _1[_110]
  using: _1@Phi(bb24), _110@Mir(bb25[5])
  _108 = move _109 as &mut [f64] (Pointer(Unsize))
  using: _109@Mir(bb25[6])
  _107 = core::slice::<impl [f64]>::as_mut_ptr(move _108) -> bb26
  using: _108@Mir(bb25[7])
bb26:
  _106 = move _107 as *const f64 (Pointer(MutToConstPointer))
  using: _107@Mir(bb25[8])
  _103 = genann::genann_run(move _104, move _106) -> bb27
  using: _104@Mir(bb25[4]), _106@Mir(bb26[0])
bb27:
  _102 = (*_103)
  using: _103@Mir(bb26[1])
  _99 = Sub(move _100, move _102)
  using: _100@Mir(bb25[2]), _102@Mir(bb27[0])
  _98 = test::fabs(move _99) -> bb28
  using: _99@Mir(bb27[1])
bb28:
  _97 = Gt(move _98, const 0.001f64)
  using: _98@Mir(bb27[2])
  switchInt(move _97) -> [0: bb33, otherwise: bb29]
  using: _97@Mir(bb28[0])
bb29:
  _111 = const {alloc185: *mut i32}
  using: 
  _112 = CheckedAdd((*_111), const 1_i32)
  using: _111@Mir(bb29[0])
  assert(!move (_112.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_111), const 1_i32) -> bb30
  using: _112@Entry, _111@Entry
bb30:
  (*_111) = move (_112.0: i32)
  using: _111@Mir(bb29[0]), _112@Mir(bb29[1])
  _117 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _116 = &raw const (*_117)
  using: _117@Mir(bb30[1])
  _115 = move _116 as *const u8 (Pointer(ArrayToPointer))
  using: _116@Mir(bb30[2])
  _114 = move _115 as *const i8 (PtrToPtr)
  using: _115@Mir(bb30[3])
  _121 = const b"test.c\x00"
  using: 
  _120 = &raw const (*_121)
  using: _121@Mir(bb30[5])
  _119 = move _120 as *const u8 (Pointer(ArrayToPointer))
  using: _120@Mir(bb30[6])
  _118 = move _119 as *const i8 (PtrToPtr)
  using: _119@Mir(bb30[7])
  _122 = const 161_i32
  using: 
  _124 = const 1_usize
  using: 
  _123 = _14[_124]
  using: _14@Phi(bb24), _124@Mir(bb30[10])
  _128 = _19
  using: _19@Phi(bb24)
  _127 = move _128 as *const example1::genann (Pointer(MutToConstPointer))
  using: _128@Mir(bb30[12])
  _133 = const 1_usize
  using: 
  _132 = &mut _1[_133]
  using: _1@Phi(bb24), _133@Mir(bb30[14])
  _131 = move _132 as &mut [f64] (Pointer(Unsize))
  using: _132@Mir(bb30[15])
  _130 = core::slice::<impl [f64]>::as_mut_ptr(move _131) -> bb31
  using: _131@Mir(bb30[16])
bb31:
  _129 = move _130 as *const f64 (Pointer(MutToConstPointer))
  using: _130@Mir(bb30[17])
  _126 = genann::genann_run(move _127, move _129) -> bb32
  using: _127@Mir(bb30[13]), _129@Mir(bb31[0])
bb32:
  _125 = (*_126)
  using: _126@Mir(bb31[1])
  _113 = test::printf(move _114, move _118, move _122, move _123, move _125) -> bb33
  using: _114@Mir(bb30[4]), _118@Mir(bb30[8]), _122@Mir(bb30[9]), _123@Mir(bb30[11]), _125@Mir(bb32[0])
bb33:
  _134 = const {alloc184: *mut i32}
  using: 
  _135 = CheckedAdd((*_134), const 1_i32)
  using: _134@Mir(bb33[0])
  assert(!move (_135.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_134), const 1_i32) -> bb34
  using: _135@Entry, _134@Entry
bb34:
  (*_134) = move (_135.0: i32)
  using: _134@Mir(bb33[0]), _135@Mir(bb33[1])
  _140 = const 2_usize
  using: 
  _139 = _14[_140]
  using: _14@Phi(bb33), _140@Mir(bb34[1])
  _144 = _19
  using: _19@Phi(bb33)
  _143 = move _144 as *const example1::genann (Pointer(MutToConstPointer))
  using: _144@Mir(bb34[3])
  _149 = const 2_usize
  using: 
  _148 = &mut _1[_149]
  using: _1@Phi(bb33), _149@Mir(bb34[5])
  _147 = move _148 as &mut [f64] (Pointer(Unsize))
  using: _148@Mir(bb34[6])
  _146 = core::slice::<impl [f64]>::as_mut_ptr(move _147) -> bb35
  using: _147@Mir(bb34[7])
bb35:
  _145 = move _146 as *const f64 (Pointer(MutToConstPointer))
  using: _146@Mir(bb34[8])
  _142 = genann::genann_run(move _143, move _145) -> bb36
  using: _143@Mir(bb34[4]), _145@Mir(bb35[0])
bb36:
  _141 = (*_142)
  using: _142@Mir(bb35[1])
  _138 = Sub(move _139, move _141)
  using: _139@Mir(bb34[2]), _141@Mir(bb36[0])
  _137 = test::fabs(move _138) -> bb37
  using: _138@Mir(bb36[1])
bb37:
  _136 = Gt(move _137, const 0.001f64)
  using: _137@Mir(bb36[2])
  switchInt(move _136) -> [0: bb42, otherwise: bb38]
  using: _136@Mir(bb37[0])
bb38:
  _150 = const {alloc185: *mut i32}
  using: 
  _151 = CheckedAdd((*_150), const 1_i32)
  using: _150@Mir(bb38[0])
  assert(!move (_151.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_150), const 1_i32) -> bb39
  using: _151@Entry, _150@Entry
bb39:
  (*_150) = move (_151.0: i32)
  using: _150@Mir(bb38[0]), _151@Mir(bb38[1])
  _156 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _155 = &raw const (*_156)
  using: _156@Mir(bb39[1])
  _154 = move _155 as *const u8 (Pointer(ArrayToPointer))
  using: _155@Mir(bb39[2])
  _153 = move _154 as *const i8 (PtrToPtr)
  using: _154@Mir(bb39[3])
  _160 = const b"test.c\x00"
  using: 
  _159 = &raw const (*_160)
  using: _160@Mir(bb39[5])
  _158 = move _159 as *const u8 (Pointer(ArrayToPointer))
  using: _159@Mir(bb39[6])
  _157 = move _158 as *const i8 (PtrToPtr)
  using: _158@Mir(bb39[7])
  _161 = const 162_i32
  using: 
  _163 = const 2_usize
  using: 
  _162 = _14[_163]
  using: _14@Phi(bb33), _163@Mir(bb39[10])
  _167 = _19
  using: _19@Phi(bb33)
  _166 = move _167 as *const example1::genann (Pointer(MutToConstPointer))
  using: _167@Mir(bb39[12])
  _172 = const 2_usize
  using: 
  _171 = &mut _1[_172]
  using: _1@Phi(bb33), _172@Mir(bb39[14])
  _170 = move _171 as &mut [f64] (Pointer(Unsize))
  using: _171@Mir(bb39[15])
  _169 = core::slice::<impl [f64]>::as_mut_ptr(move _170) -> bb40
  using: _170@Mir(bb39[16])
bb40:
  _168 = move _169 as *const f64 (Pointer(MutToConstPointer))
  using: _169@Mir(bb39[17])
  _165 = genann::genann_run(move _166, move _168) -> bb41
  using: _166@Mir(bb39[13]), _168@Mir(bb40[0])
bb41:
  _164 = (*_165)
  using: _165@Mir(bb40[1])
  _152 = test::printf(move _153, move _157, move _161, move _162, move _164) -> bb42
  using: _153@Mir(bb39[4]), _157@Mir(bb39[8]), _161@Mir(bb39[9]), _162@Mir(bb39[11]), _164@Mir(bb41[0])
bb42:
  _173 = const {alloc184: *mut i32}
  using: 
  _174 = CheckedAdd((*_173), const 1_i32)
  using: _173@Mir(bb42[0])
  assert(!move (_174.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_173), const 1_i32) -> bb43
  using: _174@Entry, _173@Entry
bb43:
  (*_173) = move (_174.0: i32)
  using: _173@Mir(bb42[0]), _174@Mir(bb42[1])
  _179 = const 3_usize
  using: 
  _178 = _14[_179]
  using: _14@Phi(bb42), _179@Mir(bb43[1])
  _183 = _19
  using: _19@Phi(bb42)
  _182 = move _183 as *const example1::genann (Pointer(MutToConstPointer))
  using: _183@Mir(bb43[3])
  _188 = const 3_usize
  using: 
  _187 = &mut _1[_188]
  using: _1@Phi(bb42), _188@Mir(bb43[5])
  _186 = move _187 as &mut [f64] (Pointer(Unsize))
  using: _187@Mir(bb43[6])
  _185 = core::slice::<impl [f64]>::as_mut_ptr(move _186) -> bb44
  using: _186@Mir(bb43[7])
bb44:
  _184 = move _185 as *const f64 (Pointer(MutToConstPointer))
  using: _185@Mir(bb43[8])
  _181 = genann::genann_run(move _182, move _184) -> bb45
  using: _182@Mir(bb43[4]), _184@Mir(bb44[0])
bb45:
  _180 = (*_181)
  using: _181@Mir(bb44[1])
  _177 = Sub(move _178, move _180)
  using: _178@Mir(bb43[2]), _180@Mir(bb45[0])
  _176 = test::fabs(move _177) -> bb46
  using: _177@Mir(bb45[1])
bb46:
  _175 = Gt(move _176, const 0.001f64)
  using: _176@Mir(bb45[2])
  switchInt(move _175) -> [0: bb51, otherwise: bb47]
  using: _175@Mir(bb46[0])
bb47:
  _189 = const {alloc185: *mut i32}
  using: 
  _190 = CheckedAdd((*_189), const 1_i32)
  using: _189@Mir(bb47[0])
  assert(!move (_190.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_189), const 1_i32) -> bb48
  using: _190@Entry, _189@Entry
bb48:
  (*_189) = move (_190.0: i32)
  using: _189@Mir(bb47[0]), _190@Mir(bb47[1])
  _195 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _194 = &raw const (*_195)
  using: _195@Mir(bb48[1])
  _193 = move _194 as *const u8 (Pointer(ArrayToPointer))
  using: _194@Mir(bb48[2])
  _192 = move _193 as *const i8 (PtrToPtr)
  using: _193@Mir(bb48[3])
  _199 = const b"test.c\x00"
  using: 
  _198 = &raw const (*_199)
  using: _199@Mir(bb48[5])
  _197 = move _198 as *const u8 (Pointer(ArrayToPointer))
  using: _198@Mir(bb48[6])
  _196 = move _197 as *const i8 (PtrToPtr)
  using: _197@Mir(bb48[7])
  _200 = const 163_i32
  using: 
  _202 = const 3_usize
  using: 
  _201 = _14[_202]
  using: _14@Phi(bb42), _202@Mir(bb48[10])
  _206 = _19
  using: _19@Phi(bb42)
  _205 = move _206 as *const example1::genann (Pointer(MutToConstPointer))
  using: _206@Mir(bb48[12])
  _211 = const 3_usize
  using: 
  _210 = &mut _1[_211]
  using: _1@Phi(bb42), _211@Mir(bb48[14])
  _209 = move _210 as &mut [f64] (Pointer(Unsize))
  using: _210@Mir(bb48[15])
  _208 = core::slice::<impl [f64]>::as_mut_ptr(move _209) -> bb49
  using: _209@Mir(bb48[16])
bb49:
  _207 = move _208 as *const f64 (Pointer(MutToConstPointer))
  using: _208@Mir(bb48[17])
  _204 = genann::genann_run(move _205, move _207) -> bb50
  using: _205@Mir(bb48[13]), _207@Mir(bb49[0])
bb50:
  _203 = (*_204)
  using: _204@Mir(bb49[1])
  _191 = test::printf(move _192, move _196, move _200, move _201, move _203) -> bb51
  using: _192@Mir(bb48[4]), _196@Mir(bb48[8]), _200@Mir(bb48[9]), _201@Mir(bb48[11]), _203@Mir(bb50[0])
bb51:
  _213 = _19
  using: _19@Phi(bb51)
  _212 = genann::genann_free(move _213) -> bb52
  using: _213@Mir(bb51[0])
bb52:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _2, move _5, move _8, move _11] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _15, move _16, move _17, move _18] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:391:46: 391:64 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_54) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_54) = 1 is ignored
rewrite call test::fabs @ workspace/genann/test.rs:400:8: 402:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:412:8: 414:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:424:8: 426:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:436:8: 438:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:132 ~ c2rust_lib[1043]::test::train_xor)
bb0:
  _3 = const 0f64
  using: 
  _4 = const 0f64
  using: 
  _2 = [move _3, move _4]
  using: _3@Mir(bb0[0]), _4@Mir(bb0[1])
  _6 = const 0f64
  using: 
  _7 = const 1f64
  using: 
  _5 = [move _6, move _7]
  using: _6@Mir(bb0[3]), _7@Mir(bb0[4])
  _9 = const 1f64
  using: 
  _10 = const 0f64
  using: 
  _8 = [move _9, move _10]
  using: _9@Mir(bb0[6]), _10@Mir(bb0[7])
  _12 = const 1f64
  using: 
  _13 = const 1f64
  using: 
  _11 = [move _12, move _13]
  using: _12@Mir(bb0[9]), _13@Mir(bb0[10])
  _1 = [move _2, move _5, move _8, move _11]
  using: _2@Mir(bb0[2]), _5@Mir(bb0[5]), _8@Mir(bb0[8]), _11@Mir(bb0[11])
  _15 = const 0f64
  using: 
  _16 = const 1f64
  using: 
  _17 = const 1f64
  using: 
  _18 = const 0f64
  using: 
  _14 = [move _15, move _16, move _17, move _18]
  using: _15@Mir(bb0[13]), _16@Mir(bb0[14]), _17@Mir(bb0[15]), _18@Mir(bb0[16])
  _20 = const 2_i32
  using: 
  _21 = const 1_i32
  using: 
  _22 = const 2_i32
  using: 
  _23 = const 1_i32
  using: 
  _19 = genann::genann_init(move _20, move _21, move _22, move _23) -> bb1
  using: _20@Mir(bb0[18]), _21@Mir(bb0[19]), _22@Mir(bb0[20]), _23@Mir(bb0[21])
bb1:
  _24 = const 0_i32
  using: 
  _25 = const 0_i32
  using: 
  _24 = const 0_i32
  using: 
  goto -> bb2
  using: 
bb2:
  _27 = _24
  using: _24@Phi(bb2)
  _28 = const 500_i32
  using: 
  _26 = Lt(move _27, move _28)
  using: _27@Mir(bb2[0]), _28@Mir(bb2[1])
  switchInt(move _26) -> [0: bb14, otherwise: bb3]
  using: _26@Mir(bb2[2])
bb3:
  _25 = const 0_i32
  using: 
  goto -> bb4
  using: 
bb4:
  _30 = _25
  using: _25@Phi(bb4)
  _31 = const 4_i32
  using: 
  _29 = Lt(move _30, move _31)
  using: _30@Mir(bb4[0]), _31@Mir(bb4[1])
  switchInt(move _29) -> [0: bb12, otherwise: bb5]
  using: _29@Mir(bb4[2])
bb5:
  _34 = _19
  using: _19@Phi(bb4)
  _33 = move _34 as *const example1::genann (Pointer(MutToConstPointer))
  using: _34@Mir(bb5[0])
  _40 = _25
  using: _25@Phi(bb4)
  _39 = move _40 as usize (IntToInt)
  using: _40@Mir(bb5[2])
  _41 = const 4_usize
  using: 
  _42 = Lt(_39, _41)
  using: _39@Mir(bb5[3]), _41@Mir(bb5[4])
  assert(move _42, "index out of bounds: the length is {} but the index is {}", move _41, _39) -> bb6
  using: _42@Entry, _41@Entry, _39@Entry
bb6:
  _38 = &mut _1[_39]
  using: _1@Phi(bb4), _39@Mir(bb5[3])
  _37 = move _38 as &mut [f64] (Pointer(Unsize))
  using: _38@Mir(bb6[0])
  _36 = core::slice::<impl [f64]>::as_mut_ptr(move _37) -> bb7
  using: _37@Mir(bb6[1])
bb7:
  _35 = move _36 as *const f64 (Pointer(MutToConstPointer))
  using: _36@Mir(bb6[2])
  _47 = &mut _14
  using: _14@Phi(bb4)
  _46 = move _47 as &mut [f64] (Pointer(Unsize))
  using: _47@Mir(bb7[1])
  _45 = core::slice::<impl [f64]>::as_mut_ptr(move _46) -> bb8
  using: _46@Mir(bb7[2])
bb8:
  _49 = _25
  using: _25@Phi(bb4)
  _48 = move _49 as isize (IntToInt)
  using: _49@Mir(bb8[0])
  _44 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _45, move _48) -> bb9
  using: _45@Mir(bb7[3]), _48@Mir(bb8[1])
bb9:
  _43 = move _44 as *const f64 (Pointer(MutToConstPointer))
  using: _44@Mir(bb8[2])
  _50 = const 3f64
  using: 
  _32 = genann::genann_train(move _33, move _35, move _43, move _50) -> bb10
  using: _33@Mir(bb5[1]), _35@Mir(bb7[0]), _43@Mir(bb9[0]), _50@Mir(bb9[1])
bb10:
  _51 = CheckedAdd(_25, const 1_i32)
  using: _25@Phi(bb4)
  assert(!move (_51.1: bool), "attempt to compute `{} + {}`, which would overflow", _25, const 1_i32) -> bb11
  using: _51@Entry, _25@Entry
bb11:
  _25 = move (_51.0: i32)
  using: _51@Mir(bb10[0])
  goto -> bb4
  using: 
bb12:
  _52 = CheckedAdd(_24, const 1_i32)
  using: _24@Phi(bb2)
  assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", _24, const 1_i32) -> bb13
  using: _52@Entry, _24@Entry
bb13:
  _24 = move (_52.0: i32)
  using: _52@Mir(bb12[0])
  goto -> bb2
  using: 
bb14:
  _54 = genann::genann_act_threshold as unsafe extern "C" fn(f64) -> f64 (Pointer(ReifyFnPointer))
  using: 
  Deinit(_53)
  using: 
  ((_53 as Some).0: unsafe extern "C" fn(f64) -> f64) = move _54
  using: _54@Mir(bb14[0])
  discriminant(_53) = 1
  using: 
  ((*_19).5: std::option::Option<unsafe extern "C" fn(f64) -> f64>) = move _53
  using: _19@Phi(bb4), _53@Mir(bb14[1])
  _55 = const {alloc184: *mut i32}
  using: 
  _56 = CheckedAdd((*_55), const 1_i32)
  using: _55@Mir(bb14[5])
  assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_55), const 1_i32) -> bb15
  using: _56@Entry, _55@Entry
bb15:
  (*_55) = move (_56.0: i32)
  using: _55@Mir(bb14[5]), _56@Mir(bb14[6])
  _61 = const 0_usize
  using: 
  _60 = _14[_61]
  using: _14@Phi(bb4), _61@Mir(bb15[1])
  _65 = _19
  using: _19@Phi(bb4)
  _64 = move _65 as *const example1::genann (Pointer(MutToConstPointer))
  using: _65@Mir(bb15[3])
  _70 = const 0_usize
  using: 
  _69 = &mut _1[_70]
  using: _1@Phi(bb4), _70@Mir(bb15[5])
  _68 = move _69 as &mut [f64] (Pointer(Unsize))
  using: _69@Mir(bb15[6])
  _67 = core::slice::<impl [f64]>::as_mut_ptr(move _68) -> bb16
  using: _68@Mir(bb15[7])
bb16:
  _66 = move _67 as *const f64 (Pointer(MutToConstPointer))
  using: _67@Mir(bb15[8])
  _63 = genann::genann_run(move _64, move _66) -> bb17
  using: _64@Mir(bb15[4]), _66@Mir(bb16[0])
bb17:
  _62 = (*_63)
  using: _63@Mir(bb16[1])
  _59 = Sub(move _60, move _62)
  using: _60@Mir(bb15[2]), _62@Mir(bb17[0])
  _58 = test::fabs(move _59) -> bb18
  using: _59@Mir(bb17[1])
bb18:
  _57 = Gt(move _58, const 0.001f64)
  using: _58@Mir(bb17[2])
  switchInt(move _57) -> [0: bb23, otherwise: bb19]
  using: _57@Mir(bb18[0])
bb19:
  _71 = const {alloc185: *mut i32}
  using: 
  _72 = CheckedAdd((*_71), const 1_i32)
  using: _71@Mir(bb19[0])
  assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_71), const 1_i32) -> bb20
  using: _72@Entry, _71@Entry
bb20:
  (*_71) = move (_72.0: i32)
  using: _71@Mir(bb19[0]), _72@Mir(bb19[1])
  _77 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _76 = &raw const (*_77)
  using: _77@Mir(bb20[1])
  _75 = move _76 as *const u8 (Pointer(ArrayToPointer))
  using: _76@Mir(bb20[2])
  _74 = move _75 as *const i8 (PtrToPtr)
  using: _75@Mir(bb20[3])
  _81 = const b"test.c\x00"
  using: 
  _80 = &raw const (*_81)
  using: _81@Mir(bb20[5])
  _79 = move _80 as *const u8 (Pointer(ArrayToPointer))
  using: _80@Mir(bb20[6])
  _78 = move _79 as *const i8 (PtrToPtr)
  using: _79@Mir(bb20[7])
  _82 = const 186_i32
  using: 
  _84 = const 0_usize
  using: 
  _83 = _14[_84]
  using: _14@Phi(bb4), _84@Mir(bb20[10])
  _88 = _19
  using: _19@Phi(bb4)
  _87 = move _88 as *const example1::genann (Pointer(MutToConstPointer))
  using: _88@Mir(bb20[12])
  _93 = const 0_usize
  using: 
  _92 = &mut _1[_93]
  using: _1@Phi(bb4), _93@Mir(bb20[14])
  _91 = move _92 as &mut [f64] (Pointer(Unsize))
  using: _92@Mir(bb20[15])
  _90 = core::slice::<impl [f64]>::as_mut_ptr(move _91) -> bb21
  using: _91@Mir(bb20[16])
bb21:
  _89 = move _90 as *const f64 (Pointer(MutToConstPointer))
  using: _90@Mir(bb20[17])
  _86 = genann::genann_run(move _87, move _89) -> bb22
  using: _87@Mir(bb20[13]), _89@Mir(bb21[0])
bb22:
  _85 = (*_86)
  using: _86@Mir(bb21[1])
  _73 = test::printf(move _74, move _78, move _82, move _83, move _85) -> bb23
  using: _74@Mir(bb20[4]), _78@Mir(bb20[8]), _82@Mir(bb20[9]), _83@Mir(bb20[11]), _85@Mir(bb22[0])
bb23:
  _94 = const {alloc184: *mut i32}
  using: 
  _95 = CheckedAdd((*_94), const 1_i32)
  using: _94@Mir(bb23[0])
  assert(!move (_95.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_94), const 1_i32) -> bb24
  using: _95@Entry, _94@Entry
bb24:
  (*_94) = move (_95.0: i32)
  using: _94@Mir(bb23[0]), _95@Mir(bb23[1])
  _100 = const 1_usize
  using: 
  _99 = _14[_100]
  using: _14@Phi(bb23), _100@Mir(bb24[1])
  _104 = _19
  using: _19@Phi(bb23)
  _103 = move _104 as *const example1::genann (Pointer(MutToConstPointer))
  using: _104@Mir(bb24[3])
  _109 = const 1_usize
  using: 
  _108 = &mut _1[_109]
  using: _1@Phi(bb23), _109@Mir(bb24[5])
  _107 = move _108 as &mut [f64] (Pointer(Unsize))
  using: _108@Mir(bb24[6])
  _106 = core::slice::<impl [f64]>::as_mut_ptr(move _107) -> bb25
  using: _107@Mir(bb24[7])
bb25:
  _105 = move _106 as *const f64 (Pointer(MutToConstPointer))
  using: _106@Mir(bb24[8])
  _102 = genann::genann_run(move _103, move _105) -> bb26
  using: _103@Mir(bb24[4]), _105@Mir(bb25[0])
bb26:
  _101 = (*_102)
  using: _102@Mir(bb25[1])
  _98 = Sub(move _99, move _101)
  using: _99@Mir(bb24[2]), _101@Mir(bb26[0])
  _97 = test::fabs(move _98) -> bb27
  using: _98@Mir(bb26[1])
bb27:
  _96 = Gt(move _97, const 0.001f64)
  using: _97@Mir(bb26[2])
  switchInt(move _96) -> [0: bb32, otherwise: bb28]
  using: _96@Mir(bb27[0])
bb28:
  _110 = const {alloc185: *mut i32}
  using: 
  _111 = CheckedAdd((*_110), const 1_i32)
  using: _110@Mir(bb28[0])
  assert(!move (_111.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_110), const 1_i32) -> bb29
  using: _111@Entry, _110@Entry
bb29:
  (*_110) = move (_111.0: i32)
  using: _110@Mir(bb28[0]), _111@Mir(bb28[1])
  _116 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _115 = &raw const (*_116)
  using: _116@Mir(bb29[1])
  _114 = move _115 as *const u8 (Pointer(ArrayToPointer))
  using: _115@Mir(bb29[2])
  _113 = move _114 as *const i8 (PtrToPtr)
  using: _114@Mir(bb29[3])
  _120 = const b"test.c\x00"
  using: 
  _119 = &raw const (*_120)
  using: _120@Mir(bb29[5])
  _118 = move _119 as *const u8 (Pointer(ArrayToPointer))
  using: _119@Mir(bb29[6])
  _117 = move _118 as *const i8 (PtrToPtr)
  using: _118@Mir(bb29[7])
  _121 = const 187_i32
  using: 
  _123 = const 1_usize
  using: 
  _122 = _14[_123]
  using: _14@Phi(bb23), _123@Mir(bb29[10])
  _127 = _19
  using: _19@Phi(bb23)
  _126 = move _127 as *const example1::genann (Pointer(MutToConstPointer))
  using: _127@Mir(bb29[12])
  _132 = const 1_usize
  using: 
  _131 = &mut _1[_132]
  using: _1@Phi(bb23), _132@Mir(bb29[14])
  _130 = move _131 as &mut [f64] (Pointer(Unsize))
  using: _131@Mir(bb29[15])
  _129 = core::slice::<impl [f64]>::as_mut_ptr(move _130) -> bb30
  using: _130@Mir(bb29[16])
bb30:
  _128 = move _129 as *const f64 (Pointer(MutToConstPointer))
  using: _129@Mir(bb29[17])
  _125 = genann::genann_run(move _126, move _128) -> bb31
  using: _126@Mir(bb29[13]), _128@Mir(bb30[0])
bb31:
  _124 = (*_125)
  using: _125@Mir(bb30[1])
  _112 = test::printf(move _113, move _117, move _121, move _122, move _124) -> bb32
  using: _113@Mir(bb29[4]), _117@Mir(bb29[8]), _121@Mir(bb29[9]), _122@Mir(bb29[11]), _124@Mir(bb31[0])
bb32:
  _133 = const {alloc184: *mut i32}
  using: 
  _134 = CheckedAdd((*_133), const 1_i32)
  using: _133@Mir(bb32[0])
  assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_133), const 1_i32) -> bb33
  using: _134@Entry, _133@Entry
bb33:
  (*_133) = move (_134.0: i32)
  using: _133@Mir(bb32[0]), _134@Mir(bb32[1])
  _139 = const 2_usize
  using: 
  _138 = _14[_139]
  using: _14@Phi(bb32), _139@Mir(bb33[1])
  _143 = _19
  using: _19@Phi(bb32)
  _142 = move _143 as *const example1::genann (Pointer(MutToConstPointer))
  using: _143@Mir(bb33[3])
  _148 = const 2_usize
  using: 
  _147 = &mut _1[_148]
  using: _1@Phi(bb32), _148@Mir(bb33[5])
  _146 = move _147 as &mut [f64] (Pointer(Unsize))
  using: _147@Mir(bb33[6])
  _145 = core::slice::<impl [f64]>::as_mut_ptr(move _146) -> bb34
  using: _146@Mir(bb33[7])
bb34:
  _144 = move _145 as *const f64 (Pointer(MutToConstPointer))
  using: _145@Mir(bb33[8])
  _141 = genann::genann_run(move _142, move _144) -> bb35
  using: _142@Mir(bb33[4]), _144@Mir(bb34[0])
bb35:
  _140 = (*_141)
  using: _141@Mir(bb34[1])
  _137 = Sub(move _138, move _140)
  using: _138@Mir(bb33[2]), _140@Mir(bb35[0])
  _136 = test::fabs(move _137) -> bb36
  using: _137@Mir(bb35[1])
bb36:
  _135 = Gt(move _136, const 0.001f64)
  using: _136@Mir(bb35[2])
  switchInt(move _135) -> [0: bb41, otherwise: bb37]
  using: _135@Mir(bb36[0])
bb37:
  _149 = const {alloc185: *mut i32}
  using: 
  _150 = CheckedAdd((*_149), const 1_i32)
  using: _149@Mir(bb37[0])
  assert(!move (_150.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_149), const 1_i32) -> bb38
  using: _150@Entry, _149@Entry
bb38:
  (*_149) = move (_150.0: i32)
  using: _149@Mir(bb37[0]), _150@Mir(bb37[1])
  _155 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _154 = &raw const (*_155)
  using: _155@Mir(bb38[1])
  _153 = move _154 as *const u8 (Pointer(ArrayToPointer))
  using: _154@Mir(bb38[2])
  _152 = move _153 as *const i8 (PtrToPtr)
  using: _153@Mir(bb38[3])
  _159 = const b"test.c\x00"
  using: 
  _158 = &raw const (*_159)
  using: _159@Mir(bb38[5])
  _157 = move _158 as *const u8 (Pointer(ArrayToPointer))
  using: _158@Mir(bb38[6])
  _156 = move _157 as *const i8 (PtrToPtr)
  using: _157@Mir(bb38[7])
  _160 = const 188_i32
  using: 
  _162 = const 2_usize
  using: 
  _161 = _14[_162]
  using: _14@Phi(bb32), _162@Mir(bb38[10])
  _166 = _19
  using: _19@Phi(bb32)
  _165 = move _166 as *const example1::genann (Pointer(MutToConstPointer))
  using: _166@Mir(bb38[12])
  _171 = const 2_usize
  using: 
  _170 = &mut _1[_171]
  using: _1@Phi(bb32), _171@Mir(bb38[14])
  _169 = move _170 as &mut [f64] (Pointer(Unsize))
  using: _170@Mir(bb38[15])
  _168 = core::slice::<impl [f64]>::as_mut_ptr(move _169) -> bb39
  using: _169@Mir(bb38[16])
bb39:
  _167 = move _168 as *const f64 (Pointer(MutToConstPointer))
  using: _168@Mir(bb38[17])
  _164 = genann::genann_run(move _165, move _167) -> bb40
  using: _165@Mir(bb38[13]), _167@Mir(bb39[0])
bb40:
  _163 = (*_164)
  using: _164@Mir(bb39[1])
  _151 = test::printf(move _152, move _156, move _160, move _161, move _163) -> bb41
  using: _152@Mir(bb38[4]), _156@Mir(bb38[8]), _160@Mir(bb38[9]), _161@Mir(bb38[11]), _163@Mir(bb40[0])
bb41:
  _172 = const {alloc184: *mut i32}
  using: 
  _173 = CheckedAdd((*_172), const 1_i32)
  using: _172@Mir(bb41[0])
  assert(!move (_173.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_172), const 1_i32) -> bb42
  using: _173@Entry, _172@Entry
bb42:
  (*_172) = move (_173.0: i32)
  using: _172@Mir(bb41[0]), _173@Mir(bb41[1])
  _178 = const 3_usize
  using: 
  _177 = _14[_178]
  using: _14@Phi(bb41), _178@Mir(bb42[1])
  _182 = _19
  using: _19@Phi(bb41)
  _181 = move _182 as *const example1::genann (Pointer(MutToConstPointer))
  using: _182@Mir(bb42[3])
  _187 = const 3_usize
  using: 
  _186 = &mut _1[_187]
  using: _1@Phi(bb41), _187@Mir(bb42[5])
  _185 = move _186 as &mut [f64] (Pointer(Unsize))
  using: _186@Mir(bb42[6])
  _184 = core::slice::<impl [f64]>::as_mut_ptr(move _185) -> bb43
  using: _185@Mir(bb42[7])
bb43:
  _183 = move _184 as *const f64 (Pointer(MutToConstPointer))
  using: _184@Mir(bb42[8])
  _180 = genann::genann_run(move _181, move _183) -> bb44
  using: _181@Mir(bb42[4]), _183@Mir(bb43[0])
bb44:
  _179 = (*_180)
  using: _180@Mir(bb43[1])
  _176 = Sub(move _177, move _179)
  using: _177@Mir(bb42[2]), _179@Mir(bb44[0])
  _175 = test::fabs(move _176) -> bb45
  using: _176@Mir(bb44[1])
bb45:
  _174 = Gt(move _175, const 0.001f64)
  using: _175@Mir(bb44[2])
  switchInt(move _174) -> [0: bb50, otherwise: bb46]
  using: _174@Mir(bb45[0])
bb46:
  _188 = const {alloc185: *mut i32}
  using: 
  _189 = CheckedAdd((*_188), const 1_i32)
  using: _188@Mir(bb46[0])
  assert(!move (_189.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_188), const 1_i32) -> bb47
  using: _189@Entry, _188@Entry
bb47:
  (*_188) = move (_189.0: i32)
  using: _188@Mir(bb46[0]), _189@Mir(bb46[1])
  _194 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _193 = &raw const (*_194)
  using: _194@Mir(bb47[1])
  _192 = move _193 as *const u8 (Pointer(ArrayToPointer))
  using: _193@Mir(bb47[2])
  _191 = move _192 as *const i8 (PtrToPtr)
  using: _192@Mir(bb47[3])
  _198 = const b"test.c\x00"
  using: 
  _197 = &raw const (*_198)
  using: _198@Mir(bb47[5])
  _196 = move _197 as *const u8 (Pointer(ArrayToPointer))
  using: _197@Mir(bb47[6])
  _195 = move _196 as *const i8 (PtrToPtr)
  using: _196@Mir(bb47[7])
  _199 = const 189_i32
  using: 
  _201 = const 3_usize
  using: 
  _200 = _14[_201]
  using: _14@Phi(bb41), _201@Mir(bb47[10])
  _205 = _19
  using: _19@Phi(bb41)
  _204 = move _205 as *const example1::genann (Pointer(MutToConstPointer))
  using: _205@Mir(bb47[12])
  _210 = const 3_usize
  using: 
  _209 = &mut _1[_210]
  using: _1@Phi(bb41), _210@Mir(bb47[14])
  _208 = move _209 as &mut [f64] (Pointer(Unsize))
  using: _209@Mir(bb47[15])
  _207 = core::slice::<impl [f64]>::as_mut_ptr(move _208) -> bb48
  using: _208@Mir(bb47[16])
bb48:
  _206 = move _207 as *const f64 (Pointer(MutToConstPointer))
  using: _207@Mir(bb47[17])
  _203 = genann::genann_run(move _204, move _206) -> bb49
  using: _204@Mir(bb47[13]), _206@Mir(bb48[0])
bb49:
  _202 = (*_203)
  using: _203@Mir(bb48[1])
  _190 = test::printf(move _191, move _195, move _199, move _200, move _202) -> bb50
  using: _191@Mir(bb47[4]), _195@Mir(bb47[8]), _199@Mir(bb47[9]), _200@Mir(bb47[11]), _202@Mir(bb49[0])
bb50:
  _212 = _19
  using: _19@Phi(bb50)
  _211 = genann::genann_free(move _212) -> bb51
  using: _212@Mir(bb50[0])
bb51:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _2, move _5, move _8, move _11] is not supported
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m [move _15, move _16, move _17, move _18] is not supported
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:475:46: 475:64 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m Deinit(_53) is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m discriminant(_53) = 1 is ignored
rewrite call test::fabs @ workspace/genann/test.rs:486:8: 488:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:498:8: 500:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:510:8: 512:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fabs @ workspace/genann/test.rs:522:8: 524:84 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:136 ~ c2rust_lib[1043]::test::persist)
bb0:
  _2 = const 1000_i32
  using: 
  _3 = const 5_i32
  using: 
  _4 = const 50_i32
  using: 
  _5 = const 10_i32
  using: 
  _1 = genann::genann_init(move _2, move _3, move _4, move _5) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1]), _4@Mir(bb0[2]), _5@Mir(bb0[3])
bb1:
  _10 = const b"persist.txt\x00"
  using: 
  _9 = &raw const (*_10)
  using: _10@Mir(bb1[0])
  _8 = move _9 as *const u8 (Pointer(ArrayToPointer))
  using: _9@Mir(bb1[1])
  _7 = move _8 as *const i8 (PtrToPtr)
  using: _8@Mir(bb1[2])
  _14 = const b"w\x00"
  using: 
  _13 = &raw const (*_14)
  using: _14@Mir(bb1[4])
  _12 = move _13 as *const u8 (Pointer(ArrayToPointer))
  using: _13@Mir(bb1[5])
  _11 = move _12 as *const i8 (PtrToPtr)
  using: _12@Mir(bb1[6])
  _6 = test::fopen(move _7, move _11) -> bb2
  using: _7@Mir(bb1[3]), _11@Mir(bb1[7])
bb2:
  _17 = _1
  using: _1@Mir(bb0[4])
  _16 = move _17 as *const example1::genann (Pointer(MutToConstPointer))
  using: _17@Mir(bb2[0])
  _18 = _6
  using: _6@Mir(bb1[8])
  _15 = genann::genann_write(move _16, move _18) -> bb3
  using: _16@Mir(bb2[1]), _18@Mir(bb2[2])
bb3:
  _20 = _6
  using: _6@Mir(bb1[8])
  _19 = test::fclose(move _20) -> bb4
  using: _20@Mir(bb3[0])
bb4:
  _25 = const b"persist.txt\x00"
  using: 
  _24 = &raw const (*_25)
  using: _25@Mir(bb4[0])
  _23 = move _24 as *const u8 (Pointer(ArrayToPointer))
  using: _24@Mir(bb4[1])
  _22 = move _23 as *const i8 (PtrToPtr)
  using: _23@Mir(bb4[2])
  _29 = const b"r\x00"
  using: 
  _28 = &raw const (*_29)
  using: _29@Mir(bb4[4])
  _27 = move _28 as *const u8 (Pointer(ArrayToPointer))
  using: _28@Mir(bb4[5])
  _26 = move _27 as *const i8 (PtrToPtr)
  using: _27@Mir(bb4[6])
  _21 = test::fopen(move _22, move _26) -> bb5
  using: _22@Mir(bb4[3]), _26@Mir(bb4[7])
bb5:
  _31 = _21
  using: _21@Mir(bb4[8])
  _30 = genann::genann_read(move _31) -> bb6
  using: _31@Mir(bb5[0])
bb6:
  _33 = _6
  using: _6@Mir(bb1[8])
  _32 = test::fclose(move _33) -> bb7
  using: _33@Mir(bb6[0])
bb7:
  _34 = const {alloc184: *mut i32}
  using: 
  _35 = CheckedAdd((*_34), const 1_i32)
  using: _34@Mir(bb7[0])
  assert(!move (_35.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_34), const 1_i32) -> bb8
  using: _35@Entry, _34@Entry
bb8:
  (*_34) = move (_35.0: i32)
  using: _34@Mir(bb7[0]), _35@Mir(bb7[1])
  _37 = ((*_1).0: i32)
  using: _1@Mir(bb0[4])
  _38 = ((*_30).0: i32)
  using: _30@Mir(bb5[1])
  _36 = Ne(move _37, move _38)
  using: _37@Mir(bb8[1]), _38@Mir(bb8[2])
  switchInt(move _36) -> [0: bb11, otherwise: bb9]
  using: _36@Mir(bb8[3])
bb9:
  _39 = const {alloc185: *mut i32}
  using: 
  _40 = CheckedAdd((*_39), const 1_i32)
  using: _39@Mir(bb9[0])
  assert(!move (_40.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_39), const 1_i32) -> bb10
  using: _40@Entry, _39@Entry
bb10:
  (*_39) = move (_40.0: i32)
  using: _39@Mir(bb9[0]), _40@Mir(bb9[1])
  _45 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _44 = &raw const (*_45)
  using: _45@Mir(bb10[1])
  _43 = move _44 as *const u8 (Pointer(ArrayToPointer))
  using: _44@Mir(bb10[2])
  _42 = move _43 as *const i8 (PtrToPtr)
  using: _43@Mir(bb10[3])
  _49 = const b"test.c\x00"
  using: 
  _48 = &raw const (*_49)
  using: _49@Mir(bb10[5])
  _47 = move _48 as *const u8 (Pointer(ArrayToPointer))
  using: _48@Mir(bb10[6])
  _46 = move _47 as *const i8 (PtrToPtr)
  using: _47@Mir(bb10[7])
  _50 = const 208_i32
  using: 
  _51 = ((*_1).0: i32)
  using: _1@Mir(bb0[4])
  _52 = ((*_30).0: i32)
  using: _30@Mir(bb5[1])
  _41 = test::printf(move _42, move _46, move _50, move _51, move _52) -> bb11
  using: _42@Mir(bb10[4]), _46@Mir(bb10[8]), _50@Mir(bb10[9]), _51@Mir(bb10[10]), _52@Mir(bb10[11])
bb11:
  _53 = const {alloc184: *mut i32}
  using: 
  _54 = CheckedAdd((*_53), const 1_i32)
  using: _53@Mir(bb11[0])
  assert(!move (_54.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_53), const 1_i32) -> bb12
  using: _54@Entry, _53@Entry
bb12:
  (*_53) = move (_54.0: i32)
  using: _53@Mir(bb11[0]), _54@Mir(bb11[1])
  _56 = ((*_1).1: i32)
  using: _1@Phi(bb11)
  _57 = ((*_30).1: i32)
  using: _30@Phi(bb11)
  _55 = Ne(move _56, move _57)
  using: _56@Mir(bb12[1]), _57@Mir(bb12[2])
  switchInt(move _55) -> [0: bb15, otherwise: bb13]
  using: _55@Mir(bb12[3])
bb13:
  _58 = const {alloc185: *mut i32}
  using: 
  _59 = CheckedAdd((*_58), const 1_i32)
  using: _58@Mir(bb13[0])
  assert(!move (_59.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_58), const 1_i32) -> bb14
  using: _59@Entry, _58@Entry
bb14:
  (*_58) = move (_59.0: i32)
  using: _58@Mir(bb13[0]), _59@Mir(bb13[1])
  _64 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _63 = &raw const (*_64)
  using: _64@Mir(bb14[1])
  _62 = move _63 as *const u8 (Pointer(ArrayToPointer))
  using: _63@Mir(bb14[2])
  _61 = move _62 as *const i8 (PtrToPtr)
  using: _62@Mir(bb14[3])
  _68 = const b"test.c\x00"
  using: 
  _67 = &raw const (*_68)
  using: _68@Mir(bb14[5])
  _66 = move _67 as *const u8 (Pointer(ArrayToPointer))
  using: _67@Mir(bb14[6])
  _65 = move _66 as *const i8 (PtrToPtr)
  using: _66@Mir(bb14[7])
  _69 = const 209_i32
  using: 
  _70 = ((*_1).1: i32)
  using: _1@Phi(bb11)
  _71 = ((*_30).1: i32)
  using: _30@Phi(bb11)
  _60 = test::printf(move _61, move _65, move _69, move _70, move _71) -> bb15
  using: _61@Mir(bb14[4]), _65@Mir(bb14[8]), _69@Mir(bb14[9]), _70@Mir(bb14[10]), _71@Mir(bb14[11])
bb15:
  _72 = const {alloc184: *mut i32}
  using: 
  _73 = CheckedAdd((*_72), const 1_i32)
  using: _72@Mir(bb15[0])
  assert(!move (_73.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_72), const 1_i32) -> bb16
  using: _73@Entry, _72@Entry
bb16:
  (*_72) = move (_73.0: i32)
  using: _72@Mir(bb15[0]), _73@Mir(bb15[1])
  _75 = ((*_1).2: i32)
  using: _1@Phi(bb15)
  _76 = ((*_30).2: i32)
  using: _30@Phi(bb15)
  _74 = Ne(move _75, move _76)
  using: _75@Mir(bb16[1]), _76@Mir(bb16[2])
  switchInt(move _74) -> [0: bb19, otherwise: bb17]
  using: _74@Mir(bb16[3])
bb17:
  _77 = const {alloc185: *mut i32}
  using: 
  _78 = CheckedAdd((*_77), const 1_i32)
  using: _77@Mir(bb17[0])
  assert(!move (_78.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_77), const 1_i32) -> bb18
  using: _78@Entry, _77@Entry
bb18:
  (*_77) = move (_78.0: i32)
  using: _77@Mir(bb17[0]), _78@Mir(bb17[1])
  _83 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _82 = &raw const (*_83)
  using: _83@Mir(bb18[1])
  _81 = move _82 as *const u8 (Pointer(ArrayToPointer))
  using: _82@Mir(bb18[2])
  _80 = move _81 as *const i8 (PtrToPtr)
  using: _81@Mir(bb18[3])
  _87 = const b"test.c\x00"
  using: 
  _86 = &raw const (*_87)
  using: _87@Mir(bb18[5])
  _85 = move _86 as *const u8 (Pointer(ArrayToPointer))
  using: _86@Mir(bb18[6])
  _84 = move _85 as *const i8 (PtrToPtr)
  using: _85@Mir(bb18[7])
  _88 = const 210_i32
  using: 
  _89 = ((*_1).2: i32)
  using: _1@Phi(bb15)
  _90 = ((*_30).2: i32)
  using: _30@Phi(bb15)
  _79 = test::printf(move _80, move _84, move _88, move _89, move _90) -> bb19
  using: _80@Mir(bb18[4]), _84@Mir(bb18[8]), _88@Mir(bb18[9]), _89@Mir(bb18[10]), _90@Mir(bb18[11])
bb19:
  _91 = const {alloc184: *mut i32}
  using: 
  _92 = CheckedAdd((*_91), const 1_i32)
  using: _91@Mir(bb19[0])
  assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_91), const 1_i32) -> bb20
  using: _92@Entry, _91@Entry
bb20:
  (*_91) = move (_92.0: i32)
  using: _91@Mir(bb19[0]), _92@Mir(bb19[1])
  _94 = ((*_1).3: i32)
  using: _1@Phi(bb19)
  _95 = ((*_30).3: i32)
  using: _30@Phi(bb19)
  _93 = Ne(move _94, move _95)
  using: _94@Mir(bb20[1]), _95@Mir(bb20[2])
  switchInt(move _93) -> [0: bb23, otherwise: bb21]
  using: _93@Mir(bb20[3])
bb21:
  _96 = const {alloc185: *mut i32}
  using: 
  _97 = CheckedAdd((*_96), const 1_i32)
  using: _96@Mir(bb21[0])
  assert(!move (_97.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_96), const 1_i32) -> bb22
  using: _97@Entry, _96@Entry
bb22:
  (*_96) = move (_97.0: i32)
  using: _96@Mir(bb21[0]), _97@Mir(bb21[1])
  _102 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _101 = &raw const (*_102)
  using: _102@Mir(bb22[1])
  _100 = move _101 as *const u8 (Pointer(ArrayToPointer))
  using: _101@Mir(bb22[2])
  _99 = move _100 as *const i8 (PtrToPtr)
  using: _100@Mir(bb22[3])
  _106 = const b"test.c\x00"
  using: 
  _105 = &raw const (*_106)
  using: _106@Mir(bb22[5])
  _104 = move _105 as *const u8 (Pointer(ArrayToPointer))
  using: _105@Mir(bb22[6])
  _103 = move _104 as *const i8 (PtrToPtr)
  using: _104@Mir(bb22[7])
  _107 = const 211_i32
  using: 
  _108 = ((*_1).3: i32)
  using: _1@Phi(bb19)
  _109 = ((*_30).3: i32)
  using: _30@Phi(bb19)
  _98 = test::printf(move _99, move _103, move _107, move _108, move _109) -> bb23
  using: _99@Mir(bb22[4]), _103@Mir(bb22[8]), _107@Mir(bb22[9]), _108@Mir(bb22[10]), _109@Mir(bb22[11])
bb23:
  _110 = const {alloc184: *mut i32}
  using: 
  _111 = CheckedAdd((*_110), const 1_i32)
  using: _110@Mir(bb23[0])
  assert(!move (_111.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_110), const 1_i32) -> bb24
  using: _111@Entry, _110@Entry
bb24:
  (*_110) = move (_111.0: i32)
  using: _110@Mir(bb23[0]), _111@Mir(bb23[1])
  _113 = ((*_1).6: i32)
  using: _1@Phi(bb23)
  _114 = ((*_30).6: i32)
  using: _30@Phi(bb23)
  _112 = Ne(move _113, move _114)
  using: _113@Mir(bb24[1]), _114@Mir(bb24[2])
  switchInt(move _112) -> [0: bb27, otherwise: bb25]
  using: _112@Mir(bb24[3])
bb25:
  _115 = const {alloc185: *mut i32}
  using: 
  _116 = CheckedAdd((*_115), const 1_i32)
  using: _115@Mir(bb25[0])
  assert(!move (_116.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_115), const 1_i32) -> bb26
  using: _116@Entry, _115@Entry
bb26:
  (*_115) = move (_116.0: i32)
  using: _115@Mir(bb25[0]), _116@Mir(bb25[1])
  _121 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _120 = &raw const (*_121)
  using: _121@Mir(bb26[1])
  _119 = move _120 as *const u8 (Pointer(ArrayToPointer))
  using: _120@Mir(bb26[2])
  _118 = move _119 as *const i8 (PtrToPtr)
  using: _119@Mir(bb26[3])
  _125 = const b"test.c\x00"
  using: 
  _124 = &raw const (*_125)
  using: _125@Mir(bb26[5])
  _123 = move _124 as *const u8 (Pointer(ArrayToPointer))
  using: _124@Mir(bb26[6])
  _122 = move _123 as *const i8 (PtrToPtr)
  using: _123@Mir(bb26[7])
  _126 = const 212_i32
  using: 
  _127 = ((*_1).6: i32)
  using: _1@Phi(bb23)
  _128 = ((*_30).6: i32)
  using: _30@Phi(bb23)
  _117 = test::printf(move _118, move _122, move _126, move _127, move _128) -> bb27
  using: _118@Mir(bb26[4]), _122@Mir(bb26[8]), _126@Mir(bb26[9]), _127@Mir(bb26[10]), _128@Mir(bb26[11])
bb27:
  _129 = const 0_i32
  using: 
  _129 = const 0_i32
  using: 
  goto -> bb28
  using: 
bb28:
  _131 = _129
  using: _129@Phi(bb28)
  _132 = ((*_1).6: i32)
  using: _1@Phi(bb28)
  _130 = Lt(move _131, move _132)
  using: _131@Mir(bb28[0]), _132@Mir(bb28[1])
  switchInt(move _130) -> [0: bb37, otherwise: bb29]
  using: _130@Mir(bb28[2])
bb29:
  _133 = const {alloc184: *mut i32}
  using: 
  _134 = CheckedAdd((*_133), const 1_i32)
  using: _133@Mir(bb29[0])
  assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_133), const 1_i32) -> bb30
  using: _134@Entry, _133@Entry
bb30:
  (*_133) = move (_134.0: i32)
  using: _133@Mir(bb29[0]), _134@Mir(bb29[1])
  _139 = ((*_1).8: *mut f64)
  using: _1@Phi(bb28)
  _141 = _129
  using: _129@Phi(bb28)
  _140 = move _141 as isize (IntToInt)
  using: _141@Mir(bb30[2])
  _138 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _139, move _140) -> bb31
  using: _139@Mir(bb30[1]), _140@Mir(bb30[3])
bb31:
  _137 = (*_138)
  using: _138@Mir(bb30[4])
  _144 = ((*_30).8: *mut f64)
  using: _30@Phi(bb28)
  _146 = _129
  using: _129@Phi(bb28)
  _145 = move _146 as isize (IntToInt)
  using: _146@Mir(bb31[2])
  _143 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _144, move _145) -> bb32
  using: _144@Mir(bb31[1]), _145@Mir(bb31[3])
bb32:
  _142 = (*_143)
  using: _143@Mir(bb31[4])
  _136 = Eq(move _137, move _142)
  using: _137@Mir(bb31[0]), _142@Mir(bb32[0])
  _135 = Not(move _136)
  using: _136@Mir(bb32[1])
  switchInt(move _135) -> [0: bb35, otherwise: bb33]
  using: _135@Mir(bb32[2])
bb33:
  _147 = const {alloc185: *mut i32}
  using: 
  _148 = CheckedAdd((*_147), const 1_i32)
  using: _147@Mir(bb33[0])
  assert(!move (_148.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_147), const 1_i32) -> bb34
  using: _148@Entry, _147@Entry
bb34:
  (*_147) = move (_148.0: i32)
  using: _147@Mir(bb33[0]), _148@Mir(bb33[1])
  _153 = const b"%s:%d error \n\x00"
  using: 
  _152 = &raw const (*_153)
  using: _153@Mir(bb34[1])
  _151 = move _152 as *const u8 (Pointer(ArrayToPointer))
  using: _152@Mir(bb34[2])
  _150 = move _151 as *const i8 (PtrToPtr)
  using: _151@Mir(bb34[3])
  _157 = const b"test.c\x00"
  using: 
  _156 = &raw const (*_157)
  using: _157@Mir(bb34[5])
  _155 = move _156 as *const u8 (Pointer(ArrayToPointer))
  using: _156@Mir(bb34[6])
  _154 = move _155 as *const i8 (PtrToPtr)
  using: _155@Mir(bb34[7])
  _158 = const 216_i32
  using: 
  _149 = test::printf(move _150, move _154, move _158) -> bb35
  using: _150@Mir(bb34[4]), _154@Mir(bb34[8]), _158@Mir(bb34[9])
bb35:
  _159 = CheckedAdd(_129, const 1_i32)
  using: _129@Phi(bb28)
  assert(!move (_159.1: bool), "attempt to compute `{} + {}`, which would overflow", _129, const 1_i32) -> bb36
  using: _159@Entry, _129@Entry
bb36:
  _129 = move (_159.0: i32)
  using: _159@Mir(bb35[0])
  goto -> bb28
  using: 
bb37:
  _161 = _1
  using: _1@Phi(bb28)
  _160 = genann::genann_free(move _161) -> bb38
  using: _161@Mir(bb37[0])
bb38:
  _163 = _30
  using: _30@Phi(bb28)
  _162 = genann::genann_free(move _163) -> bb39
  using: _163@Mir(bb38[0])
bb39:
  return
  using: _0@Entry
rewrite call test::fopen @ workspace/genann/test.rs:541:9: 542:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fclose @ workspace/genann/test.rs:544:5: 544:16 (#0) by default
rewrite call test::fopen @ workspace/genann/test.rs:546:9: 547:68 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::fclose @ workspace/genann/test.rs:549:5: 549:16 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:591:31: 591:49 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:592:36: 592:54 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:137 ~ c2rust_lib[1043]::test::copy)
bb0:
  _2 = const 1000_i32
  using: 
  _3 = const 5_i32
  using: 
  _4 = const 50_i32
  using: 
  _5 = const 10_i32
  using: 
  _1 = genann::genann_init(move _2, move _3, move _4, move _5) -> bb1
  using: _2@Mir(bb0[0]), _3@Mir(bb0[1]), _4@Mir(bb0[2]), _5@Mir(bb0[3])
bb1:
  _8 = _1
  using: _1@Mir(bb0[4])
  _7 = move _8 as *const example1::genann (Pointer(MutToConstPointer))
  using: _8@Mir(bb1[0])
  _6 = genann::genann_copy(move _7) -> bb2
  using: _7@Mir(bb1[1])
bb2:
  _9 = const {alloc184: *mut i32}
  using: 
  _10 = CheckedAdd((*_9), const 1_i32)
  using: _9@Mir(bb2[0])
  assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_9), const 1_i32) -> bb3
  using: _10@Entry, _9@Entry
bb3:
  (*_9) = move (_10.0: i32)
  using: _9@Mir(bb2[0]), _10@Mir(bb2[1])
  _12 = ((*_1).0: i32)
  using: _1@Mir(bb0[4])
  _13 = ((*_6).0: i32)
  using: _6@Mir(bb1[2])
  _11 = Ne(move _12, move _13)
  using: _12@Mir(bb3[1]), _13@Mir(bb3[2])
  switchInt(move _11) -> [0: bb6, otherwise: bb4]
  using: _11@Mir(bb3[3])
bb4:
  _14 = const {alloc185: *mut i32}
  using: 
  _15 = CheckedAdd((*_14), const 1_i32)
  using: _14@Mir(bb4[0])
  assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_14), const 1_i32) -> bb5
  using: _15@Entry, _14@Entry
bb5:
  (*_14) = move (_15.0: i32)
  using: _14@Mir(bb4[0]), _15@Mir(bb4[1])
  _20 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _19 = &raw const (*_20)
  using: _20@Mir(bb5[1])
  _18 = move _19 as *const u8 (Pointer(ArrayToPointer))
  using: _19@Mir(bb5[2])
  _17 = move _18 as *const i8 (PtrToPtr)
  using: _18@Mir(bb5[3])
  _24 = const b"test.c\x00"
  using: 
  _23 = &raw const (*_24)
  using: _24@Mir(bb5[5])
  _22 = move _23 as *const u8 (Pointer(ArrayToPointer))
  using: _23@Mir(bb5[6])
  _21 = move _22 as *const i8 (PtrToPtr)
  using: _22@Mir(bb5[7])
  _25 = const 229_i32
  using: 
  _26 = ((*_1).0: i32)
  using: _1@Mir(bb0[4])
  _27 = ((*_6).0: i32)
  using: _6@Mir(bb1[2])
  _16 = test::printf(move _17, move _21, move _25, move _26, move _27) -> bb6
  using: _17@Mir(bb5[4]), _21@Mir(bb5[8]), _25@Mir(bb5[9]), _26@Mir(bb5[10]), _27@Mir(bb5[11])
bb6:
  _28 = const {alloc184: *mut i32}
  using: 
  _29 = CheckedAdd((*_28), const 1_i32)
  using: _28@Mir(bb6[0])
  assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_28), const 1_i32) -> bb7
  using: _29@Entry, _28@Entry
bb7:
  (*_28) = move (_29.0: i32)
  using: _28@Mir(bb6[0]), _29@Mir(bb6[1])
  _31 = ((*_1).1: i32)
  using: _1@Phi(bb6)
  _32 = ((*_6).1: i32)
  using: _6@Phi(bb6)
  _30 = Ne(move _31, move _32)
  using: _31@Mir(bb7[1]), _32@Mir(bb7[2])
  switchInt(move _30) -> [0: bb10, otherwise: bb8]
  using: _30@Mir(bb7[3])
bb8:
  _33 = const {alloc185: *mut i32}
  using: 
  _34 = CheckedAdd((*_33), const 1_i32)
  using: _33@Mir(bb8[0])
  assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_33), const 1_i32) -> bb9
  using: _34@Entry, _33@Entry
bb9:
  (*_33) = move (_34.0: i32)
  using: _33@Mir(bb8[0]), _34@Mir(bb8[1])
  _39 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _38 = &raw const (*_39)
  using: _39@Mir(bb9[1])
  _37 = move _38 as *const u8 (Pointer(ArrayToPointer))
  using: _38@Mir(bb9[2])
  _36 = move _37 as *const i8 (PtrToPtr)
  using: _37@Mir(bb9[3])
  _43 = const b"test.c\x00"
  using: 
  _42 = &raw const (*_43)
  using: _43@Mir(bb9[5])
  _41 = move _42 as *const u8 (Pointer(ArrayToPointer))
  using: _42@Mir(bb9[6])
  _40 = move _41 as *const i8 (PtrToPtr)
  using: _41@Mir(bb9[7])
  _44 = const 230_i32
  using: 
  _45 = ((*_1).1: i32)
  using: _1@Phi(bb6)
  _46 = ((*_6).1: i32)
  using: _6@Phi(bb6)
  _35 = test::printf(move _36, move _40, move _44, move _45, move _46) -> bb10
  using: _36@Mir(bb9[4]), _40@Mir(bb9[8]), _44@Mir(bb9[9]), _45@Mir(bb9[10]), _46@Mir(bb9[11])
bb10:
  _47 = const {alloc184: *mut i32}
  using: 
  _48 = CheckedAdd((*_47), const 1_i32)
  using: _47@Mir(bb10[0])
  assert(!move (_48.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_47), const 1_i32) -> bb11
  using: _48@Entry, _47@Entry
bb11:
  (*_47) = move (_48.0: i32)
  using: _47@Mir(bb10[0]), _48@Mir(bb10[1])
  _50 = ((*_1).2: i32)
  using: _1@Phi(bb10)
  _51 = ((*_6).2: i32)
  using: _6@Phi(bb10)
  _49 = Ne(move _50, move _51)
  using: _50@Mir(bb11[1]), _51@Mir(bb11[2])
  switchInt(move _49) -> [0: bb14, otherwise: bb12]
  using: _49@Mir(bb11[3])
bb12:
  _52 = const {alloc185: *mut i32}
  using: 
  _53 = CheckedAdd((*_52), const 1_i32)
  using: _52@Mir(bb12[0])
  assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_52), const 1_i32) -> bb13
  using: _53@Entry, _52@Entry
bb13:
  (*_52) = move (_53.0: i32)
  using: _52@Mir(bb12[0]), _53@Mir(bb12[1])
  _58 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _57 = &raw const (*_58)
  using: _58@Mir(bb13[1])
  _56 = move _57 as *const u8 (Pointer(ArrayToPointer))
  using: _57@Mir(bb13[2])
  _55 = move _56 as *const i8 (PtrToPtr)
  using: _56@Mir(bb13[3])
  _62 = const b"test.c\x00"
  using: 
  _61 = &raw const (*_62)
  using: _62@Mir(bb13[5])
  _60 = move _61 as *const u8 (Pointer(ArrayToPointer))
  using: _61@Mir(bb13[6])
  _59 = move _60 as *const i8 (PtrToPtr)
  using: _60@Mir(bb13[7])
  _63 = const 231_i32
  using: 
  _64 = ((*_1).2: i32)
  using: _1@Phi(bb10)
  _65 = ((*_6).2: i32)
  using: _6@Phi(bb10)
  _54 = test::printf(move _55, move _59, move _63, move _64, move _65) -> bb14
  using: _55@Mir(bb13[4]), _59@Mir(bb13[8]), _63@Mir(bb13[9]), _64@Mir(bb13[10]), _65@Mir(bb13[11])
bb14:
  _66 = const {alloc184: *mut i32}
  using: 
  _67 = CheckedAdd((*_66), const 1_i32)
  using: _66@Mir(bb14[0])
  assert(!move (_67.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_66), const 1_i32) -> bb15
  using: _67@Entry, _66@Entry
bb15:
  (*_66) = move (_67.0: i32)
  using: _66@Mir(bb14[0]), _67@Mir(bb14[1])
  _69 = ((*_1).3: i32)
  using: _1@Phi(bb14)
  _70 = ((*_6).3: i32)
  using: _6@Phi(bb14)
  _68 = Ne(move _69, move _70)
  using: _69@Mir(bb15[1]), _70@Mir(bb15[2])
  switchInt(move _68) -> [0: bb18, otherwise: bb16]
  using: _68@Mir(bb15[3])
bb16:
  _71 = const {alloc185: *mut i32}
  using: 
  _72 = CheckedAdd((*_71), const 1_i32)
  using: _71@Mir(bb16[0])
  assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_71), const 1_i32) -> bb17
  using: _72@Entry, _71@Entry
bb17:
  (*_71) = move (_72.0: i32)
  using: _71@Mir(bb16[0]), _72@Mir(bb16[1])
  _77 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _76 = &raw const (*_77)
  using: _77@Mir(bb17[1])
  _75 = move _76 as *const u8 (Pointer(ArrayToPointer))
  using: _76@Mir(bb17[2])
  _74 = move _75 as *const i8 (PtrToPtr)
  using: _75@Mir(bb17[3])
  _81 = const b"test.c\x00"
  using: 
  _80 = &raw const (*_81)
  using: _81@Mir(bb17[5])
  _79 = move _80 as *const u8 (Pointer(ArrayToPointer))
  using: _80@Mir(bb17[6])
  _78 = move _79 as *const i8 (PtrToPtr)
  using: _79@Mir(bb17[7])
  _82 = const 232_i32
  using: 
  _83 = ((*_1).3: i32)
  using: _1@Phi(bb14)
  _84 = ((*_6).3: i32)
  using: _6@Phi(bb14)
  _73 = test::printf(move _74, move _78, move _82, move _83, move _84) -> bb18
  using: _74@Mir(bb17[4]), _78@Mir(bb17[8]), _82@Mir(bb17[9]), _83@Mir(bb17[10]), _84@Mir(bb17[11])
bb18:
  _85 = const {alloc184: *mut i32}
  using: 
  _86 = CheckedAdd((*_85), const 1_i32)
  using: _85@Mir(bb18[0])
  assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_85), const 1_i32) -> bb19
  using: _86@Entry, _85@Entry
bb19:
  (*_85) = move (_86.0: i32)
  using: _85@Mir(bb18[0]), _86@Mir(bb18[1])
  _88 = ((*_1).6: i32)
  using: _1@Phi(bb18)
  _89 = ((*_6).6: i32)
  using: _6@Phi(bb18)
  _87 = Ne(move _88, move _89)
  using: _88@Mir(bb19[1]), _89@Mir(bb19[2])
  switchInt(move _87) -> [0: bb22, otherwise: bb20]
  using: _87@Mir(bb19[3])
bb20:
  _90 = const {alloc185: *mut i32}
  using: 
  _91 = CheckedAdd((*_90), const 1_i32)
  using: _90@Mir(bb20[0])
  assert(!move (_91.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_90), const 1_i32) -> bb21
  using: _91@Entry, _90@Entry
bb21:
  (*_90) = move (_91.0: i32)
  using: _90@Mir(bb20[0]), _91@Mir(bb20[1])
  _96 = const b"%s:%d (%d != %d)\n\x00"
  using: 
  _95 = &raw const (*_96)
  using: _96@Mir(bb21[1])
  _94 = move _95 as *const u8 (Pointer(ArrayToPointer))
  using: _95@Mir(bb21[2])
  _93 = move _94 as *const i8 (PtrToPtr)
  using: _94@Mir(bb21[3])
  _100 = const b"test.c\x00"
  using: 
  _99 = &raw const (*_100)
  using: _100@Mir(bb21[5])
  _98 = move _99 as *const u8 (Pointer(ArrayToPointer))
  using: _99@Mir(bb21[6])
  _97 = move _98 as *const i8 (PtrToPtr)
  using: _98@Mir(bb21[7])
  _101 = const 233_i32
  using: 
  _102 = ((*_1).6: i32)
  using: _1@Phi(bb18)
  _103 = ((*_6).6: i32)
  using: _6@Phi(bb18)
  _92 = test::printf(move _93, move _97, move _101, move _102, move _103) -> bb22
  using: _93@Mir(bb21[4]), _97@Mir(bb21[8]), _101@Mir(bb21[9]), _102@Mir(bb21[10]), _103@Mir(bb21[11])
bb22:
  _104 = const 0_i32
  using: 
  _104 = const 0_i32
  using: 
  goto -> bb23
  using: 
bb23:
  _106 = _104
  using: _104@Phi(bb23)
  _107 = ((*_1).6: i32)
  using: _1@Phi(bb23)
  _105 = Lt(move _106, move _107)
  using: _106@Mir(bb23[0]), _107@Mir(bb23[1])
  switchInt(move _105) -> [0: bb35, otherwise: bb24]
  using: _105@Mir(bb23[2])
bb24:
  _108 = const {alloc184: *mut i32}
  using: 
  _109 = CheckedAdd((*_108), const 1_i32)
  using: _108@Mir(bb24[0])
  assert(!move (_109.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_108), const 1_i32) -> bb25
  using: _109@Entry, _108@Entry
bb25:
  (*_108) = move (_109.0: i32)
  using: _108@Mir(bb24[0]), _109@Mir(bb24[1])
  _115 = ((*_1).8: *mut f64)
  using: _1@Phi(bb23)
  _117 = _104
  using: _104@Phi(bb23)
  _116 = move _117 as isize (IntToInt)
  using: _117@Mir(bb25[2])
  _114 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _115, move _116) -> bb26
  using: _115@Mir(bb25[1]), _116@Mir(bb25[3])
bb26:
  _113 = (*_114)
  using: _114@Mir(bb25[4])
  _120 = ((*_6).8: *mut f64)
  using: _6@Phi(bb23)
  _122 = _104
  using: _104@Phi(bb23)
  _121 = move _122 as isize (IntToInt)
  using: _122@Mir(bb26[2])
  _119 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _120, move _121) -> bb27
  using: _120@Mir(bb26[1]), _121@Mir(bb26[3])
bb27:
  _118 = (*_119)
  using: _119@Mir(bb26[4])
  _112 = Sub(move _113, move _118)
  using: _113@Mir(bb26[0]), _118@Mir(bb27[0])
  _111 = test::fabs(move _112) -> bb28
  using: _112@Mir(bb27[1])
bb28:
  _110 = Gt(move _111, const 0.001f64)
  using: _111@Mir(bb27[2])
  switchInt(move _110) -> [0: bb33, otherwise: bb29]
  using: _110@Mir(bb28[0])
bb29:
  _123 = const {alloc185: *mut i32}
  using: 
  _124 = CheckedAdd((*_123), const 1_i32)
  using: _123@Mir(bb29[0])
  assert(!move (_124.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_123), const 1_i32) -> bb30
  using: _124@Entry, _123@Entry
bb30:
  (*_123) = move (_124.0: i32)
  using: _123@Mir(bb29[0]), _124@Mir(bb29[1])
  _129 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _128 = &raw const (*_129)
  using: _129@Mir(bb30[1])
  _127 = move _128 as *const u8 (Pointer(ArrayToPointer))
  using: _128@Mir(bb30[2])
  _126 = move _127 as *const i8 (PtrToPtr)
  using: _127@Mir(bb30[3])
  _133 = const b"test.c\x00"
  using: 
  _132 = &raw const (*_133)
  using: _133@Mir(bb30[5])
  _131 = move _132 as *const u8 (Pointer(ArrayToPointer))
  using: _132@Mir(bb30[6])
  _130 = move _131 as *const i8 (PtrToPtr)
  using: _131@Mir(bb30[7])
  _134 = const 237_i32
  using: 
  _137 = ((*_1).8: *mut f64)
  using: _1@Phi(bb23)
  _139 = _104
  using: _104@Phi(bb23)
  _138 = move _139 as isize (IntToInt)
  using: _139@Mir(bb30[11])
  _136 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _137, move _138) -> bb31
  using: _137@Mir(bb30[10]), _138@Mir(bb30[12])
bb31:
  _135 = (*_136)
  using: _136@Mir(bb30[13])
  _142 = ((*_6).8: *mut f64)
  using: _6@Phi(bb23)
  _144 = _104
  using: _104@Phi(bb23)
  _143 = move _144 as isize (IntToInt)
  using: _144@Mir(bb31[2])
  _141 = std::ptr::mut_ptr::<impl *mut f64>::offset(move _142, move _143) -> bb32
  using: _142@Mir(bb31[1]), _143@Mir(bb31[3])
bb32:
  _140 = (*_141)
  using: _141@Mir(bb31[4])
  _125 = test::printf(move _126, move _130, move _134, move _135, move _140) -> bb33
  using: _126@Mir(bb30[4]), _130@Mir(bb30[8]), _134@Mir(bb30[9]), _135@Mir(bb31[0]), _140@Mir(bb32[0])
bb33:
  _145 = CheckedAdd(_104, const 1_i32)
  using: _104@Phi(bb33)
  assert(!move (_145.1: bool), "attempt to compute `{} + {}`, which would overflow", _104, const 1_i32) -> bb34
  using: _145@Entry, _104@Entry
bb34:
  _104 = move (_145.0: i32)
  using: _145@Mir(bb33[0])
  goto -> bb23
  using: 
bb35:
  _147 = _1
  using: _1@Phi(bb33)
  _146 = genann::genann_free(move _147) -> bb36
  using: _147@Mir(bb35[0])
bb36:
  _149 = _6
  using: _6@Phi(bb33)
  _148 = genann::genann_free(move _149) -> bb37
  using: _149@Mir(bb36[0])
bb37:
  return
  using: _0@Entry
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:650:34: 650:52 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:651:39: 651:57 (#0) by default
rewrite call test::fabs @ workspace/genann/test.rs:650:12: 651:58 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:656:65: 656:83 (#0) by default
rewrite call std::ptr::mut_ptr::<impl *mut T>::offset @ workspace/genann/test.rs:657:38: 657:56 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:138 ~ c2rust_lib[1043]::test::sigmoid)
bb0:
  _1 = const -20f64
  using: 
  _2 = const 20f64
  using: 
  _3 = const 1.0E-4f64
  using: 
  goto -> bb1
  using: 
bb1:
  _5 = _1
  using: _1@Phi(bb1)
  _6 = _2
  using: _2@Mir(bb0[1])
  _4 = Lt(move _5, move _6)
  using: _5@Mir(bb1[0]), _6@Mir(bb1[1])
  switchInt(move _4) -> [0: bb12, otherwise: bb2]
  using: _4@Mir(bb1[2])
bb2:
  _7 = const {alloc184: *mut i32}
  using: 
  _8 = CheckedAdd((*_7), const 1_i32)
  using: _7@Mir(bb2[0])
  assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_7), const 1_i32) -> bb3
  using: _8@Entry, _7@Entry
bb3:
  (*_7) = move (_8.0: i32)
  using: _7@Mir(bb2[0]), _8@Mir(bb2[1])
  _13 = _1
  using: _1@Phi(bb1)
  _12 = genann::genann_act_sigmoid(move _13) -> bb4
  using: _13@Mir(bb3[1])
bb4:
  _15 = _1
  using: _1@Phi(bb1)
  _14 = genann::genann_act_sigmoid_cached(move _15) -> bb5
  using: _15@Mir(bb4[0])
bb5:
  _11 = Sub(move _12, move _14)
  using: _12@Mir(bb3[2]), _14@Mir(bb4[1])
  _10 = test::fabs(move _11) -> bb6
  using: _11@Mir(bb5[0])
bb6:
  _9 = Gt(move _10, const 0.001f64)
  using: _10@Mir(bb5[1])
  switchInt(move _9) -> [0: bb11, otherwise: bb7]
  using: _9@Mir(bb6[0])
bb7:
  _16 = const {alloc185: *mut i32}
  using: 
  _17 = CheckedAdd((*_16), const 1_i32)
  using: _16@Mir(bb7[0])
  assert(!move (_17.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_16), const 1_i32) -> bb8
  using: _17@Entry, _16@Entry
bb8:
  (*_16) = move (_17.0: i32)
  using: _16@Mir(bb7[0]), _17@Mir(bb7[1])
  _22 = const b"%s:%d (%f != %f)\n\x00"
  using: 
  _21 = &raw const (*_22)
  using: _22@Mir(bb8[1])
  _20 = move _21 as *const u8 (Pointer(ArrayToPointer))
  using: _21@Mir(bb8[2])
  _19 = move _20 as *const i8 (PtrToPtr)
  using: _20@Mir(bb8[3])
  _26 = const b"test.c\x00"
  using: 
  _25 = &raw const (*_26)
  using: _26@Mir(bb8[5])
  _24 = move _25 as *const u8 (Pointer(ArrayToPointer))
  using: _25@Mir(bb8[6])
  _23 = move _24 as *const i8 (PtrToPtr)
  using: _24@Mir(bb8[7])
  _27 = const 251_i32
  using: 
  _29 = _1
  using: _1@Phi(bb1)
  _28 = genann::genann_act_sigmoid(move _29) -> bb9
  using: _29@Mir(bb8[10])
bb9:
  _31 = _1
  using: _1@Phi(bb1)
  _30 = genann::genann_act_sigmoid_cached(move _31) -> bb10
  using: _31@Mir(bb9[0])
bb10:
  _18 = test::printf(move _19, move _23, move _27, move _28, move _30) -> bb11
  using: _19@Mir(bb8[4]), _23@Mir(bb8[8]), _27@Mir(bb8[9]), _28@Mir(bb8[11]), _30@Mir(bb9[1])
bb11:
  _32 = _3
  using: _3@Phi(bb1)
  _1 = Add(_1, move _32)
  using: _32@Mir(bb11[0])
  goto -> bb1
  using: 
bb12:
  return
  using: _0@Entry
rewrite call test::fabs @ workspace/genann/test.rs:671:12: 671:100 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
@DefId(0:139 ~ c2rust_lib[1043]::test::main_0)
bb0:
  _7 = const b"GENANN TEST SUITE\n\x00"
  using: 
  _6 = &raw const (*_7)
  using: _7@Mir(bb0[0])
  _5 = move _6 as *const u8 (Pointer(ArrayToPointer))
  using: _6@Mir(bb0[1])
  _4 = move _5 as *const i8 (PtrToPtr)
  using: _5@Mir(bb0[2])
  _3 = test::printf(move _4) -> bb1
  using: _4@Mir(bb0[3])
bb1:
  _9 = const 100_u32
  using: 
  _8 = test::srand(move _9) -> bb2
  using: _9@Mir(bb1[0])
bb2:
  _11 = const {alloc184: *mut i32}
  using: 
  _10 = (*_11)
  using: _11@Mir(bb2[0])
  _13 = const {alloc185: *mut i32}
  using: 
  _12 = (*_13)
  using: _13@Mir(bb2[2])
  _14 = test::clock() -> bb3
  using: 
bb3:
  _19 = const b"\t%-14s\x00"
  using: 
  _18 = &raw const (*_19)
  using: _19@Mir(bb3[0])
  _17 = move _18 as *const u8 (Pointer(ArrayToPointer))
  using: _18@Mir(bb3[1])
  _16 = move _17 as *const i8 (PtrToPtr)
  using: _17@Mir(bb3[2])
  _23 = const b"basic\x00"
  using: 
  _22 = &raw const (*_23)
  using: _23@Mir(bb3[4])
  _21 = move _22 as *const u8 (Pointer(ArrayToPointer))
  using: _22@Mir(bb3[5])
  _20 = move _21 as *const i8 (PtrToPtr)
  using: _21@Mir(bb3[6])
  _15 = test::printf(move _16, move _20) -> bb4
  using: _16@Mir(bb3[3]), _20@Mir(bb3[7])
bb4:
  _24 = test::basic() -> bb5
  using: 
bb5:
  _29 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _28 = &raw const (*_29)
  using: _29@Mir(bb5[0])
  _27 = move _28 as *const u8 (Pointer(ArrayToPointer))
  using: _28@Mir(bb5[1])
  _26 = move _27 as *const i8 (PtrToPtr)
  using: _27@Mir(bb5[2])
  _33 = const {alloc184: *mut i32}
  using: 
  _32 = (*_33)
  using: _33@Mir(bb5[4])
  _34 = _10
  using: _10@Mir(bb2[1])
  _35 = CheckedSub(_32, _34)
  using: _32@Mir(bb5[5]), _34@Mir(bb5[6])
  assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", move _32, move _34) -> bb6
  using: _35@Entry, _32@Entry, _34@Entry
bb6:
  _31 = move (_35.0: i32)
  using: _35@Mir(bb5[7])
  _38 = const {alloc185: *mut i32}
  using: 
  _37 = (*_38)
  using: _38@Mir(bb6[1])
  _39 = _12
  using: _12@Mir(bb2[3])
  _40 = CheckedSub(_37, _39)
  using: _37@Mir(bb6[2]), _39@Mir(bb6[3])
  assert(!move (_40.1: bool), "attempt to compute `{} - {}`, which would overflow", move _37, move _39) -> bb7
  using: _40@Entry, _37@Entry, _39@Entry
bb7:
  _36 = move (_40.0: i32)
  using: _40@Mir(bb6[4])
  _41 = CheckedSub(_31, _36)
  using: _31@Mir(bb6[0]), _36@Mir(bb7[0])
  assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", move _31, move _36) -> bb8
  using: _41@Entry, _31@Entry, _36@Entry
bb8:
  _30 = move (_41.0: i32)
  using: _41@Mir(bb7[1])
  _44 = const {alloc185: *mut i32}
  using: 
  _43 = (*_44)
  using: _44@Mir(bb8[1])
  _45 = _12
  using: _12@Mir(bb2[3])
  _46 = CheckedSub(_43, _45)
  using: _43@Mir(bb8[2]), _45@Mir(bb8[3])
  assert(!move (_46.1: bool), "attempt to compute `{} - {}`, which would overflow", move _43, move _45) -> bb9
  using: _46@Entry, _43@Entry, _45@Entry
bb9:
  _42 = move (_46.0: i32)
  using: _46@Mir(bb8[4])
  _51 = test::clock() -> bb10
  using: 
bb10:
  _52 = _14
  using: _14@Mir(bb2[4])
  _50 = core::num::<impl u64>::wrapping_sub(move _51, move _52) -> bb11
  using: _51@Mir(bb9[1]), _52@Mir(bb10[0])
bb11:
  _53 = const 1000_u64
  using: 
  _49 = core::num::<impl u64>::wrapping_mul(move _50, move _53) -> bb12
  using: _50@Mir(bb10[1]), _53@Mir(bb11[0])
bb12:
  _54 = const 1000000_u64
  using: 
  _48 = core::num::<impl u64>::wrapping_div(move _49, move _54) -> bb13
  using: _49@Mir(bb11[1]), _54@Mir(bb12[0])
bb13:
  _47 = move _48 as i32 (IntToInt)
  using: _48@Mir(bb12[1])
  _25 = test::printf(move _26, move _30, move _42, move _47) -> bb14
  using: _26@Mir(bb5[3]), _30@Mir(bb8[0]), _42@Mir(bb9[0]), _47@Mir(bb13[0])
bb14:
  _56 = const {alloc184: *mut i32}
  using: 
  _55 = (*_56)
  using: _56@Mir(bb14[0])
  _58 = const {alloc185: *mut i32}
  using: 
  _57 = (*_58)
  using: _58@Mir(bb14[2])
  _59 = test::clock() -> bb15
  using: 
bb15:
  _64 = const b"\t%-14s\x00"
  using: 
  _63 = &raw const (*_64)
  using: _64@Mir(bb15[0])
  _62 = move _63 as *const u8 (Pointer(ArrayToPointer))
  using: _63@Mir(bb15[1])
  _61 = move _62 as *const i8 (PtrToPtr)
  using: _62@Mir(bb15[2])
  _68 = const b"xor\x00"
  using: 
  _67 = &raw const (*_68)
  using: _68@Mir(bb15[4])
  _66 = move _67 as *const u8 (Pointer(ArrayToPointer))
  using: _67@Mir(bb15[5])
  _65 = move _66 as *const i8 (PtrToPtr)
  using: _66@Mir(bb15[6])
  _60 = test::printf(move _61, move _65) -> bb16
  using: _61@Mir(bb15[3]), _65@Mir(bb15[7])
bb16:
  _69 = test::xor() -> bb17
  using: 
bb17:
  _74 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _73 = &raw const (*_74)
  using: _74@Mir(bb17[0])
  _72 = move _73 as *const u8 (Pointer(ArrayToPointer))
  using: _73@Mir(bb17[1])
  _71 = move _72 as *const i8 (PtrToPtr)
  using: _72@Mir(bb17[2])
  _78 = const {alloc184: *mut i32}
  using: 
  _77 = (*_78)
  using: _78@Mir(bb17[4])
  _79 = _55
  using: _55@Mir(bb14[1])
  _80 = CheckedSub(_77, _79)
  using: _77@Mir(bb17[5]), _79@Mir(bb17[6])
  assert(!move (_80.1: bool), "attempt to compute `{} - {}`, which would overflow", move _77, move _79) -> bb18
  using: _80@Entry, _77@Entry, _79@Entry
bb18:
  _76 = move (_80.0: i32)
  using: _80@Mir(bb17[7])
  _83 = const {alloc185: *mut i32}
  using: 
  _82 = (*_83)
  using: _83@Mir(bb18[1])
  _84 = _57
  using: _57@Mir(bb14[3])
  _85 = CheckedSub(_82, _84)
  using: _82@Mir(bb18[2]), _84@Mir(bb18[3])
  assert(!move (_85.1: bool), "attempt to compute `{} - {}`, which would overflow", move _82, move _84) -> bb19
  using: _85@Entry, _82@Entry, _84@Entry
bb19:
  _81 = move (_85.0: i32)
  using: _85@Mir(bb18[4])
  _86 = CheckedSub(_76, _81)
  using: _76@Mir(bb18[0]), _81@Mir(bb19[0])
  assert(!move (_86.1: bool), "attempt to compute `{} - {}`, which would overflow", move _76, move _81) -> bb20
  using: _86@Entry, _76@Entry, _81@Entry
bb20:
  _75 = move (_86.0: i32)
  using: _86@Mir(bb19[1])
  _89 = const {alloc185: *mut i32}
  using: 
  _88 = (*_89)
  using: _89@Mir(bb20[1])
  _90 = _57
  using: _57@Mir(bb14[3])
  _91 = CheckedSub(_88, _90)
  using: _88@Mir(bb20[2]), _90@Mir(bb20[3])
  assert(!move (_91.1: bool), "attempt to compute `{} - {}`, which would overflow", move _88, move _90) -> bb21
  using: _91@Entry, _88@Entry, _90@Entry
bb21:
  _87 = move (_91.0: i32)
  using: _91@Mir(bb20[4])
  _96 = test::clock() -> bb22
  using: 
bb22:
  _97 = _59
  using: _59@Mir(bb14[4])
  _95 = core::num::<impl u64>::wrapping_sub(move _96, move _97) -> bb23
  using: _96@Mir(bb21[1]), _97@Mir(bb22[0])
bb23:
  _98 = const 1000_u64
  using: 
  _94 = core::num::<impl u64>::wrapping_mul(move _95, move _98) -> bb24
  using: _95@Mir(bb22[1]), _98@Mir(bb23[0])
bb24:
  _99 = const 1000000_u64
  using: 
  _93 = core::num::<impl u64>::wrapping_div(move _94, move _99) -> bb25
  using: _94@Mir(bb23[1]), _99@Mir(bb24[0])
bb25:
  _92 = move _93 as i32 (IntToInt)
  using: _93@Mir(bb24[1])
  _70 = test::printf(move _71, move _75, move _87, move _92) -> bb26
  using: _71@Mir(bb17[3]), _75@Mir(bb20[0]), _87@Mir(bb21[0]), _92@Mir(bb25[0])
bb26:
  _101 = const {alloc184: *mut i32}
  using: 
  _100 = (*_101)
  using: _101@Mir(bb26[0])
  _103 = const {alloc185: *mut i32}
  using: 
  _102 = (*_103)
  using: _103@Mir(bb26[2])
  _104 = test::clock() -> bb27
  using: 
bb27:
  _109 = const b"\t%-14s\x00"
  using: 
  _108 = &raw const (*_109)
  using: _109@Mir(bb27[0])
  _107 = move _108 as *const u8 (Pointer(ArrayToPointer))
  using: _108@Mir(bb27[1])
  _106 = move _107 as *const i8 (PtrToPtr)
  using: _107@Mir(bb27[2])
  _113 = const b"backprop\x00"
  using: 
  _112 = &raw const (*_113)
  using: _113@Mir(bb27[4])
  _111 = move _112 as *const u8 (Pointer(ArrayToPointer))
  using: _112@Mir(bb27[5])
  _110 = move _111 as *const i8 (PtrToPtr)
  using: _111@Mir(bb27[6])
  _105 = test::printf(move _106, move _110) -> bb28
  using: _106@Mir(bb27[3]), _110@Mir(bb27[7])
bb28:
  _114 = test::backprop() -> bb29
  using: 
bb29:
  _119 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _118 = &raw const (*_119)
  using: _119@Mir(bb29[0])
  _117 = move _118 as *const u8 (Pointer(ArrayToPointer))
  using: _118@Mir(bb29[1])
  _116 = move _117 as *const i8 (PtrToPtr)
  using: _117@Mir(bb29[2])
  _123 = const {alloc184: *mut i32}
  using: 
  _122 = (*_123)
  using: _123@Mir(bb29[4])
  _124 = _100
  using: _100@Mir(bb26[1])
  _125 = CheckedSub(_122, _124)
  using: _122@Mir(bb29[5]), _124@Mir(bb29[6])
  assert(!move (_125.1: bool), "attempt to compute `{} - {}`, which would overflow", move _122, move _124) -> bb30
  using: _125@Entry, _122@Entry, _124@Entry
bb30:
  _121 = move (_125.0: i32)
  using: _125@Mir(bb29[7])
  _128 = const {alloc185: *mut i32}
  using: 
  _127 = (*_128)
  using: _128@Mir(bb30[1])
  _129 = _102
  using: _102@Mir(bb26[3])
  _130 = CheckedSub(_127, _129)
  using: _127@Mir(bb30[2]), _129@Mir(bb30[3])
  assert(!move (_130.1: bool), "attempt to compute `{} - {}`, which would overflow", move _127, move _129) -> bb31
  using: _130@Entry, _127@Entry, _129@Entry
bb31:
  _126 = move (_130.0: i32)
  using: _130@Mir(bb30[4])
  _131 = CheckedSub(_121, _126)
  using: _121@Mir(bb30[0]), _126@Mir(bb31[0])
  assert(!move (_131.1: bool), "attempt to compute `{} - {}`, which would overflow", move _121, move _126) -> bb32
  using: _131@Entry, _121@Entry, _126@Entry
bb32:
  _120 = move (_131.0: i32)
  using: _131@Mir(bb31[1])
  _134 = const {alloc185: *mut i32}
  using: 
  _133 = (*_134)
  using: _134@Mir(bb32[1])
  _135 = _102
  using: _102@Mir(bb26[3])
  _136 = CheckedSub(_133, _135)
  using: _133@Mir(bb32[2]), _135@Mir(bb32[3])
  assert(!move (_136.1: bool), "attempt to compute `{} - {}`, which would overflow", move _133, move _135) -> bb33
  using: _136@Entry, _133@Entry, _135@Entry
bb33:
  _132 = move (_136.0: i32)
  using: _136@Mir(bb32[4])
  _141 = test::clock() -> bb34
  using: 
bb34:
  _142 = _104
  using: _104@Mir(bb26[4])
  _140 = core::num::<impl u64>::wrapping_sub(move _141, move _142) -> bb35
  using: _141@Mir(bb33[1]), _142@Mir(bb34[0])
bb35:
  _143 = const 1000_u64
  using: 
  _139 = core::num::<impl u64>::wrapping_mul(move _140, move _143) -> bb36
  using: _140@Mir(bb34[1]), _143@Mir(bb35[0])
bb36:
  _144 = const 1000000_u64
  using: 
  _138 = core::num::<impl u64>::wrapping_div(move _139, move _144) -> bb37
  using: _139@Mir(bb35[1]), _144@Mir(bb36[0])
bb37:
  _137 = move _138 as i32 (IntToInt)
  using: _138@Mir(bb36[1])
  _115 = test::printf(move _116, move _120, move _132, move _137) -> bb38
  using: _116@Mir(bb29[3]), _120@Mir(bb32[0]), _132@Mir(bb33[0]), _137@Mir(bb37[0])
bb38:
  _146 = const {alloc184: *mut i32}
  using: 
  _145 = (*_146)
  using: _146@Mir(bb38[0])
  _148 = const {alloc185: *mut i32}
  using: 
  _147 = (*_148)
  using: _148@Mir(bb38[2])
  _149 = test::clock() -> bb39
  using: 
bb39:
  _154 = const b"\t%-14s\x00"
  using: 
  _153 = &raw const (*_154)
  using: _154@Mir(bb39[0])
  _152 = move _153 as *const u8 (Pointer(ArrayToPointer))
  using: _153@Mir(bb39[1])
  _151 = move _152 as *const i8 (PtrToPtr)
  using: _152@Mir(bb39[2])
  _158 = const b"train and\x00"
  using: 
  _157 = &raw const (*_158)
  using: _158@Mir(bb39[4])
  _156 = move _157 as *const u8 (Pointer(ArrayToPointer))
  using: _157@Mir(bb39[5])
  _155 = move _156 as *const i8 (PtrToPtr)
  using: _156@Mir(bb39[6])
  _150 = test::printf(move _151, move _155) -> bb40
  using: _151@Mir(bb39[3]), _155@Mir(bb39[7])
bb40:
  _159 = test::train_and() -> bb41
  using: 
bb41:
  _164 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _163 = &raw const (*_164)
  using: _164@Mir(bb41[0])
  _162 = move _163 as *const u8 (Pointer(ArrayToPointer))
  using: _163@Mir(bb41[1])
  _161 = move _162 as *const i8 (PtrToPtr)
  using: _162@Mir(bb41[2])
  _168 = const {alloc184: *mut i32}
  using: 
  _167 = (*_168)
  using: _168@Mir(bb41[4])
  _169 = _145
  using: _145@Mir(bb38[1])
  _170 = CheckedSub(_167, _169)
  using: _167@Mir(bb41[5]), _169@Mir(bb41[6])
  assert(!move (_170.1: bool), "attempt to compute `{} - {}`, which would overflow", move _167, move _169) -> bb42
  using: _170@Entry, _167@Entry, _169@Entry
bb42:
  _166 = move (_170.0: i32)
  using: _170@Mir(bb41[7])
  _173 = const {alloc185: *mut i32}
  using: 
  _172 = (*_173)
  using: _173@Mir(bb42[1])
  _174 = _147
  using: _147@Mir(bb38[3])
  _175 = CheckedSub(_172, _174)
  using: _172@Mir(bb42[2]), _174@Mir(bb42[3])
  assert(!move (_175.1: bool), "attempt to compute `{} - {}`, which would overflow", move _172, move _174) -> bb43
  using: _175@Entry, _172@Entry, _174@Entry
bb43:
  _171 = move (_175.0: i32)
  using: _175@Mir(bb42[4])
  _176 = CheckedSub(_166, _171)
  using: _166@Mir(bb42[0]), _171@Mir(bb43[0])
  assert(!move (_176.1: bool), "attempt to compute `{} - {}`, which would overflow", move _166, move _171) -> bb44
  using: _176@Entry, _166@Entry, _171@Entry
bb44:
  _165 = move (_176.0: i32)
  using: _176@Mir(bb43[1])
  _179 = const {alloc185: *mut i32}
  using: 
  _178 = (*_179)
  using: _179@Mir(bb44[1])
  _180 = _147
  using: _147@Mir(bb38[3])
  _181 = CheckedSub(_178, _180)
  using: _178@Mir(bb44[2]), _180@Mir(bb44[3])
  assert(!move (_181.1: bool), "attempt to compute `{} - {}`, which would overflow", move _178, move _180) -> bb45
  using: _181@Entry, _178@Entry, _180@Entry
bb45:
  _177 = move (_181.0: i32)
  using: _181@Mir(bb44[4])
  _186 = test::clock() -> bb46
  using: 
bb46:
  _187 = _149
  using: _149@Mir(bb38[4])
  _185 = core::num::<impl u64>::wrapping_sub(move _186, move _187) -> bb47
  using: _186@Mir(bb45[1]), _187@Mir(bb46[0])
bb47:
  _188 = const 1000_u64
  using: 
  _184 = core::num::<impl u64>::wrapping_mul(move _185, move _188) -> bb48
  using: _185@Mir(bb46[1]), _188@Mir(bb47[0])
bb48:
  _189 = const 1000000_u64
  using: 
  _183 = core::num::<impl u64>::wrapping_div(move _184, move _189) -> bb49
  using: _184@Mir(bb47[1]), _189@Mir(bb48[0])
bb49:
  _182 = move _183 as i32 (IntToInt)
  using: _183@Mir(bb48[1])
  _160 = test::printf(move _161, move _165, move _177, move _182) -> bb50
  using: _161@Mir(bb41[3]), _165@Mir(bb44[0]), _177@Mir(bb45[0]), _182@Mir(bb49[0])
bb50:
  _191 = const {alloc184: *mut i32}
  using: 
  _190 = (*_191)
  using: _191@Mir(bb50[0])
  _193 = const {alloc185: *mut i32}
  using: 
  _192 = (*_193)
  using: _193@Mir(bb50[2])
  _194 = test::clock() -> bb51
  using: 
bb51:
  _199 = const b"\t%-14s\x00"
  using: 
  _198 = &raw const (*_199)
  using: _199@Mir(bb51[0])
  _197 = move _198 as *const u8 (Pointer(ArrayToPointer))
  using: _198@Mir(bb51[1])
  _196 = move _197 as *const i8 (PtrToPtr)
  using: _197@Mir(bb51[2])
  _203 = const b"train or\x00"
  using: 
  _202 = &raw const (*_203)
  using: _203@Mir(bb51[4])
  _201 = move _202 as *const u8 (Pointer(ArrayToPointer))
  using: _202@Mir(bb51[5])
  _200 = move _201 as *const i8 (PtrToPtr)
  using: _201@Mir(bb51[6])
  _195 = test::printf(move _196, move _200) -> bb52
  using: _196@Mir(bb51[3]), _200@Mir(bb51[7])
bb52:
  _204 = test::train_or() -> bb53
  using: 
bb53:
  _209 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _208 = &raw const (*_209)
  using: _209@Mir(bb53[0])
  _207 = move _208 as *const u8 (Pointer(ArrayToPointer))
  using: _208@Mir(bb53[1])
  _206 = move _207 as *const i8 (PtrToPtr)
  using: _207@Mir(bb53[2])
  _213 = const {alloc184: *mut i32}
  using: 
  _212 = (*_213)
  using: _213@Mir(bb53[4])
  _214 = _190
  using: _190@Mir(bb50[1])
  _215 = CheckedSub(_212, _214)
  using: _212@Mir(bb53[5]), _214@Mir(bb53[6])
  assert(!move (_215.1: bool), "attempt to compute `{} - {}`, which would overflow", move _212, move _214) -> bb54
  using: _215@Entry, _212@Entry, _214@Entry
bb54:
  _211 = move (_215.0: i32)
  using: _215@Mir(bb53[7])
  _218 = const {alloc185: *mut i32}
  using: 
  _217 = (*_218)
  using: _218@Mir(bb54[1])
  _219 = _192
  using: _192@Mir(bb50[3])
  _220 = CheckedSub(_217, _219)
  using: _217@Mir(bb54[2]), _219@Mir(bb54[3])
  assert(!move (_220.1: bool), "attempt to compute `{} - {}`, which would overflow", move _217, move _219) -> bb55
  using: _220@Entry, _217@Entry, _219@Entry
bb55:
  _216 = move (_220.0: i32)
  using: _220@Mir(bb54[4])
  _221 = CheckedSub(_211, _216)
  using: _211@Mir(bb54[0]), _216@Mir(bb55[0])
  assert(!move (_221.1: bool), "attempt to compute `{} - {}`, which would overflow", move _211, move _216) -> bb56
  using: _221@Entry, _211@Entry, _216@Entry
bb56:
  _210 = move (_221.0: i32)
  using: _221@Mir(bb55[1])
  _224 = const {alloc185: *mut i32}
  using: 
  _223 = (*_224)
  using: _224@Mir(bb56[1])
  _225 = _192
  using: _192@Mir(bb50[3])
  _226 = CheckedSub(_223, _225)
  using: _223@Mir(bb56[2]), _225@Mir(bb56[3])
  assert(!move (_226.1: bool), "attempt to compute `{} - {}`, which would overflow", move _223, move _225) -> bb57
  using: _226@Entry, _223@Entry, _225@Entry
bb57:
  _222 = move (_226.0: i32)
  using: _226@Mir(bb56[4])
  _231 = test::clock() -> bb58
  using: 
bb58:
  _232 = _194
  using: _194@Mir(bb50[4])
  _230 = core::num::<impl u64>::wrapping_sub(move _231, move _232) -> bb59
  using: _231@Mir(bb57[1]), _232@Mir(bb58[0])
bb59:
  _233 = const 1000_u64
  using: 
  _229 = core::num::<impl u64>::wrapping_mul(move _230, move _233) -> bb60
  using: _230@Mir(bb58[1]), _233@Mir(bb59[0])
bb60:
  _234 = const 1000000_u64
  using: 
  _228 = core::num::<impl u64>::wrapping_div(move _229, move _234) -> bb61
  using: _229@Mir(bb59[1]), _234@Mir(bb60[0])
bb61:
  _227 = move _228 as i32 (IntToInt)
  using: _228@Mir(bb60[1])
  _205 = test::printf(move _206, move _210, move _222, move _227) -> bb62
  using: _206@Mir(bb53[3]), _210@Mir(bb56[0]), _222@Mir(bb57[0]), _227@Mir(bb61[0])
bb62:
  _236 = const {alloc184: *mut i32}
  using: 
  _235 = (*_236)
  using: _236@Mir(bb62[0])
  _238 = const {alloc185: *mut i32}
  using: 
  _237 = (*_238)
  using: _238@Mir(bb62[2])
  _239 = test::clock() -> bb63
  using: 
bb63:
  _244 = const b"\t%-14s\x00"
  using: 
  _243 = &raw const (*_244)
  using: _244@Mir(bb63[0])
  _242 = move _243 as *const u8 (Pointer(ArrayToPointer))
  using: _243@Mir(bb63[1])
  _241 = move _242 as *const i8 (PtrToPtr)
  using: _242@Mir(bb63[2])
  _248 = const b"train xor\x00"
  using: 
  _247 = &raw const (*_248)
  using: _248@Mir(bb63[4])
  _246 = move _247 as *const u8 (Pointer(ArrayToPointer))
  using: _247@Mir(bb63[5])
  _245 = move _246 as *const i8 (PtrToPtr)
  using: _246@Mir(bb63[6])
  _240 = test::printf(move _241, move _245) -> bb64
  using: _241@Mir(bb63[3]), _245@Mir(bb63[7])
bb64:
  _249 = test::train_xor() -> bb65
  using: 
bb65:
  _254 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _253 = &raw const (*_254)
  using: _254@Mir(bb65[0])
  _252 = move _253 as *const u8 (Pointer(ArrayToPointer))
  using: _253@Mir(bb65[1])
  _251 = move _252 as *const i8 (PtrToPtr)
  using: _252@Mir(bb65[2])
  _258 = const {alloc184: *mut i32}
  using: 
  _257 = (*_258)
  using: _258@Mir(bb65[4])
  _259 = _235
  using: _235@Mir(bb62[1])
  _260 = CheckedSub(_257, _259)
  using: _257@Mir(bb65[5]), _259@Mir(bb65[6])
  assert(!move (_260.1: bool), "attempt to compute `{} - {}`, which would overflow", move _257, move _259) -> bb66
  using: _260@Entry, _257@Entry, _259@Entry
bb66:
  _256 = move (_260.0: i32)
  using: _260@Mir(bb65[7])
  _263 = const {alloc185: *mut i32}
  using: 
  _262 = (*_263)
  using: _263@Mir(bb66[1])
  _264 = _237
  using: _237@Mir(bb62[3])
  _265 = CheckedSub(_262, _264)
  using: _262@Mir(bb66[2]), _264@Mir(bb66[3])
  assert(!move (_265.1: bool), "attempt to compute `{} - {}`, which would overflow", move _262, move _264) -> bb67
  using: _265@Entry, _262@Entry, _264@Entry
bb67:
  _261 = move (_265.0: i32)
  using: _265@Mir(bb66[4])
  _266 = CheckedSub(_256, _261)
  using: _256@Mir(bb66[0]), _261@Mir(bb67[0])
  assert(!move (_266.1: bool), "attempt to compute `{} - {}`, which would overflow", move _256, move _261) -> bb68
  using: _266@Entry, _256@Entry, _261@Entry
bb68:
  _255 = move (_266.0: i32)
  using: _266@Mir(bb67[1])
  _269 = const {alloc185: *mut i32}
  using: 
  _268 = (*_269)
  using: _269@Mir(bb68[1])
  _270 = _237
  using: _237@Mir(bb62[3])
  _271 = CheckedSub(_268, _270)
  using: _268@Mir(bb68[2]), _270@Mir(bb68[3])
  assert(!move (_271.1: bool), "attempt to compute `{} - {}`, which would overflow", move _268, move _270) -> bb69
  using: _271@Entry, _268@Entry, _270@Entry
bb69:
  _267 = move (_271.0: i32)
  using: _271@Mir(bb68[4])
  _276 = test::clock() -> bb70
  using: 
bb70:
  _277 = _239
  using: _239@Mir(bb62[4])
  _275 = core::num::<impl u64>::wrapping_sub(move _276, move _277) -> bb71
  using: _276@Mir(bb69[1]), _277@Mir(bb70[0])
bb71:
  _278 = const 1000_u64
  using: 
  _274 = core::num::<impl u64>::wrapping_mul(move _275, move _278) -> bb72
  using: _275@Mir(bb70[1]), _278@Mir(bb71[0])
bb72:
  _279 = const 1000000_u64
  using: 
  _273 = core::num::<impl u64>::wrapping_div(move _274, move _279) -> bb73
  using: _274@Mir(bb71[1]), _279@Mir(bb72[0])
bb73:
  _272 = move _273 as i32 (IntToInt)
  using: _273@Mir(bb72[1])
  _250 = test::printf(move _251, move _255, move _267, move _272) -> bb74
  using: _251@Mir(bb65[3]), _255@Mir(bb68[0]), _267@Mir(bb69[0]), _272@Mir(bb73[0])
bb74:
  _281 = const {alloc184: *mut i32}
  using: 
  _280 = (*_281)
  using: _281@Mir(bb74[0])
  _283 = const {alloc185: *mut i32}
  using: 
  _282 = (*_283)
  using: _283@Mir(bb74[2])
  _284 = test::clock() -> bb75
  using: 
bb75:
  _289 = const b"\t%-14s\x00"
  using: 
  _288 = &raw const (*_289)
  using: _289@Mir(bb75[0])
  _287 = move _288 as *const u8 (Pointer(ArrayToPointer))
  using: _288@Mir(bb75[1])
  _286 = move _287 as *const i8 (PtrToPtr)
  using: _287@Mir(bb75[2])
  _293 = const b"persist\x00"
  using: 
  _292 = &raw const (*_293)
  using: _293@Mir(bb75[4])
  _291 = move _292 as *const u8 (Pointer(ArrayToPointer))
  using: _292@Mir(bb75[5])
  _290 = move _291 as *const i8 (PtrToPtr)
  using: _291@Mir(bb75[6])
  _285 = test::printf(move _286, move _290) -> bb76
  using: _286@Mir(bb75[3]), _290@Mir(bb75[7])
bb76:
  _294 = test::persist() -> bb77
  using: 
bb77:
  _299 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _298 = &raw const (*_299)
  using: _299@Mir(bb77[0])
  _297 = move _298 as *const u8 (Pointer(ArrayToPointer))
  using: _298@Mir(bb77[1])
  _296 = move _297 as *const i8 (PtrToPtr)
  using: _297@Mir(bb77[2])
  _303 = const {alloc184: *mut i32}
  using: 
  _302 = (*_303)
  using: _303@Mir(bb77[4])
  _304 = _280
  using: _280@Mir(bb74[1])
  _305 = CheckedSub(_302, _304)
  using: _302@Mir(bb77[5]), _304@Mir(bb77[6])
  assert(!move (_305.1: bool), "attempt to compute `{} - {}`, which would overflow", move _302, move _304) -> bb78
  using: _305@Entry, _302@Entry, _304@Entry
bb78:
  _301 = move (_305.0: i32)
  using: _305@Mir(bb77[7])
  _308 = const {alloc185: *mut i32}
  using: 
  _307 = (*_308)
  using: _308@Mir(bb78[1])
  _309 = _282
  using: _282@Mir(bb74[3])
  _310 = CheckedSub(_307, _309)
  using: _307@Mir(bb78[2]), _309@Mir(bb78[3])
  assert(!move (_310.1: bool), "attempt to compute `{} - {}`, which would overflow", move _307, move _309) -> bb79
  using: _310@Entry, _307@Entry, _309@Entry
bb79:
  _306 = move (_310.0: i32)
  using: _310@Mir(bb78[4])
  _311 = CheckedSub(_301, _306)
  using: _301@Mir(bb78[0]), _306@Mir(bb79[0])
  assert(!move (_311.1: bool), "attempt to compute `{} - {}`, which would overflow", move _301, move _306) -> bb80
  using: _311@Entry, _301@Entry, _306@Entry
bb80:
  _300 = move (_311.0: i32)
  using: _311@Mir(bb79[1])
  _314 = const {alloc185: *mut i32}
  using: 
  _313 = (*_314)
  using: _314@Mir(bb80[1])
  _315 = _282
  using: _282@Mir(bb74[3])
  _316 = CheckedSub(_313, _315)
  using: _313@Mir(bb80[2]), _315@Mir(bb80[3])
  assert(!move (_316.1: bool), "attempt to compute `{} - {}`, which would overflow", move _313, move _315) -> bb81
  using: _316@Entry, _313@Entry, _315@Entry
bb81:
  _312 = move (_316.0: i32)
  using: _316@Mir(bb80[4])
  _321 = test::clock() -> bb82
  using: 
bb82:
  _322 = _284
  using: _284@Mir(bb74[4])
  _320 = core::num::<impl u64>::wrapping_sub(move _321, move _322) -> bb83
  using: _321@Mir(bb81[1]), _322@Mir(bb82[0])
bb83:
  _323 = const 1000_u64
  using: 
  _319 = core::num::<impl u64>::wrapping_mul(move _320, move _323) -> bb84
  using: _320@Mir(bb82[1]), _323@Mir(bb83[0])
bb84:
  _324 = const 1000000_u64
  using: 
  _318 = core::num::<impl u64>::wrapping_div(move _319, move _324) -> bb85
  using: _319@Mir(bb83[1]), _324@Mir(bb84[0])
bb85:
  _317 = move _318 as i32 (IntToInt)
  using: _318@Mir(bb84[1])
  _295 = test::printf(move _296, move _300, move _312, move _317) -> bb86
  using: _296@Mir(bb77[3]), _300@Mir(bb80[0]), _312@Mir(bb81[0]), _317@Mir(bb85[0])
bb86:
  _326 = const {alloc184: *mut i32}
  using: 
  _325 = (*_326)
  using: _326@Mir(bb86[0])
  _328 = const {alloc185: *mut i32}
  using: 
  _327 = (*_328)
  using: _328@Mir(bb86[2])
  _329 = test::clock() -> bb87
  using: 
bb87:
  _334 = const b"\t%-14s\x00"
  using: 
  _333 = &raw const (*_334)
  using: _334@Mir(bb87[0])
  _332 = move _333 as *const u8 (Pointer(ArrayToPointer))
  using: _333@Mir(bb87[1])
  _331 = move _332 as *const i8 (PtrToPtr)
  using: _332@Mir(bb87[2])
  _338 = const b"copy\x00"
  using: 
  _337 = &raw const (*_338)
  using: _338@Mir(bb87[4])
  _336 = move _337 as *const u8 (Pointer(ArrayToPointer))
  using: _337@Mir(bb87[5])
  _335 = move _336 as *const i8 (PtrToPtr)
  using: _336@Mir(bb87[6])
  _330 = test::printf(move _331, move _335) -> bb88
  using: _331@Mir(bb87[3]), _335@Mir(bb87[7])
bb88:
  _339 = test::copy() -> bb89
  using: 
bb89:
  _344 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _343 = &raw const (*_344)
  using: _344@Mir(bb89[0])
  _342 = move _343 as *const u8 (Pointer(ArrayToPointer))
  using: _343@Mir(bb89[1])
  _341 = move _342 as *const i8 (PtrToPtr)
  using: _342@Mir(bb89[2])
  _348 = const {alloc184: *mut i32}
  using: 
  _347 = (*_348)
  using: _348@Mir(bb89[4])
  _349 = _325
  using: _325@Mir(bb86[1])
  _350 = CheckedSub(_347, _349)
  using: _347@Mir(bb89[5]), _349@Mir(bb89[6])
  assert(!move (_350.1: bool), "attempt to compute `{} - {}`, which would overflow", move _347, move _349) -> bb90
  using: _350@Entry, _347@Entry, _349@Entry
bb90:
  _346 = move (_350.0: i32)
  using: _350@Mir(bb89[7])
  _353 = const {alloc185: *mut i32}
  using: 
  _352 = (*_353)
  using: _353@Mir(bb90[1])
  _354 = _327
  using: _327@Mir(bb86[3])
  _355 = CheckedSub(_352, _354)
  using: _352@Mir(bb90[2]), _354@Mir(bb90[3])
  assert(!move (_355.1: bool), "attempt to compute `{} - {}`, which would overflow", move _352, move _354) -> bb91
  using: _355@Entry, _352@Entry, _354@Entry
bb91:
  _351 = move (_355.0: i32)
  using: _355@Mir(bb90[4])
  _356 = CheckedSub(_346, _351)
  using: _346@Mir(bb90[0]), _351@Mir(bb91[0])
  assert(!move (_356.1: bool), "attempt to compute `{} - {}`, which would overflow", move _346, move _351) -> bb92
  using: _356@Entry, _346@Entry, _351@Entry
bb92:
  _345 = move (_356.0: i32)
  using: _356@Mir(bb91[1])
  _359 = const {alloc185: *mut i32}
  using: 
  _358 = (*_359)
  using: _359@Mir(bb92[1])
  _360 = _327
  using: _327@Mir(bb86[3])
  _361 = CheckedSub(_358, _360)
  using: _358@Mir(bb92[2]), _360@Mir(bb92[3])
  assert(!move (_361.1: bool), "attempt to compute `{} - {}`, which would overflow", move _358, move _360) -> bb93
  using: _361@Entry, _358@Entry, _360@Entry
bb93:
  _357 = move (_361.0: i32)
  using: _361@Mir(bb92[4])
  _366 = test::clock() -> bb94
  using: 
bb94:
  _367 = _329
  using: _329@Mir(bb86[4])
  _365 = core::num::<impl u64>::wrapping_sub(move _366, move _367) -> bb95
  using: _366@Mir(bb93[1]), _367@Mir(bb94[0])
bb95:
  _368 = const 1000_u64
  using: 
  _364 = core::num::<impl u64>::wrapping_mul(move _365, move _368) -> bb96
  using: _365@Mir(bb94[1]), _368@Mir(bb95[0])
bb96:
  _369 = const 1000000_u64
  using: 
  _363 = core::num::<impl u64>::wrapping_div(move _364, move _369) -> bb97
  using: _364@Mir(bb95[1]), _369@Mir(bb96[0])
bb97:
  _362 = move _363 as i32 (IntToInt)
  using: _363@Mir(bb96[1])
  _340 = test::printf(move _341, move _345, move _357, move _362) -> bb98
  using: _341@Mir(bb89[3]), _345@Mir(bb92[0]), _357@Mir(bb93[0]), _362@Mir(bb97[0])
bb98:
  _371 = const {alloc184: *mut i32}
  using: 
  _370 = (*_371)
  using: _371@Mir(bb98[0])
  _373 = const {alloc185: *mut i32}
  using: 
  _372 = (*_373)
  using: _373@Mir(bb98[2])
  _374 = test::clock() -> bb99
  using: 
bb99:
  _379 = const b"\t%-14s\x00"
  using: 
  _378 = &raw const (*_379)
  using: _379@Mir(bb99[0])
  _377 = move _378 as *const u8 (Pointer(ArrayToPointer))
  using: _378@Mir(bb99[1])
  _376 = move _377 as *const i8 (PtrToPtr)
  using: _377@Mir(bb99[2])
  _383 = const b"sigmoid\x00"
  using: 
  _382 = &raw const (*_383)
  using: _383@Mir(bb99[4])
  _381 = move _382 as *const u8 (Pointer(ArrayToPointer))
  using: _382@Mir(bb99[5])
  _380 = move _381 as *const i8 (PtrToPtr)
  using: _381@Mir(bb99[6])
  _375 = test::printf(move _376, move _380) -> bb100
  using: _376@Mir(bb99[3]), _380@Mir(bb99[7])
bb100:
  _384 = test::sigmoid() -> bb101
  using: 
bb101:
  _389 = const b"pass:%2d   fail:%2d   %4dms\n\x00"
  using: 
  _388 = &raw const (*_389)
  using: _389@Mir(bb101[0])
  _387 = move _388 as *const u8 (Pointer(ArrayToPointer))
  using: _388@Mir(bb101[1])
  _386 = move _387 as *const i8 (PtrToPtr)
  using: _387@Mir(bb101[2])
  _393 = const {alloc184: *mut i32}
  using: 
  _392 = (*_393)
  using: _393@Mir(bb101[4])
  _394 = _370
  using: _370@Mir(bb98[1])
  _395 = CheckedSub(_392, _394)
  using: _392@Mir(bb101[5]), _394@Mir(bb101[6])
  assert(!move (_395.1: bool), "attempt to compute `{} - {}`, which would overflow", move _392, move _394) -> bb102
  using: _395@Entry, _392@Entry, _394@Entry
bb102:
  _391 = move (_395.0: i32)
  using: _395@Mir(bb101[7])
  _398 = const {alloc185: *mut i32}
  using: 
  _397 = (*_398)
  using: _398@Mir(bb102[1])
  _399 = _372
  using: _372@Mir(bb98[3])
  _400 = CheckedSub(_397, _399)
  using: _397@Mir(bb102[2]), _399@Mir(bb102[3])
  assert(!move (_400.1: bool), "attempt to compute `{} - {}`, which would overflow", move _397, move _399) -> bb103
  using: _400@Entry, _397@Entry, _399@Entry
bb103:
  _396 = move (_400.0: i32)
  using: _400@Mir(bb102[4])
  _401 = CheckedSub(_391, _396)
  using: _391@Mir(bb102[0]), _396@Mir(bb103[0])
  assert(!move (_401.1: bool), "attempt to compute `{} - {}`, which would overflow", move _391, move _396) -> bb104
  using: _401@Entry, _391@Entry, _396@Entry
bb104:
  _390 = move (_401.0: i32)
  using: _401@Mir(bb103[1])
  _404 = const {alloc185: *mut i32}
  using: 
  _403 = (*_404)
  using: _404@Mir(bb104[1])
  _405 = _372
  using: _372@Mir(bb98[3])
  _406 = CheckedSub(_403, _405)
  using: _403@Mir(bb104[2]), _405@Mir(bb104[3])
  assert(!move (_406.1: bool), "attempt to compute `{} - {}`, which would overflow", move _403, move _405) -> bb105
  using: _406@Entry, _403@Entry, _405@Entry
bb105:
  _402 = move (_406.0: i32)
  using: _406@Mir(bb104[4])
  _411 = test::clock() -> bb106
  using: 
bb106:
  _412 = _374
  using: _374@Mir(bb98[4])
  _410 = core::num::<impl u64>::wrapping_sub(move _411, move _412) -> bb107
  using: _411@Mir(bb105[1]), _412@Mir(bb106[0])
bb107:
  _413 = const 1000_u64
  using: 
  _409 = core::num::<impl u64>::wrapping_mul(move _410, move _413) -> bb108
  using: _410@Mir(bb106[1]), _413@Mir(bb107[0])
bb108:
  _414 = const 1000000_u64
  using: 
  _408 = core::num::<impl u64>::wrapping_div(move _409, move _414) -> bb109
  using: _409@Mir(bb107[1]), _414@Mir(bb108[0])
bb109:
  _407 = move _408 as i32 (IntToInt)
  using: _408@Mir(bb108[1])
  _385 = test::printf(move _386, move _390, move _402, move _407) -> bb110
  using: _386@Mir(bb101[3]), _390@Mir(bb104[0]), _402@Mir(bb105[0]), _407@Mir(bb109[0])
bb110:
  _417 = const {alloc185: *mut i32}
  using: 
  _416 = (*_417)
  using: _417@Mir(bb110[0])
  _418 = const 0_i32
  using: 
  _415 = Eq(move _416, move _418)
  using: _416@Mir(bb110[1]), _418@Mir(bb110[2])
  switchInt(move _415) -> [0: bb112, otherwise: bb111]
  using: _415@Mir(bb110[3])
bb111:
  _423 = const b"ALL TESTS PASSED (%d/%d)\n\x00"
  using: 
  _422 = &raw const (*_423)
  using: _423@Mir(bb111[0])
  _421 = move _422 as *const u8 (Pointer(ArrayToPointer))
  using: _422@Mir(bb111[1])
  _420 = move _421 as *const i8 (PtrToPtr)
  using: _421@Mir(bb111[2])
  _425 = const {alloc184: *mut i32}
  using: 
  _424 = (*_425)
  using: _425@Mir(bb111[4])
  _427 = const {alloc184: *mut i32}
  using: 
  _426 = (*_427)
  using: _427@Mir(bb111[6])
  _419 = test::printf(move _420, move _424, move _426) -> bb114
  using: _420@Mir(bb111[3]), _424@Mir(bb111[5]), _426@Mir(bb111[7])
bb112:
  _432 = const b"SOME TESTS FAILED (%d/%d)\n\x00"
  using: 
  _431 = &raw const (*_432)
  using: _432@Mir(bb112[0])
  _430 = move _431 as *const u8 (Pointer(ArrayToPointer))
  using: _431@Mir(bb112[1])
  _429 = move _430 as *const i8 (PtrToPtr)
  using: _430@Mir(bb112[2])
  _435 = const {alloc184: *mut i32}
  using: 
  _434 = (*_435)
  using: _435@Mir(bb112[4])
  _437 = const {alloc185: *mut i32}
  using: 
  _436 = (*_437)
  using: _437@Mir(bb112[6])
  _438 = CheckedSub(_434, _436)
  using: _434@Mir(bb112[5]), _436@Mir(bb112[7])
  assert(!move (_438.1: bool), "attempt to compute `{} - {}`, which would overflow", move _434, move _436) -> bb113
  using: _438@Entry, _434@Entry, _436@Entry
bb113:
  _433 = move (_438.0: i32)
  using: _438@Mir(bb112[8])
  _440 = const {alloc184: *mut i32}
  using: 
  _439 = (*_440)
  using: _440@Mir(bb113[1])
  _428 = test::printf(move _429, move _433, move _439) -> bb114
  using: _429@Mir(bb112[3]), _433@Mir(bb113[0]), _439@Mir(bb113[2])
bb114:
  _443 = const {alloc185: *mut i32}
  using: 
  _442 = (*_443)
  using: _443@Mir(bb114[0])
  _444 = const 0_i32
  using: 
  _441 = Ne(move _442, move _444)
  using: _442@Mir(bb114[1]), _444@Mir(bb114[2])
  _0 = move _441 as i32 (IntToInt)
  using: _441@Mir(bb114[3])
  return
  using: _0@Mir(bb114[4])
rewrite call test::srand @ workspace/genann/test.rs:686:5: 686:62 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:689:26: 689:33 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:695:12: 695:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:695:20: 695:39 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:695:40: 696:79 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:696:80: 700:111 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:704:28: 704:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:711:12: 711:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:711:20: 711:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:711:42: 712:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:712:82: 716:113 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:720:28: 720:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:727:12: 727:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:727:20: 727:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:727:42: 728:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:728:82: 732:113 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:736:28: 736:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:743:12: 743:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:743:20: 743:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:743:42: 744:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:744:82: 748:113 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:752:28: 752:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:759:12: 759:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:759:20: 759:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:759:42: 760:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:760:82: 764:113 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:768:28: 768:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:775:12: 775:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:775:20: 775:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:775:42: 776:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:776:82: 780:113 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:784:28: 784:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:791:12: 791:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:791:20: 791:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:791:42: 792:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:792:82: 796:113 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:800:28: 800:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:807:12: 807:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:807:20: 807:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:807:42: 808:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:808:82: 812:113 (#0) by default
rewrite call test::clock @ workspace/genann/test.rs:816:28: 816:35 (#0) by default
[31mERROR[0m [2mrefactor::rewrite_fn[0m[2m:[0m const addr is ignored
rewrite call test::clock @ workspace/genann/test.rs:823:12: 823:19 (#0) by default
rewrite call core::num::<impl u64>::wrapping_sub @ workspace/genann/test.rs:823:20: 823:41 (#0) by default
rewrite call core::num::<impl u64>::wrapping_mul @ workspace/genann/test.rs:823:42: 824:81 (#0) by default
rewrite call core::num::<impl u64>::wrapping_div @ workspace/genann/test.rs:824:82: 828:113 (#0) by default

extern "C" {
    
    #[no_mangle]
    fn fclose(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fopen(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> *mut FILE;
    
    
    
    
    #[no_mangle]
    fn printf(_: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    #[no_mangle]
    fn fabs(_: std::os::raw::c_double) -> std::os::raw::c_double;
    #[no_mangle]
    fn clock() -> clock_t;
    #[no_mangle]
    fn srand(_: std::os::raw::c_uint);
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_clock_t = std::os::raw::c_ulong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor8;
impl Default for ErasedByPreprocessor8 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor9;
impl Default for ErasedByPreprocessor9 {fn default() -> Self {Self {
}}}

pub type FILE = crate::example3::__sFILE;
pub type genann_actfun
    =
    Option<unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double>;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor10;
impl Default for ErasedByPreprocessor10 {fn default() -> Self {Self {
}}}

pub type clock_t = __darwin_clock_t;
static mut lfails: std::os::raw::c_int = 0 as std::os::raw::c_int;
static mut ltests: std::os::raw::c_int = 0 as std::os::raw::c_int;
/*
 * GENANN - Minimal C Artificial Neural Network
 *
 * Copyright (c) 2015, 2016 Lewis Van Winkle
 *
 * http://CodePlea.com
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgement in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 *
 */
#[no_mangle]
pub unsafe extern "C" fn basic() {
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(1 as std::os::raw::c_int, 0 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    ltests += 1;
    if (*ann).total_weights != 2 as std::os::raw::c_int {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               37 as std::os::raw::c_int, (*ann).total_weights, 2 as std::os::raw::c_int);
    }
    let mut a: std::os::raw::c_double = 0.;
    a= 0 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(0 as std::os::raw::c_int as isize) =
        0 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(1 as std::os::raw::c_int as isize) =
        0 as std::os::raw::c_int as std::os::raw::c_double;
    ltests += 1;
    if fabs(0.5f64 - *crate::genann::genann_run(ann.as_mut(), &mut a)) > 0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               44 as std::os::raw::c_int, 0.5f64, *crate::genann::genann_run(ann.as_mut(), &mut a));
    }
    a= 1 as std::os::raw::c_int as std::os::raw::c_double;
    ltests += 1;
    if fabs(0.5f64 - *crate::genann::genann_run(ann.as_mut(), &mut a)) > 0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               47 as std::os::raw::c_int, 0.5f64, *crate::genann::genann_run(ann.as_mut(), &mut a));
    }
    a= 11 as std::os::raw::c_int as std::os::raw::c_double;
    ltests += 1;
    if fabs(0.5f64 - *crate::genann::genann_run(ann.as_mut(), &mut a)) > 0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               50 as std::os::raw::c_int, 0.5f64, *crate::genann::genann_run(ann.as_mut(), &mut a));
    }
    a= 1 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(0 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(1 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    ltests += 1;
    if fabs(0.5f64 - *crate::genann::genann_run(ann.as_mut(), &mut a)) > 0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               55 as std::os::raw::c_int, 0.5f64, *crate::genann::genann_run(ann.as_mut(), &mut a));
    }
    a= 10 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(0 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(1 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    ltests += 1;
    if fabs(1.0f64 - *crate::genann::genann_run(ann.as_mut(), &mut a)) > 0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               60 as std::os::raw::c_int, 1.0f64, *crate::genann::genann_run(ann.as_mut(), &mut a));
    }
    a= -(10 as std::os::raw::c_int) as std::os::raw::c_double;
    ltests += 1;
    if fabs(0.0f64 - *crate::genann::genann_run(ann.as_mut(), &mut a)) > 0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               63 as std::os::raw::c_int, 0.0f64, *crate::genann::genann_run(ann.as_mut(), &mut a));
    }
    crate::genann::genann_free(ann);
}
#[no_mangle]
pub unsafe extern "C" fn xor() {
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(2 as std::os::raw::c_int, 1 as std::os::raw::c_int, 2 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    (*ann).activation_hidden=
        Some(crate::genann::genann_act_threshold as
                 unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double);
    (*ann).activation_output=
        Some(crate::genann::genann_act_threshold as
                 unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double);
    ltests += 1;
    if (*ann).total_weights != 9 as std::os::raw::c_int {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               74 as std::os::raw::c_int, (*ann).total_weights, 9 as std::os::raw::c_int);
    }
    /* First hidden. */
    *(*ann).weight.offset(0 as std::os::raw::c_int as isize) = 0.5f64;
    *(*ann).weight.offset(1 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(2 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    /* Second hidden. */
    *(*ann).weight.offset(3 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(4 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(5 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    /* Output. */
    *(*ann).weight.offset(6 as std::os::raw::c_int as isize) = 0.5f64;
    *(*ann).weight.offset(7 as std::os::raw::c_int as isize) =
        1 as std::os::raw::c_int as std::os::raw::c_double;
    *(*ann).weight.offset(8 as std::os::raw::c_int as isize) =
        -(1 as std::os::raw::c_int) as std::os::raw::c_double;
    let mut input: [[std::os::raw::c_double; 2]; 4] =
        [[0 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [0 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double]];
    let mut output: [std::os::raw::c_double; 4] =
        [0 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         0 as std::os::raw::c_int as std::os::raw::c_double];
    ltests += 1;
    if fabs(output[0 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               95 as std::os::raw::c_int, output[0 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[1 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               96 as std::os::raw::c_int, output[1 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[2 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               97 as std::os::raw::c_int, output[2 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[3 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               98 as std::os::raw::c_int, output[3 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    crate::genann::genann_free(ann);
}
#[no_mangle]
pub unsafe extern "C" fn backprop() {
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(1 as std::os::raw::c_int, 0 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    let mut input: std::os::raw::c_double = 0.;
    let mut output: std::os::raw::c_double = 0.;
    input= 0.5f64;
    output= 1 as std::os::raw::c_int as std::os::raw::c_double;
    let mut first_try: std::os::raw::c_double = *crate::genann::genann_run(ann.as_mut(), &mut input);
    crate::genann::genann_train(ann, &mut input, &mut output, 0.5f64);
    let mut second_try: std::os::raw::c_double = *crate::genann::genann_run(ann.as_mut(), &mut input);
    ltests += 1;
    if !(fabs(first_try - output) > fabs(second_try - output)) {
        lfails += 1;
        printf(b"%s:%d error \n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               114 as std::os::raw::c_int);
    }
    crate::genann::genann_free(ann);
}
#[no_mangle]
pub unsafe extern "C" fn train_and() {
    let mut input: [[std::os::raw::c_double; 2]; 4] =
        [[0 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [0 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double]];
    let mut output: [std::os::raw::c_double; 4] =
        [0 as std::os::raw::c_int as std::os::raw::c_double,
         0 as std::os::raw::c_int as std::os::raw::c_double,
         0 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double];
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(2 as std::os::raw::c_int, 0 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < 50 as std::os::raw::c_int {
        j= 0 as std::os::raw::c_int;
        while j < 4 as std::os::raw::c_int {
            crate::genann::genann_train(ann, input[索引].as_mut_ptr(),
                         output.as_mut_ptr().offset(j as isize), 0.8f64);
            j+= 1
        }
        i+= 1
    }
    (*ann).activation_output=
        Some(crate::genann::genann_act_threshold as
                 unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double);
    ltests += 1;
    if fabs(output[0 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               135 as std::os::raw::c_int, output[0 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[1 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               136 as std::os::raw::c_int, output[1 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[2 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               137 as std::os::raw::c_int, output[2 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[3 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               138 as std::os::raw::c_int, output[3 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    crate::genann::genann_free(ann);
}
#[no_mangle]
pub unsafe extern "C" fn train_or() {
    let mut input: [[std::os::raw::c_double; 2]; 4] =
        [[0 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [0 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double]];
    let mut output: [std::os::raw::c_double; 4] =
        [0 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double];
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(2 as std::os::raw::c_int, 0 as std::os::raw::c_int, 0 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    crate::genann::genann_randomize(ann.as_mut());
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < 50 as std::os::raw::c_int {
        j= 0 as std::os::raw::c_int;
        while j < 4 as std::os::raw::c_int {
            crate::genann::genann_train(ann, input[索引].as_mut_ptr(),
                         output.as_mut_ptr().offset(j as isize), 0.8f64);
            j+= 1
        }
        i+= 1
    }
    (*ann).activation_output=
        Some(crate::genann::genann_act_threshold as
                 unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double);
    ltests += 1;
    if fabs(output[0 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               160 as std::os::raw::c_int, output[0 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[1 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               161 as std::os::raw::c_int, output[1 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[2 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               162 as std::os::raw::c_int, output[2 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[3 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               163 as std::os::raw::c_int, output[3 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    crate::genann::genann_free(ann);
}
#[no_mangle]
pub unsafe extern "C" fn train_xor() {
    let mut input: [[std::os::raw::c_double; 2]; 4] =
        [[0 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [0 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double]];
    let mut output: [std::os::raw::c_double; 4] =
        [0 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         0 as std::os::raw::c_int as std::os::raw::c_double];
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(2 as std::os::raw::c_int, 1 as std::os::raw::c_int, 2 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < 500 as std::os::raw::c_int {
        j= 0 as std::os::raw::c_int;
        while j < 4 as std::os::raw::c_int {
            crate::genann::genann_train(ann, input[索引].as_mut_ptr(),
                         output.as_mut_ptr().offset(j as isize),
                         3 as std::os::raw::c_int as std::os::raw::c_double);
            j+= 1
        }
        i+= 1
        /* printf("%1.2f ", xor_score(ann)); */
    }
    (*ann).activation_output=
        Some(crate::genann::genann_act_threshold as
                 unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double);
    ltests += 1;
    if fabs(output[0 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               186 as std::os::raw::c_int, output[0 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[1 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               187 as std::os::raw::c_int, output[1 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[2 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               188 as std::os::raw::c_int, output[2 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    ltests += 1;
    if fabs(output[3 as std::os::raw::c_int as usize] -
                *crate::genann::genann_run(ann.as_mut(),
                            input[索引].as_mut_ptr())) >
           0.001f64 {
        lfails += 1;
        printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               189 as std::os::raw::c_int, output[3 as std::os::raw::c_int as usize],
               *crate::genann::genann_run(ann.as_mut(),
                           input[索引].as_mut_ptr()));
    }
    crate::genann::genann_free(ann);
}
#[no_mangle]
pub unsafe extern "C" fn persist() {
    let mut first: *mut crate::example1::genann =
        crate::genann::genann_init(1000 as std::os::raw::c_int, 5 as std::os::raw::c_int, 50 as std::os::raw::c_int,
                    10 as std::os::raw::c_int);
    let mut out: *mut FILE =
        fopen(b"persist.txt\x00" as *const u8 as *const std::os::raw::c_char,
              b"w\x00" as *const u8 as *const std::os::raw::c_char);
    crate::genann::genann_write(core::mem::transmute::<_, *const crate::example1::genann>(first.as_deref()), out);
    fclose(out);
    let mut in_0: *mut FILE =
        fopen(b"persist.txt\x00" as *const u8 as *const std::os::raw::c_char,
              b"r\x00" as *const u8 as *const std::os::raw::c_char);
    let mut second: *mut crate::example1::genann = crate::genann::genann_read(in_0);
    fclose(out);
    ltests += 1;
    if (*first.as_deref().unwrap()).inputs != (*second.as_deref().unwrap()).inputs {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               208 as std::os::raw::c_int, (*first.as_deref().unwrap()).inputs, (*second.as_deref().unwrap()).inputs);
    }
    ltests += 1;
    if (*first.as_deref().unwrap()).hidden_layers != (*second.as_deref().unwrap()).hidden_layers {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               209 as std::os::raw::c_int, (*first.as_deref().unwrap()).hidden_layers,
               (*second.as_deref().unwrap()).hidden_layers);
    }
    ltests += 1;
    if (*first.as_deref().unwrap()).hidden != (*second.as_deref().unwrap()).hidden {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               210 as std::os::raw::c_int, (*first.as_deref().unwrap()).hidden, (*second.as_deref().unwrap()).hidden);
    }
    ltests += 1;
    if (*first.as_deref().unwrap()).outputs != (*second.as_deref().unwrap()).outputs {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               211 as std::os::raw::c_int, (*first.as_deref().unwrap()).outputs, (*second.as_deref().unwrap()).outputs);
    }
    ltests += 1;
    if (*first.as_deref().unwrap()).total_weights != (*second.as_deref().unwrap()).total_weights {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               212 as std::os::raw::c_int, (*first.as_deref().unwrap()).total_weights,
               (*second.as_deref().unwrap()).total_weights);
    }
    let mut i: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < (*first.as_deref().unwrap()).total_weights {
        ltests += 1;
        if !(*(*first.as_deref().unwrap()).weight.offset(i as isize) ==
                 *(*second.as_deref().unwrap()).weight.offset(i as isize)) {
            lfails += 1;
            printf(b"%s:%d error \n\x00" as *const u8 as *const std::os::raw::c_char,
                   b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
                   216 as std::os::raw::c_int);
        }
        i+= 1
    }
    crate::genann::genann_free(core::mem::transmute::<_, *mut crate::example1::genann>(first.as_deref_mut()));
    crate::genann::genann_free(core::mem::transmute::<_, *mut crate::example1::genann>(second.as_deref_mut()));
}
#[no_mangle]
pub unsafe extern "C" fn copy() {
    let mut first: *mut crate::example1::genann =
        crate::genann::genann_init(1000 as std::os::raw::c_int, 5 as std::os::raw::c_int, 50 as std::os::raw::c_int,
                    10 as std::os::raw::c_int);
    let mut second: *mut crate::example1::genann = crate::genann::genann_copy(first as *const crate::example1::genann);
    ltests += 1;
    if (*first).inputs != (*second.as_deref().unwrap()).inputs {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               229 as std::os::raw::c_int, (*first).inputs, (*second.as_deref().unwrap()).inputs);
    }
    ltests += 1;
    if (*first).hidden_layers != (*second.as_deref().unwrap()).hidden_layers {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               230 as std::os::raw::c_int, (*first).hidden_layers,
               (*second.as_deref().unwrap()).hidden_layers);
    }
    ltests += 1;
    if (*first).hidden != (*second.as_deref().unwrap()).hidden {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               231 as std::os::raw::c_int, (*first).hidden, (*second.as_deref().unwrap()).hidden);
    }
    ltests += 1;
    if (*first).outputs != (*second.as_deref().unwrap()).outputs {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               232 as std::os::raw::c_int, (*first).outputs, (*second.as_deref().unwrap()).outputs);
    }
    ltests += 1;
    if (*first).total_weights != (*second.as_deref().unwrap()).total_weights {
        lfails += 1;
        printf(b"%s:%d (%d != %d)\n\x00" as *const u8 as *const std::os::raw::c_char,
               b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
               233 as std::os::raw::c_int, (*first).total_weights,
               (*second.as_deref().unwrap()).total_weights);
    }
    let mut i: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < (*first).total_weights {
        ltests += 1;
        if fabs(*(*first).weight.offset(i as isize) -
                    *(*second.as_deref().unwrap()).weight.offset(i as isize)) > 0.001f64 {
            lfails += 1;
            printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as
                       *const std::os::raw::c_char,
                   b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
                   237 as std::os::raw::c_int, *(*first).weight.offset(i as isize),
                   *(*second.as_deref().unwrap()).weight.offset(i as isize));
        }
        i+= 1
    }
    crate::genann::genann_free(first);
    crate::genann::genann_free(core::mem::transmute::<_, *mut crate::example1::genann>(second.as_deref_mut()));
}
#[no_mangle]
pub unsafe extern "C" fn sigmoid() {
    let mut i: std::os::raw::c_double = -(20 as std::os::raw::c_int) as std::os::raw::c_double;
    let max: std::os::raw::c_double = 20 as std::os::raw::c_int as std::os::raw::c_double;
    let d: std::os::raw::c_double = 0.0001f64;
    while i < max {
        ltests += 1;
        if fabs(crate::genann::genann_act_sigmoid(i) - crate::genann::genann_act_sigmoid_cached(i)) >
               0.001f64 {
            lfails += 1;
            printf(b"%s:%d (%f != %f)\n\x00" as *const u8 as
                       *const std::os::raw::c_char,
                   b"test.c\x00" as *const u8 as *const std::os::raw::c_char,
                   251 as std::os::raw::c_int, crate::genann::genann_act_sigmoid(i),
                   crate::genann::genann_act_sigmoid_cached(i));
        }
        i+= d
    };
}
unsafe fn main_0(mut argc: std::os::raw::c_int, mut argv: *const *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    printf(b"GENANN TEST SUITE\n\x00" as *const u8 as *const std::os::raw::c_char);
    srand(100 as std::os::raw::c_int as std::os::raw::c_uint);
    let ts: std::os::raw::c_int = ltests;
    let fs: std::os::raw::c_int = lfails;
    let start: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"basic\x00" as *const u8 as *const std::os::raw::c_char);
    basic();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts - (lfails - fs), lfails - fs,
           clock().wrapping_sub(start).wrapping_mul(1000 as std::os::raw::c_int as
                                                        std::os::raw::c_ulong).wrapping_div(1000000
                                                                                        as
                                                                                        std::os::raw::c_int
                                                                                        as
                                                                                        std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_0: std::os::raw::c_int = ltests;
    let fs_0: std::os::raw::c_int = lfails;
    let start_0: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"xor\x00" as *const u8 as *const std::os::raw::c_char);
    xor();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_0 - (lfails - fs_0),
           lfails - fs_0,
           clock().wrapping_sub(start_0).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_1: std::os::raw::c_int = ltests;
    let fs_1: std::os::raw::c_int = lfails;
    let start_1: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"backprop\x00" as *const u8 as *const std::os::raw::c_char);
    backprop();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_1 - (lfails - fs_1),
           lfails - fs_1,
           clock().wrapping_sub(start_1).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_2: std::os::raw::c_int = ltests;
    let fs_2: std::os::raw::c_int = lfails;
    let start_2: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"train and\x00" as *const u8 as *const std::os::raw::c_char);
    train_and();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_2 - (lfails - fs_2),
           lfails - fs_2,
           clock().wrapping_sub(start_2).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_3: std::os::raw::c_int = ltests;
    let fs_3: std::os::raw::c_int = lfails;
    let start_3: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"train or\x00" as *const u8 as *const std::os::raw::c_char);
    train_or();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_3 - (lfails - fs_3),
           lfails - fs_3,
           clock().wrapping_sub(start_3).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_4: std::os::raw::c_int = ltests;
    let fs_4: std::os::raw::c_int = lfails;
    let start_4: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"train xor\x00" as *const u8 as *const std::os::raw::c_char);
    train_xor();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_4 - (lfails - fs_4),
           lfails - fs_4,
           clock().wrapping_sub(start_4).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_5: std::os::raw::c_int = ltests;
    let fs_5: std::os::raw::c_int = lfails;
    let start_5: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"persist\x00" as *const u8 as *const std::os::raw::c_char);
    persist();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_5 - (lfails - fs_5),
           lfails - fs_5,
           clock().wrapping_sub(start_5).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_6: std::os::raw::c_int = ltests;
    let fs_6: std::os::raw::c_int = lfails;
    let start_6: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"copy\x00" as *const u8 as *const std::os::raw::c_char);
    copy();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_6 - (lfails - fs_6),
           lfails - fs_6,
           clock().wrapping_sub(start_6).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    let ts_7: std::os::raw::c_int = ltests;
    let fs_7: std::os::raw::c_int = lfails;
    let start_7: clock_t = clock();
    printf(b"\t%-14s\x00" as *const u8 as *const std::os::raw::c_char,
           b"sigmoid\x00" as *const u8 as *const std::os::raw::c_char);
    sigmoid();
    printf(b"pass:%2d   fail:%2d   %4dms\n\x00" as *const u8 as
               *const std::os::raw::c_char, ltests - ts_7 - (lfails - fs_7),
           lfails - fs_7,
           clock().wrapping_sub(start_7).wrapping_mul(1000 as std::os::raw::c_int as
                                                          std::os::raw::c_ulong).wrapping_div(1000000
                                                                                          as
                                                                                          std::os::raw::c_int
                                                                                          as
                                                                                          std::os::raw::c_ulong)
               as std::os::raw::c_int);
    if lfails == 0 as std::os::raw::c_int {
        printf(b"ALL TESTS PASSED (%d/%d)\n\x00" as *const u8 as
                   *const std::os::raw::c_char, ltests, ltests);
    } else {
        printf(b"SOME TESTS FAILED (%d/%d)\n\x00" as *const u8 as
                   *const std::os::raw::c_char, ltests - lfails, ltests);
    }
    return (lfails != 0 as std::os::raw::c_int) as std::os::raw::c_int;
}
// pub fn main() {
//     let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
//     for arg in ::std::env::args() {
//         args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
//     };
//     args.push(::std::ptr::null_mut());
//     unsafe {
//         ::std::process::exit(main_0((args.len() - 1) as std::os::raw::c_int,
//                                     args.as_mut_ptr() as
//                                         *mut *mut std::os::raw::c_char) as i32)
//     }
// }
#![feature(main)]

extern "C" {
    #[no_mangle]
    fn printf(_: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    
    
    
    
    
    
    
    
}
pub type genann_actfun
    =
    Option<unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double>;
#[derive(Copy, Clone)]
#[repr(C)]
struct ErasedByRefactorer0;
#[repr(C)]
pub struct genann {
    pub inputs: std::os::raw::c_int,
    pub hidden_layers: std::os::raw::c_int,
    pub hidden: std::os::raw::c_int,
    pub outputs: std::os::raw::c_int,
    pub activation_hidden: genann_actfun,
    pub activation_output: genann_actfun,
    pub total_weights: std::os::raw::c_int,
    pub total_neurons: std::os::raw::c_int,
    pub weight: *mut /* owning */ std::os::raw::c_double,
    pub output: *mut /* owning */ std::os::raw::c_double,
    pub delta: *mut /* owning */ std::os::raw::c_double,
}
impl Default for genann {fn default() -> Self {Self {
inputs: Default::default(),
hidden_layers: Default::default(),
hidden: Default::default(),
outputs: Default::default(),
activation_hidden: Default::default(),
activation_output: Default::default(),
total_weights: Default::default(),
total_neurons: Default::default(),
weight: std::ptr::null_mut(),
output: std::ptr::null_mut(),
delta: std::ptr::null_mut(),
}}}
impl genann {pub fn take(&mut self) -> Self {core::mem::take(self)}}

unsafe fn main_0(mut argc: std::os::raw::c_int, mut argv: *const *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    printf(b"GENANN example 1.\n\x00" as *const u8 as *const std::os::raw::c_char);
    printf(b"Train a small ANN to the XOR function using backpropagation.\n\x00"
               as *const u8 as *const std::os::raw::c_char);
    /* Input and expected out data for the XOR function. */
    let input: [[std::os::raw::c_double; 2]; 4] =
        [[0 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [0 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double]];
    let output: [std::os::raw::c_double; 4] =
        [0 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         0 as std::os::raw::c_int as std::os::raw::c_double];
    let mut i: std::os::raw::c_int = 0;
    /* New network with 2 inputs,
     * 1 hidden layer of 2 neurons,
     * and 1 output. */
    let mut ann: *mut genann =
        crate::genann::genann_init(2 as std::os::raw::c_int, 1 as std::os::raw::c_int, 2 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    /* Train on the four labeled data points many times. */
    i= 0 as std::os::raw::c_int;
    while i < 300 as std::os::raw::c_int {
        crate::genann::genann_train(ann, input[0 as std::os::raw::c_int as usize].as_ptr(),
                     output.as_ptr().offset(0 as std::os::raw::c_int as isize),
                     3 as std::os::raw::c_int as std::os::raw::c_double);
        crate::genann::genann_train(ann, input[1 as std::os::raw::c_int as usize].as_ptr(),
                     output.as_ptr().offset(1 as std::os::raw::c_int as isize),
                     3 as std::os::raw::c_int as std::os::raw::c_double);
        crate::genann::genann_train(ann, input[2 as std::os::raw::c_int as usize].as_ptr(),
                     output.as_ptr().offset(2 as std::os::raw::c_int as isize),
                     3 as std::os::raw::c_int as std::os::raw::c_double);
        crate::genann::genann_train(ann, input[3 as std::os::raw::c_int as usize].as_ptr(),
                     output.as_ptr().offset(3 as std::os::raw::c_int as isize),
                     3 as std::os::raw::c_int as std::os::raw::c_double);
        i+= 1
    }
    /* Run the network and see what it predicts. */
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[0 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[0 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[0 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[1 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[1 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[1 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[2 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[2 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[2 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[3 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[3 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[3 as std::os::raw::c_int as usize].as_ptr()));
    crate::genann::genann_free(ann);
    return 0 as std::os::raw::c_int;
}
// pub fn main() {
//     let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
//     for arg in ::std::env::args() {
//         args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
//     };
//     args.push(::std::ptr::null_mut());
//     unsafe {
//         ::std::process::exit(main_0((args.len() - 1) as std::os::raw::c_int,
//                                     args.as_mut_ptr() as
//                                         *mut *mut std::os::raw::c_char) as i32)
//     }
// }

extern "C" {
    #[no_mangle]
    fn printf(_: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn rand() -> std::os::raw::c_int;
    #[no_mangle]
    fn pow(_: std::os::raw::c_double, _: std::os::raw::c_double) -> std::os::raw::c_double;
    
    
    
    
    
    
    
    
    
    
}
pub type genann_actfun
    =
    Option<unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double>;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor0;
impl Default for ErasedByPreprocessor0 {fn default() -> Self {Self {
}}}

unsafe fn main_0(mut argc: std::os::raw::c_int, mut argv: *const *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    printf(b"GENANN example 2.\n\x00" as *const u8 as *const std::os::raw::c_char);
    printf(b"Train a small ANN to the XOR function using random search.\n\x00"
               as *const u8 as *const std::os::raw::c_char);
    /* Input and expected out data for the XOR function. */
    let input: [[std::os::raw::c_double; 2]; 4] =
        [[0 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [0 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double]];
    let output: [std::os::raw::c_double; 4] =
        [0 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         1 as std::os::raw::c_int as std::os::raw::c_double,
         0 as std::os::raw::c_int as std::os::raw::c_double];
    let mut i: std::os::raw::c_int = 0;
    /* New network with 2 inputs,
     * 1 hidden layer of 2 neurons,
     * and 1 output. */
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(2 as std::os::raw::c_int, 1 as std::os::raw::c_int, 2 as std::os::raw::c_int,
                    1 as std::os::raw::c_int);
    let mut err: std::os::raw::c_double = 0.;
    let mut last_err: std::os::raw::c_double = 1000 as std::os::raw::c_int as std::os::raw::c_double;
    let mut count: std::os::raw::c_int = 0 as std::os::raw::c_int;
    loop  {
        count+= 1;
        if count % 1000 as std::os::raw::c_int == 0 as std::os::raw::c_int {
            /* We're stuck, start over. */
            crate::genann::genann_randomize(ann.as_mut());
        }
        let mut save: *mut crate::example1::genann = crate::genann::genann_copy(ann);
        /* Take a random guess at the ANN weights. */
        i= 0 as std::os::raw::c_int;
        while i < (*ann).total_weights {
            *(*ann).weight.offset(i as isize) +=
                rand() as std::os::raw::c_double /
                    0x7fffffff as std::os::raw::c_int as std::os::raw::c_double - 0.5f64;
            i+= 1
        }
        /* See how we did. */
        err= 0 as std::os::raw::c_int as std::os::raw::c_double;
        err+=
            pow(*crate::genann::genann_run(ann.as_mut(), input[0 as std::os::raw::c_int as usize].as_ptr()) -
                    output[0 as std::os::raw::c_int as usize], 2.0f64);
        err+=
            pow(*crate::genann::genann_run(ann.as_mut(), input[1 as std::os::raw::c_int as usize].as_ptr()) -
                    output[1 as std::os::raw::c_int as usize], 2.0f64);
        err+=
            pow(*crate::genann::genann_run(ann.as_mut(), input[2 as std::os::raw::c_int as usize].as_ptr()) -
                    output[2 as std::os::raw::c_int as usize], 2.0f64);
        err+=
            pow(*crate::genann::genann_run(ann.as_mut(), input[3 as std::os::raw::c_int as usize].as_ptr()) -
                    output[3 as std::os::raw::c_int as usize], 2.0f64);
        /* Keep these weights if they're an improvement. */
        if err < last_err {
            crate::genann::genann_free(save);
            last_err= err
        } else { crate::genann::genann_free(ann); ann= save }
        if !(err > 0.01f64) { break ; }
    }
    printf(b"Finished in %d loops.\n\x00" as *const u8 as *const std::os::raw::c_char,
           count);
    /* Run the network and see what it predicts. */
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[0 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[0 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[0 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[1 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[1 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[1 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[2 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[2 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[2 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[3 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[3 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[3 as std::os::raw::c_int as usize].as_ptr()));
    crate::genann::genann_free(ann);
    return 0 as std::os::raw::c_int;
}
// pub fn main() {
//     let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
//     for arg in ::std::env::args() {
//         args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
//     };
//     args.push(::std::ptr::null_mut());
//     unsafe {
//         ::std::process::exit(main_0((args.len() - 1) as std::os::raw::c_int,
//                                     args.as_mut_ptr() as
//                                         *mut *mut std::os::raw::c_char) as i32)
//     }
// }

extern "C" {
    
    #[no_mangle]
    fn fprintf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn fscanf(_: *mut FILE, _: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn perror(_: *const std::os::raw::c_char);
    #[no_mangle]
    fn __assert_rtn(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char,
                    _: std::os::raw::c_int, _: *const std::os::raw::c_char) -> !;
    #[no_mangle]
    fn __error() -> *mut std::os::raw::c_int;
    #[no_mangle]
    fn exp(_: std::os::raw::c_double) -> std::os::raw::c_double;
    #[no_mangle]
    fn malloc(_: std::os::raw::c_ulong) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn rand() -> std::os::raw::c_int;
    #[no_mangle]
    fn free(_: *mut std::os::raw::c_void);
    #[no_mangle]
    fn memcpy(_: *mut std::os::raw::c_void, _: *const std::os::raw::c_void, _: std::os::raw::c_ulong)
     -> *mut std::os::raw::c_void;
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor5;
impl Default for ErasedByPreprocessor5 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor6;
impl Default for ErasedByPreprocessor6 {fn default() -> Self {Self {
}}}

pub type FILE = crate::example3::__sFILE;
pub type genann_actfun
    =
    Option<unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double>;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor7;
impl Default for ErasedByPreprocessor7 {fn default() -> Self {Self {
}}}

#[no_mangle]
pub unsafe extern "C" fn genann_act_sigmoid(mut a: std::os::raw::c_double)
 -> std::os::raw::c_double {
    if a < -45.0f64 { return 0 as std::os::raw::c_int as std::os::raw::c_double }
    if a > 45.0f64 { return 1 as std::os::raw::c_int as std::os::raw::c_double }
    return 1.0f64 / (1 as std::os::raw::c_int as std::os::raw::c_double + exp(-a));
}
#[no_mangle]
pub unsafe extern "C" fn genann_act_sigmoid_cached(mut a: std::os::raw::c_double)
 -> std::os::raw::c_double {
    /* If you're optimizing for memory usage, just
     * delete this entire function and replace references
     * of genann_act_sigmoid_cached to genann_act_sigmoid
     */
    let min: std::os::raw::c_double = -15.0f64;
    let max: std::os::raw::c_double = 15.0f64;
    static mut interval: std::os::raw::c_double = 0.;
    static mut initialized: std::os::raw::c_int = 0 as std::os::raw::c_int;
    static mut lookup: [std::os::raw::c_double; 4096] = [0.; 4096];
    /* Calculate entire lookup table on first run. */
    if initialized == 0 {
        interval = (max - min) / 4096 as std::os::raw::c_int as std::os::raw::c_double;
        let mut i: std::os::raw::c_int = 0;
        i= 0 as std::os::raw::c_int;
        while i < 4096 as std::os::raw::c_int {
            lookup[i as usize] =
                genann_act_sigmoid(min + interval * i as std::os::raw::c_double);
            i+= 1
        }
        /* This is down here to make this thread safe. */
        initialized = 1 as std::os::raw::c_int
    }
    let mut i_0: std::os::raw::c_int = 0;
    i_0= ((a - min) / interval + 0.5f64) as std::os::raw::c_int;
    if i_0 <= 0 as std::os::raw::c_int { return lookup[0 as std::os::raw::c_int as usize] }
    if i_0 >= 4096 as std::os::raw::c_int {
        return lookup[(4096 as std::os::raw::c_int - 1 as std::os::raw::c_int) as usize]
    }
    return lookup[i_0 as usize];
}
#[no_mangle]
pub unsafe extern "C" fn genann_act_threshold(mut a: std::os::raw::c_double)
 -> std::os::raw::c_double {
    return (a > 0 as std::os::raw::c_int as std::os::raw::c_double) as std::os::raw::c_int as
               std::os::raw::c_double;
}
#[no_mangle]
pub unsafe extern "C" fn genann_act_linear(mut a: std::os::raw::c_double)
 -> std::os::raw::c_double {
    return a;
}
#[no_mangle]
pub unsafe extern "C" fn genann_init(mut inputs: std::os::raw::c_int,
                                     mut hidden_layers: std::os::raw::c_int,
                                     mut hidden: std::os::raw::c_int,
                                     mut outputs: std::os::raw::c_int)
 -> *mut /* owning */ crate::example1::genann {
    if hidden_layers < 0 as std::os::raw::c_int { return 0 as *mut crate::example1::genann }
    if inputs < 1 as std::os::raw::c_int { return 0 as *mut crate::example1::genann }
    if outputs < 1 as std::os::raw::c_int { return 0 as *mut crate::example1::genann }
    if hidden_layers > 0 as std::os::raw::c_int && hidden < 1 as std::os::raw::c_int {
        return 0 as *mut crate::example1::genann
    }
    let hidden_weights: std::os::raw::c_int =
        if hidden_layers != 0 {
            ((inputs + 1 as std::os::raw::c_int) * hidden) +
                (hidden_layers - 1 as std::os::raw::c_int) *
                    (hidden + 1 as std::os::raw::c_int) * hidden
        } else { 0 as std::os::raw::c_int };
    let output_weights: std::os::raw::c_int =
        (if hidden_layers != 0 {
             (hidden) + 1 as std::os::raw::c_int
         } else { (inputs) + 1 as std::os::raw::c_int }) * outputs;
    let total_weights: std::os::raw::c_int = hidden_weights + output_weights;
    let total_neurons: std::os::raw::c_int =
        inputs + hidden * hidden_layers + outputs;
    /* Allocate extra size for weights, outputs, and deltas. */
    let size: std::os::raw::c_int =
        (::std::mem::size_of::<crate::example1::genann>() as
             std::os::raw::c_ulong).wrapping_add((::std::mem::size_of::<std::os::raw::c_double>()
                                              as
                                              std::os::raw::c_ulong).wrapping_mul((total_weights
                                                                               +
                                                                               total_neurons
                                                                               +
                                                                               (total_neurons
                                                                                    -
                                                                                    inputs))
                                                                              as
                                                                              std::os::raw::c_ulong))
            as std::os::raw::c_int;
    let mut ret: *mut crate::example1::genann = malloc(size as std::os::raw::c_ulong) as *mut crate::example1::genann;
    if ret.is_null() {();(); return 0 as *mut crate::example1::genann }
    (*ret).inputs= inputs;
    (*ret).hidden_layers= hidden_layers;
    (*ret).hidden= hidden;
    (*ret).outputs= outputs;
    (*ret).total_weights= total_weights;
    (*ret).total_neurons= total_neurons;
    /* Set pointers. */
    (*ret).weight=
        (ret as
             *mut std::os::raw::c_char).offset(::std::mem::size_of::<crate::example1::genann>() as
                                           std::os::raw::c_ulong as isize) as
            *mut std::os::raw::c_double;
    (*ret).output= (*ret).weight.offset((*ret).total_weights as isize);
    (*ret).delta= (*ret).output.offset((*ret).total_neurons as isize);
    genann_randomize(ret.as_mut());
    (*ret).activation_hidden=
        Some(genann_act_sigmoid_cached as
                 unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double);
    (*ret).activation_output=
        Some(genann_act_sigmoid_cached as
                 unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn genann_read(mut in_0: *mut FILE) -> Option<Box<crate::example1::genann>> {
    let mut inputs: std::os::raw::c_int = 0;
    let mut hidden_layers: std::os::raw::c_int = 0;
    let mut hidden: std::os::raw::c_int = 0;
    let mut outputs: std::os::raw::c_int = 0;
    let mut rc: std::os::raw::c_int = 0;
    *__error() = 0 as std::os::raw::c_int;
    rc=
        fscanf(in_0, b"%d %d %d %d\x00" as *const u8 as *const std::os::raw::c_char,
               &mut inputs as *mut std::os::raw::c_int,
               &mut hidden_layers as *mut std::os::raw::c_int,
               &mut hidden as *mut std::os::raw::c_int,
               &mut outputs as *mut std::os::raw::c_int);
    if rc < 4 as std::os::raw::c_int || *__error() != 0 as std::os::raw::c_int {
        perror(b"fscanf\x00" as *const u8 as *const std::os::raw::c_char);
        return None
    }
    let mut ann: *mut crate::example1::genann =
        genann_init(inputs, hidden_layers, hidden, outputs);
    let mut i: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < (*ann.as_deref().unwrap()).total_weights {
        *__error() = 0 as std::os::raw::c_int;
        rc=
            fscanf(in_0, b" %le\x00" as *const u8 as *const std::os::raw::c_char,
                   (*ann.as_deref().unwrap()).weight.offset(i as isize));
        if rc < 1 as std::os::raw::c_int || *__error() != 0 as std::os::raw::c_int {
            perror(b"fscanf\x00" as *const u8 as *const std::os::raw::c_char);
            genann_free(core::mem::transmute::<_, *mut crate::example1::genann>(ann.as_deref_mut()));
            return None
        }
        i+= 1
    }
    return ann;
}
#[no_mangle]
pub unsafe extern "C" fn genann_copy(mut ann: *const crate::example1::genann) -> *mut /* owning */ crate::example1::genann {
    let size: std::os::raw::c_int =
        (::std::mem::size_of::<crate::example1::genann>() as
             std::os::raw::c_ulong).wrapping_add((::std::mem::size_of::<std::os::raw::c_double>()
                                              as
                                              std::os::raw::c_ulong).wrapping_mul(((*ann).total_weights
                                                                               +
                                                                               (*ann).total_neurons
                                                                               +
                                                                               ((*ann).total_neurons
                                                                                    -
                                                                                    (*ann).inputs))
                                                                              as
                                                                              std::os::raw::c_ulong))
            as std::os::raw::c_int;
    let mut ret: *mut crate::example1::genann = malloc(size as std::os::raw::c_ulong) as *mut crate::example1::genann;
    if ret.is_null() {();(); return 0 as *mut crate::example1::genann }
    memcpy(ret as *mut std::os::raw::c_void, ann as *const std::os::raw::c_void,
           size as std::os::raw::c_ulong);
    /* Set pointers. */
    (*ret).weight=
        (ret as
             *mut std::os::raw::c_char).offset(::std::mem::size_of::<crate::example1::genann>() as
                                           std::os::raw::c_ulong as isize) as
            *mut std::os::raw::c_double;
    (*ret).output= (*ret).weight.offset((*ret).total_weights as isize);
    (*ret).delta= (*ret).output.offset((*ret).total_neurons as isize);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn genann_randomize(mut ann: Option<&mut crate::example1::genann>) {
    let mut i: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < (*ann.as_deref().unwrap()).total_weights {
        let mut r: std::os::raw::c_double =
            rand() as std::os::raw::c_double /
                0x7fffffff as std::os::raw::c_int as std::os::raw::c_double;
        /* Sets weights from -0.5 to 0.5. */
        *(*ann.as_deref().unwrap()).weight.offset(i as isize) = r - 0.5f64;
        i+= 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn genann_free(mut ann: *mut crate::example1::genann) {
    /* The weight, output, and delta pointers go to the same buffer. */
    ();
}
#[no_mangle]
pub unsafe extern "C" fn genann_run(mut ann: Option<&mut crate::example1::genann>,
                                    mut inputs: *const std::os::raw::c_double)
 -> *const std::os::raw::c_double {
    let mut w: *const std::os::raw::c_double = (*ann.as_deref().unwrap()).weight as *const f64;
    let mut o: *mut std::os::raw::c_double =
        (*ann.as_deref().unwrap()).output.offset((*ann.as_deref().unwrap()).inputs as isize);
    let mut i: *const std::os::raw::c_double = (*ann.as_deref().unwrap()).output as *const f64;
    /* Copy the inputs to the scratch area, where we also store each neuron's
     * output, for consistency. This way the first layer isn't a special case. */
    memcpy((*ann.as_deref().unwrap()).output as *mut std::os::raw::c_void, inputs as *const std::os::raw::c_void,
           (::std::mem::size_of::<std::os::raw::c_double>() as
                std::os::raw::c_ulong).wrapping_mul((*ann.as_deref().unwrap()).inputs as std::os::raw::c_ulong));
    let mut h: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut k: std::os::raw::c_int = 0;
    let act: genann_actfun = (*ann.as_deref().unwrap()).activation_hidden;
    let acto: genann_actfun = (*ann.as_deref().unwrap()).activation_output;
    /* Figure hidden layers, if any. */
    h= 0 as std::os::raw::c_int;
    while h < (*ann.as_deref().unwrap()).hidden_layers {
        j= 0 as std::os::raw::c_int;
        while j < (*ann.as_deref().unwrap()).hidden {
            let fresh0 = w;
            w= w.offset(1);
            let mut sum: std::os::raw::c_double = (*fresh0) * -1.0f64;
            k= 0 as std::os::raw::c_int;
            while k <
                      (if h == 0 as std::os::raw::c_int {
                           (*ann.as_deref().unwrap()).inputs
                       } else { (*ann.as_deref().unwrap()).hidden }) {
                let fresh1 = w;
                w= w.offset(1);
                sum+= (*fresh1) * *i.offset(k as isize);
                k+= 1
            }
            let fresh2 = o;
            o= o.offset(1);
            *fresh2= act.expect("non-null function pointer")(sum);
            j+= 1
        }
        i=
            i.offset(if h == 0 as std::os::raw::c_int {
                         (*ann.as_deref().unwrap()).inputs
                     } else { (*ann.as_deref().unwrap()).hidden } as isize);
        h+= 1
    }
    let mut ret: *const std::os::raw::c_double = o;
    /* Figure output layer. */
    j= 0 as std::os::raw::c_int;
    while j < (*ann.as_deref().unwrap()).outputs {
        let fresh3 = w;
        w= w.offset(1);
        let mut sum_0: std::os::raw::c_double = (*fresh3) * -1.0f64;
        k= 0 as std::os::raw::c_int;
        while k <
                  (if (*ann.as_deref().unwrap()).hidden_layers != 0 {
                       (*ann.as_deref().unwrap()).hidden
                   } else { (*ann.as_deref().unwrap()).inputs }) {
            let fresh4 = w;
            w= w.offset(1);
            sum_0+= (*fresh4) * *i.offset(k as isize);
            k+= 1
        }
        let fresh5 = o;
        o= o.offset(1);
        *fresh5= acto.expect("non-null function pointer")(sum_0);
        j+= 1
    }
    /* Sanity check that we used all weights and wrote all outputs. */
    if !(w.offset_from((*ann.as_deref().unwrap()).weight as *const f64) as std::os::raw::c_long ==
             (*ann.as_deref().unwrap()).total_weights as std::os::raw::c_long) as std::os::raw::c_int as
           std::os::raw::c_long != 0 {
        __assert_rtn(b"genann_run\x00" as *const u8 as *const i8,
                     b"genann.c\x00" as *const u8 as *const std::os::raw::c_char,
                     225 as std::os::raw::c_int,
                     b"w - ann->weight == ann->total_weights\x00" as *const u8
                         as *const std::os::raw::c_char);
    } else { };
    if !(o.offset_from((*ann.as_deref().unwrap()).output as *const f64) as std::os::raw::c_long ==
             (*ann.as_deref().unwrap()).total_neurons as std::os::raw::c_long) as std::os::raw::c_int as
           std::os::raw::c_long != 0 {
        __assert_rtn(b"genann_run\x00" as *const u8 as *const i8,
                     b"genann.c\x00" as *const u8 as *const std::os::raw::c_char,
                     226 as std::os::raw::c_int,
                     b"o - ann->output == ann->total_neurons\x00" as *const u8
                         as *const std::os::raw::c_char);
    } else { };
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn genann_train(mut ann: *const crate::example1::genann,
                                      mut inputs: *const std::os::raw::c_double,
                                      mut desired_outputs:
                                          *const std::os::raw::c_double,
                                      mut learning_rate: std::os::raw::c_double) {
    /* To begin with, we must run the network forward. */
    genann_run(ann.as_mut(), inputs);
    let mut h: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut k: std::os::raw::c_int = 0;
    /* First set the output layer deltas. */
    let mut o: *const std::os::raw::c_double =
        (*ann).output.offset((*ann).inputs as
                                 isize).offset(((*ann).hidden *
                                                    (*ann).hidden_layers) as
                                                   isize); /* First output. */
    let mut d: *mut std::os::raw::c_double =
        (*ann).delta.offset(((*ann).hidden * (*ann).hidden_layers) as
                                isize); /* First delta. */
    let mut t: *const std::os::raw::c_double =
        desired_outputs; /* First desired output. */
    if (*ann).activation_output ==
           Some(genann_act_linear as
                    unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double)
       {
        j= 0 as std::os::raw::c_int;
        while j < (*ann).outputs {
            let fresh6 = t;
            t= t.offset(1);
            let fresh7 = o;
            o= o.offset(1);
            let fresh8 = d;
            d= d.offset(1);
            *fresh8= (*fresh6) - (*fresh7);
            j+= 1
        }
    } else {
        j= 0 as std::os::raw::c_int;
        while j < (*ann).outputs {
            let fresh9 = d;
            d= d.offset(1);
            *fresh9= ((*t) - (*o)) * (*o) * (1.0f64 - (*o));
            o= o.offset(1);
            t= t.offset(1);
            j+= 1
        }
    }
    /* Set output layer deltas. */
    /* Set hidden layer deltas, start on last layer and work backwards. */
    /* Note that loop is skipped in the case of hidden_layers == 0. */
    h= (*ann).hidden_layers - 1 as std::os::raw::c_int;
    while h >= 0 as std::os::raw::c_int {
        /* Find first output and delta in this layer. */
        let mut o_0: *const std::os::raw::c_double =
            (*ann).output.offset((*ann).inputs as
                                     isize).offset((h * (*ann).hidden) as
                                                       isize);
        let mut d_0: *mut std::os::raw::c_double =
            (*ann).delta.offset((h * (*ann).hidden) as isize);
        /* Find first delta in following layer (which may be hidden or output). */
        let dd: *const std::os::raw::c_double =
            (*ann).delta.offset(((h + 1 as std::os::raw::c_int) * (*ann).hidden) as
                                    isize);
        /* Find first weight in following layer (which may be hidden or output). */
        let ww: *const std::os::raw::c_double =
            (*ann).weight.offset((((*ann).inputs + 1 as std::os::raw::c_int) *
                                      (*ann).hidden) as
                                     isize).offset((((*ann).hidden +
                                                         1 as std::os::raw::c_int) *
                                                        (*ann).hidden * h) as
                                                       isize);
        j= 0 as std::os::raw::c_int;
        while j < (*ann).hidden {
            let mut delta: std::os::raw::c_double =
                0 as std::os::raw::c_int as std::os::raw::c_double;
            k= 0 as std::os::raw::c_int;
            while k <
                      (if h == (*ann).hidden_layers - 1 as std::os::raw::c_int {
                           (*ann).outputs
                       } else { (*ann).hidden }) {
                let forward_delta: std::os::raw::c_double = *dd.offset(k as isize);
                let windex: std::os::raw::c_int =
                    k * ((*ann).hidden + 1 as std::os::raw::c_int) +
                        (j + 1 as std::os::raw::c_int);
                let forward_weight: std::os::raw::c_double =
                    *ww.offset(windex as isize);
                delta+= forward_delta * forward_weight;
                k+= 1
            }
            *d_0= (*o_0) * (1.0f64 - (*o_0)) * delta;
            d_0= d_0.offset(1);
            o_0= o_0.offset(1);
            j+= 1
        }
        h-= 1
    }
    /* Train the outputs. */
    /* Find first output delta. */
    let mut d_1: *const std::os::raw::c_double =
        (*ann).delta.offset(((*ann).hidden * (*ann).hidden_layers) as
                                isize); /* First output delta. */
    let mut w: *mut std::os::raw::c_double =
        (*ann).weight.offset((if (*ann).hidden_layers != 0 {
                                  (((*ann).inputs + 1 as std::os::raw::c_int) *
                                       (*ann).hidden) +
                                      ((*ann).hidden + 1 as std::os::raw::c_int) *
                                          (*ann).hidden *
                                          ((*ann).hidden_layers -
                                               1 as std::os::raw::c_int)
                              } else { 0 as std::os::raw::c_int }) as isize);
    let i: *const std::os::raw::c_double =
        (*ann).output.offset((if (*ann).hidden_layers != 0 {
                                  ((*ann).inputs) +
                                      (*ann).hidden *
                                          ((*ann).hidden_layers -
                                               1 as std::os::raw::c_int)
                              } else { 0 as std::os::raw::c_int }) as isize);
    j= 0 as std::os::raw::c_int;
    while j < (*ann).outputs {
        k= 0 as std::os::raw::c_int;
        while k <
                  (if (*ann).hidden_layers != 0 {
                       (*ann).hidden
                   } else { (*ann).inputs }) + 1 as std::os::raw::c_int {
            if k == 0 as std::os::raw::c_int {
                let fresh10 = w;
                w= w.offset(1);
                *fresh10+= (*d_1) * learning_rate * -1.0f64
            } else {
                let fresh11 = w;
                w= w.offset(1);
                *fresh11+=
                    (*d_1) * learning_rate *
                        *i.offset((k - 1 as std::os::raw::c_int) as isize)
            }
            k+= 1
        }
        d_1= d_1.offset(1);
        j+= 1
    }
    if !(w.offset_from((*ann).weight as *const f64) as std::os::raw::c_long ==
             (*ann).total_weights as std::os::raw::c_long) as std::os::raw::c_int as
           std::os::raw::c_long != 0 {
        __assert_rtn(b"genann_train\x00" as *const u8 as *const i8,
                     b"genann.c\x00" as *const u8 as *const std::os::raw::c_char,
                     318 as std::os::raw::c_int,
                     b"w - ann->weight == ann->total_weights\x00" as *const u8
                         as *const std::os::raw::c_char);
    } else { };
    /* Find first weight to first output delta. */
    /* Find first output in previous layer. */
    /* Set output layer weights. */
    /* Train the hidden layers. */
    h= (*ann).hidden_layers - 1 as std::os::raw::c_int;
    while h >= 0 as std::os::raw::c_int {
        /* Find first delta in this layer. */
        let mut d_2: *const std::os::raw::c_double =
            (*ann).delta.offset((h * (*ann).hidden) as isize);
        /* Find first input to this layer. */
        let mut i_0: *const std::os::raw::c_double =
            (*ann).output.offset((if h != 0 {
                                      ((*ann).inputs) +
                                          (*ann).hidden *
                                              (h - 1 as std::os::raw::c_int)
                                  } else { 0 as std::os::raw::c_int }) as isize);
        /* Find first weight to this layer. */
        let mut w_0: *mut std::os::raw::c_double =
            (*ann).weight.offset((if h != 0 {
                                      (((*ann).inputs + 1 as std::os::raw::c_int) *
                                           (*ann).hidden) +
                                          ((*ann).hidden + 1 as std::os::raw::c_int) *
                                              (*ann).hidden *
                                              (h - 1 as std::os::raw::c_int)
                                  } else { 0 as std::os::raw::c_int }) as isize);
        j= 0 as std::os::raw::c_int;
        while j < (*ann).hidden {
            k= 0 as std::os::raw::c_int;
            while k <
                      (if h == 0 as std::os::raw::c_int {
                           (*ann).inputs
                       } else { (*ann).hidden }) + 1 as std::os::raw::c_int {
                if k == 0 as std::os::raw::c_int {
                    let fresh12 = w_0;
                    w_0= w_0.offset(1);
                    *fresh12+= (*d_2) * learning_rate * -1.0f64
                } else {
                    let fresh13 = w_0;
                    w_0= w_0.offset(1);
                    *fresh13+=
                        (*d_2) * learning_rate *
                            *i_0.offset((k - 1 as std::os::raw::c_int) as isize)
                }
                k+= 1
            }
            d_2= d_2.offset(1);
            j+= 1
        }
        h-= 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn genann_write(mut ann: *const crate::example1::genann,
                                      mut out: *const FILE) {
    fprintf(out, b"%d %d %d %d\x00" as *const u8 as *const std::os::raw::c_char,
            (*ann).inputs, (*ann).hidden_layers, (*ann).hidden,
            (*ann).outputs);
    let mut i: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < (*ann).total_weights {
        fprintf(out, b" %.20e\x00" as *const u8 as *const std::os::raw::c_char,
                *(*ann).weight.offset(i as isize));
        i+= 1
    };
}

extern "C" {
    
    #[no_mangle]
    fn fclose(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn feof(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fgets(_: *mut std::os::raw::c_char, _: std::os::raw::c_int, _: *mut FILE)
     -> *mut std::os::raw::c_char;
    #[no_mangle]
    fn fopen(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> *mut FILE;
    #[no_mangle]
    fn fseek(_: *mut FILE, _: std::os::raw::c_long, _: std::os::raw::c_int) -> std::os::raw::c_int;
    #[no_mangle]
    fn perror(_: *const std::os::raw::c_char);
    #[no_mangle]
    fn printf(_: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn malloc(_: std::os::raw::c_ulong) -> *mut std::os::raw::c_void;
    #[no_mangle]
    fn atof(_: *const std::os::raw::c_char) -> std::os::raw::c_double;
    #[no_mangle]
    fn exit(_: std::os::raw::c_int) -> !;
    #[no_mangle]
    fn strcmp(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> std::os::raw::c_int;
    #[no_mangle]
    fn strlen(_: *const std::os::raw::c_char) -> std::os::raw::c_ulong;
    #[no_mangle]
    fn strtok(_: *mut std::os::raw::c_char, _: *const std::os::raw::c_char)
     -> *mut std::os::raw::c_char;
    
    
    
    
    
    
    
    
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor2;
impl Default for ErasedByPreprocessor2 {fn default() -> Self {Self {
}}}

#[derive(Copy, Clone)]

struct ErasedByPreprocessor3;
impl Default for ErasedByPreprocessor3 {fn default() -> Self {Self {
}}}

pub type FILE = crate::example3::__sFILE;
pub type genann_actfun
    =
    Option<unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double>;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor4;
impl Default for ErasedByPreprocessor4 {fn default() -> Self {Self {
}}}

/* This example is to illustrate how to use GENANN.
 * It is NOT an example of good machine learning techniques.
 */
#[no_mangle]
pub static mut iris_data: *const std::os::raw::c_char =
    b"example/iris.data\x00" as *const u8 as *const std::os::raw::c_char;
#[no_mangle]
pub static mut input: *mut std::os::raw::c_double =
    0 as *const std::os::raw::c_double as *mut std::os::raw::c_double;
#[no_mangle]
pub static mut class: *mut std::os::raw::c_double =
    0 as *const std::os::raw::c_double as *mut std::os::raw::c_double;
#[no_mangle]
pub static mut samples: std::os::raw::c_int = 0;
#[no_mangle]
pub static mut class_names: [*const std::os::raw::c_char; 3] =
    [b"Iris-setosa\x00" as *const u8 as *const std::os::raw::c_char,
     b"Iris-versicolor\x00" as *const u8 as *const std::os::raw::c_char,
     b"Iris-virginica\x00" as *const u8 as *const std::os::raw::c_char];
#[no_mangle]
pub unsafe extern "C" fn load_data() {
    /* Load the iris data-set. */
    let mut in_0: *mut FILE =
        fopen(b"example/iris.data\x00" as *const u8 as *const std::os::raw::c_char,
              b"r\x00" as *const u8 as *const std::os::raw::c_char);
    if in_0.is_null() {();
        printf(b"Could not open file: %s\n\x00" as *const u8 as
                   *const std::os::raw::c_char, iris_data);
        exit(1 as std::os::raw::c_int);
    }
    /* Loop through the data to get a count. */
    let mut line: [std::os::raw::c_char; 1024] = [0; 1024];
    while feof(in_0) == 0 &&
              !fgets(line.as_mut_ptr(), 1024 as std::os::raw::c_int, in_0).is_null() {
        samples += 1
    }
    fseek(in_0, 0 as std::os::raw::c_int as std::os::raw::c_long, 0 as std::os::raw::c_int);
    printf(b"Loading %d data points from %s\n\x00" as *const u8 as
               *const std::os::raw::c_char, samples, iris_data);
    /* Allocate memory for input and output data. */
    input =
        malloc((::std::mem::size_of::<std::os::raw::c_double>() as
                    std::os::raw::c_ulong).wrapping_mul(samples as
                                                    std::os::raw::c_ulong).wrapping_mul(4
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    std::os::raw::c_ulong))
            as *mut std::os::raw::c_double;
    class =
        malloc((::std::mem::size_of::<std::os::raw::c_double>() as
                    std::os::raw::c_ulong).wrapping_mul(samples as
                                                    std::os::raw::c_ulong).wrapping_mul(3
                                                                                    as
                                                                                    std::os::raw::c_int
                                                                                    as
                                                                                    std::os::raw::c_ulong))
            as *mut std::os::raw::c_double;
    /* Read the file into our arrays. */
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    i= 0 as std::os::raw::c_int;
    while i < samples {
        let mut p: *mut std::os::raw::c_double =
            input.offset((i * 4 as std::os::raw::c_int) as isize);
        let mut c: *mut std::os::raw::c_double =
            class.offset((i * 3 as std::os::raw::c_int) as isize);
        *c.offset(2 as std::os::raw::c_int as isize) = 0.0f64; *c.offset(1 as std::os::raw::c_int as isize) = *c.offset(2 as std::os::raw::c_int as isize);
        *c.offset(0 as std::os::raw::c_int as isize) = *c.offset(1 as std::os::raw::c_int as isize);
        if fgets(line.as_mut_ptr(), 1024 as std::os::raw::c_int, in_0).is_null() {();
            perror(b"fgets\x00" as *const u8 as *const std::os::raw::c_char);
            exit(1 as std::os::raw::c_int);
        }
        let mut split: *mut std::os::raw::c_char =
            strtok(line.as_mut_ptr(),
                   b",\x00" as *const u8 as *const std::os::raw::c_char);
        j= 0 as std::os::raw::c_int;
        while j < 4 as std::os::raw::c_int {
            *p.offset(j as isize) = atof(split);
            split=
                strtok(0 as *mut std::os::raw::c_char,
                       b",\x00" as *const u8 as *const std::os::raw::c_char);
            j+= 1
        }
        *split.offset(strlen(split).wrapping_sub(1 as std::os::raw::c_int as
                                                     std::os::raw::c_ulong) as isize)
            = 0 as std::os::raw::c_int as std::os::raw::c_char;
        if strcmp(split, class_names[0 as std::os::raw::c_int as usize]) ==
               0 as std::os::raw::c_int {
            *c.offset(0 as std::os::raw::c_int as isize) = 1.0f64
        } else if strcmp(split, class_names[1 as std::os::raw::c_int as usize]) ==
                      0 as std::os::raw::c_int {
            *c.offset(1 as std::os::raw::c_int as isize) = 1.0f64
        } else if strcmp(split, class_names[2 as std::os::raw::c_int as usize]) ==
                      0 as std::os::raw::c_int {
            *c.offset(2 as std::os::raw::c_int as isize) = 1.0f64
        } else {
            printf(b"Unknown class %s.\n\x00" as *const u8 as
                       *const std::os::raw::c_char, split);
            exit(1 as std::os::raw::c_int);
        }
        i+= 1
        /* printf("Data point %d is %f %f %f %f  ->   %f %f %f\n", i, p[0], p[1], p[2], p[3], c[0], c[1], c[2]); */
    }
    fclose(in_0);
}
unsafe fn main_0(mut argc: std::os::raw::c_int, mut argv: *const *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    printf(b"GENANN example 4.\n\x00" as *const u8 as *const std::os::raw::c_char);
    printf(b"Train an ANN on the IRIS dataset using backpropagation.\n\x00" as
               *const u8 as *const std::os::raw::c_char);
    /* Load the data from file. */
    load_data();
    /* 4 inputs.
     * 1 hidden layer(s) of 4 neurons.
     * 3 outputs (1 per class)
     */
    let mut ann: *mut crate::example1::genann =
        crate::genann::genann_init(4 as std::os::raw::c_int, 1 as std::os::raw::c_int, 4 as std::os::raw::c_int,
                    3 as std::os::raw::c_int);
    let mut i: std::os::raw::c_int = 0;
    let mut j: std::os::raw::c_int = 0;
    let mut loops: std::os::raw::c_int = 5000 as std::os::raw::c_int;
    /* Train the network with backpropagation. */
    printf(b"Training for %d loops over data.\n\x00" as *const u8 as
               *const std::os::raw::c_char, loops);
    i= 0 as std::os::raw::c_int;
    while i < loops {
        j= 0 as std::os::raw::c_int;
        while j < samples {
            crate::genann::genann_train(ann, input.offset((j * 4 as std::os::raw::c_int) as isize),
                         class.offset((j * 3 as std::os::raw::c_int) as isize),
                         0.01f64);
            j+= 1
        }
        i+= 1
        /* printf("%1.2f ", xor_score(ann)); */
    }
    let mut correct: std::os::raw::c_int = 0 as std::os::raw::c_int;
    j= 0 as std::os::raw::c_int;
    while j < samples {
        let mut guess: *const std::os::raw::c_double =
            crate::genann::genann_run(ann.as_mut(), input.offset((j * 4 as std::os::raw::c_int) as isize));
        if *class.offset((j * 3 as std::os::raw::c_int + 0 as std::os::raw::c_int) as isize)
               == 1.0f64 {
            if *guess.offset(0 as std::os::raw::c_int as isize) >
                   *guess.offset(1 as std::os::raw::c_int as isize) &&
                   *guess.offset(0 as std::os::raw::c_int as isize) >
                       *guess.offset(2 as std::os::raw::c_int as isize) {
                correct+= 1
            }
        } else if *class.offset((j * 3 as std::os::raw::c_int + 1 as std::os::raw::c_int) as
                                    isize) == 1.0f64 {
            if *guess.offset(1 as std::os::raw::c_int as isize) >
                   *guess.offset(0 as std::os::raw::c_int as isize) &&
                   *guess.offset(1 as std::os::raw::c_int as isize) >
                       *guess.offset(2 as std::os::raw::c_int as isize) {
                correct+= 1
            }
        } else if *class.offset((j * 3 as std::os::raw::c_int + 2 as std::os::raw::c_int) as
                                    isize) == 1.0f64 {
            if *guess.offset(2 as std::os::raw::c_int as isize) >
                   *guess.offset(0 as std::os::raw::c_int as isize) &&
                   *guess.offset(2 as std::os::raw::c_int as isize) >
                       *guess.offset(1 as std::os::raw::c_int as isize) {
                correct+= 1
            }
        } else {
            printf(b"Logic error.\n\x00" as *const u8 as *const std::os::raw::c_char);
            exit(1 as std::os::raw::c_int);
        }
        j+= 1
    }
    printf(b"%d/%d correct (%0.1f%%).\n\x00" as *const u8 as
               *const std::os::raw::c_char, correct, samples,
           correct as std::os::raw::c_double / samples as std::os::raw::c_double * 100.0f64);
    crate::genann::genann_free(ann);
    return 0 as std::os::raw::c_int;
}
// pub fn main() {
//     let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
//     for arg in ::std::env::args() {
//         args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
//     };
//     args.push(::std::ptr::null_mut());
//     unsafe {
//         ::std::process::exit(main_0((args.len() - 1) as std::os::raw::c_int,
//                                     args.as_mut_ptr() as
//                                         *mut *mut std::os::raw::c_char) as i32)
//     }
// }

extern "C" {
    pub type __sFILEX;
    #[no_mangle]
    fn fclose(_: *mut FILE) -> std::os::raw::c_int;
    #[no_mangle]
    fn fopen(_: *const std::os::raw::c_char, _: *const std::os::raw::c_char) -> *mut FILE;
    #[no_mangle]
    fn printf(_: *const std::os::raw::c_char, _: ...) -> std::os::raw::c_int;
    #[no_mangle]
    fn exit(_: std::os::raw::c_int) -> !;
    
    
    
    
    
    
}
pub type __int64_t = std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sbuf {
    pub _base: *const std::os::raw::c_uchar,
    pub _size: std::os::raw::c_int,
}
impl Default for __sbuf {fn default() -> Self {Self {
_base: std::ptr::null_mut(),
_size: Default::default(),
}}}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sFILE {
    pub _p: *const std::os::raw::c_uchar,
    pub _r: std::os::raw::c_int,
    pub _w: std::os::raw::c_int,
    pub _flags: std::os::raw::c_short,
    pub _file: std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: std::os::raw::c_int,
    pub _cookie: *const std::os::raw::c_void,
    pub _close: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void)
                           -> std::os::raw::c_int>,
    pub _read: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                           _: *mut std::os::raw::c_char,
                                           _: std::os::raw::c_int) -> std::os::raw::c_int>,
    pub _seek: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void, _: fpos_t,
                                           _: std::os::raw::c_int) -> fpos_t>,
    pub _write: Option<unsafe extern "C" fn(_: *mut std::os::raw::c_void,
                                            _: *const std::os::raw::c_char,
                                            _: std::os::raw::c_int) -> std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *const __sFILEX,
    pub _ur: std::os::raw::c_int,
    pub _ubuf: [std::os::raw::c_uchar; 3],
    pub _nbuf: [std::os::raw::c_uchar; 1],
    pub _lb: __sbuf,
    pub _blksize: std::os::raw::c_int,
    pub _offset: fpos_t,
}
impl Default for __sFILE {fn default() -> Self {Self {
_p: std::ptr::null_mut(),
_r: Default::default(),
_w: Default::default(),
_flags: Default::default(),
_file: Default::default(),
_bf: Default::default(),
_lbfsize: Default::default(),
_cookie: std::ptr::null_mut(),
_close: Default::default(),
_read: Default::default(),
_seek: Default::default(),
_write: Default::default(),
_ub: Default::default(),
_extra: std::ptr::null_mut(),
_ur: Default::default(),
_ubuf: Default::default(),
_nbuf: Default::default(),
_lb: Default::default(),
_blksize: Default::default(),
_offset: Default::default(),
}}}

pub type FILE = __sFILE;
pub type genann_actfun
    =
    Option<unsafe extern "C" fn(_: std::os::raw::c_double) -> std::os::raw::c_double>;
#[derive(Copy, Clone)]

struct ErasedByPreprocessor1;
impl Default for ErasedByPreprocessor1 {fn default() -> Self {Self {
}}}

#[no_mangle]
pub static mut save_name: *const std::os::raw::c_char =
    b"example/xor.ann\x00" as *const u8 as *const std::os::raw::c_char;
unsafe fn main_0(mut argc: std::os::raw::c_int, mut argv: *const *const std::os::raw::c_char)
 -> std::os::raw::c_int {
    printf(b"GENANN example 3.\n\x00" as *const u8 as *const std::os::raw::c_char);
    printf(b"Load a saved ANN to solve the XOR function.\n\x00" as *const u8
               as *const std::os::raw::c_char);
    let mut saved: *mut FILE =
        fopen(save_name, b"r\x00" as *const u8 as *const std::os::raw::c_char);
    if saved.is_null() {();
        printf(b"Couldn\'t open file: %s\n\x00" as *const u8 as
                   *const std::os::raw::c_char, save_name);
        exit(1 as std::os::raw::c_int);
    }
    let mut ann: *mut crate::example1::genann = crate::genann::genann_read(saved);
    fclose(saved);
    if ann.is_null() {();
        printf(b"Error loading ANN from file: %s.\x00" as *const u8 as
                   *const std::os::raw::c_char, save_name);
        exit(1 as std::os::raw::c_int);
    }
    /* Input data for the XOR function. */
    let input: [[std::os::raw::c_double; 2]; 4] =
        [[0 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [0 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          0 as std::os::raw::c_int as std::os::raw::c_double],
         [1 as std::os::raw::c_int as std::os::raw::c_double,
          1 as std::os::raw::c_int as std::os::raw::c_double]];
    /* Run the network and see what it predicts. */
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[0 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[0 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[0 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[1 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[1 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[1 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[2 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[2 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[2 as std::os::raw::c_int as usize].as_ptr()));
    printf(b"Output for [%1.f, %1.f] is %1.f.\n\x00" as *const u8 as
               *const std::os::raw::c_char,
           input[3 as std::os::raw::c_int as usize][0 as std::os::raw::c_int as usize],
           input[3 as std::os::raw::c_int as usize][1 as std::os::raw::c_int as usize],
           *crate::genann::genann_run(ann.as_mut(), input[3 as std::os::raw::c_int as usize].as_ptr()));
    crate::genann::genann_free(ann);
    return 0 as std::os::raw::c_int;
}
// pub fn main() {
//     let mut args: Vec<*mut std::os::raw::c_char> = Vec::new();
//     for arg in ::std::env::args() {
//         args.push(::std::ffi::CString::new(arg).expect("Failed to convert argument into CString.").into_raw());
//     };
//     args.push(::std::ptr::null_mut());
//     unsafe {
//         ::std::process::exit(main_0((args.len() - 1) as std::os::raw::c_int,
//                                     args.as_mut_ptr() as
//                                         *mut *mut std::os::raw::c_char) as i32)
//     }
// }
